{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    if (download) {\n      for (auto &file : required_files) {\n        if (!FileTransfer::FileExists(file)) {\n          Log::Info(\"Downloading file: \" + file);\n          RequestFile(file);\n        } else {\n          Log::Info(\"File found in cache: \" + file);\n        }\n      }\n    }\n    return required_files;\n  }", "CodeBleu_score": 68.03431064230627}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Retrieve the list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    if (download) {\n        // Download the files that are not found locally\n        for (const auto &file : files) {\n            if (!FileTransfer::FileExists(file)) {\n                RequestFile(file);\n                std::cout << \"Downloaded file: \" << file << std::endl;\n            } else {\n                std::cout << \"Found file in cache: \" << file << std::endl;\n            }\n        }\n    }\n    return files;\n}", "CodeBleu_score": 66.09835842557722}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get a list of required files from the server\n\tauto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\t// If the download flag is set to true, check if each file exists locally\n\tif (download) {\n\t\tfor (const auto &file : files) {\n\t\t\t// If the file does not exist locally, request it and log the download action\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\tRequestFile(file);\n\t\t\t\tLog::Info(\"File \" + file + \" downloaded\");\n\t\t\t}\n\t\t\t// If the file exists locally, log that the file is found in the cache\n\t\t\telse {\n\t\t\t\tLog::Info(\"File \" + file + \" found in cache\");\n\t\t\t}\n\t\t}\n\t}\n\treturn files;\n}", "CodeBleu_score": 61.75697425608377}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t", "CodeBleu_score": 8.448293753010953}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifndef NDEBUG\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation.x != 0 || transform.translation.y != 0) {\n      std::cerr << \"WARNING: The translation of the provided transform is not zero when spawning an actor with a spring arm or spring arm ghost attachment. This may lead to unexpected behavior.\" << std::endl;\n    }\n  }\n#endif  // NDEBUG\n\n  return SpawnActor(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 43.06396407886725}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t\tauto actor = SpawnActor(description);\n\tif (!actor) {\n\t\treturn {};\n\t}\n\tif (attachment_type == rpc::AttachmentType::SpringArm) {\n\t\tif (transform.translation.x != 0 || transform.translation.y != 0) {\n\t\t\tLOG(WARNING) << \"The translation of the provided transform is not (0, 0, 0) when attaching actor to a spring arm. This is likely to cause ill-formed transformations. Please check the transformation provided to the SpawnActorWithParent function.\";\n\t\t}\n\t}\n\tif (attachment_type == rpc::AttachmentType::SpringArmGhost) {\n\t\tif (transform.translation.x != 0 || transform.translation.y != 0) {\n\t\t\tLOG(WARNING) << \"The translation of the provided transform is not (0, 0, 0) when attaching actor to a spring arm ghost. This is likely to cause ill-formed transformations. Please check the transformation provided to the SpawnActorWithParent function.\";\n\t\t}\n\t}\n\tSetActorTransform(actor, transform, parent, attachment_type, socket_name);\n\treturn actor;\n}", "CodeBleu_score": 45.204281543342425}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n#ifdef _DEBUG\n  std::cout << \"Client::SubscribeToGBuffer\" << std::endl;\n#endif\n\n  // Create a token for the G-buffer\n  rpc::Token token = CreateToken(ActorId, GBufferId);\n\n  // Copy the token data\n  rpc::TokenData tokenData;\n  token.CopyTo(tokenData);\n\n  // Subscribe to the streaming client\n  Subscribe(tokenData, callback);\n}", "CodeBleu_score": 37.82166440155699}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\n}", "CodeBleu_score": 7.390850490544927}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t\trpc::GBufferId gbuffer_id;\n\tgbuffer_id.actor_id = ActorId;\n\tgbuffer_id.gbuffer_id = GBufferId;\n\tauto token = rpc_client->SubscribeToGBuffer(gbuffer_id);\n\tauto buffer = rpc_client->GetGBuffer(token);\n\tcallback(buffer);\n}", "CodeBleu_score": 37.4664309157704}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = this->GetNavigation();\n\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(this->GetWorld());\n\t\tthis->SetNavigation(navigation);\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 37.994500662612076}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (m_pWalkerNavigation == nullptr) {\n\t\tm_pWalkerNavigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn m_pWalkerNavigation;\n}", "CodeBleu_score": 26.924305290426126}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (this->navigation == nullptr) {\n\t\tthis->navigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn this->navigation;\n}", "CodeBleu_score": 16.15970696996433}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = high_resolution_clock::now();\n\twhile (episode.GetCurrentFrame() < frame) {\n\t\tif (high_resolution_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tthis_thread::yield();\n\t}\n\tthis_thread::yield();\n\tthis_thread::sleep_for(chrono::milliseconds(1));\n\treturn true;\n}", "CodeBleu_score": 33.39456372040246}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tconst auto start_time = system_clock::now();\n\twhile (true) {\n\t\tif (episode.GetCurrentFrameNumber() >= frame) {\n\t\t\tepisode.GetTrafficManager().TriggerTick();\n\t\t\treturn true;\n\t\t}\n\t\tauto current_time = system_clock::now();\n\t\tif (current_time - start_time >= timeout) {\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.91867218581498}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tconst uint64_t start_time = std::chrono::duration_cast<std::chrono::milliseconds>(system_clock::now().time_since_epoch()).count();\n\twhile (true) {\n\t\tconst uint64_t current_frame = episode.GetCurrentFrame();\n\t\tif (current_frame >= frame) {\n\t\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t\t\treturn true;\n\t\t}\n\t\tconst uint64_t current_time = std::chrono::duration_cast<std::chrono::milliseconds>(system_clock::now().time_since_epoch()).count();\n\t\tif (current_time - start_time >= timeout.count()) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n}", "CodeBleu_score": 45.70220409728269}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t#ifdef _WIN32\n  Sleep(1000);\n#else\n  usleep(1000000);\n#endif\n  auto episode = std::make_shared<rpc::Episode>();\n  episode->map_name = map_name;\n  episode->map_layers = map_layers;\n  episode->reset_settings = reset_settings;\n  std::unique_lock<std::mutex> lk(episode_id_mutex);\n  episode_id_to_load = episode->id;\n  lk.unlock();\n  episode_id_cv.notify_all();\n  std::unique_lock<std::mutex> lk2(episode_id_mutex);\n  while (episode_id_to_load == episode->id) {\n    episode_id_cv.wait(lk2);\n  }\n  if (episode_id_to_load != episode->id) {\n    throw std::runtime_error(\"Failed to connect to the new episode.\");\n  }\n  return EpisodeProxy{episode};\n}", "CodeBleu_score": 39.79133528844071}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n}", "CodeBleu_score": 3.4852633042533125}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\n#ifdef _DEBUG\n  std::cout << \"Simulator::LoadEpisode(\" << map_name << \", \" << reset_settings << \", \" << map_layers << \")\n\";\n#endif\n\n  // Wait for the simulator to be ready to accept new episodes.\n  GetReady();\n\n  // Create the new episode request.\n  rpc::RequestLoadEpisode request;\n  request.map_name = map_name;\n  request.reset_settings = reset_settings;\n  request.map_layers = map_layers;\n\n  // Send the request to the simulator.\n  rpc::ResponseLoadEpisode response;\n  SendMessage(request, &response);\n\n  // Check if the episode loaded successfully.\n  if (response.status == rpc::ResponseLoadEpisode::SUCCESS) {\n    // Return the episode object.\n    return EpisodeProxy{shared_from_this()};\n  }\n  else if (response.status == rpc::ResponseLoadEpisode::INVALID_MAP_NAME) {\n    throw std::runtime_error(\"Simulator::LoadEpisode: Invalid map name.\");\n  }\n  else if (response.status == rpc::ResponseLoadEpisode::INVALID_MAP_LAYERS) {\n    throw std::runtime_error(\"Simulator::LoadEpisode: Invalid map layers.\");\n  }\n  else {\n    throw std::runtime_error(\"Simulator::LoadEpisode: Failed to load episode.\");\n  }\n}", "CodeBleu_score": 30.392079531128264}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller.\n\tWalker *walker = GetWalker(controller.GetID());\n\n\t// Throw an exception if the walker is not found.\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found.\");\n\t}\n\n\t// Assert that the episode is not null.\n\tif (episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode not found.\");\n\t}\n\n\t// Create navigation if it is missing.\n\tif (episode->GetNavigation() == nullptr) {\n\t\tepisode->SetNavigation(std::make_shared<Navigation>(episode));\n\t}\n\n\t// Register the walker with the controller's ID.\n\tepisode->GetNavigation()->RegisterWalker(controller.GetID(), walker);\n}", "CodeBleu_score": 52.10290781175549}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.episode == nullptr) {\n\t\tthrow std::invalid_argument(\"controller.episode is null\");\n\t}\n\tif (controller.episode->navigation == nullptr) {\n\t\tcontroller.episode->navigation = std::make_shared<Navigation>(controller.episode->scene);\n\t}\n\tif (controller.episode->scene->get_walker(controller.id) == nullptr) {\n\t\tthrow std::invalid_argument(\"controller.id is not a valid walker ID\");\n\t}\n\tcontroller.episode->ai_controllers.push_back(controller);\n}", "CodeBleu_score": 30.226255992799693}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.episode == nullptr) {\n\t\tthrow std::runtime_error(\"The controller must be associated with an episode\");\n\t}\n\tif (controller.episode->navigation == nullptr) {\n\t\tcontroller.episode->navigation = std::make_unique<Navigation>(controller.episode->scene);\n\t}\n\tcontroller.episode->navigation->RegisterWalker(controller.id, controller.walker);\n}", "CodeBleu_score": 28.789775336758407}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t\n}", "CodeBleu_score": 7.425333410238643}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n// Ensure that the episode is valid.\nif (!episode_ || episode_->GetState() != EpisodeState::ACTIVE) {\nthrow std::runtime_error(\n      \"Episode is not valid, or is not in the ACTIVE state.\");\n}\n\n// Subscribe to the sensor.\nauto client = std::dynamic_pointer_cast<rpc::Client>(episode_->GetClient());\nauto sensor_id = sensor.id;\nauto sensor_type = sensor.type;\nclient->SubscribeToStream(\n      sensor_id,\n      sensor_type,\n      [this, callback](const rpc::Request &request) {\n\n// Deserialize the sensor data.\nauto sensor_data = std::dynamic_pointer_cast<SensorData>(\n      this->DeserializeSensorData(request.response, request.type));\n\n// Associate the sensor data with the current episode.\nsensor_data->set_id(this->episode_->GetId());\n\n// Invoke the callback.\ncallback(sensor_data);\n});\n}", "CodeBleu_score": 44.719890861737156}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t", "CodeBleu_score": 10.021712233824069}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n#ifdef DEBUG_WALKERS\n  if (_debug_output)\n    std::cout << \"WalkerNavigation::Tick\" << std::endl;\n#endif\n\n  // get the current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // get all walkers from episode\n  std::vector<WalkerHandle> walkers = GetRegisteredWalkers();\n\n  // check if walkers exist\n  if (walkers.empty()) {\n#ifdef DEBUG_WALKERS\n    if (_debug_output)\n      std::cout << \"WalkerNavigation::Tick: No walkers\" << std::endl;\n#endif\n    return;\n  }\n\n  // update vehicles\n  UpdateVehiclesInCrowd(episode, _debug_output);\n\n  // update the crowd\n  _nav.UpdateCrowd();\n\n  // update the walkers\n  for (auto &&walker : walkers) {\n\n    // get the transform and speed\n    carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n    float speed = state->GetActorSnapshot(walker.walker).velocity.length();\n\n    // update the controller\n    walker.controller->Update(transform, speed);\n\n    // get the new transform and speed\n    carla::geom::Transform new_transform = walker.controller->GetTransform();\n    float new_speed = walker.controller->GetSpeed();\n\n    // apply the new transform and speed\n    _simulator.lock()->ApplyWalkerControl(walker.walker, new_transform, new_speed);\n\n    // check if the walker is dead\n    if (walker.controller->IsDead()) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n\n  }\n\n  // check if any walker has been killed\n  CheckIfWalkerExist(walkers, *state);\n\n}", "CodeBleu_score": 49.554232817000724}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// check if the list is empty\nif (_walkers.empty())\n  return;\n\n// get current state\nstd::shared_ptr<const EpisodeState> state = episode->GetState();\n\n// remove any walkers that no longer exist\nCheckIfWalkerExist(_walkers, *state);\n\n// update the vehicles in the crowd\nUpdateVehiclesInCrowd(episode, false);\n\n// update the crowd\n_nav.UpdateCrowd();\n\n// apply the states of the walkers\nfor (auto &&walker : _walkers) {\n  // get the transform and speed\n  carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n  float speed = state->GetActorSnapshot(walker.walker).velocity.length();\n  // apply the state to the controller\n  walker.controller->ApplyWalkerState(transform, speed);\n}\n\n// check if any walker has been killed\nfor (auto &&walker : _walkers) {\n  if (walker.controller->IsDead()) {\n    // remove from the crowd\n    _nav.RemoveAgent(walker.walker);\n    // destroy the controller\n    _simulator.lock()->DestroyActor(walker.controller);\n    // unregister from list\n    UnregisterWalker(walker.walker, walker.controller);\n  }\n}\n\n}", "CodeBleu_score": 40.76799958499973}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n#ifdef DEBUG_WALKERS\n  std::cout << \"WalkerNavigation::Tick\" << std::endl;\n#endif\n\n  // get the current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // check if there are any walkers\n  if (_walkers.empty()) {\n    return;\n  }\n\n  // remove any walkers that are no longer alive\n  CheckIfWalkerExist(_walkers, *state);\n\n  // update the crowd\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update the crowd\n  UpdateCrowd(state, episode->GetWorld());\n\n  // update the walkers\n  UpdateWalkers(state);\n}", "CodeBleu_score": 21.35856141170121}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(actor_uid);\n\tdescription.set_id(actor_id);\n\tfor (auto &attribute : attributes) {\n\t\tauto *attribute_description = description.add_attributes();\n\t\t*attribute_description = attribute.MakeAttributeDescription();\n\t}\n\treturn description;\n}", "CodeBleu_score": 55.038998713829315}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\n\tfor (auto& attribute : attributes) {\n\t\trpc::AttributeDescription* attribute_description = description.add_attributes();\n\t\tattribute_description->set_name(attribute.name);\n\t\tattribute_description->set_type(attribute.type);\n\t\tattribute_description->set_size(attribute.size);\n\t\tattribute_description->set_default_value(attribute.default_value);\n\t}\n\n\treturn description;\n}", "CodeBleu_score": 49.08092351229292}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tfor (const auto &attribute : attributes) {\n\t\tdescription.add_attributes()->CopyFrom(attribute);\n\t}\n\treturn description;\n}", "CodeBleu_score": 58.7932163556623}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto blueprint : blueprints_) {\n\t\tbool found = false;\n\t\tfor (auto attribute : blueprint->attributes_) {\n\t\t\tif (attribute.name == name) {\n\t\t\t\tfound = true;\n\t\t\t\tif (attribute.value == value) {\n\t\t\t\t\tresult->AddBlueprint(blueprint);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tfor (auto attribute : blueprint->recommended_attributes_) {\n\t\t\t\tif (attribute.name == name) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tif (attribute.value == value) {\n\t\t\t\t\t\tresult->AddBlueprint(blueprint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.40925315630828}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n\tfor (const auto &bp : blueprints_) {\n\t\tif (bp->HasAttribute(name)) {\n\t\t\tconst auto &attr = bp->GetAttribute(name);\n\t\t\tif (attr.GetValue() == value || attr.GetRecommendedValues().count(value)) {\n\t\t\t\tresult->AddBlueprint(bp);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 36.779135834948775}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tSharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\tfor (auto &bp : blueprints) {\n\t\tif (bp.HasAttribute(name)) {\n\t\t\tconst auto &attr = bp.GetAttribute(name);\n\t\t\tif (attr.type == Attribute::Type::Value) {\n\t\t\t\tif (attr.value == value) {\n\t\t\t\t\tresult->blueprints.push_back(bp);\n\t\t\t\t}\n\t\t\t} else if (attr.type == Attribute::Type::RecommendedValue) {\n\t\t\t\tif (std::find(attr.recommendedValues.begin(), attr.recommendedValues.end(), value) != attr.recommendedValues.end()) {\n\t\t\t\t\tresult->blueprints.push_back(bp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 47.90354444883753}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = path + \"/\" + GetVersionString();\n\tif (!ValidateFilePath(fullPath)) {\n\t\treturn false;\n\t}\n\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 43.84428873756831}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\t// Construct the full file path.\n\tpath = FileTransfer::GetFilePath(path, version);\n\n\t// Validate the file path.\n\tif (path.empty()) {\n\t\treturn false;\n\t}\n\n\t// Open the file in binary mode to truncate its contents.\n\tstd::ofstream file(path, std::ios::binary);\n\n\t// If the file was opened, write the content and close the file.\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\n\t// The file could not be opened.\n\treturn false;\n}", "CodeBleu_score": 32.09565957855604}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string full_path = GetFullFilePath(path);\n\tif (!ValidateFilePath(full_path)) {\n\t\treturn false;\n\t}\n\n\tFILE* file = fopen(full_path.c_str(), \"wb\");\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\n\tfwrite(&content[0], 1, content.size(), file);\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 36.19033353999825}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n//  std::cout << \"MakeBounds: frame: \" << frame << \", transform: \" << transform << std::endl;\n\n  const auto location = transform.location;\n  const auto yaw = transform.rotation.yaw;\n\n  const auto corners = MakeCorners(location, yaw);\n\n  const auto bounds = std::make_shared<Bounds>(frame, corners);\n\n  return bounds;\n}", "CodeBleu_score": 33.953233084483145}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t", "CodeBleu_score": 6.625397345875101}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::unique_lock<std::mutex> lock(_mutex);\n\tstd::vector<LightState> lightStates;\n\tif (_client.QueryLightsState(lightStates)) {\n\t\tfor (LightState lightState : lightStates) {\n\t\t\tif (lightState.id < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (_lights.find(lightState.id) == _lights.end()) {\n\t\t\t\t_lights[lightState.id] = std::make_shared<Light>(lightState.id, lightState.position, lightState.color, lightState.intensity);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_lights[lightState.id]->SetLightState(lightState);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.606004746825}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tif (_client == nullptr) {\n\t\treturn;\n\t}\n\tauto lights = _client->GetLights();\n\tfor (auto light : lights) {\n\t\tif (_lights.find(light.id) == _lights.end()) {\n\t\t\t_lights[light.id] = std::make_shared<Light>(light);\n\t\t}\n\t\telse {\n\t\t\t_lights[light.id]->Update(light);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.348488396478807}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::unique_lock<std::mutex> lock(_mutex);\n\n\t// Query the current state of lights from the server\n\tauto lights_state = _light_server.QueryLightsState();\n\n\t// Update the local light states\n\tfor (auto& light_state : lights_state) {\n\t\t// Update the local light state\n\t\t_lights[light_state.id].UpdateState(light_state);\n\t}\n\n\t// Create new light objects if they do not already exist in the _lights map\n\tfor (auto& light_state : lights_state) {\n\t\tif (_lights.find(light_state.id) == _lights.end()) {\n\t\t\t// Create a new light object\n\t\t\tLight light(light_state.id, light_state.type, light_state.position, light_state.direction, light_state.color, light_state.intensity);\n\n\t\t\t// Add the new light to the _lights map\n\t\t\t_lights[light_state.id] = light;\n\t\t}\n\t}\n\n\t// Unlock the mutex\n\tlock.unlock();\n}", "CodeBleu_score": 36.049268069776815}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(m_mutex);\n\n\t// If there are no changes, return\n\tif (!m_dirty)\n\t\treturn;\n\n\t// Create a message\n\tMessage message(MessageID::MSG_LIGHT_STATE);\n\n\t// Add the light states\n\tfor (auto it = m_lights.begin(); it != m_lights.end(); ++it) {\n\t\t// Add the light state\n\t\tmessage.AddData(it->second.state);\n\t}\n\n\t// Send the message to the server\n\tNetwork::Get().Send(message, discard_client);\n\n\t// Clear the changes\n\tm_dirty = false;\n}", "CodeBleu_score": 29.833148450380477}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (!dirty)\n\t\treturn;\n\tdirty = false;\n\tlock.unlock();\n\tstd::vector<LightState> light_states;\n\tfor (auto& light : lights) {\n\t\tlight_states.push_back(light.second);\n\t}\n\tif (discard_client) {\n\t\tclient_state_buffer.clear();\n\t\tclient_state_buffer.assign(light_states.begin(), light_states.end());\n\t}\n\tstd::string message = \"lights_update\";\n\tfor (auto& light : light_states) {\n\t\tmessage += \" \" + light.Serialize();\n\t}\n\tclient_socket.Send(message);\n}", "CodeBleu_score": 39.83990932053817}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (discard_client) {\n\t\t// If we are discarding the client, we just clear the dirty flag and return\n\t\tstd::unique_lock<std::mutex> lock(light_manager_mutex);\n\t\tdirty = false;\n\t\treturn;\n\t}\n\n\t// If the dirty flag is not set, we don't need to do anything\n\tif (!dirty) return;\n\n\t// We lock the mutex to ensure thread safety\n\tstd::unique_lock<std::mutex> lock(light_manager_mutex);\n\n\t// We create a message to send to the server\n\tauto msg = std::make_shared<LightManagerMsg>();\n\tmsg->light_states = light_states;\n\n\t// We send the message to the server\n\tlight_manager_client->SendMsg(msg);\n\n\t// We clear the dirty flag and reset the light states\n\tdirty = false;\n\tlight_states.clear();\n}", "CodeBleu_score": 29.00601222297939}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetID() != \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"WARNING: ServerSideSensor::Send() called with a sensor that is not a v2x_custom sensor!\" << std::endl;\n\t\treturn;\n\t}\n\tstd::cout << \"Sending message '\" << message << \"' to episode.\" << std::endl;\n\tGetContext()->Send(message);\n}", "CodeBleu_score": 49.38037347675879}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->id != \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"WARNING: The sensor's ID is not \\\"sensor.other.v2x_custom\\\".\" << std::endl;\n\t\treturn;\n\t}\n\tthis->context->send_message(message);\n}", "CodeBleu_score": 27.894577636875763}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (GetID() != \"sensor.other.v2x_custom\") {\n\t\tWARN(\"ServerSideSensor::Send called on sensor of type \" + GetID() + \" instead of sensor.other.v2x_custom\");\n\t\treturn;\n\t}\n\n\tauto* context = GetContext();\n\tif (context == nullptr) {\n\t\tWARN(\"ServerSideSensor::Send called on sensor with null context\");\n\t\treturn;\n\t}\n\n\tcontext->Send(message);\n}", "CodeBleu_score": 49.96463475844105}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t\tif (tm_port == 0) {\n\t\ttm_port = 8000;\n\t}\n\tif (enabled) {\n\t\ttm_client = std::unique_ptr<carla::client::TrafficManagerClient>(new carla::client::TrafficManagerClient(GetWorld(), tm_port));\n\t\ttm_client->SetAutoLaneChange(false);\n\t\ttm_client->SetHybridPhysicsMode(false);\n\t\ttm_client->SetSimulationMode(carla::traffic_manager::TrafficManagerMode::Hybrid);\n\t\ttm_client->SetClientRole(GetActor(), carla::rpc::TrafficManagerClient::ClientRole::Autopilot);\n\t}\n\telse {\n\t\ttm_client->SetClientRole(GetActor(), carla::rpc::TrafficManagerClient::ClientRole::Disengage);\n\t}\n}", "CodeBleu_score": 39.9726856170982}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// Get the Pawn Owner\n\tWalker = Cast<APawn>(GetPawn());\n\tif (Walker) {\n\t\t// Get the controller's movement component\n\t\tWalker->GetMovementComponent()->bConstrainToPlane = true;\n\t\tWalker->GetMovementComponent()->bSnapToPlaneAtStart = true;\n\t\tWalker->GetMovementComponent()->bProjectNavMeshToNavigation = true;\n\t\tWalker->GetMovementComponent()->bAutoActivate = true;\n\t\tWalker->GetMovementComponent()->bOrientRotationToMovement = true;\n\t\tWalker->GetMovementComponent()->bUseControllerDesiredRotation = true;\n\n\t\t// Add the Pawn to the game world's navigation system\n\t\tFVector SpawnLocation = GetActorLocation();\n\t\tFRotator SpawnRotation = GetActorRotation();\n\t\tSpawnRotation.Roll = 0.0f;\n\t\tSpawnRotation.Pitch = 0.0f;\n\t\tSpawnRotation.Yaw = 0.0f;\n\t\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(GetWorld());\n\t\tNavSys->AddNavData(Walker);\n\t\tNavSys->UpdateNavData(Walker);\n\n\t\t// Disable the physics simulation for the Pawn\n\t\tWalker->GetCharacterMovement()->bSimulatePhysics = false;\n\n\t\t// Disable collision for the Pawn\n\t\tWalker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n}", "CodeBleu_score": 35.762156266379655}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// Get the Pawn controlled by this AI Controller\n\tWalker = GetPawn();\n\tif (Walker) {\n\t\t// Get the controller's player start reference\n\t\tAPlayerStart* Start = GetWorld()->FindActorByClass<APlayerStart>();\n\t\tif (Start) {\n\t\t\t// Get the AI Controller's control rotation\n\t\t\tFRotator ControlRotation = Start->GetActorRotation();\n\t\t\t// Set the AI Controller to face the player start\n\t\t\tWalker->SetActorRotation(ControlRotation);\n\t\t\t// Get the AI Controller's control location\n\t\t\tFVector ControlLocation = Start->GetActorLocation();\n\t\t\t// Set the AI Controller to face the player start\n\t\t\tWalker->SetActorLocation(ControlLocation);\n\t\t\t// Add the AI Controller to the navigation system\n\t\t\tGetWorld()->GetNavigationSystem()->AddNavigableGeometry(Walker);\n\t\t\t// Disable the physics simulation and collisions for the AI Controller\n\t\t\tWalker->SetActorEnableCollision(false);\n\t\t\tWalker->SetActorHiddenInGame(true);\n\t\t}\n\t}\n}", "CodeBleu_score": 45.40112339293284}, {"code": "void WalkerAIController::Start(){\n\t\tSuper::Start();\n\n\t// Get the Pawn being controlled\n\tAPawn* Pawn = GetPawn();\n\tif (Pawn) {\n\t\t// Get the walker from the pawn\n\t\tWalker = Cast<AWalkerAIController>(Pawn);\n\n\t\t// Add the walker to the navigation system\n\t\tFVector StartLocation = Pawn->GetActorLocation();\n\t\tUNavigationSystemV1::GetNavigationSystem(GetWorld())->AddNavAgent(Pawn, FVector(1.0f, 0.0f, 1.0f), true);\n\n\t\t// Disable physics simulation and collision\n\t\tPawn->SetActorEnableCollision(false);\n\t\tPawn->SetActorEnableCollision(true);\n\n\t\t// Set the destination\n\t\tWalker->SetDestination(Destination);\n\t}\n}", "CodeBleu_score": 37.556353127016465}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (max_speed <= 0) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: max_speed must be greater than zero!\"));\n\t\treturn;\n\t}\n\n\t// Get the navigation instance from the current episode\n\tAICrowdAgentInterface* navigation = Cast<AICrowdAgentInterface>(GetEpisodeAgent(0));\n\tif (!navigation) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: navigation is not valid!\"));\n\t\treturn;\n\t}\n\n\t// Get the parent walker from the navigation instance\n\tAWalker* walker = Cast<AWalker>(navigation->GetNavAgent());\n\tif (!walker) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: walker is not valid!\"));\n\t\treturn;\n\t}\n\n\t// Set the maximum speed for the walker\n\twalker->SetMaxSpeed(max_speed);\n}", "CodeBleu_score": 40.921533272848286}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tif (navigation == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed -- Navigation instance is null!\"));\n\t\treturn;\n\t}\n\tif (walker == nullptr) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed -- Walker instance is null!\"));\n\t\treturn;\n\t}\n\tif (navigation->SetMaxSpeed(walker, max_speed)) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed -- Failed to set maximum speed!\"));\n\t}\n}", "CodeBleu_score": 38.35968161150436}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the navigation interface, if available\n\tFNavAgentInterface* const nav_interface = GetNavAgentInterface();\n\tif (nav_interface) {\n\t\t// Get the parent walker from the navigation interface\n\t\tAPawn* const pawn = nav_interface->GetPathFollowingComponent()->GetPawn();\n\t\tif (pawn) {\n\t\t\t// Cast the pawn to a walker\n\t\t\tAWalkerAI* const walker = Cast<AWalkerAI>(pawn);\n\t\t\tif (walker) {\n\t\t\t\t// Set the maximum speed\n\t\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- Could not cast pawn to a walker\"));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- Could not get pawn from navigation interface\"));\n\t\t}\n\t}\n\telse {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed() -- Could not get navigation interface from controller\"));\n\t}\n}", "CodeBleu_score": 40.50278168662068}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\n\tfor (auto it = parent_map->waypoints.begin(); it != parent_map->waypoints.end(); ++it) {\n\t\tif (it->second->GetDistance() < distance) {\n\t\t\tresult.push_back(it->second);\n\t\t}\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 43.49991582865511}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<Waypoint> waypoints = map->GetPrevious(this->x, this->y, distance);\n\tfor (Waypoint waypoint : waypoints) {\n\t\tresult.push_back(MakeShared<Waypoint>(waypoint));\n\t}\n\treturn result;\n}", "CodeBleu_score": 50.35793328041402}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\n\t// Get the previous waypoints from the parent map\n\tstd::vector<Waypoint*> waypoints = map->GetPrevious(this->id, distance);\n\n\t// For each waypoint, create a new Waypoint object and add it to the result vector\n\tfor (Waypoint* waypoint : waypoints) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 51.810221382345546}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tauto landmark = MakeShared<Landmark>(signal->GetPosition(), signal->GetBearing(), signal->GetDistance());\n\t\tresult.push_back(landmark);\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.9293792876564}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tauto landmark = std::make_shared<Landmark>(signal->GetPosition(), signal->GetSignalType());\n\t\tresult.push_back(landmark);\n\t}\n\treturn result;\n}", "CodeBleu_score": 35.57004264615756}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tif (std::find(result.begin(), result.end(), signal->GetLandmark()) == result.end()) {\n\t\t\tresult.push_back(signal->GetLandmark());\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 33.2012477734025}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t#if defined(_WIN32)\n  static const char *kWarningMessage =\n      \"The provided fixed delta time is not correctly applied. Please consider using a fixed delta time of zero.\";\n#else\n  static const char *kWarningMessage =\n      \"The provided fixed delta time is not correctly applied. Please consider using a fixed delta time of zero or setting the environment variable CARLA_SERVER_FIXED_DELTA_SECOND to 0.\";\n#endif\n\n  auto settings_id = _episode.Lock()->ApplySettings(settings);\n  if (settings.fixed_delta_seconds != 0.0) {\n    auto local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    auto start_time = std::chrono::system_clock::now();\n    while (true) {\n      auto current_time = std::chrono::system_clock::now();\n      auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(current_time - start_time).count();\n      if (elapsed_time > 1000) {\n        log_warning(kWarningMessage);\n        break;\n      }\n      auto snapshot = _episode.Lock()->GetWorldSnapshot();\n      if (snapshot.delta_seconds == settings.fixed_delta_seconds) {\n        break;\n      }\n      _episode.Lock()->Tick(local_timeout);\n    }\n  }\n  return settings_id;\n}", "CodeBleu_score": 50.80956742979584}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t\n}", "CodeBleu_score": 3.2079205477712285}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t//    std::unique_lock<std::mutex> lock(_episode.Mutex());\n    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, local_timeout);\n  }", "CodeBleu_score": 21.20803872787691}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = (segmentEnd - segmentStart).LengthSquared();\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn {0.0f, (point - segmentStart).Length()};\n\t}\n\n\tVector2 segmentDirection = (segmentEnd - segmentStart).Normalized();\n\tVector2 segmentToPoint = point - segmentStart;\n\tfloat segmentProjection = segmentDirection.Dot(segmentToPoint);\n\tfloat clampedSegmentProjection = std::max(0.0f, std::min(segmentLengthSquared, segmentProjection));\n\tVector2 segmentProjectionPoint = segmentStart + segmentDirection * clampedSegmentProjection;\n\treturn {(segmentProjectionPoint - point).Length(), (segmentProjectionPoint - segmentStart).Length()};\n}", "CodeBleu_score": 32.55482709345109}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\treturn std::pair<float, float> (0.0f, 0.0f);\n}", "CodeBleu_score": 3.487625535734183}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat segmentLengthSquared = (end - start).lengthSquared();\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn {0.0f, (point - start).length()};\n\t}\n\tfloat segmentLength = sqrt(segmentLengthSquared);\n\tfloat segmentNormalizedT = dot(point - start, end - start) / segmentLengthSquared;\n\tsegmentNormalizedT = clamp(segmentNormalizedT, 0.0f, segmentLength);\n\tvec2 segmentProjection = start + segmentNormalizedT * (end - start);\n\treturn {segmentNormalizedT, (point - segmentProjection).length()};\n}", "CodeBleu_score": 31.63545522448056}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tindex_type initial_index = _vertices.size();\n\t_vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n\tfor (size_t i = 1; i < vertices.size() - 1; i++) {\n\t\tAddIndex(initial_index);\n\t\tAddIndex(initial_index + i);\n\t\tAddIndex(initial_index + i + 1);\n\t}\n}", "CodeBleu_score": 53.43261706755478}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\n}", "CodeBleu_score": 5.829718325262547}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t assert(vertices.size() >= 3);\n index_type initial_index = GetVerticesNum();\n AddVertices(vertices);\n for (index_type i = 1; i < vertices.size() - 1; i++) {\n AddIndex(initial_index);\n AddIndex(initial_index + i);\n AddIndex(initial_index + i + 1);\n }\n }", "CodeBleu_score": 50.32132908585739}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\treturn;\n\t}\n\tauto message_size = message->size();\n\tif (message_size == 0) {\n\t\treturn;\n\t}\n\tif (!IsOpen()) {\n\t\treturn;\n\t}\n\tauto self = shared_from_this();\n\tauto handle_sent = [self, message_size](boost::system::error_code ec, std::size_t) {\n\t\tif (ec) {\n\t\t\tLOG_ERROR(\"Error while writing: \" << ec.message());\n\t\t\tself->Close();\n\t\t} else if (message_size != self->message_size_) {\n\t\t\tLOG_ERROR(\"Error while writing: sent \" << message_size << \" bytes instead of \" << self->message_size_);\n\t\t\tself->Close();\n\t\t} else {\n\t\t\tLOG_DEBUG(\"Sent message of \" << message_size << \" bytes\");\n\t\t}\n\t};\n\tboost::asio::async_write(*socket_, boost::asio::buffer(message->data(), message_size), handle_sent);\n}", "CodeBleu_score": 41.32252738136039}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\treturn;\n\t}\n\tif (message->type() == carla::streaming::detail::tcp::Message::Type::Control) {\n\t\treturn;\n\t}\n\tif (!IsConnected()) {\n\t\treturn;\n\t}\n\tif (!message->is_valid()) {\n\t\treturn;\n\t}\n\tauto handle_sent = [this](boost::system::error_code error, std::size_t bytes_transferred) {\n\t\tif (error) {\n\t\t\tLOG_ERROR(\"Write error: {}\", error.message());\n\t\t\tDisconnect();\n\t\t}\n\t};\n\t_strand.post([this, message, handle_sent]() {\n\t\tboost::asio::async_write(\n\t\t\t_socket,\n\t\t\tboost::asio::buffer(message->header_buffer()),\n\t\t\thandle_sent);\n\t\tboost::asio::async_write(\n\t\t\t_socket,\n\t\t\tboost::asio::buffer(message->payload_buffer()),\n\t\t\thandle_sent);\n\t});\n}", "CodeBleu_score": 38.288588118065455}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (message->size() > MAX_MESSAGE_SIZE) {\n\t\tLOG_WARNING(\"Message too large to be sent: \" + std::to_string(message->size()));\n\t\treturn;\n\t}\n\tif (!IsOpen()) {\n\t\tLOG_WARNING(\"Attempted to write to closed connection\");\n\t\treturn;\n\t}\n\tauto handle_sent = [this, message](const boost::system::error_code &ec, std::size_t bytes_transferred) {\n\t\tif (ec) {\n\t\t\tLOG_WARNING(\"Error sending message: \" + ec.message());\n\t\t\tClose();\n\t\t}\n\t};\n\tauto handle_timeout = [this, message](const boost::system::error_code &ec) {\n\t\tif (ec) {\n\t\t\tLOG_WARNING(\"Timeout sending message: \" + ec.message());\n\t\t\tClose();\n\t\t}\n\t};\n\tboost::asio::post(strand, [this, message, handle_sent, handle_timeout]() {\n\t\tif (!IsOpen()) {\n\t\t\tLOG_WARNING(\"Attempted to write to closed connection\");\n\t\t\treturn;\n\t\t}\n\t\tboost::asio::async_write(socket, *message, handle_sent);\n\t\ttimer.expires_from_now(boost::posix_time::milliseconds(WRITE_TIMEOUT_MS));\n\t\ttimer.async_wait(handle_timeout);\n\t});\n}", "CodeBleu_score": 43.89059867504434}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tdeadline_.cancel();\n\tif (!ec && socket_.is_open()) {\n\t\tsocket_.shutdown(tcp::socket::shutdown_both, ec);\n\t\tsocket_.close(ec);\n\t}\n\tif (on_closed) {\n\t\ton_closed();\n\t}\n\tLOG(INFO) << \"Session \" << id << \" closed.\";\n}", "CodeBleu_score": 50.06587357131218}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer\n\tdeadline_.cancel();\n\n\t// Close the socket\n\tif (socket_.is_open()) {\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\tsocket_.close(ec);\n\t}\n\n\t// If there was an error\n\tif (ec) {\n\t\t// Log the error\n\t\tstd::cerr << \"Error: \" << ec.message() << std::endl;\n\t} else {\n\t\t// Log the session close\n\t\tstd::cout << \"Session closed.\" << std::endl;\n\t}\n\n\t// Trigger the on_closed callback\n\ton_closed();\n}", "CodeBleu_score": 52.92226233071188}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\tif (ec) {\n\t\treturn;\n\t}\n\n\tif (deadline_timer_) {\n\t\tdeadline_timer_.cancel();\n\t}\n\n\tif (socket_.is_open()) {\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\tsocket_.close(ec);\n\t}\n\n\tif (ec) {\n\t\treturn;\n\t}\n\n\tLOG_INFO << \"Session closed\";\n\n\tif (on_closed_) {\n\t\ton_closed_();\n\t}\n}", "CodeBleu_score": 49.41527205966818}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar message[] = \"Are you alive?\";\n\tchar buffer[256];\n\tsprintf(buffer, \"%s\", message);\n\tLog(buffer);\n\tWrite(buffer, YOU_ALIVE);\n\tSleep(1000);\n\tRead();\n}", "CodeBleu_score": 18.665296721944202}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar buffer[100];\n\tsprintf(buffer, \"Are you alive?\");\n\tLogger::Log(\"Sending: %s\", buffer);\n\tSerial.write(buffer);\n\tSerial.write(\"\n\");\n\tSerial.flush();\n\tLogger::Log(\"Waiting for response...\");\n\tchar response[100];\n\tSerial.readBytesUntil('\n', response, 100);\n\tLogger::Log(\"Received: %s\", response);\n}", "CodeBleu_score": 39.08452326783715}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer from the message\n\tchar buffer[100];\n\tsprintf(buffer, \"Are you alive?\");\n\n\t// Log the sending action\n\tLogSending(buffer);\n\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\tWrite(buffer, YOU_ALIVE);\n\n\t// Wait for and log the response from the system\n\tchar response[100];\n\tRead(response, YOU_ALIVE);\n\tLogReceiving(response);\n}", "CodeBleu_score": 25.763638868612777}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor is already activated\n\tif (sensor_id in active_sensors) {\n\t\treturn;\n\t}\n\n\t// Create a buffer to send to the server\n\tuint8_t buffer[1024];\n\tuint32_t buffer_len = 0;\n\n\t// Add the sensor ID to the buffer\n\tbuffer[buffer_len++] = sensor_id;\n\n\t// Add the command to the buffer\n\tbuffer[buffer_len++] = ENABLE_ROS;\n\n\t// Send the buffer to the server\n\tSendBuffer(buffer, buffer_len);\n\n\t// Wait for the response from the server\n\tuint8_t* response = ReceiveBuffer();\n\tuint32_t response_len = response[0];\n\n\t// Check if the server responded with an error\n\tif (response[1] == ERROR) {\n\t\t// Log an error message\n\t\tstd::string error_message = \"Error: \";\n\t\terror_message += std::string(response + 2, response_len - 2);\n\t\tLog(error_message);\n\n\t\t// Free the response\n\t\tfree(response);\n\t\treturn;\n\t}\n\n\t// Check if the server responded with a success\n\tif (response[1] == SUCCESS) {\n\t\t// Add the sensor to the active sensors list\n\t\tactive_sensors.push_back(sensor_id);\n\n\t\t// Log a success message\n\t\tstd::string success_message = \"Enabled ROS for sensor \";\n\t\tsuccess_message += std::to_string(sensor_id);\n\t\tLog(success_message);\n\t}\n\n\t// Free the response\n\tfree(response);\n}", "CodeBleu_score": 37.73318995465373}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tint i = 0;\n\tfor(i = 0; i < NUM_SECONDARY_SERVERS; i++) {\n\t\tif(secondary_servers[i].activated) {\n\t\t\tROS_INFO(\"PrimaryCommands::SendEnableForROS: Found sensor on secondary server %d\", i);\n\t\t\tROS_INFO(\"PrimaryCommands::SendEnableForROS: Sending ENABLE_ROS to secondary server %d\", i);\n\t\t\tstream_id sensor_id_buf;\n\t\t\tsensor_id_buf.id = sensor_id.id;\n\t\t\tsecondary_servers[i].ros_comm.SendEnableROS(sensor_id_buf);\n\t\t\tROS_INFO(\"PrimaryCommands::SendEnableForROS: Waiting for response from secondary server %d\", i);\n\t\t\tsecondary_servers[i].ros_comm.RecvEnableROS();\n\t\t\tROS_INFO(\"PrimaryCommands::SendEnableForROS: Response from secondary server %d received\", i);\n\t\t\treturn;\n\t\t}\n\t}\n\tROS_ERROR(\"PrimaryCommands::SendEnableForROS: Sensor %d not found on any secondary server\", sensor_id.id);\n}", "CodeBleu_score": 34.32499424280231}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if the sensor is activated on any secondary server\n\tif (CheckSensor(sensor_id)) {\n\t\t// Create a buffer with the sensor ID\n\t\tuint8_t buffer[1];\n\t\tbuffer[0] = sensor_id;\n\t\t// Send an ENABLE_ROS command to the server using the router\n\t\tRouter::SendCommandToSecondaryServer(buffer, 1, ENABLE_ROS);\n\t\t// Wait for and process the server's response\n\t\tProcessSecondaryServerResponse(sensor_id);\n\t}\n\telse {\n\t\t// Log an error message\n\t\tLog::Log(\"ERROR: Sensor \" + to_string(sensor_id) + \" not found on any secondary server.\", ERROR);\n\t}\n}", "CodeBleu_score": 25.244088720212186}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tauto it = _sensor_map.find(sensor_id);\n\tif (it != _sensor_map.end()) {\n\t\tlog_info(\"sensor already enabled\");\n\t\treturn it->second.get_token();\n\t}\n\telse {\n\t\tlog_info(\"sensor not enabled, enabling\");\n\t\tauto token = SendGetToken(sensor_id);\n\t\t_sensor_map[sensor_id] = sensor_data(token, true);\n\t\treturn token;\n\t}\n}", "CodeBleu_score": 47.20262125923686}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t\tauto it = _sensor_map.find(sensor_id);\n\tif (it != _sensor_map.end()) {\n\t\tlog_info(\"sensor \", sensor_id, \" is already active, returning the token\");\n\t\treturn it->second;\n\t}\n\tlog_info(\"sensor \", sensor_id, \" is not active, asking for a token\");\n\tauto token = SendGetToken(sensor_id);\n\t_sensor_map.insert(std::make_pair(sensor_id, token));\n\treturn token;\n}", "CodeBleu_score": 46.28475058669699}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t#ifdef DEBUG\n  log_info(\"asking for a token\");\n#endif\n  if (sensor_id == 0) {\n    throw std::runtime_error(\"cannot get token for sensor 0\");\n  }\n  if (_sensors_map.find(sensor_id) != _sensors_map.end()) {\n    auto token = _sensors_map[sensor_id].get_token();\n#ifdef DEBUG\n    log_info(\"got a token: \", token.get_stream_id(), \", \", token.get_port());\n#endif\n    return token;\n  }\n  token_type token = SendGetToken(sensor_id);\n  _sensors_map[sensor_id] = SensorData(sensor_id, token);\n#ifdef DEBUG\n  log_info(\"got a token: \", token.get_stream_id(), \", \", token.get_port());\n#endif\n  return token;\n}", "CodeBleu_score": 50.00830948180691}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\nstd::istream_iterator<uint8_t> start(f), end;\n\n// read the whole file\nf.open(filename, std::ios::binary);\nif (!f.is_open()) {\nreturn false;\n}\nstd::vector<uint8_t> content(start, end);\nf.close();\n\n// parse the content\nreturn Load(std::move(content));\n}", "CodeBleu_score": 96.41415633097596}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!ready) {\n\t\tassert(false);\n\t\treturn false;\n\t}\n\tif (crowd == nullptr) {\n\t\tassert(false);\n\t\treturn false;\n\t}\n\n\t// Get the index of the agent in the crowd\n\tint index = crowd->getAgentIndex(id);\n\tif (index == -1) {\n\t\t// Agent is not in the crowd\n\t\treturn false;\n\t}\n\n\t// Remove the agent from the crowd\n\tstd::lock_guard<std::mutex> lock(crowd_mutex);\n\tcrowd->removeAgent(index);\n\n\t// Remove the agent from the walker or vehicle manager\n\tif (agent_manager == &walker_manager) {\n\t\twalker_manager.RemoveAgent(id);\n\t}\n\telse if (agent_manager == &vehicle_manager) {\n\t\tvehicle_manager.RemoveAgent(id);\n\t}\n\telse {\n\t\tassert(false);\n\t}\n\n\t// Remove the agent from the id mappings\n\tagent_id_to_index.erase(id);\n\tindex_to_agent_id.erase(index);\n\n\treturn true;\n}", "CodeBleu_score": 45.11775430675784}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!ready) {\n\t\tassert(false);\n\t\treturn false;\n\t}\n\n\tif (!crowd) {\n\t\tassert(false);\n\t\treturn false;\n\t}\n\n\tstd::lock_guard<std::mutex> lock(agent_mutex);\n\n\tif (walkers.find(id) != walkers.end()) {\n\t\tcrowd->removeAgent(walkers[id]);\n\t\twalkers.erase(id);\n\t\treturn true;\n\t}\n\telse if (vehicles.find(id) != vehicles.end()) {\n\t\tcrowd->removeAgent(vehicles[id]);\n\t\tvehicles.erase(id);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 41.190446985473194}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// Ensure the system is ready\n\tassert(ready);\n\t// Ensure the crowd object is not null\n\tassert(crowd);\n\n\t// Enter a critical section\n\tstd::lock_guard<std::mutex> lock(crowdMutex);\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tauto walkerItr = walkers.find(id);\n\tauto vehicleItr = vehicles.find(id);\n\n\t// If found, remove the agent from the crowd, update the walker or vehicle manager, and remove the id from the mappings\n\tif (walkerItr != walkers.end()) {\n\t\tcrowd->removeAgent(walkerItr->second);\n\t\twalkers.erase(walkerItr);\n\t} else if (vehicleItr != vehicles.end()) {\n\t\tcrowd->removeAgent(vehicleItr->second);\n\t\tvehicles.erase(vehicleItr);\n\t} else {\n\t\treturn false;\n\t}\n\n\t// Exit the critical section\n\treturn true;\n}", "CodeBleu_score": 47.35950029448311}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n#if DEBUG_VEHICLE_SPAWN\n    static int frame = 0;\n    if (frame % 20 == 0) {\n      std::cout << \"UpdateVehicles: \" << vehicles.size() << std::endl;\n    }\n    ++frame;\n#endif\n\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // get the currently mapped vehicles\n    std::set<ActorId> mapped_vehicles_id;\n    for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end(); ++it) {\n      mapped_vehicles_id.insert(it->first);\n    }\n\n    // add or update vehicles\n    for (auto &vehicle : vehicles) {\n      if (vehicle.id == INVALID_ACTOR_ID) {\n        continue;\n      }\n      if (vehicle.transform.location.x == 0.0f && vehicle.transform.location.y == 0.0f) {\n        continue;\n      }\n      if (vehicle.transform.rotation.yaw == 0.0f) {\n        continue;\n      }\n\n      // add or update\n      if (mapped_vehicles_id.find(vehicle.id) == mapped_vehicles_id.end()) {\n        AddOrUpdateVehicle(vehicle);\n      } else {\n        AddOrUpdateVehicle(vehicle);\n      }\n    }\n\n    // remove vehicles\n    for (auto it = mapped_vehicles_id.begin(); it != mapped_vehicles_id.end(); ++it) {\n      if (vehicles.end() == std::find_if(vehicles.begin(), vehicles.end(),\n          [it](const VehicleCollisionInfo &vehicle) { return vehicle.id == *it; })) {\n        RemoveAgent(*it);\n      }\n    }\n\n    return true;\n  }", "CodeBleu_score": 48.124474789297864}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n#if DEBUG_HELPERS\n  if (_debug_helper) {\n    _debug_helper->DrawPoint(vehicles[0].transform.location, 0.1f, carla::Color(255, 0, 0), 0.05f);\n  }\n#endif\n\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  DEBUG_ASSERT(_crowd != nullptr);\n\n  // get the ids of the current mapped vehicles\n  std::set<ActorId> current_ids;\n  for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end(); ++it) {\n    current_ids.insert(it->first);\n  }\n\n  // add or update vehicles\n  for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n    if (current_ids.find(it->id) != current_ids.end()) {\n      AddOrUpdateVehicle(*it);\n    } else {\n      AddOrUpdateVehicle(*it);\n    }\n  }\n\n  // remove vehicles not updated\n  for (auto it = current_ids.begin(); it != current_ids.end(); ++it) {\n    if (vehicles.end() == std::find_if(vehicles.begin(), vehicles.end(), [it](const VehicleCollisionInfo &v) { return v.id == *it; })) {\n      RemoveAgent(*it);\n    }\n  }\n\n  return true;\n}", "CodeBleu_score": 43.80206535858353}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tnamespace cg = carla::geom;\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // get the current vehicle IDs\n    std::set<ActorId> current_ids;\n    for (auto &pair : _mapped_vehicles_id) {\n      current_ids.insert(pair.first);\n    }\n\n    // add vehicles\n    for (auto &vehicle : vehicles) {\n      if (current_ids.find(vehicle.id) == current_ids.end()) {\n        AddOrUpdateVehicle(vehicle);\n      } else {\n        current_ids.erase(vehicle.id);\n      }\n    }\n\n    // remove vehicles\n    for (auto id : current_ids) {\n      RemoveAgent(id);\n    }\n\n    return true;\n  }", "CodeBleu_score": 49.58298866001035}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t", "CodeBleu_score": 3.60341932389708}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// Check if the actor is already in the walkers or vehicles lists\n\tif (m_Walkers.count(id) > 0) {\n\t\treturn HasVehicleNearWalker(id, distance, direction);\n\t} else if (m_Vehicles.count(id) > 0) {\n\t\treturn HasVehicleNearVehicle(id, distance, direction);\n\t} else {\n\t\t// If the actor is not in the lists, it is not in the crowd\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 26.727430206398395}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &walker = m_walkers[id];\n\tauto &route = walker.route;\n\tif (route.empty()) {\n\t\treturn EventResult::Continue;\n\t}\n\n\tauto &route_point = route.front();\n\tauto &visitor = WalkerEventVisitor{ m_context, id, delta };\n\tauto result = boost::variant2::visit(visitor, route_point);\n\tif (result == EventResult::Continue) {\n\t\troute.pop_front();\n\t}\n\treturn result;\n}", "CodeBleu_score": 43.38019899962086}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the current route point from the walker info\n\tauto route_point = info.route_points.front();\n\tinfo.route_points.pop_front();\n\n\t// Create a visitor that will process the event\n\tWalkerEventVisitor visitor(info.context);\n\n\t// Execute the event using the visitor\n\tauto result = boost::variant2::visit(visitor, route_point);\n\n\t// Return the result of the event\n\treturn result;\n}", "CodeBleu_score": 43.65780620895941}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tif (info.route.empty()) {\n\t\treturn EventResult::kContinue;\n\t}\n\n\tauto &route_point = info.route.front();\n\tauto result = boost::variant2::visit(WalkerEventVisitor(id, delta, info.context), route_point.event);\n\tif (result == EventResult::kContinue) {\n\t\tinfo.route.pop_front();\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.52383772134104}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t", "CodeBleu_score": 4.77195233928401}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node in the xml document\nfor (pugi::xml_node road_node : xml.children(\"road\")) {\n\n  // Get the road id\n  road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n  // Iterate through each lane section in the lanes node\n  for (pugi::xml_node lane_section_node : road_node.children(\"lanes\").children(\"laneSection\")) {\n\n    // Get the lane section id\n    road::LaneSectionId section_id = lane_section_node.attribute(\"id\").as_int();\n\n    // Iterate through each left lane in the lane section\n    for (pugi::xml_node left_lane_node : lane_section_node.children(\"left\")) {\n\n      // Get the left lane id\n      road::LaneId left_lane_id = left_lane_node.attribute(\"id\").as_int();\n\n      // Parse the lane\n      ParseLanes(\n          road_id,\n          section_id,\n          left_lane_id,\n          left_lane_node,\n          map_builder);\n    }\n\n    // Iterate through each center lane in the lane section\n    for (pugi::xml_node center_lane_node : lane_section_node.children(\"center\")) {\n\n      // Get the center lane id\n      road::LaneId center_lane_id = center_lane_node.attribute(\"id\").as_int();\n\n      // Parse the lane\n      ParseLanes(\n          road_id,\n          section_id,\n          center_lane_id,\n          center_lane_node,\n          map_builder);\n    }\n\n    // Iterate through each right lane in the lane section\n    for (pugi::xml_node right_lane_node : lane_section_node.children(\"right\")) {\n\n      // Get the right lane id\n      road::LaneId right_lane_id = right_lane_node.attribute(\"id\").as_int();\n\n      // Parse the lane\n      ParseLanes(\n          road_id,\n          section_id,\n          right_lane_id,\n          right_lane_node,\n          map_builder);\n    }\n  }\n}\n}", "CodeBleu_score": 57.69350993157359}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through all roads in the XML document\nfor (pugi::xml_node road_node : xml.children(\"road\")) {\n\n  // Extract road ID\n  road::RoadId road_id = road_node.attribute(\"id\").as_int();\n\n  // Iterate through all lane sections in the road\n  for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n\n    // Extract lane section ID\n    road::LaneSectionId lane_section_id = lane_section_node.attribute(\"id\").as_int();\n\n    // Extract lane section s\n    double s = lane_section_node.attribute(\"s\").as_double();\n\n    // Iterate through all left lanes in the lane section\n    for (pugi::xml_node left_lanes_node : lane_section_node.children(\"left\")) {\n\n      // Parse lanes\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          s,\n          left_lanes_node,\n          map_builder);\n    }\n\n    // Iterate through all center lanes in the lane section\n    for (pugi::xml_node center_lanes_node : lane_section_node.children(\"center\")) {\n\n      // Parse lanes\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          s,\n          center_lanes_node,\n          map_builder);\n    }\n\n    // Iterate through all right lanes in the lane section\n    for (pugi::xml_node right_lanes_node : lane_section_node.children(\"right\")) {\n\n      // Parse lanes\n      ParseLanes(\n          road_id,\n          lane_section_id,\n          s,\n          right_lanes_node,\n          map_builder);\n    }\n  }\n}\n}", "CodeBleu_score": 60.837024786503434}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (info.total_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tmatched_count_++;\n\t\t\tif (matched_count_ == 1) {\n\t\t\t\tfirst_connection_ = true;\n\t\t\t}\n\t\t} else {\n\t\t\tmatched_count_--;\n\t\t}\n\t} else if (info.total_count_change == -1) {\n\t\tif (info.current_count == 0) {\n\t\t\tmatched_count_--;\n\t\t} else {\n\t\t\tmatched_count_++;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Error: invalid count change on topic \" << info.topic_name << std::endl;\n\t}\n}", "CodeBleu_score": 55.515145085098425}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t#if DEBUG_LOG == 1\n  std::cout << \"Publication Matched\" << std::endl;\n#endif\n\n  if (info.current_count_change == 1) {\n    _matched_count = info.total_count;\n    _first_connection = true;\n  } else if (info.current_count_change == -1) {\n    _matched_count = info.total_count;\n  } else {\n#if DEBUG_LOG == 1\n    std::cout << \"Error: invalid matched count change \" << info.current_count_change << std::endl;\n#endif\n  }\n}", "CodeBleu_score": 70.57113612136193}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\tif (info.total_count_change == 1) {\n\t\tmatched_ = true;\n\t\tconnection_ready_ = true;\n\t\tconnection_ready_cv_.notify_all();\n\t} else if (info.total_count_change == -1) {\n\t\tmatched_ = false;\n\t} else {\n\t\tRCLCPP_ERROR(get_logger(), \"Unexpected total count change on topic %s: %d\", writer->get_topic_name(), info.total_count_change);\n\t}\n}", "CodeBleu_score": 40.36586469044801}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\t\tif (matched_count_ == 0) {\n\t\t\tfirst_connected_ = true;\n\t\t}\n\t\t++matched_count_;\n\t} else if (info.current_count_change == -1) {\n\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\t\t--matched_count_;\n\t\tif (matched_count_ == 0) {\n\t\t\tif (reader_ != nullptr) {\n\t\t\t\treader_->destroy();\n\t\t\t}\n\t\t\treader_ = nullptr;\n\t\t}\n\t} else {\n\t\tstd::cout << \"SubscriptionMatchedStatus current count change \" << info.current_count_change << \" invalid.\" << std::endl;\n\t}\n}", "CodeBleu_score": 54.89789769642459}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\tm_matched_count++;\n\t\tif (m_matched_count == 1) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\tm_matched_count--;\n\t\tif (m_matched_count == 0) {\n\t\t\tm_subscriber.reset();\n\t\t}\n\t} else {\n\t\tstd::cout << \"Subscription matched callback with invalid change count \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 55.43674771964715}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (info.current_count_change == 1) {\n\t\t++matched_count;\n\t\tif (matched_count == 1) {\n\t\t\tfirst_connected = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\t--matched_count;\n\t\tif (matched_count == 0) {\n\t\t\treader->destroy();\n\t\t}\n\t} else {\n\t\tstd::cout << \"Subscription matched callback: invalid change count \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 53.48357369110877}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#if WITH_FASTCDR\n                CarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n                if (p_type == nullptr) {\n                        return false;\n                }\n\n                if (handle != nullptr) {\n                        if (force_md5 || p_type->md5sum == \"\") {\n                                *handle = InstanceHandle_t();\n                                return true;\n                        }\n                        else {\n                                *handle = InstanceHandle_t(p_type->md5sum);\n                                return true;\n                        }\n                }\n\n                return false;\n\n#else\n                (void)data;\n                (void)handle;\n                (void)force_md5;\n                return false;\n#endif\n        }", "CodeBleu_score": 28.3449442828191}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#ifdef ENABLE_DEBUG\n    if (!CarlaCollisionEventPubSubType::isKeyDefined()) {\n        return false;\n    }\n#endif\n\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n\n    // Get serialized key\n    SerializedPayload_t payload(MAX_SER_LEN);\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload.data, MAX_SER_LEN);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    p_type->serializeKey(ser);\n    return m_key_serializer->deserialize(handle, payload);\n}", "CodeBleu_score": 29.034031341650095}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t#if WITH_FASTCDR\n                bool key_present = false;\n                CarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n                cdrStream stream;\n                try {\n                        if (stream.serialize(p_type->id)) {\n                                key_present = true;\n                        }\n                }\n                catch (exception& e) {\n                        string msg(\"Exception in getKey(): \");\n                        msg += e.what();\n                        RMW_CONNECTOR_ERROR(msg.c_str());\n                        return false;\n                }\n                if (!key_present) {\n                        RMW_CONNECTOR_ERROR(\"Unable to retrieve key\");\n                        return false;\n                }\n                if (force_md5 || stream.getSerializedDataLength() > 16) {\n                        MD5 md5;\n                        md5.update(stream.getData(), stream.getSerializedDataLength());\n                        unsigned char* digest = md5.digest();\n                        for (uint32_t i = 0; i < 16; ++i) {\n                                handle->at(i) = digest[i];\n                        }\n                } else {\n                        for (uint32_t i = 0; i < stream.getSerializedDataLength(); ++i) {\n                                handle->at(i) = stream.getData()[i];\n                        }\n                }\n                return true;\n#else\n                (void)data;\n                (void)handle;\n                (void)force_md5;\n                RMW_CONNECTOR_ERROR(\"Function not available since Fast-CDR is not available.\");\n                return false;\n#endif\n        }", "CodeBleu_score": 45.81677537246109}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t(void)payload;\n\tCarlaEgoVehicleControl* typed_data = (CarlaEgoVehicleControl*)data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr cdr(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tif (serialize(cdr, *typed_data)) { // Serialize object.\n\t\tpayload->length = cdr.getSerializedDataLength(); // Get serialized length\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 53.41498096575704}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t(void)payload;\n\tCarlaEgoVehicleControl* p = (CarlaEgoVehicleControl*)data;\n\n\t// Create and initialize CDR serialization object.\n\teprosima::fastcdr::Cdr ser(\n\t\t\teprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR);\n\t// Serialize encapsulation\n\tser.serialize_encapsulation();\n\n\ttry {\n\t\t// Serialize the object.\n\t\tp->serialize(ser);\n\t}\n\tcatch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\t// Get the serialized length\n\tpayload->length = (uint32_t)ser.getSerializedDataLength();\n\treturn true;\n}", "CodeBleu_score": 50.00430200194289}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\t(void)payload;\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that uses the CDR serialization operator\n\teprosima::fastcdr::Cdr cdr(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\tpayload->encapsulation = CDR_LE;\n\t// Serialize encapsulation\n\ttry {\n\t\tcdr << eprosima::fastcdr::Cdr::ENCAPSULATION_ID_CDR;\n\n\t\t// Serialize the object:\n\t\tcdr << *p_type;\n\t}\n\tcatch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 54.68331059572341}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK_BaseClass::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 63.54230855630449}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK_BaseClass::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_altitude_calibration = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 64.80208736644148}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_altitude_calibration = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.7654700664084}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 != 0.0 && packet.param1 != 1.0) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\tif (packet.param1 == 1.0) {\n\t\tarmServos();\n\t}\n\telse {\n\t\tdisarmServos();\n\t}\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 36.86745379026689}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n\tif (packet.param1 == 1.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\t// Arm the servos\n\t} else if (packet.param1 == 0.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\t// Disarm the servos\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 48.030122431162695}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\t// Arm\n\t\tif (this->arm()) {\n\t\t\treturn MAV_RESULT::MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT::MAV_RESULT_FAILED;\n\t\t}\n\t} else if (packet.param1 == 0.0) {\n\t\t// Disarm\n\t\tif (this->disarm()) {\n\t\t\treturn MAV_RESULT::MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT::MAV_RESULT_FAILED;\n\t\t}\n\t} else {\n\t\treturn MAV_RESULT::MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 44.879046738500705}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t", "CodeBleu_score": 5.5394447414533605}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over the available GCS channels\n\tfor (uint8_t i = 0; i < MAX_GCS_CHANNELS; i++) {\n\t\t// Check if the channel is available\n\t\tif (gcs_channels[i].available) {\n\t\t\t// Check if space is available on the channel\n\t\t\tif (gcs_channels[i].available_space >= POSITION_DATA_SIZE) {\n\t\t\t\t// Send a request to start the data stream\n\t\t\t\tsend_datastream_request(sysid, compid, i, POSITION_DATA_SIZE, POSITION_DATA_RATE);\n\t\t\t\t// Set the channel to busy\n\t\t\t\tgcs_channels[i].busy = true;\n\t\t\t\t// Update the available space\n\t\t\t\tgcs_channels[i].available_space -= POSITION_DATA_SIZE;\n\t\t\t\t// Break the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.90273936981007}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\t// Iterate over all available channels\n\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\t// Check if channel is available\n\t\tif (channels[i].available) {\n\t\t\t// Check if space is available\n\t\t\tif (channels[i].space_available()) {\n\t\t\t\t// Send request to start data stream\n\t\t\t\tchannels[i].request_datastream_position(sysid, compid);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 31.423532311628644}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Retrieve the AHRS instance\n\tAHRS *ahrs = ahrs_get_instance();\n\n\t// Check for a zero pitch cosine to avoid division by zero\n\tif(cos(pitch) == 0) {\n\t\treturn false;\n\t}\n\n\t// Calculate the earth frame pitch and yaw using trigonometric conversions\n\tef_pitch = atan2(sin(pitch) * cos(ahrs->roll) + cos(pitch) * sin(ahrs->roll) * sin(ahrs->yaw), cos(pitch) * cos(ahrs->yaw) - sin(pitch) * sin(ahrs->roll) * cos(ahrs->yaw));\n\tef_yaw = atan2(sin(yaw) * cos(ahrs->roll) + cos(yaw) * sin(ahrs->roll) * sin(ahrs->yaw), cos(yaw) * cos(ahrs->yaw) - sin(yaw) * sin(ahrs->roll) * cos(ahrs->yaw));\n\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 49.88902382540181}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tAHRS *ahrs = ahrs_get_yaw_pitch_roll();\n\tif (ahrs == NULL) {\n\t\treturn false;\n\t}\n\tfloat pitch_cos = cos(pitch);\n\tif (pitch_cos == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = -ahrs->pitch + pitch;\n\tef_yaw = ahrs->yaw + yaw;\n\treturn true;\n}", "CodeBleu_score": 45.88874528916729}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\tfloat pitch_cos = cos(pitch);\n\tif (pitch_cos == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = atan(tan(pitch) / pitch_cos);\n\tef_yaw = yaw + asin(pitch_cos);\n\treturn true;\n}", "CodeBleu_score": 34.15079319894202}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// get yaw and pitch from navigation status\n\tconst struct Tracker::NavStatus &nav_status = tracker.nav_status;\n\tfloat yaw = nav_status.bearing;\n\tfloat pitch = nav_status.pitch;\n\n\t// check if the direction is reversed\n\tbool direction_reversed = get_ef_yaw_direction();\n\n\t// calculate angle error\n\tcalc_angle_error(pitch, yaw, direction_reversed);\n\n\t// if the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n\tif (tracker.target_distance_valid || tracker.target_distance_min == 0) {\n\t\t// convert the angle error from body frame to earth frame\n\t\tfloat bf_pitch_err = tracker.nav_status.angle_error_pitch;\n\t\tfloat bf_yaw_err = tracker.nav_status.angle_error_yaw;\n\t\tfloat ef_pitch_err;\n\t\tfloat ef_yaw_err;\n\t\tconvert_bf_to_ef(bf_pitch_err, bf_yaw_err, ef_pitch_err, ef_yaw_err);\n\n\t\t// update the pitch and yaw servos\n\t\tParameters &g = tracker.g;\n\t\ttracker.pitch_servo_out_filt.apply_lowpass(ef_pitch_err * g.pidPitch2Srv.get_p() + g.pidPitch2Srv.get_i() * tracker.pitch_servo_out_filt.get());\n\t\ttracker.yaw_servo_out_filt.apply_lowpass(ef_yaw_err * g.pidYaw2Srv.get_p() + g.pidYaw2Srv.get_i() * tracker.yaw_servo_out_filt.get());\n\t}\n}", "CodeBleu_score": 52.810050737120484}, {"code": "void Mode::update_auto(void){\n\t\t// get yaw and pitch from navigation status\n\tstruct Tracker::NavStatus &nav_status = tracker.nav_status;\n\tfloat yaw = nav_status.bearing;\n\tfloat pitch = nav_status.pitch;\n\n\t// if the target is valid or no minimum distance is set, then use the yaw and pitch\n\tif (nav_status.distance_valid || !tracker.g.min_distance_cm) {\n\t\t// calculate angle error in centidegrees\n\t\tcalc_angle_error(pitch, yaw, get_ef_yaw_direction());\n\n\t\t// convert angle error to body frame\n\t\tfloat bf_pitch_err;\n\t\tfloat bf_yaw_err;\n\t\tconvert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n\n\t\t// update pitch and yaw servos\n\t\ttracker.update_servos(bf_pitch_err, bf_yaw_err);\n\t}\n}", "CodeBleu_score": 39.014069178563126}, {"code": "void Mode::update_auto(void){\n\t", "CodeBleu_score": 1.437537036756294}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tGPS_fix_status = GPS.status;\n\tGPS_fix_time = GPS.last_message_time_ms;\n\tif (GPS.status >= 3) {\n\t\tif (GPS.location.isUpdated()) {\n\t\t\tif (GPS_fix_time != GPS.last_message_time_ms) {\n\t\t\t\tGPS_fix_time = GPS.last_message_time_ms;\n\t\t\t\tif (GPS_home_count > 0) {\n\t\t\t\t\tGPS_home_count = 0;\n\t\t\t\t}\n\t\t\t\tif (GPS_home_count == 0) {\n\t\t\t\t\tif (GPS.location.isUpdated()) {\n\t\t\t\t\t\tif (GPS.location.is_3D()) {\n\t\t\t\t\t\t\tif (GPS.location.is_valid()) {\n\t\t\t\t\t\t\t\tGPS_home_lat = GPS.location.lat();\n\t\t\t\t\t\t\t\tGPS_home_lon = GPS.location.lon();\n\t\t\t\t\t\t\t\tGPS_home_alt = GPS.altitude();\n\t\t\t\t\t\t\t\tGPS_home_count = GPS_HOME_DELAY;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (GPS_home_count > 0) {\n\t\t\tGPS_home_count = 0;\n\t\t}\n\t}\n\tif (GPS_home_count > 0) {\n\t\tGPS_home_count--;\n\t}\n}", "CodeBleu_score": 44.448002133092224}, {"code": "void Tracker::update_GPS(void){\n\t\tif (GPS_status == 0) {\n\t\tif (GPS_last_message_time != GPS_current_message_time) {\n\t\t\tGPS_current_message_time = GPS_last_message_time;\n\t\t\tif (GPS_status >= 3) {\n\t\t\t\tif (GPS_fix_type == 3) {\n\t\t\t\t\tif (GPS_countdown == 0) {\n\t\t\t\t\t\tif (GPS_latitude != 0.0f && GPS_longitude != 0.0f) {\n\t\t\t\t\t\t\tif (GPS_altitude != 0.0f) {\n\t\t\t\t\t\t\t\tif (GPS_speed != 0.0f) {\n\t\t\t\t\t\t\t\t\tGPS_countdown = 10;\n\t\t\t\t\t\t\t\t\tif (home_location_set == false) {\n\t\t\t\t\t\t\t\t\t\thome_location_set = true;\n\t\t\t\t\t\t\t\t\t\thome_location.latitude = GPS_latitude;\n\t\t\t\t\t\t\t\t\t\thome_location.longitude = GPS_longitude;\n\t\t\t\t\t\t\t\t\t\thome_location.altitude = GPS_altitude;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tGPS_countdown = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tGPS_countdown = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGPS_countdown = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGPS_countdown--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tGPS_countdown = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGPS_countdown = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.255202146266925}, {"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\n}", "CodeBleu_score": 4.699969814793938}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch >= 0) {\n\t\tif (pitch > 180) {\n\t\t\tpitch = 180;\n\t\t}\n\t\tif (pitch < 0) {\n\t\t\tpitch = 0;\n\t\t}\n\t\t//Serial.print(\"Pitch: \");\n\t\t//Serial.println(pitch);\n\t\tif (pitch < 10) {\n\t\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, LOW);\n\t\t\tdelay(1000);\n\t\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, HIGH);\n\t\t} else {\n\t\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, HIGH);\n\t\t\tdelay(1000);\n\t\t\tdigitalWrite(PITCH_ONOFF_SERVO_PIN, LOW);\n\t\t}\n\t}\n}", "CodeBleu_score": 26.937987213529937}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\t// Update the pitch\n\tpitch_onoff_servo.write(pitch);\n}", "CodeBleu_score": 9.580925094747831}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\n// call base class method\nbool success = AP_Arming::barometer_checks(display_failure);\n\n// check if we are arming and the barometer check is enabled\nif (armed() && _check_baro) {\n\n// get barometer altitude\nfloat baro_alt = get_baro_altitude();\n\n// compare with inertial navigation altitude\nfloat nav_alt = get_nav_altitude();\n\n// if the barometer altitude is more than 100 meters above the inertial navigation altitude, log a failure\nif (baro_alt - nav_alt > 100.0f) {\nif (display_failure) {\nprint_name(\"barometer altitude disparity too large\");\n}\nreturn false;\n}\n}\n\n// return success\nreturn success;\n}", "CodeBleu_score": 27.61096239785167}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tbool result = AP_Arming::barometer_checks(display_failure);\n\nif (result) {\n// if we are arming using a barometer, check the altitude\nif (_baro_enabled && _baro_alt_source == ARMING_CHECK_BARO) {\nfloat baro_alt = _baro.get_altitude_feet();\nfloat nav_alt = _ahrs.get_altitude_feet();\n\nif (fabsf(baro_alt - nav_alt) > _baro_alt_max_diff) {\nif (display_failure) {\nif (_baro_alt_max_diff == 0) {\nmavlink_log_info(_mavlink_fd, \"Barometer altitude too high\");\n} else {\nmavlink_log_info(_mavlink_fd, \"Barometer altitude too high (%.1f ft)\", (baro_alt - nav_alt));\n}\n}\nreturn false;\n}\n}\n}\nreturn result;\n}", "CodeBleu_score": 44.177009978236924}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_APM1\n    if (g.baro_cal_status == AP_HAL::Util::Baro::CAL_STATUS_ERROR) {\n        if (display_failure) {\n            hal.console->println(\"Barometer calibration error\");\n        }\n        return false;\n    }\n#endif\n    return AP_Arming::barometer_checks(display_failure);\n}", "CodeBleu_score": 21.374322334955064}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_rangefinder != NULL) {\n\t\treturn false;\n\t}\n\tif (_terrain_source == RangeFinder::TerrainSource_TerrainDatabase && _rtl_alt_type == RangeFinder::RTL_AltitudeType_Terrain) {\n\t\treturn true;\n\t}\n\treturn AP_Arming_Base::terrain_database_required();\n}", "CodeBleu_score": 38.39219097688281}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_vehicle->rangefinder->get_distance() > 0.0f) {\n\t\treturn false;\n\t}\n\tif (_vehicle->rangefinder->get_terrain_source() == RangeFinder::TerrainSource_Database && _vehicle->rangefinder->get_terrain_alt_source() == RangeFinder::TerrainAltitudeSource_Terrain) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 63.55023291651724}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_PX4\n    if (_rangefinder_required) {\n        return false;\n    }\n#endif\n\n    if (_rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 39.55419033046764}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\n}", "CodeBleu_score": 3.7146568610244484}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the controllers\n\t_loop_time_micros = _scheduler.get_loop_time_micros();\n\n\t// run the attitude controller\n\t_attitude_control.rate_controller_run(_loop_time_micros);\n}", "CodeBleu_score": 31.657216613542722}, {"code": "void Copter::run_rate_controller(){\n\t\n#if 0 /* this is a test for the new rate controller */\n    // get the time since the last loop\n    float dt_loop = _loop_perf.elapsed_time();\n    _loop_perf.restart();\n\n    // run the rate controller\n    rate_controller_run(dt_loop, _imu_sample_delayed.quat, _imu_sample_delayed.gyro);\n\n    // publish the loop time\n    perf_publish(perf_control_latency, dt_loop);\n\n    // publish the loop time\n    perf_publish(perf_loop_dt, dt_loop);\n#else\n    // get the time since the last loop\n    float dt_loop = _loop_perf.elapsed_time();\n    _loop_perf.restart();\n\n    // run the rate controller\n    rate_controller_run(dt_loop, _imu_sample_delayed.quat, _imu_sample_delayed.gyro);\n\n    // publish the loop time\n    perf_publish(perf_control_latency, dt_loop);\n\n    // publish the loop time\n    perf_publish(perf_loop_dt, dt_loop);\n#endif\n}", "CodeBleu_score": 42.11172412559737}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n#if FRAME_CONFIG == HELI_FRAME\n    // Check if the old and new locations are the same\n    if (old_loc.alt == new_loc.alt && old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n        return false;\n    }\n#else\n    // Check if the old and new locations are the same\n    if (old_loc.alt == new_loc.alt && old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng && old_loc.yaw == new_loc.yaw) {\n        return false;\n    }\n#endif\n\n    // Set the new location as the target\n    set_target_location(new_loc);\n\n    return true;\n}", "CodeBleu_score": 44.26813771949727}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n//    // exit if vehicle is not in Guided mode or Auto-Guided mode\n//    if (!flightmode->in_guided_mode()) {\n//        return false;\n//    }\n\n    // get next waypoint location\n    Location wp_loc = get_location_metres();\n\n    // check if the old location matches the next waypoint location and if the altitude frames of the old and new locations are the same\n    if ((wp_loc.lat == old_loc.lat) && (wp_loc.lng == old_loc.lng) && (wp_loc.alt == old_loc.alt) && (wp_loc.alt_frame == old_loc.alt_frame)) {\n        // set the new location as the target\n        set_target_location(new_loc);\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 55.82034677530589}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\n#if FRAME_CONFIG == HELI_FRAME\n    // if the altitude frame is different, return false\n    if (old_loc.alt_frame != new_loc.alt_frame) {\n        return false;\n    }\n#endif\n\n    // if the old location matches the new location, return false\n    if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n        return false;\n    }\n\n    // set the new location as the target location\n    set_target_location(new_loc);\n\n    return true;\n}", "CodeBleu_score": 49.2089446124769}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode == _mode) {\n\t\t\trc().reset_mode_switch();\n\t\t} else {\n\t\t\tset_mode(mode);\n\t\t}\n\t} else {\n\t\tif (mode == _mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 51.716114317741415}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t#if RC_CHANNEL_DEBUG\n    if (ch_flag == AuxSwitchPos::LOW) {\n        debug_print(\"RC_Channel_Copter::do_aux_function_change_mode: AUX switch is in LOW position.\");\n    } else if (ch_flag == AuxSwitchPos::HIGH) {\n        debug_print(\"RC_Channel_Copter::do_aux_function_change_mode: AUX switch is in HIGH position.\");\n    } else {\n        debug_print(\"RC_Channel_Copter::do_aux_function_change_mode: AUX switch is in UNKNOWN position.\");\n    }\n#endif\n\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        // AUX switch is in HIGH position\n        if (mode == _mode) {\n            // Current flight mode matches the given mode, so reset the mode switch\n            rc().reset_mode_switch();\n        } else {\n            // Attempt to set the mode using the copter's set_mode method\n            if (copter().set_mode(mode)) {\n                // Mode was successfully set, so reset the mode switch\n                rc().reset_mode_switch();\n            } else {\n                // Mode was not successfully set, so reset the mode switch\n                rc().reset_mode_switch();\n            }\n        }\n    } else if (ch_flag == AuxSwitchPos::LOW) {\n        // AUX switch is in LOW position\n        if (_mode == mode) {\n            // Current flight mode matches the given mode, so reset the mode switch\n            rc().reset_mode_switch();\n        }\n    } else {\n        // AUX switch is in UNKNOWN position\n        // Do nothing\n    }\n}", "CodeBleu_score": 50.51475017044299}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (mode != get_mode()) {\n\t\t\tset_mode(mode);\n\t\t}\n\t} else {\n\t\tif (mode == get_mode()) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}", "CodeBleu_score": 50.21810139846692}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\tfloat roll_trim_radians = _roll_control.get_control_output() * _roll_control.get_control_effort() * _ahrs.roll_trim_cd();\n\tfloat pitch_trim_radians = _pitch_control.get_control_output() * _pitch_control.get_control_effort() * _ahrs.pitch_trim_cd();\n\n\t_ahrs.set_roll_trim(roll_trim_radians);\n\t_ahrs.set_pitch_trim(pitch_trim_radians);\n\n\t_log_pub.publish(vehicle_status_s());\n\n\tmavlink_log_info(_mavlink_fd, \"[cal] Roll trim: %.2f degrees\", RAD_TO_DEG * roll_trim_radians);\n\tmavlink_log_info(_mavlink_fd, \"[cal] Pitch trim: %.2f degrees\", RAD_TO_DEG * pitch_trim_radians);\n}", "CodeBleu_score": 39.880586741217755}, {"code": "void Copter::save_trim(){\n\t\tfloat roll_trim_rad = (float)(_roll_control->control_input() - 1500) / 1000.0f;\n\tfloat pitch_trim_rad = (float)(_pitch_control->control_input() - 1500) / 1000.0f;\n\n\t_ahrs.set_trim(roll_trim_rad, pitch_trim_rad);\n\n\t_log_pub.publish(vehicle_status_s());\n\t_mavlink->send_statustext_info(\"Trim saved\");\n}", "CodeBleu_score": 41.45698546972044}, {"code": "void Copter::save_trim(){\n\t\tfloat roll_trim_rad = 0.0f;\n\tfloat pitch_trim_rad = 0.0f;\n\n\t/*\n\t * Calculate the trim values from the control inputs of the roll and pitch channels.\n\t */\n\troll_trim_rad = (float)(_roll_control.control_in * _roll_control.control_in) * _roll_control.control_out;\n\tpitch_trim_rad = (float)(_pitch_control.control_in * _pitch_control.control_in) * _pitch_control.control_out;\n\n\t/*\n\t * Add the trim values to the AHRS trim.\n\t */\n\t_ahrs.set_trim(roll_trim_rad, pitch_trim_rad);\n\n\t/*\n\t * Log the event.\n\t */\n\tevents->log(\"TRIM: roll = %.2f, pitch = %.2f\", (double)roll_trim_rad, (double)pitch_trim_rad);\n\n\t/*\n\t * Send a confirmation message with MAV_SEVERITY_INFO.\n\t */\n\tsend_statustext_info(\"TRIM: roll = %.2f, pitch = %.2f\", (double)roll_trim_rad, (double)pitch_trim_rad);\n}", "CodeBleu_score": 40.34689304875605}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tif (copter.valid_position() && copter.velocity.speed_squared() > 0.01f) {\n\t\tfloat yaw_angle = atan2(copter.velocity.vy, copter.velocity.vx);\n\t\treturn yaw_angle;\n\t}\n\telse {\n\t\treturn 0.0f;\n\t}\n}", "CodeBleu_score": 28.952558314556885}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t", "CodeBleu_score": 2.3286180195392645}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\t// Retrieve the copter's velocity.\n\tfloat vx = state.velocity.x;\n\tfloat vy = state.velocity.y;\n\n\t// Calculate the speed squared.\n\tfloat speed_sq = vx * vx + vy * vy;\n\n\t// If the copter's position is valid and the speed exceeds the minimum threshold, update the look-ahead yaw angle.\n\tif (state.position_valid && speed_sq > MIN_SPEED_SQ) {\n\t\tlook_ahead_yaw_angle = atan2(vy, vx);\n\t}\n\n\t// Return the computed look-ahead yaw angle.\n\treturn look_ahead_yaw_angle;\n}", "CodeBleu_score": 41.678551963440945}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (arming_checks_disabled) {\n\t\treturn true;\n\t}\n\tif (watchdog_armed) {\n\t\treturn true;\n\t}\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (rc_channel_data[AP_RC_Channel::RUDDER] != 1500) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 41.85001377216253}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// bypass arming checks if arming is disabled or the watchdog was armed\n\tif (arming_disabled || watchdog_armed) {\n\t\treturn true;\n\t}\n\n\t// perform plane-specific arming checks\n\tswitch (method) {\n\t\tcase AP_Arming::RUDDER:\n\t\t\t// check if rudder arming is disabled\n\t\t\tif (rudder_arming_disabled) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// check if throttle is not zero\n\t\t\tif (fabsf(get_throttle()) < 0.01f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t// perform arming checks from parent class\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 37.12206641416083}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (arming_disabled() || watchdog_armed()) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 25.739892327562853}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if AP_AHRS_AVAILABLE\n    // update the home location\n    if (ahrs.get_home_location() == Location()) {\n        ahrs.set_home_location(location);\n    }\n#endif\n\n    // update the current location\n    location.update(ahrs.get_location());\n\n    // change the arm state\n    change_arm_state();\n\n    // set the delay arming flag\n    delay_arming = true;\n\n    // send a status text indicating that the throttle is armed\n    if (state == AP_Arming::ARMED) {\n        hal.util->set_status_text(AP_HAL::Util::Arming_State_Name[state]);\n    } else {\n        hal.util->set_status_text(AP_HAL::Util::Arming_State_Name[state] + \" (check radio)\");\n    }\n\n    // return true if arming is successful\n    return true;\n}", "CodeBleu_score": 49.18921319471588}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // in SITL, we always arm the vehicle\n    return true;\n#endif\n\n    // if the vehicle is already armed, don't do anything\n    if (sub.armed()) {\n        return true;\n    }\n\n    // if there's no disarm button, fail if requested\n    if (!has_disarm_function) {\n        if (display_failure) {\n            AP_Notify::flags.arm_failed = true;\n            sub.notify_immediate_msg(MAV_SEVERITY_CRITICAL, PSTR(\"No disarm function assigned\"));\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 60.9317475080529}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\t// check if the vehicle is already armed\n\tif (sub.armed()) {\n\t\treturn true;\n\t}\n\n\t// check if the vehicle has a disarm button assigned\n\tif (!has_disarm_function) {\n\t\tif (display_failure) {\n\t\t\tsub.display_status_message(MAV_SEVERITY_WARNING, PSTR(\"No disarm function assigned\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// call the standard pre-arm checks\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 62.66300559969805}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if defined(HAS_SERVO_ESC)\n    // check for servo esc\n    if (sub.get_servo_esc() != nullptr) {\n        if (sub.get_servo_esc()->servo_esc_enabled()) {\n            if (display_failure) {\n                // show failure message\n                sub.get_status_leds().set_color(LEDs::RED);\n                sub.get_status_leds().set_mode(LEDs::APM_BLINK_FAST);\n                sub.get_status_leds().set_custom_status_msg(\"Servo ESC\");\n                sub.get_status_leds().notify_observers();\n            }\n            return false;\n        }\n    }\n#endif\n\n    // check for disarm button\n    if (!has_disarm_function) {\n        if (display_failure) {\n            // show failure message\n            sub.get_status_leds().set_color(LEDs::RED);\n            sub.get_status_leds().set_mode(LEDs::APM_BLINK_FAST);\n            sub.get_status_leds().set_custom_status_msg(\"No disarm\");\n            sub.get_status_leds().notify_observers();\n        }\n        return false;\n    }\n\n    // do standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 48.68164334304145}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat cos_yaw = cos(yaw);\n\tfloat sin_yaw = sin(yaw);\n\tfloat ne_x = cos_yaw * x - sin_yaw * y;\n\tfloat ne_y = sin_yaw * x + cos_yaw * y;\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 52.756740490525075}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tx = temp_x * cos(yaw) + y * sin(yaw);\n\ty = -temp_x * sin(yaw) + y * cos(yaw);\n}", "CodeBleu_score": 31.854750145874057}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat temp_x = x;\n\tx = cos(yaw)*temp_x + sin(yaw)*y;\n\ty = -sin(yaw)*temp_x + cos(yaw)*y;\n}", "CodeBleu_score": 31.036994740000758}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_DENIED;\n\tfloat yaw_angle = 0;\n\tfloat yaw_rate = 0;\n\tfloat direction = 0;\n\tfloat relative_offset = 0;\n\tfloat yaw_param5 = 0;\n\tfloat yaw_param6 = 0;\n\tfloat yaw_param7 = 0;\n\n\t// Check if the yaw angle and rate are within acceptable ranges\n\tif (packet.param1 >= CONDITION_YAW_ANGLE_MIN && packet.param1 <= CONDITION_YAW_ANGLE_MAX && packet.param2 >= CONDITION_YAW_RATE_MIN && packet.param2 <= CONDITION_YAW_RATE_MAX) {\n\t\t// Set the yaw angle and rate\n\t\tyaw_angle = packet.param1;\n\t\tyaw_rate = packet.param2;\n\t\tdirection = packet.param3;\n\t\trelative_offset = packet.param4;\n\t\tyaw_param5 = packet.param5;\n\t\tyaw_param6 = packet.param6;\n\t\tyaw_param7 = packet.param7;\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 43.4251783084204}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if the yaw angle and param4 values are within acceptable ranges.\n\tif (packet.param1 < 0.0 || packet.param1 > 360.0 || packet.param4 < -90.0 || packet.param4 > 90.0) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters.\n\tyaw_heading = packet.param1;\n\tyaw_mode = packet.param2;\n\tyaw_direction = packet.param3;\n\tyaw_relative = packet.param4;\n\n\t// Return MAV_RESULT_ACCEPTED.\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 50.22829957131758}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_DENIED;\n\n\t// Check that the yaw angle and param4 are within acceptable ranges\n\tif (fabs(packet.param4) <= 360.0f) {\n\t\t// Set the yaw heading\n\t\tyaw_heading = packet.param4;\n\n\t\t// Set the result to accepted\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 25.339874877349857}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.150400996515202}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t)((_high_latency_tgt_heading & 0xFF00) >> 8);\n}", "CodeBleu_score": 6.669861617039438}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn (uint8_t)(_high_latency_tgt_heading >> 1);\n}", "CodeBleu_score": 6.423659320327591}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t", "CodeBleu_score": 4.479492289212416}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logger_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.timestamp = HAL_GetTick();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tlogger_mutex.lock();\n\t\tlogger.write_critical_block(packet);\n\t\tlogger_mutex.unlock();\n\t}\n}", "CodeBleu_score": 36.710697007251376}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_enabled) {\n\t\tLogPacket log_packet = LogPacket();\n\t\tlog_packet.timestamp = millis();\n\t\tlog_packet.id = id;\n\t\tlog_packet.value = value;\n\t\twrite_log_packet(log_packet);\n\t}\n}", "CodeBleu_score": 37.18568430243546}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t#if 0\n    // get current location from EKF\n    Location temp_loc;\n    if (ahrs.get_location(temp_loc)) {\n\n        // Make home always at the water's surface.\n        // This allows disarming and arming again at depth.\n        // This also ensures that mission items with relative altitude frame, are always\n        // relative to the water's surface, whether in a high elevation lake, or at sea level.\n        temp_loc.alt -= barometer.get_altitude() * 100.0f;\n        if (!set_home(temp_loc, false)) {\n            // ignore this failure\n        }\n    }\n#else\n    // If the motors are armed, set the home to the current location in-flight.\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        // If the motors are not armed, set the home to the current EKF location.\n        set_home_to_current_location();\n    }\n#endif\n}", "CodeBleu_score": 38.60477706917237}, {"code": "void Sub::update_home_from_EKF(){\n\t#ifdef DEBUG_SUB_UPDATE_HOME_FROM_EKF\n    Log.info(\"update_home_from_EKF: %s\", (armed() ? \"armed\" : \"disarmed\"));\n#endif\n    if (home_is_set()) {\n        // Home is already set.\n        return;\n    }\n\n    if (armed()) {\n        // Armed. Set home to current location in-flight.\n        set_home_to_current_location_inflight();\n    } else {\n        // Motors are disarmed. Set home to current EKF location.\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 36.74945932663197}, {"code": "void Sub::update_home_from_EKF(){\n\t#if 0\n    if (!get_home_all_data().valid_alt) {\n        if (motors.armed()) {\n            set_home_to_current_location_inflight();\n        } else {\n            set_home_to_current_location(false);\n        }\n    }\n#endif\n}", "CodeBleu_score": 43.643261900877505}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t//If motors are not armed, set throttle to zero, set spool state, relax attitude controllers, and exit\n\tif (!motorsArmed) {\n\t\tthrottle = 0;\n\t\tspool.setState(Spool::UNLIMITED);\n\t\tattitudeController.relax();\n\t\treturn;\n\t}\n\t//If motors are armed, set spool state to unlimited throttle, convert pilot inputs to desired body rates, and run attitude controller\n\tspool.setState(Spool::UNLIMITED);\n\tdesiredRates = pilot.getDesiredRates();\n\tattitudeController.run(desiredRates);\n\t//Output pilot throttle input without angle boost and set forward and lateral motor inputs based on pilot controls\n\tthrottle = pilot.getThrottle();\n\tspool.setMotorSpeeds(throttle, attitudeController.getRollRate(), attitudeController.getPitchRate());\n}", "CodeBleu_score": 37.733683145656514}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t\t// Get the pilot's input\n\tfloat pilot_throttle = pilot.getThrottle();\n\tfloat pilot_yaw = pilot.getYaw();\n\n\t// If the motors are not armed, set the throttle to zero and exit\n\tif (!motors.armed) {\n\t\tmotors.setThrottle(0.0f);\n\t\treturn;\n\t}\n\n\t// Set the spool state to unlimited throttle\n\tspool.setThrottleState(Spool::ThrottleState::UNLIMITED);\n\n\t// Convert pilot inputs to desired body frame rates\n\tfloat roll_rate = pilot_throttle * cosf(pilot_yaw);\n\tfloat pitch_rate = pilot_throttle * sinf(pilot_yaw);\n\n\t// Run the attitude controller\n\tattitude_controller.run(roll_rate, pitch_rate);\n\n\t// Set the forward and lateral motor inputs based on pilot controls\n\tmotors.setMotorInputs(pilot_throttle, attitude_controller.getRoll(), attitude_controller.getPitch());\n}", "CodeBleu_score": 41.33152264377953}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\n#if 0\n    // if we're not in guided mode, just return\n    if (g.control_mode != GUIDED) {\n        return;\n    }\n#endif\n\n    // set the mode to position control\n    g.control_mode = POSITION_CONTROL;\n\n    // initialize the waypoint controller\n    wpnav.init();\n\n    // set the stopping point as the waypoint destination\n    wpnav.set_destination(sub.stopping_point);\n\n    // set the initial yaw using the default auto yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(g.rtl_mode));\n}", "CodeBleu_score": 39.387354854540355}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set mode to position control\n\tmode_auto = MODE_POSCTL;\n\t// initialize the waypoint controller\n\twpnav.init();\n\t// get the stopping point\n\tVector3f stopping_point = get_stopping_point();\n\t// set the waypoint destination\n\twpnav.set_destination(stopping_point);\n\t// initialize the yaw using the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 39.47814686603462}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\n}", "CodeBleu_score": 3.006399650678141}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialize vertical maximum speeds and acceleration using pilot-defined parameters\n\tsub.max_vert_speed_mps = param_find(\"MPC_XY_VEL_MAX\");\n\tsub.max_vert_accel_mps2 = param_find(\"MPC_XY_CRUISE\");\n\tsub.max_horz_speed_mps = param_find(\"MPC_XY_VEL_MANUAL\");\n\tsub.max_horz_accel_mps2 = param_find(\"MPC_XY_CRUISE_MANUAL\");\n\tparam_set_no_notification(sub.max_vert_speed_mps, &sub.max_vert_speed_param);\n\tparam_set_no_notification(sub.max_vert_accel_mps2, &sub.max_vert_accel_param);\n\tparam_set_no_notification(sub.max_horz_speed_mps, &sub.max_horz_speed_param);\n\tparam_set_no_notification(sub.max_horz_accel_mps2, &sub.max_horz_accel_param);\n\n\t// initialize the vertical and horizontal velocity controllers\n\tvel_ctrl.set_max_speed(sub.max_vert_speed_mps, sub.max_horz_speed_mps);\n\tvel_ctrl.set_max_accel(sub.max_vert_accel_mps2, sub.max_horz_accel_mps2);\n\n\t// set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 42.08220862720894}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set max vertical speeds and accelerations\n\tsub.max_vertical_speed = pilot.max_vertical_speed;\n\tsub.max_vertical_acceleration = pilot.max_vertical_acceleration;\n\tsub.max_horizontal_speed = pilot.max_horizontal_speed;\n\tsub.max_horizontal_acceleration = pilot.max_horizontal_acceleration;\n\n\t// initialise velocity controllers\n\tvel_control_start();\n\n\t// set yaw mode to hold\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 38.333740152554924}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set maximum speeds and accelerations\n\tsub.v_max_auto = pilot.v_max;\n\tsub.v_max_auto_fast = pilot.v_max_fast;\n\tsub.v_max_auto_slow = pilot.v_max_slow;\n\tsub.v_accel_auto = pilot.v_accel;\n\tsub.v_accel_auto_fast = pilot.v_accel_fast;\n\tsub.v_accel_auto_slow = pilot.v_accel_slow;\n\tsub.h_max_auto = pilot.h_max;\n\tsub.h_max_auto_fast = pilot.h_max_fast;\n\tsub.h_max_auto_slow = pilot.h_max_slow;\n\tsub.h_accel_auto = pilot.h_accel;\n\tsub.h_accel_auto_fast = pilot.h_accel_fast;\n\tsub.h_accel_auto_slow = pilot.h_accel_slow;\n\n\t// set up velocity controllers\n\tsub.vel_control_mode = VEL_CONTROL_XY_SPEED;\n\tsub.vel_control_mode_prev = VEL_CONTROL_XY_SPEED;\n\tsub.vel_control_mode_prev_prev = VEL_CONTROL_XY_SPEED;\n\tsub.vel_control_mode_prev_prev_prev = VEL_CONTROL_XY_SPEED;\n\n\t// set up yaw controller\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 42.89260803418495}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if a timeout has been exceeded\n\tif (current_time_millis() > guided_start_time_ms + guided_timeout_ms) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is below the minimum threshold\n\tif (current_altitude_m < guided_min_altitude_m) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum threshold\n\tif (current_altitude_m > guided_max_altitude_m) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the limit\n\tif (current_horizontal_distance_m > guided_max_horizontal_distance_m) {\n\t\treturn true;\n\t}\n\n\t// If none of the conditions are met, return false\n\treturn false;\n}", "CodeBleu_score": 19.877030174455978}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// Check if we have reached the timeout\n\tif (time_since_last_heartbeat > timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if we have reached the minimum altitude\n\tif (current_altitude < min_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if we have reached the maximum altitude\n\tif (current_altitude > max_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if we have exceeded the horizontal distance limit\n\tif (horizontal_distance > max_horizontal_distance) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 15.969299126296432}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\tbool ret = false;\n\n\t// Check if we have exceeded the timeout\n\tif (time_since_last_heartbeat > timeout) {\n\t\tret = true;\n\t}\n\n\t// Check if we have reached the minimum altitude\n\tif (current_position.alt < min_altitude) {\n\t\tret = true;\n\t}\n\n\t// Check if we have reached the maximum altitude\n\tif (current_position.alt > max_altitude) {\n\t\tret = true;\n\t}\n\n\t// Check if we have exceeded the horizontal distance limit\n\tif (fabs(current_position.x - last_position.x) > max_horizontal_distance) {\n\t\tret = true;\n\t}\n\n\t// Check if we have exceeded the vertical distance limit\n\tif (fabs(current_position.y - last_position.y) > max_vertical_distance) {\n\t\tret = true;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 33.61650435280102}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\t// TODO: Implement Sub::verify_motor_test\n\t// Report error if motor test is not enabled\n\tif (!motor_test_enabled) {\n\t\tROS_ERROR(\"Motor test is not enabled\");\n\t\treturn false;\n\t}\n\t// Report error if motor test is not armed\n\tif (!motor_test_armed) {\n\t\tROS_ERROR(\"Motor test is not armed\");\n\t\treturn false;\n\t}\n\t// Report error if motor test is not in the running state\n\tif (motor_test_state != 1) {\n\t\tROS_ERROR(\"Motor test is not running\");\n\t\treturn false;\n\t}\n\t// Report error if motor test fails to pass\n\tif (motor_test_pass == false) {\n\t\tROS_ERROR(\"Motor test failed to pass\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 35.16919739311758}, {"code": "bool Sub::verify_motor_test(){\n\t\tif (get_time_since_last_motor_test_request() > 500) {\n\t\tsend_motor_test_timeout_message();\n\t\tset_pass_fail(false);\n\t\tdisable_motor_test();\n\t\tdisarm_system();\n\t\trecord_failure_time();\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 17.285488862329814}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Record the start time of the test\n\tstd::chrono::time_point<std::chrono::system_clock> start_time = std::chrono::system_clock::now();\n\n\t// Check if the test has passed\n\tbool test_pass = true;\n\n\t// Loop until the test has passed or failed\n\twhile (test_pass) {\n\t\t// Check if the test has passed\n\t\tif (test_pass) {\n\t\t\t// Check if the test has failed\n\t\t\tif (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now() - start_time).count() >= 2) {\n\t\t\t\t// Set the test result to a failure\n\t\t\t\ttest_pass = false;\n\n\t\t\t\t// Disable the motor test\n\t\t\t\tdisable_motor_test();\n\n\t\t\t\t// Disarm the system\n\t\t\t\tdisarm_system();\n\n\t\t\t\t// Record the failure time\n\t\t\t\tstd::chrono::time_point<std::chrono::system_clock> failure_time = std::chrono::system_clock::now();\n\n\t\t\t\t// Send a timeout message\n\t\t\t\tsend_timeout_message(failure_time);\n\n\t\t\t\t// Print a failure message\n\t\t\t\tROS_ERROR(\"Motor test failed\");\n\t\t\t}\n\t\t}\n\n\t\t// Check if the test has failed\n\t\tif (!test_pass) {\n\t\t\t// Stop the test\n\t\t\tstop_test();\n\n\t\t\t// Print a failure message\n\t\t\tROS_ERROR(\"Motor test failed\");\n\n\t\t\t// Return the test result\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Print a success message\n\tROS_INFO(\"Motor test passed\");\n\n\t// Return the test result\n\treturn true;\n}", "CodeBleu_score": 38.96505968641251}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target_deg = wp_nav.roll_deg;\n\tfloat pitch_target_deg = wp_nav.pitch_deg;\n\n\t// Constrain roll_target_deg and pitch_target_deg within the specified maximum angle range.\n\tif (roll_target_deg > max_roll_deg) {\n\t\troll_target_deg = max_roll_deg;\n\t}\n\telse if (roll_target_deg < -max_roll_deg) {\n\t\troll_target_deg = -max_roll_deg;\n\t}\n\n\tif (pitch_target_deg > max_pitch_deg) {\n\t\tpitch_target_deg = max_pitch_deg;\n\t}\n\telse if (pitch_target_deg < -max_pitch_deg) {\n\t\tpitch_target_deg = -max_pitch_deg;\n\t}\n\n\t// Normalize roll_target_deg and pitch_target_deg.\n\tfloat roll_target_norm = roll_target_deg / max_roll_deg;\n\tfloat pitch_target_norm = pitch_target_deg / max_pitch_deg;\n\n\t// Assign normalized roll_target_norm and pitch_target_norm to lateral_out and forward_out.\n\tlateral_out = roll_target_norm;\n\tforward_out = pitch_target_norm;\n}", "CodeBleu_score": 36.3727136730056}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t//roll_target = wp_nav.roll_target;\n\t//pitch_target = wp_nav.pitch_target;\n\troll_target = wp_nav.roll_target;\n\tpitch_target = wp_nav.pitch_target;\n\t//roll_target = wp_nav.roll_target;\n\t//pitch_target = wp_nav.pitch_target;\n\n\t//constrain roll_target and pitch_target within maximum angle range\n\tif (roll_target > 1800) {\n\t\troll_target = 1800;\n\t}\n\tif (roll_target < -1800) {\n\t\troll_target = -1800;\n\t}\n\tif (pitch_target > 1800) {\n\t\tpitch_target = 1800;\n\t}\n\tif (pitch_target < -1800) {\n\t\tpitch_target = -1800;\n\t}\n\n\t//normalize roll_target and pitch_target\n\troll_target = (roll_target + 1800) / 3600;\n\tpitch_target = (pitch_target + 1800) / 3600;\n\n\t//assign normalized values to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 28.612657602713508}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_in = wp_nav.roll;\n\tfloat pitch_in = wp_nav.pitch;\n\n\t// Constrain roll and pitch within specified range\n\tif (roll_in > 1000) {\n\t\troll_in = 1000;\n\t} else if (roll_in < -1000) {\n\t\troll_in = -1000;\n\t}\n\n\tif (pitch_in > 1000) {\n\t\tpitch_in = 1000;\n\t} else if (pitch_in < -1000) {\n\t\tpitch_in = -1000;\n\t}\n\n\t// Normalize roll and pitch\n\troll_in = roll_in / 1000;\n\tpitch_in = pitch_in / 1000;\n\n\t// Assign normalized values to lateral_out and forward_out\n\tlateral_out = roll_in;\n\tforward_out = pitch_in;\n}", "CodeBleu_score": 29.416152314501577}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\tif (barometer.is_initialized()) {\n\t\t// Update the barometer calibration\n\t\tbarometer.update();\n\n\t\t// Update the sensor health status\n\t\tif (barometer.get_health() == BMP280_HEALTH_OVERSAMPLING) {\n\t\t\tsensor_health = SensorHealth::OVERSAMPLING;\n\t\t} else if (barometer.get_health() == BMP280_HEALTH_UNDERSAMPLING) {\n\t\t\tsensor_health = SensorHealth::UNDERSAMPLING;\n\t\t} else if (barometer.get_health() == BMP280_HEALTH_IDAC_MEASUREMENT) {\n\t\t\tsensor_health = SensorHealth::IDAC_MEASUREMENT;\n\t\t} else if (barometer.get_health() == BMP280_HEALTH_RESET) {\n\t\t\tsensor_health = SensorHealth::RESET;\n\t\t} else if (barometer.get_health() == BMP280_HEALTH_SUPPLY) {\n\t\t\tsensor_health = SensorHealth::SUPPLY;\n\t\t} else if (barometer.get_health() == BMP280_HEALTH_UNDERSAMPLING_2) {\n\t\t\tsensor_health = SensorHealth::UNDERSAMPLING_2;\n\t\t} else {\n\t\t\tsensor_health = SensorHealth::OK;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.35107286524384}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer_present) {\n\t\t// Update barometer calibration\n\t\tif (altitude > 0) {\n\t\t\tbarometer_calibration = barometer_calibration + (barometer - barometer_calibration) * 0.05;\n\t\t}\n\n\t\t// Update barometer health\n\t\tif (barometer_calibration > 0.0) {\n\t\t\tbarometer_health = true;\n\t\t} else {\n\t\t\tbarometer_health = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.63597668685611}, {"code": "void Sub::read_barometer(){\n\t", "CodeBleu_score": 2.5263458681211657}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\tif (motors_armed) {\n\t\treturn (abs(ekf_hpos_error) < 0.5f && abs(ekf_vpos_error) < 0.5f);\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 14.147640395547603}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (motors_armed) {\n\t\treturn (fabsf(ekf_pos_x) > 0.01f && fabsf(ekf_pos_y) > 0.01f && fabsf(ekf_pos_z) > 0.01f && !ekf_const_pos_mode);\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 21.35717511822514}, {"code": "bool Sub::ekf_position_ok(){\n\t\treturn true;\n}", "CodeBleu_score": 2.2774808793977237}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tbool gps_checks_pass = true;\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\tgps_checks_pass = false;\n\t}\n\tif (!ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\tconsole->printf(\"AHRS not ready\n\");\n\t\t}\n\t\tgps_checks_pass = false;\n\t}\n\tif (!ekf.using_gps()) {\n\t\tif (display_failure) {\n\t\t\tconsole->printf(\"EKF not using GPS\n\");\n\t\t}\n\t\tgps_checks_pass = false;\n\t}\n\tif (!ahrs.get_ekf_ok()) {\n\t\tif (display_failure) {\n\t\t\tconsole->printf(\"EKF not OK\n\");\n\t\t}\n\t\tgps_checks_pass = false;\n\t}\n\tif (!ahrs.position_valid()) {\n\t\tif (display_failure) {\n\t\t\tconsole->printf(\"Position invalid\n\");\n\t\t}\n\t\tgps_checks_pass = false;\n\t}\n\treturn gps_checks_pass;\n}", "CodeBleu_score": 40.676194273679755}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// call parent class's GPS checks\n\tif (!AP_Arming_Checks::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check if AHRS system is ready\n\tif (!ahrs.initialised()) {\n\t\tif (display_failure) {\n\t\t\tprint_no_gps(mavlink_fd, \"AHRS\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if EKF failsafe is active\n\tif (ahrs.get_ekf_ok() == false) {\n\t\tif (display_failure) {\n\t\t\tprint_no_gps(mavlink_fd, \"EKF\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check if position estimate is valid\n\tif (!ahrs.get_position_valid()) {\n\t\tif (display_failure) {\n\t\t\tprint_no_gps(mavlink_fd, \"Position\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 45.73146259369296}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif(get_control_mode() == STABILIZE || get_control_mode() == ALT_HOLD || get_control_mode() == POSCTL || get_control_mode() == AUTO || get_control_mode() == ACRO || get_control_mode() == OFFBOARD || get_control_mode() == STABILIZED || get_control_mode() == RATE_CTRL || get_control_mode() == TRAINING || get_control_mode() == AUTO_MISSION) {\n\t\treturn AP_Arming::gps_checks(display_failure);\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 19.339156349374537}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (!checkShouldCharge()) {\n\t\t\tif (charging_enabled) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (!charging_enabled) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_disabled_time = millis();\n\t\t}\n\t}\n}", "CodeBleu_score": 42.643021217109435}, {"code": "void updateChargingEnabled(){\n\t\tif(charging_allowed) {\n\t\tif(checkShouldCharge()) {\n\t\t\tif(!charging_enabled) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_start_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif(charging_enabled) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_stop_time = millis();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif(charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_stop_time = millis();\n\t\t}\n\n\t\tif(millis() - charging_retry_time > 10000) {\n\t\t\tcharging_retry_time = millis();\n\t\t\tcharging_allowed = checkChargingAllowed();\n\t\t}\n\t}\n}", "CodeBleu_score": 39.396868598608656}, {"code": "void updateChargingEnabled(){\n\t\tif (status_message.charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tif (status_message.charging_enabled) {\n\t\t\t\t// Charging is already enabled, so we just check to see if it should be disabled\n\t\t\t\tif (!checkShouldCharge()) {\n\t\t\t\t\t// It should be disabled, so disable it\n\t\t\t\t\tstatus_message.charging_enabled = false;\n\t\t\t\t\tstatus_message.charging_time_elapsed = 0.0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Charging is not enabled, so we need to enable it\n\t\t\t\tstatus_message.charging_enabled = true;\n\t\t\t\tstatus_message.charging_time_elapsed = 0.0;\n\t\t\t}\n\t\t} else {\n\t\t\t// Charging is not allowed, so we need to disable it\n\t\t\tif (status_message.charging_enabled) {\n\t\t\t\tstatus_message.charging_enabled = false;\n\t\t\t\tstatus_message.charging_time_elapsed = 0.0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Charging is not allowed, so we need to disable it\n\t\tif (status_message.charging_enabled) {\n\t\t\tstatus_message.charging_enabled = false;\n\t\t\tstatus_message.charging_time_elapsed = 0.0;\n\t\t}\n\t}\n}", "CodeBleu_score": 28.80586954779008}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint32_t crc = crc32(0L, Z_NULL, 0);\n\t\tcrc = crc32(crc, (uint8_t *)message, size);\n\t\tuint8_t *crcBytes = (uint8_t *)&crc;\n\t\tuint8_t messageWithCrc[size + 4];\n\t\tmemcpy(messageWithCrc, message, size);\n\t\tmemcpy(messageWithCrc + size, crcBytes, 4);\n\t\tpacketSerial.write(messageWithCrc, size + 4);\n\t}\n}", "CodeBleu_score": 43.75489962919261}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = crc16((uint8_t*)message, size);\n\t\tuint8_t crcBytes[2];\n\t\tcrcBytes[0] = crc & 0xFF;\n\t\tcrcBytes[1] = (crc >> 8) & 0xFF;\n\t\tpacketSerial.write(message, size);\n\t\tpacketSerial.write(crcBytes, 2);\n\t}\n}", "CodeBleu_score": 47.35050895284702}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (rosRunning && size >= 4) {\n\t\tuint16_t crc = crc16(message, size);\n\t\tuint8_t *crcBytes = (uint8_t *) &crc;\n\t\tuint8_t crcBytesReversed[2];\n\t\tcrcBytesReversed[0] = crcBytes[1];\n\t\tcrcBytesReversed[1] = crcBytes[0];\n\t\tpacketSerial.write(message, size);\n\t\tpacketSerial.write(crcBytesReversed, 2);\n\t}\n}", "CodeBleu_score": 38.847798668149174}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t\tif (!SD.begin(SD_CS)) {\n\t\treturn false;\n\t}\n\n\tif (!SD.exists(MP3_DIR)) {\n\t\treturn false;\n\t}\n\n\tif (!SD.exists(WAV_DIR)) {\n\t\treturn false;\n\t}\n\n\tif (!SD.exists(OGG_DIR)) {\n\t\treturn false;\n\t}\n\n\tif (!SD.exists(MP3_DIR + MP3_DIR_FILE)) {\n\t\treturn false;\n\t}\n\n\tif (!SD.exists(WAV_DIR + WAV_DIR_FILE)) {\n\t\treturn false;\n\t}\n\n\tif (!SD.exists(OGG_DIR + OGG_DIR_FILE)) {\n\t\treturn false;\n\t}\n\n\t// clear any existing data in the buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\n\t// initialize the sound module\n\tSerial.write(MP3_INIT);\n\n\t// wait for the initialization to complete\n\twhile (Serial.available() < 1) {\n\t\t;\n\t}\n\n\t// check for initialization errors\n\tif (Serial.read() != MP3_INIT_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// retrieve the number of sound files available on the SD card\n\tSerial.write(MP3_COUNT);\n\n\t// wait for the number of sound files to be returned\n\twhile (Serial.available() < 1) {\n\t\t;\n\t}\n\n\t// check for errors\n\tif (Serial.read() != MP3_COUNT_SUCCESS) {\n\t\treturn false;\n\t}\n\n\t// read the number of sound files\n\tnumFiles = Serial.read();\n\n\treturn true;\n}", "CodeBleu_score": 40.28869095439749}, {"code": "bool MP3Sound::begin(){\n\t\t// initialize the serial communication\n\tSerial.begin(9600);\n\t// clear the serial buffer\n\tSerial.flush();\n\t// initialize the sound module\n\tpinMode(SOUND_CS, OUTPUT);\n\tdigitalWrite(SOUND_CS, HIGH);\n\tpinMode(SOUND_DIN, OUTPUT);\n\tpinMode(SOUND_DOUT, INPUT);\n\tpinMode(SOUND_CLK, OUTPUT);\n\tpinMode(SOUND_DREQ, INPUT);\n\tpinMode(SOUND_BCK, OUTPUT);\n\tpinMode(SOUND_WS, OUTPUT);\n\tdigitalWrite(SOUND_WS, HIGH);\n\tdigitalWrite(SOUND_BCK, HIGH);\n\t// retrieve the number of sound files available on the SD card\n\treturn retrieveSoundFileCount();\n}", "CodeBleu_score": 34.789103222764986}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\tint numActiveSounds = 0;\n\tif(sounds.size() > 0) {\n\t\tif(soundPlaying) {\n\t\t\tnumActiveSounds = sounds.size();\n\t\t} else {\n\t\t\tnumActiveSounds = sounds.size();\n\t\t\tplaySound(sounds.back());\n\t\t\tsounds.pop_back();\n\t\t}\n\t}\n\treturn numActiveSounds;\n}", "CodeBleu_score": 40.48504084127643}, {"code": "int MP3Sound::processSounds(){\n\t\tint activeSounds = 0;\n\tfor(int i = 0; i < MAX_ACTIVE_SOUNDS; i++) {\n\t\tif(sounds[i].active) {\n\t\t\tactiveSounds++;\n\t\t}\n\t}\n\tif(activeSounds == 0) {\n\t\treturn 0;\n\t}\n\tif(playing) {\n\t\treturn activeSounds;\n\t}\n\tfor(int i = 0; i < MAX_ACTIVE_SOUNDS; i++) {\n\t\tif(sounds[i].active) {\n\t\t\tplayMP3(sounds[i].filename);\n\t\t\tsounds[i].active = false;\n\t\t\treturn activeSounds - 1;\n\t\t}\n\t}\n\treturn activeSounds;\n}", "CodeBleu_score": 35.028890129986614}, {"code": "int MP3Sound::processSounds(){\n\t\tint numActiveSounds = activeSounds.size();\n\tif (numActiveSounds == 0 || mp3Player.isPlaying()) {\n\t\treturn numActiveSounds;\n\t} else {\n\t\tstd::string soundFile = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tmp3Player.playMP3(soundFile);\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 53.80290750393656}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tbool handled = true;\n\tif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\t\tif (ac->memory_mapped_file)\n\t\t\twb_memory_mapped_file_delete(ac->memory_mapped_file);\n\t\tac->memory_mapped_file = wb_memory_mapped_file_new(r->data, r->data_size);\n\t\tif (!ac->memory_mapped_file)\n\t\t\thandled = false;\n\t} else\n\t\thandled = false;\n\treturn handled;\n}", "CodeBleu_score": 40.400113312278364}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tbool handled = true;\n\tswitch (command) {\n\t\tcase C_CAMERA_MEMORY_MAPPED_FILE: {\n\t\t\tif (ac->memory_mapped_file)\n\t\t\t\twb_memory_mapped_file_delete(ac->memory_mapped_file);\n\t\t\tac->memory_mapped_file = wb_memory_mapped_file_new(r, \"wb_abstract_camera_handle_command\");\n\t\t\tif (ac->memory_mapped_file == NULL)\n\t\t\t\thandled = false;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\thandled = false;\n\t\t\tbreak;\n\t}\n\treturn handled;\n}", "CodeBleu_score": 56.58863145522719}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tbool handled = true;\n\tif (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n\t\tif (ac->memory_mapped_file)\n\t\t\twb_memory_mapped_file_delete(ac->memory_mapped_file);\n\t\tac->memory_mapped_file = wb_memory_mapped_file_new(r, ac->image_width, ac->image_height, ac->image_depth);\n\t\tif (!ac->memory_mapped_file)\n\t\t\treturn false;\n\t\tac->image_size = ac->image_width * ac->image_height * ac->image_depth;\n\t} else\n\t\thandled = false;\n\treturn handled;\n}", "CodeBleu_score": 44.98005770499419}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint result = -1;\n\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tif (ac) {\n\t\tif (ac->mutex) {\n\t\t\twb_mutex_lock(ac->mutex);\n\t\t\tif (ac->data)\n\t\t\t\tresult = ac->data->height;\n\t\t\twb_mutex_unlock(ac->mutex);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 51.476974400807364}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\treturn wb_abstract_camera_get_width(d);\n}", "CodeBleu_score": 2.917667738578457}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t\tint result = -1;\n\tWbAbstractCamera *ac = (WbAbstractCamera *) d;\n\tif (ac) {\n\t\tpthread_mutex_lock(&ac->mutex);\n\t\tif (ac->width > 0)\n\t\t\tresult = ac->height;\n\t\tpthread_mutex_unlock(&ac->mutex);\n\t}\n\treturn result;\n}", "CodeBleu_score": 54.77777244751412}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tWbDevice *accelerometer;\n\tWbAccelerometer *accel;\n\n\t/* Get device structure */\n\taccelerometer = wb_devices_get_device_by_tag(tag, WB_NODE_ACCELEROMETER);\n\tif (accelerometer == NULL) {\n\t\twb_log_error(\"No such device: %d\", tag);\n\t\treturn -1;\n\t}\n\n\t/* Lock the device */\n\twb_device_lock(accelerometer);\n\n\t/* Get accelerometer structure */\n\taccel = (WbAccelerometer *) accelerometer;\n\n\t/* If the device is valid, get the sampling period from the structure */\n\tif (accel->pdata != NULL)\n\t\tsampling_period = accel->pdata->sampling_period;\n\telse\n\t\tsampling_period = -1;\n\n\t/* Unlock the device */\n\twb_device_unlock(accelerometer);\n\n\treturn sampling_period;\n}", "CodeBleu_score": 42.21026971285526}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period;\n\tstruct Acceleration *accelerometer;\n\n\tif(tag < 0 || tag >= WB_DEVICES_LENGTH || devices[tag].type != WB_NODE_ACCELEROMETER) {\n\t\tfprintf(stderr, \"Invalid device tag.\n\");\n\t\treturn -1;\n\t}\n\n\taccelerometer = (struct Acceleration *) devices[tag].pdata;\n\n\tpthread_mutex_lock(&devices[tag].mutex);\n\n\tif(devices[tag].type != WB_NODE_ACCELEROMETER) {\n\t\tfprintf(stderr, \"The device is not an accelerometer.\n\");\n\t\tpthread_mutex_unlock(&devices[tag].mutex);\n\t\treturn -1;\n\t}\n\n\tsampling_period = accelerometer->sampling_period;\n\n\tpthread_mutex_unlock(&devices[tag].mutex);\n\n\treturn sampling_period;\n}", "CodeBleu_score": 41.008023063794575}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t\tint sampling_period = 0;\n\tWbDevice *accelerometer = wb_robot_get_device(tag);\n\tif (accelerometer) {\n\t\tWbAccelerometer *accel = (WbAccelerometer *) accelerometer;\n\t\tpthread_mutex_lock(&accel->mutex);\n\t\tif (accel->sampling_period > 0)\n\t\t\tsampling_period = accel->sampling_period;\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a valid accelerometer.\n\", wb_device_get_name(accelerometer));\n\t\tpthread_mutex_unlock(&accel->mutex);\n\t} else\n\t\tfprintf(stderr, \"Error: invalid device tag.\n\");\n\treturn sampling_period;\n}", "CodeBleu_score": 53.36316581225864}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring s(dms);\n\tfree(dms);\n\treturn s;\n}", "CodeBleu_score": 37.52824752333729}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tstring degreesMinutesSeconds;\n\tchar * dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tdegreesMinutesSeconds = dms;\n\tfree(dms);\n\treturn degreesMinutesSeconds;\n}", "CodeBleu_score": 45.03408386957051}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString = dms;\n\twb_gps_free_degrees_minutes_seconds(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 44.79087618676087}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t\tdVector3 p;\n\tdGeomBoxGetLengths(g, p);\n\tp[0] *= 0.5;\n\tp[1] *= 0.5;\n\tp[2] *= 0.5;\n\tplane[0] = 0;\n\tplane[1] = 0;\n\tplane[2] = 0;\n\tplane[3] = 0;\n\tif (x < -p[0]) {\n\t\tplane[0] = -1;\n\t}\n\telse if (x > p[0]) {\n\t\tplane[0] = 1;\n\t}\n\tif (y < -p[1]) {\n\t\tplane[1] = -1;\n\t}\n\telse if (y > p[1]) {\n\t\tplane[1] = 1;\n\t}\n\tif (z < -p[2]) {\n\t\tplane[2] = -1;\n\t}\n\telse if (z > p[2]) {\n\t\tplane[2] = 1;\n\t}\n\tplane[3] = -(x * plane[0] + y * plane[1] + z * plane[2]);\n}", "CodeBleu_score": 21.930734473309332}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n#ifdef dNODEBUG\n  dUASSERT (box && box->body, \"Invalid box or body\");\n  dUASSERT (fluidPlane, \"Invalid fluid plane\");\n  dUASSERT (flags >= 0 && flags <= 7, \"Invalid flags\");\n#endif\n\n  immersion->box = box;\n  immersion->fluidPlane = fluidPlane;\n  immersion->flags = flags;\n\n  return dImmerseBox_ (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 45.181946539757384}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\n#ifdef dNODEBUG\n  dUASSERT (box, \"box is NULL\");\n  dUASSERT (box->body, \"box body is NULL\");\n  dUASSERT (fluidPlane, \"fluidPlane is NULL\");\n  dUASSERT (flags >= 0 && flags <= 1, \"invalid flags\");\n  dUASSERT (immersion, \"immersion is NULL\");\n#endif\n\n  immersion->box = box;\n  immersion->fluidPlane = fluidPlane;\n  immersion->flags = flags;\n\n  return dImmerseBox_internal (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 45.7708516385458}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dBoxClass,\"This function only works on boxes\");\n\tdUASSERT(o2->type == dCapsuleClass,\"This function only works on capsules\");\n\n\tsBoxCapsuleImmersionData data(o1, o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 23.9770440365351}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dBoxClass,\"This function only checks for collisions between a box and a capsule\");\n\tdUASSERT(o2->type == dCapsuleClass,\"This function only checks for collisions between a box and a capsule\");\n\n\tdGeomBox *box = (dGeomBox *) o1;\n\tdGeomCapsule *capsule = (dGeomCapsule *) o2;\n\n\tsBoxCapsuleImmersionData data(box, capsule, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 33.99713445726322}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT (o1->type == dBoxClass);\n\tdIASSERT (o2->type == dCapsuleClass);\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsBoxImmersionData data(o1, o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 27.166430216273813}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dTriMeshClass,\"This function only works with trimeshes\");\n\tdUASSERT(o2->type == dCapsuleClass,\"This function only works with capsules\");\n\tdUASSERT(immersion->geomClass == dImmersionGeomClass,\"This function only works with immersion geometries\");\n\tdUASSERT(immersion->geomClass == dImmersionGeomClass,\"This function only works with immersion geometries\");\n\n\tsCapsuleImmersionData data((dxCapsule*)o2, (dxTriMesh*)o1, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 43.29550530840562}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dTriMeshClass,\"This is not a trimesh\");\n\tdUASSERT(o2->type == dCapsuleClass,\"This is not a capsule\");\n\tdUASSERT(o2->body,\"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleImmersionData data((dxCapsule*)o2, (dxTriMesh*)o1, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 40.80442898493904}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->type == dCapsuleClass,\"This function is for capsule-trimesh immersion only\");\n\tdUASSERT(o2->type == dTriMeshClass,\"This function is for capsule-trimesh immersion only\");\n\n\tsCapsuleImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 30.72835848580911}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration in milliseconds from the input.\n\tint sleep_duration_ms = getInput<int>(\"sleep_duration_ms\");\n\n\t// If the duration is missing or non-positive, return SUCCESS.\n\tif (!sleep_duration_ms) {\n\t\tROS_INFO(\"Missing or non-positive sleep duration. Sleep node will return SUCCESS.\");\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING.\n\tROS_INFO(\"Starting sleep node with sleep duration %d ms.\", sleep_duration_ms);\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 26.701754840424112}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// Retrieve the sleep duration from the input\n\tconst std::string& duration_str = getInput(\"duration\");\n\tif (duration_str.empty()) {\n\t\tROS_WARN(\"Missing input duration, defaulting to 1 second\");\n\t\tduration_ = 1000;\n\t}\n\telse {\n\t\ttry {\n\t\t\tduration_ = std::stoll(duration_str);\n\t\t\tif (duration_ <= 0) {\n\t\t\t\tROS_WARN(\"Duration must be positive, defaulting to 1 second\");\n\t\t\t\tduration_ = 1000;\n\t\t\t}\n\t\t}\n\t\tcatch (const std::invalid_argument& e) {\n\t\t\tROS_WARN(\"Invalid argument '%s' for duration, defaulting to 1 second\", duration_str.c_str());\n\t\t\tduration_ = 1000;\n\t\t}\n\t\tcatch (const std::out_of_range& e) {\n\t\t\tROS_WARN(\"Out of range value '%s' for duration, defaulting to 1 second\", duration_str.c_str());\n\t\t\tduration_ = 1000;\n\t\t}\n\t}\n\n\t// If the duration is zero, the node is a no-op\n\tif (duration_ == 0) {\n\t\tROS_INFO(\"Sleep duration is zero, node is a no-op\");\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Set the node status to RUNNING and start the timer\n\tROS_INFO(\"Starting timer with duration %ld ms\", duration_);\n\tsetStatus(NodeStatus::RUNNING);\n\ttimer_ = nh_.createTimer(ros::Duration(duration_ / 1000.0), &SleepNode::onTimer, this);\n\n\t// Set a callback to emit a wake-up signal when the timer expires\n\ttimer_.setCallbackQueue(&callback_queue_);\n\tcallback_queue_.addCallback(boost::bind(&SleepNode::onTimer, this));\n\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 40.86435165055717}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tROS_INFO(\"Starting SleepNode\");\n\tNodeStatus status = NodeStatus::SUCCESS;\n\t// Retrieve the sleep duration from the input\n\tconst std::string duration_key = \"duration\";\n\tif (!getInput(duration_key, duration_)) {\n\t\tROS_ERROR(\"Missing parameter '%s' in SleepNode\", duration_key.c_str());\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Check the sleep duration is positive\n\tif (duration_ <= 0) {\n\t\tROS_ERROR(\"Sleep duration must be positive in SleepNode\");\n\t\treturn NodeStatus::FAILURE;\n\t}\n\t// Set the node status to RUNNING\n\tstatus = NodeStatus::RUNNING;\n\t// Start a timer to emit a wake-up signal when the timer expires\n\ttimer_ = createTimer(duration_, std::bind(&SleepNode::onWakeUp, this));\n\t// Set a callback to ensure the timer_waiting_ flag is reset if the timer is aborted\n\ttimer_.setCallback(std::bind(&SleepNode::onTimerAborted, this));\n\tROS_INFO(\"SleepNode started\");\n\treturn status;\n}", "CodeBleu_score": 34.70496243887163}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t/*\n\t * Retrieve the blackboard entry\n\t */\n\tEntry entry = blackboard->getEntry(this->entryName);\n\n\t/*\n\t * If the entry is not found, return FAILURE\n\t */\n\tif (!entry) {\n\t\tROS_ERROR_STREAM(\"EntryUpdatedAction: Entry \" << this->entryName << \" not found\");\n\t\treturn FAILURE;\n\t}\n\n\t/*\n\t * Lock the entry's mutex\n\t */\n\tentry.lockMutex();\n\n\t/*\n\t * Compare the current sequence ID with the previously stored sequence ID\n\t */\n\tif (entry.getSequenceID() != this->previousSequenceID) {\n\t\t/*\n\t\t * If the IDs differ, update the stored sequence ID\n\t\t */\n\t\tthis->previousSequenceID = entry.getSequenceID();\n\n\t\t/*\n\t\t * Unlock the entry's mutex\n\t\t */\n\t\tentry.unlockMutex();\n\n\t\t/*\n\t\t * Return SUCCESS\n\t\t */\n\t\treturn SUCCESS;\n\t}\n\telse {\n\t\t/*\n\t\t * If the IDs are the same or the entry is not found, return FAILURE\n\t\t */\n\t\tROS_ERROR_STREAM(\"EntryUpdatedAction: Entry \" << this->entryName << \" not updated\");\n\t\tentry.unlockMutex();\n\t\treturn FAILURE;\n\t}\n}", "CodeBleu_score": 29.01415989917814}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry from the blackboard\n\tEntry entry = blackboard.get(entry_name);\n\n\t// If the entry is not found, return FAILURE\n\tif (!entry) {\n\t\tROS_WARN(\"EntryUpdatedAction: Entry %s not found\", entry_name.c_str());\n\t\treturn FAILURE;\n\t}\n\n\t// Lock the entry's mutex\n\tentry.mutex.lock();\n\n\t// Compare the current sequence ID with the previously stored sequence ID\n\tif (entry.sequence_id != sequence_id) {\n\t\t// If the IDs differ, update the stored sequence ID and return SUCCESS\n\t\tsequence_id = entry.sequence_id;\n\t\tentry.mutex.unlock();\n\t\treturn SUCCESS;\n\t}\n\n\t// If the IDs are the same or the entry is not found, return FAILURE\n\tentry.mutex.unlock();\n\treturn FAILURE;\n}", "CodeBleu_score": 35.18382394982218}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Get the entry from the blackboard\n\tEntry entry = blackboard.get(this->entry_name);\n\n\t// If the entry is not found, return FAILURE\n\tif (entry == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t// Lock the mutex for the entry\n\tentry.lock();\n\n\t// Get the current sequence ID\n\tint current_sequence_id = entry.getSequenceID();\n\n\t// If the current sequence ID is different from the previously stored sequence ID, update the stored sequence ID and return SUCCESS\n\tif (current_sequence_id != this->sequence_id) {\n\t\tthis->sequence_id = current_sequence_id;\n\t\treturn SUCCESS;\n\t}\n\n\t// Otherwise, return FAILURE\n\treturn FAILURE;\n}", "CodeBleu_score": 31.200371930088068}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (success_threshold_ < 0) {\n\t\treturn static_cast<size_t>(success_threshold_ * children_.size());\n\t}\n\treturn static_cast<size_t>(success_threshold_);\n}", "CodeBleu_score": 52.899643012757856}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (this->success_threshold < 0) {\n\t\treturn (size_t) (this->success_threshold * this->children.size());\n\t}\n\treturn (size_t) this->success_threshold;\n}", "CodeBleu_score": 21.81419359138846}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_successThreshold < 0) {\n\t\treturn m_successThreshold + m_children.size();\n\t} else {\n\t\treturn m_successThreshold;\n\t}\n}", "CodeBleu_score": 50.898800388259026}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t#ifdef DEBUG_MONITOR\n  std::cout << \"Starting heartbeat loop\n\";\n#endif\n  while(_p->running)\n  {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if(_p->last_heartbeat_time != _p->current_heartbeat_time)\n    {\n      _p->last_heartbeat_time = _p->current_heartbeat_time;\n      std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n      for(auto& [node_uid, hook] : _p->pre_hooks)\n      {\n        std::unique_lock<std::mutex> lk(hook->mutex);\n        if(hook->enabled && hook->mode == Monitor::Hook::Mode::BREAKPOINT)\n        {\n          if(hook->last_heartbeat_time != _p->last_heartbeat_time)\n          {\n            hook->last_heartbeat_time = _p->last_heartbeat_time;\n            hook->wakeup.notify_all();\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 40.92446412868805}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\n#ifdef _WIN32\n  HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL);\n  LARGE_INTEGER liDueTime;\n  liDueTime.QuadPart = -10000000; // 100 nanoseconds\n  SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, 0);\n#else\n  struct itimerval timer;\n  timer.it_value.tv_sec = 0;\n  timer.it_value.tv_usec = 100000;\n  timer.it_interval.tv_sec = 0;\n  timer.it_interval.tv_usec = 100000;\n  setitimer(ITIMER_REAL, &timer, NULL);\n#endif\n\n  while(true) {\n#ifdef _WIN32\n    WaitForSingleObject(hTimer, INFINITE);\n#else\n    pause();\n#endif\n    std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n    for(auto& [node_uid, hook] : _p->pre_hooks)\n    {\n      if(hook->mode == Monitor::Hook::Mode::HEARTBEAT)\n      {\n        std::unique_lock<std::mutex> lk(hook->mutex);\n        if(hook->enabled)\n        {\n          if(hook->last_heartbeat_time < hook->last_heartbeat_time_prev)\n          {\n            hook->last_heartbeat_time_prev = hook->last_heartbeat_time;\n            hook->enabled = false;\n          }\n        }\n        else\n        {\n          if(hook->last_heartbeat_time > hook->last_heartbeat_time_prev)\n          {\n            hook->last_heartbeat_time_prev = hook->last_heartbeat_time;\n            hook->enabled = true;\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 33.978586414281594}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t#ifdef _WIN32\n  Sleep(10);\n#else\n  usleep(10000);\n#endif\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  for(auto& [node_uid, hook] : _p->pre_hooks)\n  {\n    std::unique_lock<std::mutex> lk(hook->mutex);\n    if(hook->enabled && hook->mode == Monitor::Hook::Mode::HEARTBEAT)\n    {\n      if(hook->last_heartbeat_time.get() == 0)\n      {\n        hook->last_heartbeat_time.set(std::chrono::system_clock::now());\n      }\n      auto now = std::chrono::system_clock::now();\n      if(now - hook->last_heartbeat_time.get() > std::chrono::seconds(3))\n      {\n        hook->enabled = false;\n        lk.unlock();\n        hook->wakeup.notify_all();\n      }\n    }\n  }\n  _p->heartbeat_thread = std::thread(&Groot2Publisher::heartbeatLoop, this);\n}", "CodeBleu_score": 42.0638821130089}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> result;\n\n\t// Create the root JSON object\n\tjson j_root;\n\n\t// Split the input string\n\tstd::vector<std::string> bb_list_splitted = split(bb_list, ',');\n\n\t// Iterate through the list of blackboard names\n\tfor (std::vector<std::string>::iterator it = bb_list_splitted.begin(); it != bb_list_splitted.end(); ++it) {\n\t\t// Get the blackboard name\n\t\tstd::string bb_name = *it;\n\n\t\t// Get the corresponding subtree\n\t\tBlackboard::Ptr bb = blackboard_server_->getBlackboard(bb_name);\n\n\t\t// Lock the subtree\n\t\tif (bb->lock(ros::Time::now())) {\n\t\t\t// Get the JSON object of the subtree\n\t\t\tjson j_bb = bb->getJSON();\n\n\t\t\t// Add the subtree to the root JSON object\n\t\t\tj_root[bb_name] = j_bb;\n\n\t\t\t// Unlock the subtree\n\t\t\tbb->unlock();\n\t\t}\n\t}\n\n\t// Convert the root JSON object to MessagePack format\n\tresult = msgpack::pack(j_root);\n\n\treturn result;\n}", "CodeBleu_score": 42.00867616118743}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> bb_dump;\n\n\t// Split the input string of blackboard names\n\tstd::vector<std::string> bb_names = split(bb_list, ',');\n\n\t// Create the JSON object\n\tnlohmann::json bb_dump_json;\n\n\t// Iterate through the blackboard names\n\tfor (std::string bb_name : bb_names) {\n\t\t// Find the corresponding subtree\n\t\tBlackboard::Ptr bb = blackboard_server_.getBlackboard(bb_name);\n\n\t\t// Lock the subtree\n\t\tif (bb) {\n\t\t\tbb->lockReading();\n\n\t\t\t// If the subtree is valid, export it to JSON and add it to the JSON object\n\t\t\tif (bb->isTreeValid()) {\n\t\t\t\tbb_dump_json[bb_name] = bb->exportToJSON();\n\t\t\t}\n\n\t\t\t// Unlock the subtree\n\t\t\tbb->unlockReading();\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format and return it as a vector of uint8_t\n\tbb_dump = nlohmann::json::to_msgpack(bb_dump_json);\n\n\treturn bb_dump;\n}", "CodeBleu_score": 43.18800860115998}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Split the input string of blackboard names\n\tstd::vector<std::string> bb_names = split(bb_list, ',');\n\n\t// Create the JSON object\n\trapidjson::Document json_doc;\n\tjson_doc.SetObject();\n\n\t// Iterate through the blackboard names\n\tfor (std::string bb_name : bb_names) {\n\t\t// Get the blackboard subtree\n\t\tBlackboard::Ptr bb = blackboard_server_->getBlackboard(bb_name);\n\t\tif (!bb) {\n\t\t\tROS_ERROR(\"Blackboard '%s' does not exist.\", bb_name.c_str());\n\t\t\treturn std::vector<uint8_t>();\n\t\t}\n\n\t\t// Lock the blackboard\n\t\tif (!bb->lock(ros::Time(0), ros::Duration(1))) {\n\t\t\tROS_ERROR(\"Failed to lock blackboard '%s'.\", bb_name.c_str());\n\t\t\treturn std::vector<uint8_t>();\n\t\t}\n\n\t\t// Create the blackboard JSON object\n\t\trapidjson::Document bb_json_doc;\n\t\tbb_json_doc.SetObject();\n\n\t\t// Add the blackboard subtree to the JSON object\n\t\tbb->toMessagePack(bb_json_doc);\n\n\t\t// Add the blackboard JSON object to the main JSON object\n\t\tjson_doc.AddMember(rapidjson::StringRef(bb_name.c_str()), bb_json_doc, json_doc.GetAllocator());\n\n\t\t// Unlock the blackboard\n\t\tbb->unlock();\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\treturn convertMessagePack(json_doc);\n}", "CodeBleu_score": 37.67949162924555}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t#ifdef DEBUG\n  std::cout << \"Unlocking breakpoint for node \" << node_uid << std::endl;\n#endif\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return false;\n  }\n  if(bk_it->second->getStatus() != NodeStatus::BREAKPOINT)\n  {\n    return false;\n  }\n  bk_it->second->setStatus(result);\n  bk_it->second->setRemove(remove);\n  bk_it->second->setReady(true);\n  bk_it->second->notify_all();\n  return true;\n}", "CodeBleu_score": 47.52011781445695}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto bk_it = hooks->find(node_uid);\n\tif(bk_it == hooks->end())\n\t{\n\t\treturn false;\n\t}\n\tauto hook = bk_it->second;\n\tif(hook->status != NodeStatus::BREAKPOINT)\n\t{\n\t\treturn false;\n\t}\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->cv.notify_all();\n\treturn true;\n}", "CodeBleu_score": 53.70884857442695}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t\tauto hook = getHook(pos, node_uid);\n\tif(!hook) {\n\t\treturn false;\n\t}\n\tstd::unique_lock<std::mutex> lk(hook->mutex);\n\tif(hook->status != NodeStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\thook->cv.notify_all();\n\treturn true;\n}", "CodeBleu_score": 44.66757977756515}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t#ifdef BT_DEBUG_THREAD_NAMES\n  std::string thread_name = \"Action: \" + name();\n  pthread_setname_np(pthread_self(), thread_name.c_str());\n#endif\n\n  NodeStatus status = NodeStatus::IDLE;\n  try {\n    if (status_ == NodeStatus::IDLE) {\n      status_ = NodeStatus::RUNNING;\n      halt_requested_ = false;\n      std::thread(&BT::ThreadedAction::tickThread, this).detach();\n    }\n  } catch (std::exception& e) {\n    // Catch any exception that occurs during the tick and log it\n    std::string msg = \"Caught exception in Action '\" + name() + \"': \" + e.what();\n    RCLCPP_ERROR(get_logger(), msg.c_str());\n    setStatus(NodeStatus::IDLE);\n  }\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n  return status_;\n}", "CodeBleu_score": 40.90530865970985}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t#ifdef _WIN32\n  unsigned int thread_id = 0;\n#else\n  pthread_t thread_id = 0;\n#endif\n  bool thread_created = false;\n\n  try {\n    if(status() == NodeStatus::IDLE) {\n      setStatus(NodeStatus::RUNNING);\n      halt_requested_ = false;\n      thread_created = true;\n#ifdef _WIN32\n      thread_id = _beginthreadex(NULL, 0, &ThreadedAction::runTick, this, 0, NULL);\n#else\n      pthread_create(&thread_id, NULL, &ThreadedAction::runTick, this);\n#endif\n    }\n  } catch(...) {\n    setStatus(NodeStatus::IDLE);\n    throw;\n  }\n\n  if(thread_created) {\n#ifdef _WIN32\n    WaitForSingleObject(thread_id, INFINITE);\n#else\n    pthread_join(thread_id, NULL);\n#endif\n  }\n\n  if(halt_requested_) {\n    setStatus(NodeStatus::IDLE);\n  }\n\n  return status();\n}", "CodeBleu_score": 45.024752912558}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t\tNodeStatus prev_status = status();\n\tif(prev_status == NodeStatus::IDLE)\n\t{\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\ttry\n\t{\n\t\t// start a new thread to execute the tick function\n\t\tstd::thread t(&BT::ThreadedAction::runTick, this);\n\t\tt.detach();\n\t}\n\tcatch(const std::exception& e)\n\t{\n\t\tROS_ERROR_STREAM(\"Exception caught in ThreadedAction::executeTick: \" << e.what());\n\t\tROS_ERROR_STREAM(\"Setting node status to IDLE\");\n\t\tsetStatus(NodeStatus::IDLE);\n\t\thalt_requested_ = true;\n\t\tthrow;\n\t}\n\treturn prev_status;\n}", "CodeBleu_score": 36.77524865081408}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\t// Print the tree structure starting from the root_node to the provided output stream.\n\t// This function defines a recursive lambda function to handle the printing.\n\t// The lambda function indents the output based on the node's depth, prints the node's name, and recursively prints the children for ControlNode or the child for DecoratorNode.\n\t// The function begins and ends with separator lines.\n\tauto print_tree_recursively_lambda = [&stream, &print_tree_recursively_lambda](const TreeNode* node, int depth) {\n\t\t// Print the tree structure starting from the root_node to the provided output stream.\n\t\t// This function defines a recursive lambda function to handle the printing.\n\t\t// The lambda function indents the output based on the node's depth, prints the node's name, and recursively prints the children for ControlNode or the child for DecoratorNode.\n\t\t// The function begins and ends with separator lines.\n\t\tstream << std::string(depth * 2, ' ') << node->name << std::endl;\n\t\tif (node->is_control_node()) {\n\t\t\tfor (const auto& child : node->get_children()) {\n\t\t\t\tprint_tree_recursively_lambda(child, depth + 1);\n\t\t\t}\n\t\t} else {\n\t\t\tprint_tree_recursively_lambda(node->get_child(), depth + 1);\n\t\t}\n\t};\n\tstream << \"Behavior Tree:\" << std::endl;\n\tprint_tree_recursively_lambda(root_node, 0);\n}", "CodeBleu_score": 33.781889061252514}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tif (root_node == nullptr) {\n\t\treturn;\n\t}\n\n\tstream << std::string(root_node->getDepth() * 4, ' ') << root_node->getName() << std::endl;\n\n\tif (auto control_node = dynamic_cast<const ControlNode*>(root_node)) {\n\t\tfor (const TreeNode* child : control_node->getChildren()) {\n\t\t\tprintTreeRecursively(child, stream);\n\t\t}\n\t} else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(root_node)) {\n\t\tprintTreeRecursively(decorator_node->getChild(), stream);\n\t}\n\n\tstream << std::endl;\n}", "CodeBleu_score": 32.74197810632542}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"---------------------------------------\" << std::endl;\n\tstd::function<void(const TreeNode*, int)> print_tree_recursively_lambda = [&stream, &print_tree_recursively_lambda](const TreeNode* node, int depth) {\n\t\tstream << std::string(depth, '\\t') << node->name << std::endl;\n\t\tif (node->is_control_node()) {\n\t\t\tfor (const TreeNode* child : node->children) {\n\t\t\t\tprint_tree_recursively_lambda(child, depth + 1);\n\t\t\t}\n\t\t} else if (node->is_decorator_node()) {\n\t\t\tprint_tree_recursively_lambda(node->child, depth + 1);\n\t\t}\n\t};\n\tprint_tree_recursively_lambda(root_node, 0);\n\tstream << \"---------------------------------------\" << std::endl;\n}", "CodeBleu_score": 37.770683387220075}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t}\n\telse if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.51781904209018}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n{\n  throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\nvisitor(node);\n\nif(auto control = dynamic_cast<const BT::ControlNode*>(node))\n{\n  for(const auto& child : control->children())\n  {\n    applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n  }\n}\nelse if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n{\n  applyRecursiveVisitor(decorator->child(), visitor);\n}\n}", "CodeBleu_score": 97.36385447759089}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\nthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n}\n\nvisitor(node);\n\nif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\nfor (const auto& child : control->children()) {\napplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n}\n} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\napplyRecursiveVisitor(decorator->child(), visitor);\n}\n}", "CodeBleu_score": 90.48085955054157}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_ID) != builders.end()) {\n\t\tthrow BehaviorTreeException(\"A builder with ID \\\"\" + manifest.registration_ID + \"\\\" is already registered!\");\n\t}\n\tbuilders[manifest.registration_ID] = builder;\n\tmanifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 44.928050070483515}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders.find(manifest.registration_ID) != builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID \\\"\" + manifest.registration_ID + \"\\\" already exists!\");\n\t}\n\tbuilders[manifest.registration_ID] = builder;\n\tmanifests[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 44.121895666047536}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_ID) != builders_.end()) {\n\t\tthrow BehaviorTreeException(\"A node builder with the same ID is already registered\");\n\t}\n\tbuilders_[manifest.registration_ID] = builder;\n\tmanifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 43.007952378474435}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const std::string& name, const PortsList& ports) {\n  return std::make_unique<SimpleActionNode>(name, tick_functor, ports);\n};\n\nTreeNodeManifest manifest = { ID, NodeType::ACTION, ports };\nregisterBuilder(manifest, builder);\n}", "CodeBleu_score": 65.14406209754678}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t\n#ifdef DEBUG_BT_FACTORY\n  std::cout << \"[BehaviorTreeFactory::registerSimpleAction] ID: \" << ID << std::endl;\n#endif\n\n  // Create a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n  auto builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_shared<SimpleActionNode>(name, tick_functor, ports, config);\n  };\n\n  // Create a TreeNodeManifest with the action node type, ID, and ports list.\n  TreeNodeManifest manifest = { TreeNodeManifest::SIMPLE_ACTION, ID, ports };\n\n  // Call registerBuilder to register the manifest and builder.\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 66.138927959601}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t#if defined(DEBUG) || defined(_DEBUG)\n  // Check if ID is already registered\n  auto it = _p->builders.find(ID);\n  if(it != _p->builders.end())\n  {\n    throw BehaviorTreeException(\"ID [\", ID, \"] already registered\");\n  }\n#endif\n\n  // Create a builder lambda\n  NodeBuilder builder = [tick_functor, ports](const std::string& name) {\n    return std::make_shared<SimpleActionNode>(name, tick_functor, ports);\n  };\n\n  // Create a manifest\n  TreeNodeManifest manifest = { ID, NODE_TYPE::SIMPLE_ACTION, ports };\n\n  // Register the manifest and builder\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 63.78731451177252}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> blackboard_backups;\n\tblackboard_backups.reserve(tree.GetSubtreeCount());\n\tfor (auto subtree : tree.GetSubtrees()) {\n\t\tBlackboard::Ptr blackboard = Blackboard::Create();\n\t\tblackboard->Clone(subtree->GetBlackboard());\n\t\tblackboard_backups.push_back(blackboard);\n\t}\n\treturn blackboard_backups;\n}", "CodeBleu_score": 49.074556104121804}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.GetNumSubTrees());\n\tfor (const auto& subtree : tree.GetSubTrees()) {\n\t\tbackup.emplace_back(Blackboard::Create(subtree.GetBlackboard()->GetBBType()));\n\t\tbackup.back()->CloneFrom(*subtree.GetBlackboard());\n\t}\n\treturn backup;\n}", "CodeBleu_score": 54.472208999505845}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetNumSubTrees());\n\tfor (int i = 0; i < tree.GetNumSubTrees(); i++) {\n\t\tbackups.emplace_back(Blackboard::Make());\n\t\tbackups[i]->Clone(tree.GetSubTree(i).GetBlackboard());\n\t}\n\treturn backups;\n}", "CodeBleu_score": 51.882530320906014}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor.has_value()) {\n\t\treturn executor.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.51038004251092}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor.has_value()) {\n\t\treturn executor.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.51038004251092}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor.has_value())\n\t{\n\t\treturn executor.value()(env);\n\t}\n\telse\n\t{\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 84.33243661481168}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (isLoaded())\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\tstd::string error;\n\ttry {\n\t\tlib = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\t\tif (!lib)\n\t\t\tthrow RuntimeError(\"Failed to load library: \" + std::string(dlerror()));\n\t\tthis->path = path;\n\t} catch (const std::exception& e) {\n\t\terror = e.what();\n\t}\n\tif (!error.empty())\n\t\tthrow RuntimeError(error);\n}", "CodeBleu_score": 54.15510441354054}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (lib) throw std::runtime_error(\"Library already loaded\");\n\tlib = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!lib) throw std::runtime_error(dlerror());\n\tthis->path = path;\n}", "CodeBleu_score": 46.73047337636695}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (handle) throw std::runtime_error(\"Library already loaded\");\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) throw std::runtime_error(dlerror());\n\tpath_ = path;\n}", "CodeBleu_score": 45.803970823697924}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) return false;\n\tstr = str.trim();\n\tif (str[0] != '{' || str[str.size() - 1] != '}') return false;\n\tif (stripped_pointer) *stripped_pointer = str.substr(1, str.size() - 2);\n\treturn true;\n}", "CodeBleu_score": 18.391536949058583}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.trim();\n\tif (stripped.front() != '{' || stripped.back() != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer != nullptr) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 23.077174819976182}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tstr = str.trim();\n\tif (str.front() != '{' || str.back() != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = str.substr(1, str.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 21.9226678541978}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t//  ROS_DEBUG(\"lineCost called with (%d, %d), (%d, %d)\", x0, y0, x1, y1);\n  double lineCost = 0;\n  unsigned int lineCostMax = 0;\n  unsigned int lineCostMin = 0;\n  unsigned int lineCostSum = 0;\n  unsigned int lineCostCount = 0;\n\n  unsigned int x, y;\n  unsigned int dx = abs(x1 - x0);\n  unsigned int dy = abs(y1 - y0);\n  int sx = (x0 < x1) ? 1 : -1;\n  int sy = (y0 < y1) ? 1 : -1;\n  int err = dx - dy;\n\n  while(1) {\n    x = x0;\n    y = y0;\n    lineCost = pointCost(x, y);\n    if(lineCost < 0)\n      return lineCost;\n\n    lineCostMax = std::max(lineCost, lineCostMax);\n    lineCostMin = std::min(lineCost, lineCostMin);\n    lineCostSum += lineCost;\n    lineCostCount++;\n\n    if(x == x1 && y == y1)\n      break;\n\n    int e2 = 2 * err;\n    if(e2 > -dy) {\n      err = err - dy;\n      x0 = x0 + sx;\n    }\n    if(e2 < dx) {\n      err = err + dx;\n      y0 = y0 + sy;\n    }\n  }\n\n  //ROS_DEBUG(\"lineCost returning %f\", (lineCostSum / lineCostCount));\n  return (lineCostSum / lineCostCount);\n}", "CodeBleu_score": 41.08982518425748}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\t//initialize the line cost\n\tdouble line_cost = 0.0;\n\t//calculate the line cost\n\tfor(LineIterator line_it(x0, y0, x1, y1); line_it != line_it.end(); ++line_it) {\n\t\t//get the point cost\n\t\tdouble point_cost = pointCost(*line_it);\n\t\t//if the point cost is negative, return the point cost immediately\n\t\tif(point_cost < 0)\n\t\t\treturn point_cost;\n\t\t//update the line cost if the point cost is higher\n\t\tline_cost = std::max(line_cost, point_cost);\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 59.80937071269082}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble lineCost = 0;\n\t//initialize the LineIterator\n\tLineIterator line(x0, y0, x1, y1);\n\tfor(int* p = line.begin(); p != line.end(); p++) {\n\t\t//get the point cost\n\t\tdouble pointCost = pointCost(*p);\n\t\t//if the point cost is negative, return immediately\n\t\tif(pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t}\n\t\t//update the line cost\n\t\tlineCost = max(lineCost, pointCost);\n\t}\n\treturn lineCost;\n}", "CodeBleu_score": 46.94991674348661}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path plan;\n\tplan.header.frame_id = path.front().header.frame_id;\n\tplan.header.stamp = path.front().header.stamp;\n\tplan.poses.reserve(path.size());\n\tfor (const geometry_msgs::PoseStamped& pose : path) {\n\t\tplan.poses.push_back(pose);\n\t}\n\n\tpub.publish(plan);\n}", "CodeBleu_score": 48.28229797595691}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.empty()) {\n\t\tROS_INFO(\"Path is empty. Not publishing plan.\");\n\t\treturn;\n\t}\n\tnav_msgs::Path nav_path;\n\tnav_path.header.frame_id = path.front().header.frame_id;\n\tnav_path.header.stamp = path.front().header.stamp;\n\tnav_path.poses.reserve(path.size());\n\tfor (const auto& pose : path) {\n\t\tnav_path.poses.push_back(pose);\n\t}\n\tpub.publish(nav_path);\n}", "CodeBleu_score": 48.57512500877299}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (path.size() == 0) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path rosPlan;\n\trosPlan.header.frame_id = path[0].header.frame_id;\n\trosPlan.header.stamp = path[0].header.stamp;\n\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\trosPlan.poses.push_back(path[i].pose);\n\t}\n\n\tpub.publish(rosPlan);\n}", "CodeBleu_score": 58.30400722325363}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tbool rot_stopped = false;\n\tbool trans_stopped = false;\n\n\tif (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n\t\trot_stopped = true;\n\t}\n\n\tif (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n\t\ttrans_stopped = true;\n\t}\n\n\tif (rot_stopped && trans_stopped) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 54.84790290971505}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 58.91107779407654}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity);\n}", "CodeBleu_score": 63.0430762213567}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig = default_limits;\n\t}\n\tif (!setup_done) {\n\t\tdefault_limits = config;\n\t\tsetup_done = true;\n\t}\n\tmutex.lock();\n\tcurrent_limits = config;\n\tmutex.unlock();\n}", "CodeBleu_score": 49.334539006390074}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig = default_limits;\n\t}\n\tif (!setup_done) {\n\t\tdefault_limits = config;\n\t\tsetup_done = true;\n\t}\n\tconfig_mutex.lock();\n\tcurrent_limits = config;\n\tconfig_mutex.unlock();\n}", "CodeBleu_score": 50.12022426083493}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (restore_defaults) {\n\t\tconfig = default_limits;\n\t\tsetup = false;\n\t}\n\n\tif (!setup) {\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\n\tmutex.lock();\n\tlimits = config;\n\tmutex.unlock();\n}", "CodeBleu_score": 48.45571233944831}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// Check if the cell is an obstacle or has no information.\n  if (check_cell->is_obstacle_ || check_cell->cost_ == costmap_2d::NO_INFORMATION) {\n    current_cell->target_distance_ = obstacle_cost_;\n    return false;\n  }\n// If the cell is not an obstacle, calculate the new target distance.\n  double new_target_distance = current_cell->target_distance_ +\n      costmap.getCost(check_cell->x_, check_cell->y_);\n// If the new target distance is shorter than the current target distance, update the target distance.\n  if (new_target_distance < current_cell->target_distance_) {\n    current_cell->target_distance_ = new_target_distance;\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 47.31466477257267}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\n/*\n * If the cell is an obstacle or has no information, it sets the cell's target distance to the maximum obstacle cost and returns false.\n */\n  if (check_cell->isObstacle() || !costmap.getCost(check_cell->getIndex())) {\n    current_cell->setTargetDistance(MapGrid::max_obstacle_cost);\n    return false;\n  }\n\n/*\n * If the cell is not an obstacle, it calculates a new target distance and updates the cell's target distance if the new distance is shorter.\n */\n  float new_target_distance = current_cell->getDistance() + MapGrid::getDistanceCost(check_cell->getIndex(), costmap);\n  if (new_target_distance < current_cell->getTargetDistance()) {\n    current_cell->setTargetDistance(new_target_distance);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 39.023694651725506}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\tif (!check_cell->isObstacle()) {\n\t\tdouble new_target_distance = current_cell->getTargetDistance() + costmap.getCost(check_cell->getX(), check_cell->getY());\n\t\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.85755929139686}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tdouble cost = 0.0;\n\n//if we don't have a footprint, return a high cost\nif (footprint_.size() == 0) {\n  ROS_ERROR(\"Footprint specification is empty\");\n  return -9.0;\n}\n\n//get the scaling factor based on the speed of the trajectory\ndouble scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n//calculate the footprint cost for each point in the trajectory\nfor (unsigned int i = 0; i < traj.x_.size(); ++i) {\n  double x = traj.x_[i];\n  double y = traj.y_[i];\n  double th = traj.th_[i];\n\n  double footprint_cost = footprintCost(x, y, th, scale, footprint_, costmap_, world_model_);\n\n  //if the footprint cost is negative, we can return immediately\n  if (footprint_cost < 0) {\n    return footprint_cost;\n  }\n\n  //otherwise, add the cost to the total cost\n  if (sum_scores_) {\n    cost += footprint_cost;\n  } else {\n    cost = std::max(cost, footprint_cost);\n  }\n}\n\nreturn cost;\n}", "CodeBleu_score": 68.57095436123845}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//  ROS_INFO(\"scoreTrajectory called\");\n  double cost = 0.0;\n  double scale = 1.0;\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint is empty. Cannot score trajectory.\");\n    return -9.0;\n  }\n\n  //if we're not using the footprint cost, we'll just return the cost of the\n  //trajectory\n  if (!footprint_cost_) {\n    return traj.cost_;\n  }\n\n  //if we're using the footprint cost, we'll need to scale the footprint\n  //based on the trajectory's speed\n  if (scaling_speed_ > 0.0) {\n    scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  }\n\n  //now we can start scoring the trajectory\n  for (unsigned int i = 0; i < traj.x_.size(); ++i) {\n    double cost_i = footprintCost(traj.x_[i], traj.y_[i], traj.th_[i], scale, footprint_spec_, costmap_, world_model_);\n    if (cost_i < 0) {\n      return cost_i;\n    }\n    if (sum_scores_) {\n      cost += cost_i;\n    } else {\n      cost = std::max(cost, cost_i);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 61.964005794927935}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//  ROS_DEBUG_STREAM(\"Trajectory: \" << traj.x_ << \", \" << traj.y_ << \", \" << traj.th_ << \", \" << traj.xv_ << \", \" << traj.yv_ << \", \" << traj.thetav_);\n\n  //we'll assume the footprint is legal until we find out otherwise\n  double footprint_cost = 0.0;\n\n  //if the footprint is empty, return immediately\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint is empty.  Cannot score trajectory.\");\n    return -9.0;\n  }\n\n  //initialize the cost and scaling factor based on the trajectory\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  //iterate through each point in the trajectory and calculate the footprint cost\n  for (unsigned int i = 0; i < traj.x_.size(); ++i) {\n    double x = traj.x_[i];\n    double y = traj.y_[i];\n    double th = traj.th_[i];\n    footprint_cost = footprintCost(x, y, th, scale, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    cost += footprint_cost;\n  }\n\n  //if we're summing the scores, return the sum\n  if (sum_scores_) {\n    return cost;\n  }\n  //otherwise, return the max\n  else {\n    return std::max(cost, 0.0);\n  }\n}", "CodeBleu_score": 65.34524483422256}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In the setOdomTopic function with topic: %s\", odom_topic.c_str());\n  if (odom_topic != odom_topic_) {\n    if (odom_topic != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 44.2913092513875}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_INFO_ONCE(\"setOdomTopic called with topic %s\", odom_topic.c_str());\n  if(odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if(odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1, boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 55.05853756937007}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In setOdomTopic with topic %s\", odom_topic.c_str());\n  if (odom_topic == odom_topic_) {\n    // same topic, nothing to do\n    return;\n  }\n\n  if (odom_topic == \"\") {\n    // empty topic, shut down\n    odom_topic_ = \"\";\n    if (odom_sub_) {\n      odom_sub_.shutdown();\n      odom_sub_ = boost::shared_ptr<message_filters::Subscriber<nav_msgs::Odometry> >();\n    }\n    return;\n  }\n\n  // new topic, initialize\n  odom_topic_ = odom_topic;\n\n  if (!odom_sub_) {\n    // no odom subscriber yet, initialize\n    odom_sub_ = boost::shared_ptr<message_filters::Subscriber<nav_msgs::Odometry> >(\n        new message_filters::Subscriber<nav_msgs::Odometry>(nh_, odom_topic_, 10));\n    odom_sub_filtered_ = boost::shared_ptr<message_filters::Subscriber<nav_msgs::Odometry> >(\n        new message_filters::Subscriber<nav_msgs::Odometry>(nh_, odom_topic_, 10));\n    odom_sync_ = boost::shared_ptr<message_filters::TimeSynchronizer<nav_msgs::Odometry, nav_msgs::Odometry> >(\n        new message_filters::TimeSynchronizer<nav_msgs::Odometry, nav_msgs::Odometry>(\n            boost::shared_ptr<message_filters::Subscriber<nav_msgs::Odometry> >(odom_sub_),\n            boost::shared_ptr<message_filters::Subscriber<nav_msgs::Odometry> >(odom_sub_filtered_), 10));\n    odom_sync_->registerCallback(boost::bind(&OdometryHelperRos::odomCallback, this, _1, _2));\n  } else {\n    // already subscribed, update topic\n    odom_sub_->subscribe(odom_topic_, 10);\n    odom_sub_filtered_->subscribe(odom_topic_, 10);\n  }\n}", "CodeBleu_score": 42.937056729898316}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t_\n\tif (pos.squaredNorm() > 1.0) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n\n\tconst float distance = (pos - prev).squaredNorm();\n\tconst float angle = fabs(angleDiff(pos, prev));\n\n\tif (distance > 0.001) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n\n\tif (angle > 0.01) {\n\t\tresetOscillationFlags();\n\t\treturn;\n\t}\n\n\tstrafe_pos_only_ = (pos(0) > 0.0);\n\tstrafe_neg_only_ = (pos(0) < 0.0);\n\tstrafing_pos_ = (strafe_pos_only_ && !strafe_neg_only_);\n\tstrafing_neg_ = (strafe_neg_only_ && !strafe_pos_only_);\n\n\trot_pos_only_ = (pos(1) > 0.0);\n\trot_neg_only_ = (pos(1) < 0.0);\n\trotating_pos_ = (rot_pos_only_ && !rot_neg_only_);\n\trotating_neg_ = (rot_neg_only_ && !rot_pos_only_);\n\n\tforward_pos_only_ = (pos(2) > 0.0);\n\tforward_neg_only_ = (pos(2) < 0.0);\n\tforward_pos_ = (forward_pos_only_ && !forward_neg_only_);\n\tforward_neg_ = (forward_neg_only_ && !forward_pos_only_);\n}", "CodeBleu_score": 34.52108769118676}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t", "CodeBleu_score": 5.324294863153016}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t", "CodeBleu_score": 5.324294863153016}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t", "CodeBleu_score": 5.072917382472679}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //check for out of bounds\n  if(gx >= width_ || gy >= height_ || gx < 0 || gy < 0)\n    return;\n\n  //check for too close to a neighbor\n  double sq_dist = nearestNeighborDistance(pt);\n  if(sq_dist < sq_min_separation_)\n    return;\n\n  //get the bounds of the grid cell in world coords\n  geometry_msgs::Point lower_left, upper_right;\n  getCellBounds(gx, gy, lower_left, upper_right);\n\n  //get the index of the grid cell\n  unsigned int index = getIndex(gx, gy);\n\n  //add the point to the cell\n  cells_[index].insert(pt);\n}", "CodeBleu_score": 58.82892230869843}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //check if the point is within the grid bounds\n  if(gx >= width_ || gy >= height_ || gx < 0 || gy < 0)\n    return;\n\n  //check if the point is too close to its nearest neighbor\n  double sq_dist = nearestNeighborDistance(pt);\n\n  if(sq_dist < sq_min_separation_)\n    return;\n\n  //insert the point into the cell\n  insertInCell(pt, gx, gy);\n}", "CodeBleu_score": 59.53350172842462}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n/*\n * Compute the new velocities.\n */\nEigen::Vector3f new_vel;\n\n/*\n * For each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits.\n */\nfor (int i = 0; i < 3; i++) {\n\n    /*\n     * If the target velocity is greater than the current velocity, increase the current velocity by the acceleration limit.\n     */\n    if (sample_target_vel[i] > vel[i]) {\n\n        /*\n         * If the current velocity plus the acceleration limit is greater than the target velocity, set the current velocity to the target velocity.\n         */\n        if (vel[i] + acclimits[i] > sample_target_vel[i]) {\n\n            new_vel[i] = sample_target_vel[i];\n\n        /*\n         * Otherwise, increase the current velocity by the acceleration limit.\n         */\n        } else {\n\n            new_vel[i] = vel[i] + acclimits[i];\n\n        }\n\n    /*\n     * If the target velocity is less than the current velocity, decrease the current velocity by the acceleration limit.\n     */\n    } else if (sample_target_vel[i] < vel[i]) {\n\n        /*\n         * If the current velocity minus the acceleration limit is less than the target velocity, set the current velocity to the target velocity.\n         */\n        if (vel[i] - acclimits[i] < sample_target_vel[i]) {\n\n            new_vel[i] = sample_target_vel[i];\n\n        /*\n         * Otherwise, decrease the current velocity by the acceleration limit.\n         */\n        } else {\n\n            new_vel[i] = vel[i] - acclimits[i];\n\n        }\n\n    /*\n     * If the target velocity is equal to the current velocity, set the current velocity to the target velocity.\n     */\n    } else {\n\n        new_vel[i] = sample_target_vel[i];\n\n    }\n\n}\n\nreturn new_vel;\n\n}", "CodeBleu_score": 52.948569412430366}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\n//    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    // Compute new velocities\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            vel[i] += acclimits[i] * dt;\n            if (vel[i] > sample_target_vel[i]) {\n                vel[i] = sample_target_vel[i];\n            }\n        } else if (sample_target_vel[i] < vel[i]) {\n            vel[i] -= acclimits[i] * dt;\n            if (vel[i] < sample_target_vel[i]) {\n                vel[i] = sample_target_vel[i];\n            }\n        }\n    }\n\n    return vel;\n}", "CodeBleu_score": 51.52381472266497}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\nEigen::Vector3f new_vel;\n\nfor (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n        new_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n    } else if (sample_target_vel[i] < vel[i]) {\n        new_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n    } else {\n        new_vel[i] = sample_target_vel[i];\n    }\n}\n\nreturn new_vel;\n\n}", "CodeBleu_score": 70.61636295577873}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble best_heading_diff = DBL_MAX;\n\tdouble x_world, y_world;\n\tdouble best_x = 0, best_y = 0;\n\tdouble best_heading = 0;\n\tdouble best_cost = DBL_MAX;\n\tint i = 0;\n\tint j = 0;\n\n\tfor (i = cell_x; i >= 0; i--) {\n\t\tfor (j = cell_y; j >= 0; j--) {\n\t\t\tx_world = (i + 0.5) * resolution;\n\t\t\ty_world = (j + 0.5) * resolution;\n\t\t\tdouble cost = lineCost(x, y, x_world, y_world);\n\t\t\tif (cost < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble heading_diff = atan2(y_world - y, x_world - x);\n\t\t\theading_diff = heading_diff - heading;\n\t\t\tif (heading_diff > M_PI) {\n\t\t\t\theading_diff -= 2 * M_PI;\n\t\t\t} else if (heading_diff < -M_PI) {\n\t\t\t\theading_diff += 2 * M_PI;\n\t\t\t}\n\t\t\tif (cost < best_cost) {\n\t\t\t\tbest_heading_diff = heading_diff;\n\t\t\t\tbest_x = x_world;\n\t\t\t\tbest_y = y_world;\n\t\t\t\tbest_heading = heading_diff;\n\t\t\t\tbest_cost = cost;\n\t\t\t}\n\t\t}\n\t}\n\tif (best_heading_diff == DBL_MAX) {\n\t\treturn DBL_MAX;\n\t}\n\treturn best_heading_diff;\n}", "CodeBleu_score": 37.86430872012409}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble diff = DBL_MAX;\n\tdouble robot_x, robot_y, goal_x, goal_y;\n\tdouble robot_theta = heading;\n\tdouble goal_theta;\n\tdouble dx, dy;\n\tint i = 0;\n\n\tfor (i = plan_length - 1; i >= 0; i--) {\n\t\tif (plan[i].x == cell_x && plan[i].y == cell_y) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == -1) {\n\t\treturn DBL_MAX;\n\t}\n\n\trobot_x = plan[i].x;\n\trobot_y = plan[i].y;\n\n\tgoal_x = x;\n\tgoal_y = y;\n\n\tdx = goal_x - robot_x;\n\tdy = goal_y - robot_y;\n\n\tgoal_theta = atan2(dy, dx);\n\n\tdiff = goal_theta - robot_theta;\n\n\tif (diff > M_PI) {\n\t\tdiff -= 2 * M_PI;\n\t}\n\n\tif (diff < -M_PI) {\n\t\tdiff += 2 * M_PI;\n\t}\n\n\treturn abs(diff);\n}", "CodeBleu_score": 39.5903979681244}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0.0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN(\"TrajectoryPlanner: Trajectory with vx_samp: %f, vy_samp: %f, vtheta_samp: %f, cost: %f is invalid.\", vx_samp, vy_samp, vtheta_samp, cost);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 78.2550430032533}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t#if DEBUG_TRAJECTORY_COST\n  // check if the trajectory is valid.\n  if (scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp) >= 0) {\n    return true;\n  } else {\n    // log a warning.\n    ROS_WARN_STREAM(\"Invalid trajectory with vx = \" << vx_samp << \", vy = \" << vy_samp << \", vtheta = \" << vtheta_samp << \", cost = \" << scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp));\n    return false;\n  }\n#else\n  // check if the trajectory is valid.\n  return scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp) >= 0;\n#endif\n}", "CodeBleu_score": 60.64122255834019}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t\n//    std::cout << \"vx_samp: \" << vx_samp << std::endl;\n//    std::cout << \"vy_samp: \" << vy_samp << std::endl;\n//    std::cout << \"vtheta_samp: \" << vtheta_samp << std::endl;\n\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    if (cost >= 0) {\n        return true;\n    } else {\n        ROS_WARN(\"Invalid trajectory: vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\", vx_samp, vy_samp, vtheta_samp, cost);\n        return false;\n    }\n}", "CodeBleu_score": 80.11054699387891}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t", "CodeBleu_score": 1.3478873791258357}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() to use the clear costmap recovery behavior\");\n\t\treturn;\n\t}\n\n\tif (!costmap_ros_) {\n\t\tROS_ERROR(\"Costmap is not set, please call setCostmap() to use the clear costmap recovery behavior\");\n\t\treturn;\n\t}\n\n\tif (costmap_ros_->getRobotPose().header.frame_id == \"\") {\n\t\tROS_ERROR(\"Costmap frame ID is not set, please set the global costmap frame ID to use the clear costmap recovery behavior\");\n\t\treturn;\n\t}\n\n\tif (clearable_layers_.empty()) {\n\t\tROS_ERROR(\"No layers are set to be cleared, please call addLayer() to use the clear costmap recovery behavior\");\n\t\treturn;\n\t}\n\n\tros::Time start_time = ros::Time::now();\n\n\t// clear the costmaps\n\tclear(costmap_ros_);\n\n\t// force an update of the costmap\n\tif (force_update_) {\n\t\tcostmap_ros_->updateMap();\n\t}\n\n\t// log the time taken\n\tdouble duration = (ros::Time::now() - start_time).toSec();\n\tROS_INFO(\"Clearing costmap took %f seconds\", duration);\n}", "CodeBleu_score": 33.14344344303622}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.size() < 3) {\n\t\tROS_ERROR(\"polygonOutlineCells: polygon must have at least 3 vertices\");\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline;\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tif (i == polygon.size() - 1) {\n\t\t\toutline.add(polygon[i], polygon[0]);\n\t\t} else {\n\t\t\toutline.add(polygon[i], polygon[i+1]);\n\t\t}\n\t}\n\n\tpolygon_cells = outline.getCells();\n}", "CodeBleu_score": 49.26352639907997}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.size() < 3) {\n\t\tROS_WARN(\"Costmap2D::polygonOutlineCells() - polygon is not a valid polygon\");\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline_cells;\n\n\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\tstd::vector<MapLocation> cells;\n\t\traytraceLine(polygon[i], polygon[i + 1], cells);\n\t\toutline_cells.insert(outline_cells.end(), cells.begin(), cells.end());\n\t}\n\n\t// close the polygon\n\tstd::vector<MapLocation> cells;\n\traytraceLine(polygon[polygon.size() - 1], polygon[0], cells);\n\toutline_cells.insert(outline_cells.end(), cells.begin(), cells.end());\n\n\tpolygon_cells = outline_cells;\n}", "CodeBleu_score": 52.02550795620644}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tif (polygon.size() == 0) {\n\t\treturn;\n\t}\n\n\tPolygonOutlineCells outline_cells;\n\tfor (size_t i = 0; i < polygon.size() - 1; i++) {\n\t\traytraceLine(polygon[i], polygon[i + 1], outline_cells);\n\t}\n\traytraceLine(polygon.back(), polygon.front(), outline_cells);\n\n\tpolygon_cells = outline_cells.cells;\n}", "CodeBleu_score": 44.62474614021214}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t//  ROS_DEBUG_NAMED(\"costmap_2d_publisher\", \"New subscriber to costmap_2d_publisher\");\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 98.05533239138548}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap mutex\n\tlock_guard<mutex> lock(costmap_mutex_);\n\n\t// Set the grid's header\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_ros_->getGlobalFrameID();\n\n\t// Set the grid's resolution\n\tgrid_.info.resolution = costmap_ros_->getResolution();\n\n\t// Set the grid's width and height\n\tgrid_.info.width = costmap_ros_->getSizeInCellsX();\n\tgrid_.info.height = costmap_ros_->getSizeInCellsY();\n\n\t// Set the grid's origin\n\tgrid_.info.origin.position.x = costmap_ros_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_ros_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int x = 0; x < grid_.info.width; x++) {\n\t\tfor (unsigned int y = 0; y < grid_.info.height; y++) {\n\t\t\tunsigned int index = x + y * grid_.info.width;\n\t\t\tgrid_.data[index] = costmap_ros_->getCharMap()[x + y * grid_.info.width];\n\t\t}\n\t}\n}", "CodeBleu_score": 49.76469234518982}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tstd::lock_guard<std::mutex> lock(costmap_mutex_);\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\ttranslate_table_ = costmap_->getCharMap();\n}", "CodeBleu_score": 47.91749783717849}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tlock_guard<mutex> lock(costmapMutex);\n\tgrid.header.stamp = ros::Time::now();\n\tgrid.header.frame_id = costmapFrame;\n\tgrid.info.resolution = resolution;\n\tgrid.info.width = width;\n\tgrid.info.height = height;\n\tgrid.info.origin.position.x = originX;\n\tgrid.info.origin.position.y = originY;\n\tgrid.info.origin.orientation.w = 1.0;\n\tgrid.data.resize(width * height);\n\tfor (int i = 0; i < width; i++) {\n\t\tfor (int j = 0; j < height; j++) {\n\t\t\tgrid.data[j * width + i] = costmap.getCost(i, j);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.01999519420021}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n#if ROS_VERSION_MINIMUM(1, 11, 0)\n  if (footprint_initialized_ && new_config.footprint_model.footprint != old_config.footprint_model.footprint &&\n      new_config.footprint_model.robot_radius == old_config.footprint_model.robot_radius) {\n    ROS_DEBUG_NAMED(\"costmap_2d\", \"Footprint is the same, not updating\");\n    return;\n  }\n#else\n  if (footprint_initialized_ && new_config.footprint_model.footprint != old_config.footprint_model.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    ROS_DEBUG_NAMED(\"costmap_2d\", \"Footprint is the same, not updating\");\n    return;\n  }\n#endif\n\n  if (new_config.footprint_model.footprint.size() == 0) {\n    ROS_WARN_NAMED(\"costmap_2d\", \"Footprint model is empty, using default footprint\");\n    setUnpaddedRobotFootprint(createDefaultFootprint(new_config.robot_radius));\n  } else {\n    std::vector<geometry_msgs::Point> points;\n    if (!footprintFromPoints(new_config.footprint_model.footprint, points)) {\n      ROS_ERROR_NAMED(\"costmap_2d\", \"Footprint model is invalid, using default footprint\");\n      setUnpaddedRobotFootprint(createDefaultFootprint(new_config.robot_radius));\n    } else {\n      setUnpaddedRobotFootprint(points);\n    }\n  }\n}", "CodeBleu_score": 53.698976185251965}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t", "CodeBleu_score": 4.722552995136935}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t//  if (new_config.robot_radius_ == old_config.robot_radius_ &&\n//      new_config.robot_radius_ != 0.0) {\n//    return;\n//  }\n\n  // Check for valid footprint string\n  if (new_config.footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint provided. Using default footprint.\");\n    setRobotFootprintFromRadius(new_config.robot_radius_);\n    return;\n  }\n\n  // Parse footprint string\n  std::vector<geometry_msgs::Point> points;\n  if (!costmap_2d::parseFootprintFromConfig(new_config, points)) {\n    ROS_ERROR(\"Invalid footprint string provided. Using default footprint.\");\n    setRobotFootprintFromRadius(new_config.robot_radius_);\n    return;\n  }\n\n  // Set footprint\n  setUnpaddedRobotFootprint(points);\n}", "CodeBleu_score": 49.092046400021786}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped new_pose;\n\tif (getRobotPose(new_pose)) {\n\t\t// store the new pose\n\t\tcurrent_pose_ = new_pose;\n\t\t// update the transform from the global frame to the robot's base frame\n\t\ttf2::Stamped<tf2::Transform> transform;\n\t\ttf2::fromMsg(current_pose_.pose, transform);\n\t\ttransform.frame_id_ = current_pose_.header.frame_id;\n\t\ttransform.stamp_ = current_pose_.header.stamp;\n\t\trobot_base_frame_tf_ = transform;\n\t\t// update the transform from the robot's base frame to the local costmap frame\n\t\tgeometry_msgs::TransformStamped transform_stamped;\n\t\ttry {\n\t\t\ttransform_stamped = tf_.lookupTransform(global_frame_, robot_base_frame_, current_pose_.header.stamp);\n\t\t}\n\t\tcatch (tf2::TransformException& ex) {\n\t\t\tROS_ERROR_THROTTLE(1.0, \"Transform Error: %s\n\", ex.what());\n\t\t\treturn;\n\t\t}\n\t\ttf2::fromMsg(transform_stamped.transform, transform);\n\t\ttransform.frame_id_ = transform_stamped.header.frame_id;\n\t\ttransform.stamp_ = transform_stamped.header.stamp;\n\t\trobot_base_frame_local_costmap_tf_ = transform;\n\t}\n\telse {\n\t\tROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\n\t\t// cancel the reconfiguration\n\t\tserver_.setConfigCallback(boost::bind(&Costmap2DROS::configCB, this, boost::none));\n\t}\n}", "CodeBleu_score": 56.236540314861706}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped global_pose;\nif (!getRobotPose(global_pose)) {\nROS_WARN_THROTTLE(1.0, \"Failed to get robot pose, cancelling reconfiguration\");\nreturn;\n}\n\n// store the pose\nnew_pose.header = global_pose.header;\nnew_pose.pose = global_pose.pose;\n\n// set the new pose as the robot's current pose\nrobot_pose_mutex_.lock();\nrobot_pose_ = new_pose;\nrobot_pose_mutex_.unlock();\n}", "CodeBleu_score": 62.76433034185969}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t//  if (!initialized_)\n//    return;\n//  geometry_msgs::PoseStamped new_pose;\n//  if (!getRobotPose(new_pose))\n//  {\n//    ROS_WARN(\"Costmap2DROS: Failed to get robot pose for movement callback, cancelling reconfiguration\");\n//    reconfigure_server_.cancel();\n//    return;\n//  }\n//  if (new_pose.header.frame_id != robot_base_frame_)\n//  {\n//    ROS_WARN(\"Costmap2DROS: Robot pose is not in the robot's base frame, cancelling reconfiguration\");\n//    reconfigure_server_.cancel();\n//    return;\n//  }\n//  // check if the pose has changed\n//  if (new_pose.pose.position.x != robot_pose_.pose.position.x ||\n//      new_pose.pose.position.y != robot_pose_.pose.position.y ||\n//      new_pose.pose.position.z != robot_pose_.pose.position.z ||\n//      new_pose.pose.orientation.x != robot_pose_.pose.orientation.x ||\n//      new_pose.pose.orientation.y != robot_pose_.pose.orientation.y ||\n//      new_pose.pose.orientation.z != robot_pose_.pose.orientation.z ||\n//      new_pose.pose.orientation.w != robot_pose_.pose.orientation.w)\n//  {\n//    robot_pose_ = new_pose;\n//    robot_pose_updated_ = true;\n//  }\n}", "CodeBleu_score": 9.421357781568524}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}, {"code": "void Costmap2DROS::start(){\n\t\t// Check if the costmap is already running\n\tif (!stopped_) {\n\t\tROS_WARN_NAMED(\"costmap_2d\", \"Costmap already started\");\n\t\treturn;\n\t}\n\n\t// Retrieve the list of plugins\n\tstd::vector<std::string> plugin_list;\n\tplugin_list = costmap_->getPluginNames();\n\n\t// Check if the costmap is stopped\n\tif (std::find(plugin_list.begin(), plugin_list.end(), \"obstacle_layer\") != plugin_list.end()) {\n\t\t// Subscribe to the topics\n\t\tROS_DEBUG_NAMED(\"costmap_2d\", \"Re-subscribing to all topics\");\n\t\tcostmap_ros_->start();\n\n\t\t// Activate the plugins\n\t\tcostmap_->activateAllLayers();\n\n\t\t// Set the stopped flag to false\n\t\tstopped_ = false;\n\n\t\t// Set stop_updates_ to false\n\t\tstop_updates_ = false;\n\n\t\t// Wait until the costmap is initialized and the map update thread is active\n\t\twhile (!initialized_) {\n\t\t\tros::Duration(0.01).sleep();\n\t\t}\n\t}\n\telse {\n\t\tROS_WARN_NAMED(\"costmap_2d\", \"Costmap already started\");\n\t}\n}", "CodeBleu_score": 37.96863989616447}, {"code": "void Costmap2DROS::start(){\n\t", "CodeBleu_score": 1.488121648976743}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If we don't want to keep any observations, we can just return.\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\t// Otherwise, we have to iterate through the list.\n\tstd::list<Observation*>::iterator it = observations_.begin();\n\twhile (it != observations_.end()) {\n\t\tObservation* observation = *it;\n\t\t// If the observation is too old, we can remove it.\n\t\tif (observation->time_stamp_ < (ros::Time::now() - observation_keep_time_)) {\n\t\t\tobservations_.erase(it);\n\t\t} else {\n\t\t\t// Otherwise, we have to move on to the next observation.\n\t\t\tit++;\n\t\t}\n\t}\n}", "CodeBleu_score": 34.86412291892853}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\t// If the observation_keep_time_ is zero, do nothing\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\t// Iterate through the list and remove observations that are older than the keep time\n\tfor (std::vector<Observation>::iterator it = observations_.begin(); it != observations_.end(); ) {\n\t\tif (current_time - it->time_ > observation_keep_time_) {\n\t\t\tit = observations_.erase(it);\n\t\t} else {\n\t\t\tit++;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.53818634205163}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\tdouble current_time = ros::Time::now().toSec();\n\tint index = 0;\n\twhile (index < observations_.size()) {\n\t\tif (current_time - observations_[index].header.stamp.toSec() > observation_keep_time_) {\n\t\t\tobservations_.erase(observations_.begin() + index);\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t}\n}", "CodeBleu_score": 29.339745210585683}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (path.size() == 0) {\n\t\treturn;\n\t}\n\tif (start_index < 0 || start_index >= (int)path.size()) {\n\t\tROS_ERROR(\"Start index is out of range\");\n\t\treturn;\n\t}\n\tif (end_index < 0 || end_index >= (int)path.size()) {\n\t\tROS_ERROR(\"End index is out of range\");\n\t\treturn;\n\t}\n\tif (start_index == end_index) {\n\t\tROS_ERROR(\"Start and end indices are the same\");\n\t\treturn;\n\t}\n\n\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = get_yaw(path[start_index].pose.orientation);\n\tdouble end_yaw = get_yaw(path[end_index].pose.orientation);\n\n\t// Calculate the shortest angular distance between the start and end yaw angles\n\tdouble yaw_dist = shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose and update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble yaw = get_yaw(path[i].pose.orientation);\n\t\tdouble yaw_diff = shortest_angular_distance(yaw, start_yaw);\n\t\tif (yaw_diff > yaw_dist) {\n\t\t\tyaw_diff = yaw_dist;\n\t\t}\n\t\tset_angle(path[i].pose, yaw + yaw_diff);\n\t}\n}", "CodeBleu_score": 45.962185522320645}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (start_index == end_index) {\n\t\treturn;\n\t}\n\n\tdouble start_angle = get_angle(path[start_index].pose);\n\tdouble end_angle = get_angle(path[end_index].pose);\n\n\tdouble angle_diff = fmod(end_angle - start_angle, 2.0*M_PI);\n\tif (angle_diff < -M_PI) {\n\t\tangle_diff += 2.0*M_PI;\n\t} else if (angle_diff > M_PI) {\n\t\tangle_diff -= 2.0*M_PI;\n\t}\n\n\tdouble angle_inc = angle_diff / (end_index - start_index);\n\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble angle = start_angle + angle_inc*(i - start_index);\n\t\tset_angle(path[i].pose, angle);\n\t}\n}", "CodeBleu_score": 47.30860793998628}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\n//  std::cout << \"Interpolating from index \" << start_index << \" to \" << end_index << std::endl;\n  double start_yaw = get_yaw(path[start_index].pose.orientation);\n  double end_yaw = get_yaw(path[end_index].pose.orientation);\n  double yaw_diff = shortest_angular_distance(start_yaw, end_yaw);\n\n  //  std::cout << \"Start yaw: \" << start_yaw << \" End yaw: \" << end_yaw << \" Yaw diff: \" << yaw_diff << std::endl;\n\n  if (yaw_diff > 0) {\n    for (int i = start_index + 1; i < end_index; i++) {\n      double yaw = get_yaw(path[i].pose.orientation);\n      double yaw_change = shortest_angular_distance(yaw, yaw_diff);\n      set_angle(path[i].pose, yaw_change);\n    }\n  } else if (yaw_diff < 0) {\n    for (int i = start_index + 1; i < end_index; i++) {\n      double yaw = get_yaw(path[i].pose.orientation);\n      double yaw_change = shortest_angular_distance(yaw, yaw_diff);\n      set_angle(path[i].pose, yaw_change);\n    }\n  }\n}", "CodeBleu_score": 50.83100368741532}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a new plan request\");\n\tROS_INFO(\"Frame ID of start is %s\", req.start.header.frame_id.c_str());\n\tROS_INFO(\"Frame ID of goal is %s\", req.goal.header.frame_id.c_str());\n\n\t// Set the start and goal points\n\tstart = PointStamped();\n\tstart.header.frame_id = \"map\";\n\tstart.point.x = req.start.pose.position.x;\n\tstart.point.y = req.start.pose.position.y;\n\tstart.point.z = req.start.pose.position.z;\n\n\tgoal = PointStamped();\n\tgoal.header.frame_id = \"map\";\n\tgoal.point.x = req.goal.pose.position.x;\n\tgoal.point.y = req.goal.pose.position.y;\n\tgoal.point.z = req.goal.pose.position.z;\n\n\t// Call makePlan to generate a path\n\tmakePlan();\n\n\t// Check if a path was found\n\tif(path.poses.size() == 0) {\n\t\tROS_WARN(\"No path found\");\n\t\treturn false;\n\t}\n\n\t// Update the response\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\tresp.plan.poses = path.poses;\n\n\tROS_INFO(\"Path found with %i points\", (int)path.poses.size());\n\treturn true;\n}", "CodeBleu_score": 46.69183632095125}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a make plan request\");\n\tresp.plan_found = false;\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.poses.resize(0);\n\n\t// Set the start and goal poses\n\tgeometry_msgs::PoseStamped start_pose, goal_pose;\n\tstart_pose.header.frame_id = \"map\";\n\tstart_pose.pose = req.start;\n\tgoal_pose.header.frame_id = \"map\";\n\tgoal_pose.pose = req.goal;\n\n\t// Call makePlan to generate a path\n\tnavfn::MakeNavPlan::Response plan = makePlan(start_pose, goal_pose);\n\n\t// If a plan was found, update the response\n\tif (plan.plan_found) {\n\t\tresp.plan_found = true;\n\t\tresp.plan = plan.plan;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 48.27847419469955}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\tROS_INFO(\"Received a new plan request\");\n\tresp.plan_found = false;\n\tresp.plan.poses.clear();\n\tresp.plan.header.frame_id = \"map\";\n\tresp.plan.header.stamp = ros::Time::now();\n\n\tif (req.start.header.frame_id != \"map\" || req.goal.header.frame_id != \"map\") {\n\t\tROS_ERROR(\"Start or goal are not in the map frame\");\n\t\treturn true;\n\t}\n\n\t// Create the start and goal state\n\tEigen::Vector2d start(req.start.pose.position.x, req.start.pose.position.y);\n\tEigen::Vector2d goal(req.goal.pose.position.x, req.goal.pose.position.y);\n\n\t// Call makePlan to generate the plan\n\tnavfn::MakeNavPlan::Response plan = makePlan(start, goal);\n\n\t// Check if a plan was found\n\tif (plan.plan_found) {\n\t\tresp.plan_found = true;\n\t\tresp.plan = plan.plan;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 50.05660991019748}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\tgoal_sub = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 57.874714303611974}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t", "CodeBleu_score": 18.432682072468964}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t// Check if the world coordinates are within the bounds of the costmap's origin.\n\tif (wx < originX_ && wy < originY_) {\n\t\t// Calculate the map coordinates using the costmap's resolution and an offset.\n\t\tmx = (wx - originX_) / resolution_;\n\t\tmy = (wy - originY_) / resolution_;\n\t\t// Return true if the map coordinates are within the costmap's size limits.\n\t\treturn mx >= 0.0 && my >= 0.0 && mx < mapSize_ && my < mapSize_;\n\t}\n\telse {\n\t\t// Return false if the world coordinates are not within the bounds of the costmap's origin.\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 36.69765550068692}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_origin_x_ || wy < costmap_origin_y_) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap: world coordinates (%f, %f) are outside the costmap's origin.\", wx, wy);\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_origin_x_) / costmap_resolution_;\n\tmy = (wy - costmap_origin_y_) / costmap_resolution_;\n\tif (mx < 0.0 || my < 0.0 || mx >= costmap_.info.width || my >= costmap_.info.height) {\n\t\tROS_WARN(\"GlobalPlanner::worldToMap: map coordinates (%f, %f) are outside the costmap's size.\", mx, my);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 46.60818728966471}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tif (wx < costmap_.info.origin.position.x) {\n\t\tROS_INFO(\"GlobalPlanner::worldToMap: wx < costmap_.info.origin.position.x\");\n\t\treturn false;\n\t}\n\tif (wy < costmap_.info.origin.position.y) {\n\t\tROS_INFO(\"GlobalPlanner::worldToMap: wy < costmap_.info.origin.position.y\");\n\t\treturn false;\n\t}\n\tif (wx > costmap_.info.origin.position.x + costmap_.info.width*costmap_.info.resolution) {\n\t\tROS_INFO(\"GlobalPlanner::worldToMap: wx > costmap_.info.origin.position.x + costmap_.info.width*costmap_.info.resolution\");\n\t\treturn false;\n\t}\n\tif (wy > costmap_.info.origin.position.y + costmap_.info.height*costmap_.info.resolution) {\n\t\tROS_INFO(\"GlobalPlanner::worldToMap: wy > costmap_.info.origin.position.y + costmap_.info.height*costmap_.info.resolution\");\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_.info.origin.position.x) / costmap_.info.resolution;\n\tmy = (wy - costmap_.info.origin.position.y) / costmap_.info.resolution;\n\treturn true;\n}", "CodeBleu_score": 32.596802460035036}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"Call initialize() before using the planner\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\tfor (const auto& pose : path) {\n\t\tgui_path.poses.push_back(pose);\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 49.21383961886324}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tROS_INFO_STREAM(\"Publishing plan\");\n\tif (!initialized_) {\n\t\tROS_ERROR(\"Global planner has not been initialized, cannot publish plan\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path nav_path;\n\tnav_path.header.frame_id = frame_id_;\n\tnav_path.header.stamp = ros::Time::now();\n\n\tfor (const auto& pose : path) {\n\t\tnav_path.poses.push_back(pose);\n\t}\n\n\tplan_pub_.publish(nav_path);\n}", "CodeBleu_score": 46.65152562122046}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tROS_INFO(\"Publishing plan\");\n\tif (!initialized_) {\n\t\tROS_ERROR(\"Global planner has not been initialized, cannot publish plan\");\n\t\treturn;\n\t}\n\tnav_msgs::Path gui_path;\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\tfor (const auto& pose : path) {\n\t\tgui_path.poses.push_back(pose);\n\t}\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 51.107894730249036}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_DEBUG_STREAM(\"Received goal\");\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 64.16394070222073}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"MoveBase goal callback has received a new goal\");\n\n\t// Create an action goal to publish\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\n\t// Set the timestamp of the action goal to the current time\n\taction_goal.header.stamp = ros::Time::now();\n\n\t// Set the goal pose to the pose in the goal message\n\taction_goal.goal.target_pose = *goal;\n\n\t// Publish the action goal\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 69.07513658229895}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Goal received\");\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 63.38152580872156}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_distance = getSqDistance();\n\n\tif (sq_distance > sq_distance_threshold_) {\n\t\tROS_INFO(\"Distance check passed. Moving forward at %.2f m/s.\", speed_);\n\t\tspeed_limit_thread_.join();\n\t\tspeed_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\t\tdistance_timer_.stop();\n\t}\n}", "CodeBleu_score": 43.21891795408168}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\n//  std::cout << \"Entered distance check\" << std::endl;\n\n  double sq_distance = getSqDistance();\n\n  if (sq_distance > sq_distance_threshold_) {\n\n//    std::cout << \"Distance check passed\" << std::endl;\n\n    if (remove_limit_thread_.joinable()) {\n      remove_limit_thread_.join();\n    }\n\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeLimit, this);\n\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 50.71300986335504}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble sq_distance = getSqDistance();\n\tif (sq_distance > SLOW_AND_CLEAR_DISTANCE_SQ) {\n\t\tROS_INFO(\"Robot has moved a distance of %f\", sqrt(sq_distance));\n\t\tif (remove_limit_thread_.joinable()) {\n\t\t\tremove_limit_thread_.join();\n\t\t}\n\t\tremove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\t}\n}", "CodeBleu_score": 48.77520712483996}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a goal\");\n\t// Get the current robot pose\n\tgeometry_msgs::PoseStamped robot_pose = getRobotPose();\n\t// Generate a path from the current robot pose to the goal pose\n\tmakePlan(robot_pose, goal->pose, path);\n}", "CodeBleu_score": 38.59395847401419}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\t// Get the current robot pose from the robot's tf transform.\n\tgeometry_msgs::PoseStamped robot_pose = getRobotPose();\n\n\t// Make a plan from the current robot pose to the goal pose.\n\tmakePlan(robot_pose, goal->pose, path);\n}", "CodeBleu_score": 37.2784362952062}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Received a new goal\");\n\tgeometry_msgs::PoseStamped robotPose;\n\trobotPose = getRobotPose();\n\tROS_INFO(\"Received robot pose\");\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tplan = makePlan(robotPose, goal->pose, plan);\n\tROS_INFO(\"Received plan\");\n\tif(plan.size() == 0) {\n\t\tROS_WARN(\"No path found\");\n\t\treturn;\n\t}\n\tROS_INFO(\"Sending plan\");\n\tsendPlan(plan);\n\tROS_INFO(\"Sent plan\");\n}", "CodeBleu_score": 43.66572745071911}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tROS_INFO(\"Setting Gimbal Parameters\");\n\tmavros_msgs::ParamSetRequest request;\n\trequest.param_id = param_set.param_id;\n\trequest.value = param_set.value;\n\trequest.param_type = param_set.param_type;\n\tparam_set_client_.call(request);\n}", "CodeBleu_score": 49.93060527008753}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tROS_INFO(\"Setting gimbal parameters...\");\n\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\tparam_set_client_.call(srv);\n}", "CodeBleu_score": 67.51792095334676}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\t// Create service request\n\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.value;\n\tsrv.request.param_type = param_set.param_type;\n\n\t// Send request\n\tif (param_set_client_.call(srv)) {\n\t\tROS_INFO(\"Gimbal param set successful\");\n\t}\n\telse {\n\t\tROS_ERROR(\"Gimbal param set failed\");\n\t}\n}", "CodeBleu_score": 63.88970777793538}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif(simulation_mode_) {\n\t\t// Find the UAV with the corresponding ID\n\t\tfor(auto it = swarm_control_simulation_.begin(); it != swarm_control_simulation_.end(); it++) {\n\t\t\tif(it->uav_id_ == uav_cmd.uav_id_) {\n\t\t\t\tit->uav_cmd_ = uav_cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Publish the command to a single UAV\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 36.83662442760429}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (sim_mode_ == false) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].id_ == uav_cmd.id) {\n\t\t\t\tswarm_control_simulation_[i].uav_cmd_pub_.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.64390912676511}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t", "CodeBleu_score": 2.601564811867212}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.mode) {\n\t\tcase ModeSelection::Mode::EXITNX: {\n\t\t\t// Exiting nx\n\t\t\tprintf(\"Exiting nx\n\");\n\t\t\tsvcExitProcess();\n\t\t\tbreak;\n\t\t}\n\t\tcase ModeSelection::Mode::REBOOTNX: {\n\t\t\t// Rebooting nx\n\t\t\tprintf(\"Rebooting nx\n\");\n\t\t\tsvcReboot(0);\n\t\t\tbreak;\n\t\t}\n\t\tcase ModeSelection::Mode::CREATE_MODE: {\n\t\t\t// Creating a new mode\n\t\t\tprintf(\"Creating a new mode\n\");\n\t\t\tcreateMode(mode_selection.mode_name);\n\t\t\tbreak;\n\t\t}\n\t\tcase ModeSelection::Mode::DELETE_MODE: {\n\t\t\t// Deleting a mode\n\t\t\tprintf(\"Deleting a mode\n\");\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 36.56954915891142}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tswitch (mode_selection.use_mode) {\n\tcase REBOOTNX:\n\t\tsystem(\"reboot -f\");\n\t\tbreak;\n\tcase EXITNX:\n\t\tsystem(\"reboot\");\n\t\tbreak;\n\tcase CREATE_MODE:\n\t\tcreateMode(mode_selection.mode_name);\n\t\tbreak;\n\tcase DELETE_MODE:\n\t\tdeleteMode(mode_selection.mode_name);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "CodeBleu_score": 30.27823330015307}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\t// If the mode is REBOOTNX, we want to reboot the system.\n\tif (mode_selection.use_mode == REBOOTNX) {\n\t\t// We want to reboot the system.\n\t\tsystem(\"reboot\");\n\t}\n\t// If the mode is EXITNX, we want to exit the system.\n\telse if (mode_selection.use_mode == EXITNX) {\n\t\t// We want to exit the system.\n\t\tsystem(\"poweroff\");\n\t}\n\t// If the mode is CREATE, we want to create a new mode.\n\telse if (mode_selection.use_mode == CREATE) {\n\t\t// We want to create a new mode.\n\t\tcreateMode(mode_selection.mode_name, mode_selection.mode_description);\n\t}\n\t// If the mode is DELETE, we want to delete a mode.\n\telse if (mode_selection.use_mode == DELETE) {\n\t\t// We want to delete a mode.\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}", "CodeBleu_score": 50.24077695457394}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (this->heartbeat_count > 0) {\n\t\tthis->heartbeat_count--;\n\t}\n\n\tif (this->heartbeat_count == 0) {\n\t\tROS_ERROR_STREAM(\"Lost heartbeat from vehicle.\");\n\t\tthis->disconnect_flag = true;\n\t}\n}", "CodeBleu_score": 6.291011748642242}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (this->heartbeat_count == 0) {\n\t\tthis->heartbeat_count = 1;\n\t} else {\n\t\tthis->heartbeat_count = 0;\n\t}\n\tif (this->heartbeat_count == this->heartbeat_threshold) {\n\t\tROS_ERROR(\"No heartbeat received in %d heartbeats.\", this->heartbeat_threshold);\n\t\tif (this->vehicle_type == \"UGV\") {\n\t\t\tthis->disconnect_flag = true;\n\t\t} else if (this->vehicle_type == \"UAV\") {\n\t\t\tthis->disconnect_flag = true;\n\t\t} else if (this->vehicle_type == \"SWARM\") {\n\t\t\tthis->disconnect_flag = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 10.971304128042528}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count_ == 0) {\n\t\theartbeat_count_ = 1;\n\t} else {\n\t\theartbeat_count_++;\n\t}\n\n\tif (heartbeat_count_ > 10) {\n\t\tif (is_swarm_) {\n\t\t\tROS_ERROR(\"Swarm lost connection to the ground station.\");\n\t\t} else if (is_uav_) {\n\t\t\tROS_ERROR(\"UAV lost connection to the ground station.\");\n\t\t} else if (is_ugv_) {\n\t\t\tROS_ERROR(\"UGV lost connection to the ground station.\");\n\t\t}\n\n\t\tdisconnect_flag_ = true;\n\t\theartbeat_count_ = 0;\n\t}\n}", "CodeBleu_score": 25.17913273257742}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// ROS_INFO(\"Received a new MultiBsplines message\");\n\n\t// Extract drone ID\n\tint drone_id = msg->id;\n\n\t// Extract trajectory data\n\tstd::vector<float> knots;\n\tstd::vector<std::vector<float>> pos_points;\n\tstd::vector<std::vector<float>> yaw_points;\n\tfor (int i = 0; i < msg->num_bsplines; i++) {\n\t\tknots.push_back(msg->bsplines[i].knots);\n\t\tpos_points.push_back(msg->bsplines[i].pos_points);\n\t\tyaw_points.push_back(msg->bsplines[i].yaw_points);\n\t}\n\n\t// Initialize Bspline struct\n\tBspline bspline;\n\tbspline.knots = knots;\n\tbspline.pos_points = pos_points;\n\tbspline.yaw_points = yaw_points;\n\n\t// Populate Bspline struct\n\tbspline.init();\n\n\t// Encode Bspline struct\n\tprometheus_msgs::Bspline bspline_msg;\n\tbspline.encode(bspline_msg);\n\n\t// Send encoded Bspline data via TCP\n\tif (drone_id == 0) {\n\t\ttcp_com.send_data(bspline_msg);\n\t}\n}", "CodeBleu_score": 32.34155150107316}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract the drone ID from the header\n\tint drone_id = msg->header.frame_id;\n\n\t// Iterate through each trajectory in the message\n\tfor (int i = 0; i < msg->num_bsplines; i++) {\n\t\t// Extract the trajectory data\n\t\tprometheus_msgs::Bspline bspline = msg->bsplines[i];\n\t\tint num_knots = bspline.num_knots;\n\t\tfloat dt = bspline.dt;\n\t\tint num_points = bspline.num_points;\n\t\tfloat time_from_start = bspline.time_from_start;\n\n\t\t// Initialize a Bspline struct\n\t\tBspline traj;\n\n\t\t// Set the Bspline attributes\n\t\ttraj.drone_id = drone_id;\n\t\ttraj.num_knots = num_knots;\n\t\ttraj.dt = dt;\n\t\ttraj.num_points = num_points;\n\t\ttraj.time_from_start = time_from_start;\n\n\t\t// Populate the knots\n\t\tfor (int j = 0; j < num_knots; j++) {\n\t\t\ttraj.knots[j] = bspline.knots[j];\n\t\t}\n\n\t\t// Populate the position points\n\t\tfor (int j = 0; j < num_points; j++) {\n\t\t\ttraj.position_points[j].x = bspline.position_points[j].x;\n\t\t\ttraj.position_points[j].y = bspline.position_points[j].y;\n\t\t\ttraj.position_points[j].z = bspline.position_points[j].z;\n\t\t}\n\n\t\t// Populate the yaw points\n\t\tfor (int j = 0; j < num_points; j++) {\n\t\t\ttraj.yaw_points[j] = bspline.yaw_points[j];\n\t\t}\n\n\t\t// Encode the Bspline data and send it via TCP\n\t\tencodeAndSendBspline(traj);\n\t}\n}", "CodeBleu_score": 42.69431360123001}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t\t// Extract the drone ID from the message\n\tint drone_id = msg->id;\n\t// Extract the trajectory data from the message\n\tvector<double> knots = msg->knots;\n\tvector<vector<double>> pos_points = msg->pos_points;\n\tvector<vector<double>> yaw_points = msg->yaw_points;\n\t// Initialize a Bspline struct for each trajectory\n\tBspline bspline;\n\t// Set the Bspline attributes\n\tbspline.knots = knots;\n\tbspline.pos_points = pos_points;\n\tbspline.yaw_points = yaw_points;\n\t// Encode the Bspline data\n\tstring bspline_data = bspline.encode();\n\t// Send the Bspline data via TCP\n\ttcp_com.sendData(drone_id, bspline_data);\n}", "CodeBleu_score": 16.6830021214233}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\n\t//std::cout << \"Before compression: \" << cloud.size() << std::endl;\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n\toctree_compression.compress(*cloud_ptr, *cloud_compressed);\n\t//std::cout << \"After compression: \" << cloud_compressed->size() << std::endl;\n\n\tsensor_msgs::PointCloud2 cloud_compressed_msg;\n\tpcl::toROSMsg(*cloud_compressed, cloud_compressed_msg);\n\tcloud_compressed_msg.header = msg.header;\n\treturn cloud_compressed_msg;\n}", "CodeBleu_score": 32.773715014894854}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t", "CodeBleu_score": 3.9798700205616275}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.82348116351547}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.21600270455358}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 54.82348116351547}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.ugv_id = m_multi_ugv_state.ugv_states[i].ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_states[i].battery;\n\t\tugv_state.position = m_multi_ugv_state.ugv_states[i].position;\n\t\tugv_state.velocity = m_multi_ugv_state.ugv_states[i].velocity;\n\t\tugv_state.attitude = m_multi_ugv_state.ugv_states[i].attitude;\n\t\tmulti_ugv_state.ugv_states.push_back(ugv_state);\n\t}\n\n\tmulti_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 36.08767055679056}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n// 1. Calculate the position of each moving object at each time step.\n// 2. For each time step, calculate the distance between the B-spline control point and the moving object.\n// 3. If the distance is less than the clearance, update the cost and gradient.\n\n// TODO: Implement this function.\n\n}", "CodeBleu_score": 3.845811572351676}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tdouble a2 = 1.0 / (2.0 * pow(a, 2));\n\tdouble b2 = 1.0 / (2.0 * pow(b, 2));\n\tdouble a2b2 = a2 * b2;\n\n\tcost = 0.0;\n\tgradient.setZero(q.rows(), q.cols());\n\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tdouble x = q(i, 0);\n\t\tdouble y = q(i, 1);\n\t\tdouble z = q(i, 2);\n\n\t\tdouble dx = x - ref_points(i, 0);\n\t\tdouble dy = y - ref_points(i, 1);\n\t\tdouble dz = z - ref_points(i, 2);\n\n\t\tcost += dx * dx * a2 + dy * dy * b2 + dz * dz * a2b2;\n\n\t\tgradient(i, 0) = 2.0 * a2 * dx;\n\t\tgradient(i, 1) = 2.0 * b2 * dy;\n\t\tgradient(i, 2) = 2.0 * a2b2 * dz;\n\t}\n}", "CodeBleu_score": 32.84304119195719}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\n}", "CodeBleu_score": 2.779918881159022}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getJerkControlPoints();\n\tUniformBspline jerk(ctp, p_ - 1, interval_);\n\n\t/* cut the first and last knot */\n\tEigen::VectorXd knot(u_.rows() - 2);\n\tknot = u_.segment(1, u_.rows() - 2);\n\tjerk.setKnot(knot);\n\n\tdouble jerk_value = 0.0;\n\n\t/* iterate through the control points */\n\tfor (int i = 0; i < ctp.rows(); i++) {\n\t\t/* iterate through the dimensions */\n\t\tfor (int j = 0; j < ctp.cols(); j++) {\n\t\t\tdouble temp = 0.0;\n\t\t\t/* iterate through the knot differences */\n\t\t\tfor (int k = 0; k < knot.rows(); k++) {\n\t\t\t\ttemp += pow(ctp(i, j) * (u_(k + 1) - u_(k)), 3);\n\t\t\t}\n\t\t\tjerk_value += temp;\n\t\t}\n\t}\n\n\treturn jerk_value;\n}", "CodeBleu_score": 55.83893094736141}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getJerkControlPoints();\n\tUniformBspline jerk(ctp, p_ - 1, interval_);\n\n\t/* cut the first and last knot */\n\tEigen::VectorXd knot(u_.rows() - 2);\n\tknot = u_.segment(1, u_.rows() - 2);\n\tjerk.setKnot(knot);\n\n\tdouble jerk_total = 0.0;\n\n\tfor (int i = 0; i < ctp.rows(); i++) {\n\t\tfor (int j = 0; j < ctp.cols(); j++) {\n\t\t\tjerk_total += pow(ctp(i, j), 2) * (u_(i + 1) - u_(i));\n\t\t}\n\t}\n\n\treturn jerk_total;\n}", "CodeBleu_score": 53.9301736171147}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getJerkControlPoints();\n\tUniformBspline jerk(ctp, p_ - 1, interval_);\n\n\t/* cut the first and last knot */\n\tEigen::VectorXd knot(u_.rows() - 2);\n\tknot = u_.segment(1, u_.rows() - 2);\n\tjerk.setKnot(knot);\n\n\tdouble jerk_value = 0;\n\tfor (int i = 0; i < ctp.rows(); i++) {\n\t\tfor (int j = 0; j < ctp.cols(); j++) {\n\t\t\tjerk_value += ctp(i, j) * (u_(i + 1) - u_(i));\n\t\t}\n\t}\n\treturn jerk_value;\n}", "CodeBleu_score": 52.738736929972106}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\treturn pos;\n}", "CodeBleu_score": 60.79764647195039}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\treturn Eigen::Vector4d((u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1);\n}", "CodeBleu_score": 37.86632513737512}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 62.01375361783612}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstring drone_id = odom.child_frame_id.substr(0, odom.child_frame_id.find(\"_\"));\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (exception& e) {\n\t\tcout << \"Exception caught in rcvDroneXOdomCallback: \" << e.what() << endl;\n\t}\n}", "CodeBleu_score": 49.436518612869385}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string drone_id = odom.child_frame_id;\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: caught exception: %s\", e.what());\n\t}\n}", "CodeBleu_score": 49.0314490324116}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string droneID = odom.child_frame_id;\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t}\n\tcatch (std::exception const& e) {\n\t\tROS_ERROR(\"Exception in rcvDroneXOdomCallback(): %s\", e.what());\n\t}\n}", "CodeBleu_score": 45.90258297489428}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Check if the drone is in the list of detected drones\n\tif (drones_.count(drone_id) > 0) {\n\t\t// Get the pose of the drone\n\t\tgeometry_msgs::PoseStamped drone_pose = drones_[drone_id].getPose();\n\n\t\t// Get the camera pose\n\t\tgeometry_msgs::PoseStamped camera_pose = camera_.getPose();\n\n\t\t// Get the camera intrinsics\n\t\tcv::Mat camera_matrix = camera_.getIntrinsics();\n\n\t\t// Get the camera distortion coefficients\n\t\tcv::Mat dist_coeffs = camera_.getDistortionCoefficients();\n\n\t\t// Get the camera frame\n\t\tstd::string camera_frame = camera_.getFrame();\n\n\t\t// Get the camera resolution\n\t\tcv::Size camera_resolution = camera_.getResolution();\n\n\t\t// Convert the true pixel to a 3D point in the camera frame\n\t\tcv::Point3d true_point = cv::Point3d(true_pixel.x, true_pixel.y, 1);\n\n\t\t// Convert the true pixel to a 3D point in the world frame\n\t\tcv::Point3d true_world_point = camera_.pixelToWorld(true_point, camera_matrix, dist_coeffs, camera_frame);\n\n\t\t// Compute the true pose of the drone in the world frame\n\t\tgeometry_msgs::PoseStamped true_world_pose = camera_.pixelToWorldPose(true_pixel, camera_matrix, dist_coeffs, camera_frame);\n\n\t\t// Compute the pose error between the true pose and the drone pose\n\t\tgeometry_msgs::PoseStamped pose_error = camera_.computePoseError(true_world_pose, drone_pose);\n\n\t\t// Update the debug result\n\t\tupdateDebugResult(drone_id, true_world_point, true_world_pose, pose_error);\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_.publish(pose_error);\n\t}\n\telse {\n\t\t// Update the debug result\n\t\tupdateDebugResult(drone_id, true_pixel);\n\t}\n}", "CodeBleu_score": 34.20921930369148}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current != start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 70.23339106455427}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tcurrent = current->getParent();\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 71.23334368688437}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\twhile (current != start) {\n\t\tpath.push_back(current);\n\t\tcurrent = cameFrom[current];\n\t}\n\tpath.push_back(start);\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 57.657813244377245}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to grid indices\n\tif (!ConvertPointToIndex(start_pt, start_idx)) {\n\t\tROS_ERROR(\"Start point (%f, %f, %f) is outside the grid.\", start_pt.x, start_pt.y, start_pt.z);\n\t\treturn false;\n\t}\n\tif (!ConvertPointToIndex(end_pt, end_idx)) {\n\t\tROS_ERROR(\"End point (%f, %f, %f) is outside the grid.\", end_pt.x, end_pt.y, end_pt.z);\n\t\treturn false;\n\t}\n\n\t// Adjust start and end points if they are inside obstacles\n\tif (IsPointInObstacle(start_pt)) {\n\t\tROS_INFO(\"Start point (%f, %f, %f) is inside an obstacle. Adjusting start point...\", start_pt.x, start_pt.y, start_pt.z);\n\t\tif (!AdjustPointToAvoidObstacle(start_pt, start_idx)) {\n\t\t\tROS_ERROR(\"Failed to adjust start point (%f, %f, %f) to avoid obstacles.\", start_pt.x, start_pt.y, start_pt.z);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsPointInObstacle(end_pt)) {\n\t\tROS_INFO(\"End point (%f, %f, %f) is inside an obstacle. Adjusting end point...\", end_pt.x, end_pt.y, end_pt.z);\n\t\tif (!AdjustPointToAvoidObstacle(end_pt, end_idx)) {\n\t\t\tROS_ERROR(\"Failed to adjust end point (%f, %f, %f) to avoid obstacles.\", end_pt.x, end_pt.y, end_pt.z);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 40.186053418302336}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start point to grid indices\n\tbool start_success = ConvertToIndex(start_pt, start_idx);\n\tif(!start_success) {\n\t\tROS_ERROR(\"Start point %f %f %f is outside the grid.\", start_pt.x, start_pt.y, start_pt.z);\n\t\treturn false;\n\t}\n\n\t// Convert end point to grid indices\n\tbool end_success = ConvertToIndex(end_pt, end_idx);\n\tif(!end_success) {\n\t\tROS_ERROR(\"End point %f %f %f is outside the grid.\", end_pt.x, end_pt.y, end_pt.z);\n\t\treturn false;\n\t}\n\n\t// Adjust start point if it is inside an obstacle\n\tif(IsObstacle(start_idx)) {\n\t\tROS_INFO(\"Start point %f %f %f is inside an obstacle.\", start_pt.x, start_pt.y, start_pt.z);\n\t\tbool start_adjust_success = AdjustPoint(start_pt, end_pt, start_idx);\n\t\tif(!start_adjust_success) {\n\t\t\tROS_ERROR(\"Could not adjust start point %f %f %f to be outside the obstacle.\", start_pt.x, start_pt.y, start_pt.z);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Adjust end point if it is inside an obstacle\n\tif(IsObstacle(end_idx)) {\n\t\tROS_INFO(\"End point %f %f %f is inside an obstacle.\", end_pt.x, end_pt.y, end_pt.z);\n\t\tbool end_adjust_success = AdjustPoint(end_pt, start_pt, end_idx);\n\t\tif(!end_adjust_success) {\n\t\t\tROS_ERROR(\"Could not adjust end point %f %f %f to be outside the obstacle.\", end_pt.x, end_pt.y, end_pt.z);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 38.61248125093732}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t", "CodeBleu_score": 2.802449016888383}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tEigen::Vector3d min_pos_grid, max_pos_grid;\n\n\tmin_pos_grid = min_pos;\n\tmax_pos_grid = max_pos;\n\n\tif (min_pos_grid[0] < 0) min_pos_grid[0] = 0;\n\tif (min_pos_grid[1] < 0) min_pos_grid[1] = 0;\n\tif (min_pos_grid[2] < 0) min_pos_grid[2] = 0;\n\n\tif (max_pos_grid[0] > grid_length_) max_pos_grid[0] = grid_length_;\n\tif (max_pos_grid[1] > grid_width_) max_pos_grid[1] = grid_width_;\n\tif (max_pos_grid[2] > grid_height_) max_pos_grid[2] = grid_height_;\n\n\tmin_id = gridPosToIndex(min_pos_grid);\n\tmax_id = gridPosToIndex(max_pos_grid);\n\n\tfor (int i = min_id[0]; i <= max_id[0]; i++) {\n\t\tfor (int j = min_id[1]; j <= max_id[1]; j++) {\n\t\t\tfor (int k = min_id[2]; k <= max_id[2]; k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t\tdistance_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 35.555578549493084}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = positionToIndex(min_pos);\n\tEigen::Vector3i max_id = positionToIndex(max_pos);\n\tfor (int x = min_id[0]; x <= max_id[0]; x++) {\n\t\tfor (int y = min_id[1]; y <= max_id[1]; y++) {\n\t\t\tfor (int z = min_id[2]; z <= max_id[2]; z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0.0;\n\t\t\t\tdistance_buffer_inflate_(x, y, z) = 0.0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.14514686062667}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id, max_id;\n\tthis->getGridCoordinates(min_pos, min_id);\n\tthis->getGridCoordinates(max_pos, max_id);\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\tthis->occupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t\tthis->distance_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.24193429983799}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_t = std::max(std::abs(diff[0]), std::max(std::abs(diff[1]), std::abs(diff[2])));\n\tdouble min_t = std::min(std::abs(diff[0]), std::min(std::abs(diff[1]), std::abs(diff[2])));\n\tEigen::Vector3d t_vec = diff / max_t;\n\tEigen::Vector3d new_pt = camera_pt + t_vec * min_t;\n\treturn new_pt;\n}", "CodeBleu_score": 31.94073821628819}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = camera_pt - pt;\n\tEigen::Vector3d min_trans = Eigen::Vector3d::Zero();\n\tEigen::Vector3d max_trans = Eigen::Vector3d::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff[i] < 0) {\n\t\t\tmin_trans[i] = -diff[i];\n\t\t\tmax_trans[i] = 0;\n\t\t} else {\n\t\t\tmin_trans[i] = 0;\n\t\t\tmax_trans[i] = diff[i] - map_size_[i];\n\t\t}\n\t}\n\n\tdouble min_trans_mag = min_trans.norm();\n\tdouble max_trans_mag = max_trans.norm();\n\tdouble trans_mag = min_trans_mag;\n\tEigen::Vector3d trans = min_trans;\n\tEigen::Vector3d closest_pt = pt;\n\twhile (trans_mag < max_trans_mag) {\n\t\tclosest_pt = pt + trans;\n\t\tif (isPointInMap(closest_pt)) {\n\t\t\treturn closest_pt;\n\t\t}\n\t\ttrans_mag += trans_step_;\n\t\ttrans = trans_mag * min_trans.normalized();\n\t}\n\treturn closest_pt;\n}", "CodeBleu_score": 45.47379741671717}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d min_t = Eigen::Vector3d::Zero();\n\tEigen::Vector3d max_t = Eigen::Vector3d::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tmin_t[i] = -diff[i] / resolution_;\n\t\tmax_t[i] = (map_size_[i] - diff[i]) / resolution_;\n\t}\n\tEigen::Vector3d t = min_t;\n\tdouble min_dist = (pt - camera_pt).norm();\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tEigen::Vector3d tmp_t = t;\n\t\t\ttmp_t[i] += j * (max_t[i] - min_t[i]);\n\t\t\tEigen::Vector3d tmp_pt = camera_pt + tmp_t * resolution_;\n\t\t\tdouble dist = (tmp_pt - pt).norm();\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t\tt = tmp_t;\n\t\t\t}\n\t\t}\n\t}\n\treturn camera_pt + t * resolution_;\n}", "CodeBleu_score": 51.049206535431345}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time.\n\tlastOccupancyUpdateTime = ros::Time::now();\n\n\t// Check if an update is needed.\n\tif (!updateNeeded()) {\n\t\treturn;\n\t}\n\n\t// Get the latest depth image.\n\tsensor_msgs::ImageConstPtr depthImage = getDepthImage();\n\tif (depthImage == NULL) {\n\t\treturn;\n\t}\n\n\t// Get the latest odometry.\n\tnav_msgs::OdometryConstPtr odometry = getOdometry();\n\tif (odometry == NULL) {\n\t\treturn;\n\t}\n\n\t// Get the latest transform.\n\ttf::StampedTransform transform;\n\ttry {\n\t\ttfListener.waitForTransform(odometry->header.frame_id, depthImage->header.frame_id, depthImage->header.stamp, ros::Duration(1.0));\n\t\ttfListener.lookupTransform(odometry->header.frame_id, depthImage->header.frame_id, depthImage->header.stamp, transform);\n\t} catch (tf::TransformException &e) {\n\t\tROS_ERROR(\"Failed to lookup transform from %s to %s: %s\", odometry->header.frame_id.c_str(), depthImage->header.frame_id.c_str(), e.what());\n\t\treturn;\n\t}\n\n\t// Project the depth image into points.\n\tsensor_msgs::PointCloud2ConstPtr pointCloud = projectDepthImageToPointCloud(depthImage, transform);\n\tif (pointCloud == NULL) {\n\t\treturn;\n\t}\n\n\t// Process the points with raycasting.\n\tif (!processPointCloud(pointCloud)) {\n\t\treturn;\n\t}\n\n\t// Update the local map.\n\tupdateLocalMap();\n\n\t// Update the global map.\n\tupdateGlobalMap();\n\n\t// Update the map server.\n\tupdateMapServer();\n\n\t// Publish the global map.\n\tpublishGlobalMap();\n}", "CodeBleu_score": 43.372834633549594}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tif (this->lastOccupancyUpdateTime == 0) {\n\t\tthis->lastOccupancyUpdateTime = ros::Time::now();\n\t}\n\n\tif (this->lastOccupancyUpdateTime + this->occupancyUpdateInterval < ros::Time::now()) {\n\t\tthis->lastOccupancyUpdateTime = ros::Time::now();\n\t\tthis->updateOccupancy();\n\t}\n}", "CodeBleu_score": 15.824506168272418}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\t// Read ground truth and detected ellipses for each image\n    vector<vector<Ellipse>> gt_ellipses(image_fns.size());\n    vector<vector<Ellipse>> dt_ellipses(image_fns.size());\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        _load_ellipse_GT(gt_fns[i], gt_ellipses[i], gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses[i], gt_angle_radians);\n    }\n\n    // Evaluate each image\n    float f_sum = 0.f;\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        f_sum += _ellipse_evaluate_one(gt_ellipses[i], dt_ellipses[i], imread(image_fns[i]));\n    }\n\n    return f_sum / float(image_fns.size());\n}", "CodeBleu_score": 52.268012475643985}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tunsigned n_images = image_fns.size();\n\n\tfloat total_fmeasure = 0.f;\n\n\tfor (unsigned i = 0; i < n_images; ++i) {\n\t\tMat3b img = imread(image_fns[i]);\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tfloat fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\n\t\ttotal_fmeasure += fmeasure;\n\t}\n\n\treturn total_fmeasure / float(n_images);\n}", "CodeBleu_score": 54.95929543881582}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t\tvector<Ellipse> gt_ellipses;\n\tvector<Ellipse> dt_ellipses;\n\tfloat fmeasure = 0.f;\n\tunsigned n = unsigned(image_fns.size());\n\tfor (unsigned i = 0; i < n; ++i) {\n\t\tcout << \"Evaluating image: \" << image_fns[i] << endl;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\t\tfmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, imread(image_fns[i]));\n\t}\n\treturn fmeasure / float(n);\n}", "CodeBleu_score": 54.51557244440309}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_diff_signed = 0.0;\n\tif (foci != NULL) {\n\t\tangle_diff_signed = atan2(foci[1] - y, foci[0] - x);\n\t}\n\treturn angle_diff_signed;\n}", "CodeBleu_score": 18.22613951451954}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_diff_signed;\n\tif (foci) {\n\t\tangle_diff_signed = angle_diff_signed(atan2(y - foci[1], x - foci[0]), atan2(foci[3] - y, foci[2] - x));\n\t} else {\n\t\tangle_diff_signed = 0.0f;\n\t}\n\treturn angle_diff_signed;\n}", "CodeBleu_score": 29.639481627189646}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a, b;\n\tif (foci != NULL) {\n\t\ta = atan2(y - foci[1], x - foci[0]);\n\t\tb = atan2(y - foci[3], x - foci[2]);\n\t} else {\n\t\ta = atan2(y, x);\n\t\tb = atan2(y, x);\n\t}\n\treturn angle_diff_signed(a, b);\n}", "CodeBleu_score": 41.50732382081824}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble minx = 1e300, maxx = -1e300, miny = 1e300, maxy = -1e300;\n\tfor (int i = start; i < end; i++) {\n\t\tminx = min(minx, vp1[i].x);\n\t\tmaxx = max(maxx, vp1[i].x);\n\t\tminy = min(miny, vp1[i].y);\n\t\tmaxy = max(maxy, vp1[i].y);\n\t}\n\tdouble area = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tarea += vp1[i].x * vp1[(i + 1) % end].y - vp1[(i + 1) % end].x * vp1[i].y;\n\t}\n\treturn area < 0;\n}", "CodeBleu_score": 33.459472770732845}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\t// Find the minimum and maximum x and y coordinates of the points in the section.\n\tdouble x_min = vp1[start].x;\n\tdouble x_max = vp1[start].x;\n\tdouble y_min = vp1[start].y;\n\tdouble y_max = vp1[start].y;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tif (vp1[i].x < x_min) {\n\t\t\tx_min = vp1[i].x;\n\t\t}\n\t\telse if (vp1[i].x > x_max) {\n\t\t\tx_max = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < y_min) {\n\t\t\ty_min = vp1[i].y;\n\t\t}\n\t\telse if (vp1[i].y > y_max) {\n\t\t\ty_max = vp1[i].y;\n\t\t}\n\t}\n\n\t// Compute the integral above and below the polygon section.\n\tdouble integral_above = 0.0;\n\tdouble integral_below = 0.0;\n\tfor (int i = start + 1; i < end; i++) {\n\t\tintegral_above += (vp1[i].x + vp1[i - 1].x) * (vp1[i].y - vp1[i - 1].y);\n\t\tintegral_below += (vp1[i].x - vp1[i - 1].x) * (vp1[i].y + vp1[i - 1].y);\n\t}\n\n\t// If the integral above is less than the integral below, the section is concave.\n\tif (integral_above < integral_below) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 34.59942766761927}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint minx = vp1[start].x, maxx = vp1[start].x, miny = vp1[start].y, maxy = vp1[start].y;\n\tfor (int i = start; i < end; i++) {\n\t\tminx = minx < vp1[i].x ? minx : vp1[i].x;\n\t\tmaxx = maxx > vp1[i].x ? maxx : vp1[i].x;\n\t\tminy = miny < vp1[i].y ? miny : vp1[i].y;\n\t\tmaxy = maxy > vp1[i].y ? maxy : vp1[i].y;\n\t}\n\tint area = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tarea += vp1[i].x * vp1[(i + 1) % end].y - vp1[i].y * vp1[(i + 1) % end].x;\n\t}\n\treturn area > 0;\n}", "CodeBleu_score": 32.768207015982334}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\t// TODO: Implement\n\tprometheus_msgs::DetectionInfo::ConstPtr temp_det;\n\tfor (int i = 0; i < msg->detection_infos.size(); i++) {\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost >= VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain >= VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\ttemp_det = msg->detection_infos[i];\n\t\ttemp_det->pose.position.x = msg->detection_infos[i]->pose.position.y;\n\t\ttemp_det->pose.position.y = msg->detection_infos[i]->pose.position.x;\n\t\ttemp_det->pose.position.z = msg->detection_infos[i]->pose.position.z;\n\t\ttemp_det->pose.orientation.x = msg->detection_infos[i]->pose.orientation.y;\n\t\ttemp_det->pose.orientation.y = msg->detection_infos[i]->pose.orientation.x;\n\t\ttemp_det->pose.orientation.z = msg->detection_infos[i]->pose.orientation.z;\n\t\ttemp_det->pose.orientation.w = msg->detection_infos[i]->pose.orientation.w;\n\t\tellipse_det = *temp_det;\n\t}\n}", "CodeBleu_score": 56.24778072546193}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tfor (int i = 0; i < msg->objects.size(); i++) {\n\t\tif (msg->objects[i].name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_lost++;\n\t\t\tnum_regain = 0;\n\t\t}\n\t\tif (num_lost >= VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain >= VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (is_detected) {\n\t\t\tellipse_det.sight_angle = msg->objects[i].angle;\n\t\t} else {\n\t\t\tellipse_det.sight_angle = 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 53.881658149047595}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.75179869043034}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// Check the safety of the current position\n\tif (Occupy_map_ptr->is_occupied(cur_pos, safe_distance)) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 38.10398685044012}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tEigen::Vector3d map_pos = cur_pos;\n\tmap_pos[0] = map_pos[0] / resolution_;\n\tmap_pos[1] = map_pos[1] / resolution_;\n\tmap_pos[2] = map_pos[2] / resolution_;\n\tif (map_pos[0] < 0 || map_pos[0] > Occupy_map_ptr->map_width || map_pos[1] < 0 || map_pos[1] > Occupy_map_ptr->map_height || map_pos[2] < 0 || map_pos[2] > Occupy_map_ptr->map_length) {\n\t\treturn false;\n\t}\n\tif (Occupy_map_ptr->get_map_value(map_pos[0], map_pos[1], map_pos[2]) <= safe_distance) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 40.21143519598267}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Create a vector of nodes to hold the path\n\tstd::vector<NodePtr> path_nodes;\n\t// Create a node pointer to hold the current node\n\tNodePtr current_node = end_node;\n\t// Continue until the current node is the start node\n\twhile (current_node->parent_node != nullptr) {\n\t\t// Add the current node to the path\n\t\tpath_nodes.push_back(current_node);\n\t\t// Set the current node to the current node's parent node\n\t\tcurrent_node = current_node->parent_node;\n\t}\n\t// Add the start node to the path\n\tpath_nodes.push_back(current_node);\n\t// Reverse the order of the path nodes so that it goes from start to end\n\tstd::reverse(path_nodes.begin(), path_nodes.end());\n\t// Set the path nodes to the path nodes\n\tpath_nodes_ = path_nodes;\n}", "CodeBleu_score": 59.580705763288265}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tNodePtr current_node = end_node;\n\twhile (current_node->parent_node_ptr != nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_node_ptr;\n\t}\n\tpath_nodes_.push_back(current_node);\n\treverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 64.3094229271423}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\t// Initialize current node to end node\n\tNodePtr current_node = end_node;\n\t// Loop until start node is reached\n\twhile (current_node->parent_node_ != nullptr) {\n\t\t// Add current node to path\n\t\tpath_nodes_.push_back(current_node);\n\t\t// Update current node to parent node\n\t\tcurrent_node = current_node->parent_node_;\n\t}\n\t// Add start node to path\n\tpath_nodes_.push_back(current_node);\n\t// Reverse path nodes to get from start to end\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 61.81848429019682}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode)  {\n\t\tdouble dist = sqrt(pow(odom->pose.pose.position.x - start_pose.pose.position.x, 2) + pow(odom->pose.pose.position.y - start_pose.pose.position.y, 2));\n\t\tif (dist > 5.0)  {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse  {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = odom->pose.pose.orientation.z;\n\tstate_nei[id].pitch = odom->pose.pose.orientation.x;\n\tstate_nei[id].roll = odom->pose.pose.orientation.y;\n}", "CodeBleu_score": 50.44283038266958}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode) {\n\t\tfloat dist = sqrt(pow(odom->pose.pose.position.x - start_pose.pose.position.x, 2) + pow(odom->pose.pose.position.y - start_pose.pose.position.y, 2));\n\t\tif (dist > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = odom->pose.pose.position.z;\n}", "CodeBleu_score": 50.32448674451546}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odometry_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter == 5) {\n\t\tupdate_counter = 0;\n\t\tupdateMap(msg);\n\t}\n}", "CodeBleu_score": 48.74730539516526}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_counter += 1;\n\tif (update_counter == 5) {\n\t\tupdate_counter = 0;\n\t\tAstar.UpdateMap(msg);\n\t}\n}", "CodeBleu_score": 51.46676156041785}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t// If odometry is not ready, return immediately.\n\tif (odom_ready == false) {\n\t\treturn;\n\t}\n\t// Set sensor_ready flag to true.\n\tsensor_ready = true;\n\t// Increment update counter.\n\tupdate_counter++;\n\t// Every fifth update, update the Astar map.\n\tif (update_counter == 5) {\n\t\t// Update the Astar map.\n\t\tupdate_astar_map(msg);\n\t\t// Reset the update counter.\n\t\tupdate_counter = 0;\n\t}\n}", "CodeBleu_score": 48.49443040328488}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tpcl::toROSMsg(gpcl, gpcl_msg);\n\t\tgpcl_pub.publish(gpcl_msg);\n\t\tinflate_gpcl();\n\t}\n}", "CodeBleu_score": 48.13126144009281}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl == false) {\n\t\tpcl::fromROSMsg(*global_point, global_pcl);\n\t\tget_gpcl = true;\n\t\tstd::cout << \"Global point cloud received\" << std::endl;\n\t\tmap_inflate();\n\t}\n}", "CodeBleu_score": 41.08070918929027}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t", "CodeBleu_score": 7.002342664388052}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::toROSMsg(*map_pcl_, global_pcl_msg_);\n\tglobal_pcl_msg_.header.frame_id = \"world\";\n\tglobal_pcl_pub_.publish(global_pcl_msg_);\n\n\tpcl::toROSMsg(*inflate_map_pcl_, inflate_pcl_msg_);\n\tinflate_pcl_msg_.header.frame_id = \"world\";\n\tinflate_pcl_pub_.publish(inflate_pcl_msg_);\n}", "CodeBleu_score": 49.02271597670917}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tROS_INFO(\"Publishing point cloud\");\n\t// Convert the global map to a ROS message\n\tpcl::toROSMsg(*global_map, global_pcl);\n\tglobal_pcl.header.frame_id = \"world\";\n\tglobal_pcl.header.stamp = ros::Time::now();\n\t// Publish the point cloud\n\tglobal_pcl_pub.publish(global_pcl);\n\t// Convert the inflated map to a ROS message\n\tpcl::toROSMsg(*inflate_map, inflate_pcl);\n\tinflate_pcl.header.frame_id = \"world\";\n\tinflate_pcl.header.stamp = ros::Time::now();\n\t// Publish the inflated point cloud\n\tinflate_pcl_pub.publish(inflate_pcl);\n}", "CodeBleu_score": 49.203395995401614}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\t// Convert the global point cloud map to a ROS message\n\tsensor_msgs::PointCloud2 msg;\n\tpcl_to_ros(global_map, msg);\n\n\t// Publish the point cloud\n\tglobal_pcl_pub.publish(msg);\n\n\t// Convert the inflated point cloud to a ROS message\n\tsensor_msgs::PointCloud2 inflate_msg;\n\tpcl_to_ros(inflate_map, inflate_msg);\n\n\t// Publish the inflated point cloud\n\tinflate_pcl_pub.publish(inflate_msg);\n}", "CodeBleu_score": 39.39253105623459}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tROS_INFO(\"Lpointcloud_cb called\");\n\tpcl::PointCloud<pcl::PointXYZ> pcl_pc;\n\tpcl::fromROSMsg(*msg, pcl_pc);\n\tpcl_pc.header.frame_id = \"map\";\n\tpcl_pc.header.stamp = ros::Time::now();\n\tmap_mutex.lock();\n\tmap.clear();\n\tmap.insert(pcl_pc);\n\tmap_mutex.unlock();\n\tsensor_ready = true;\n\tROS_INFO(\"Lpointcloud_cb finished\");\n}", "CodeBleu_score": 43.18504700407038}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contact_enabled_ && !in_gazebo_) {\nfoot_contacts_msg_.contacts.resize(4);\nfoot_contacts_msg_.header.stamp = ros::Time::now();\nfor (int i = 0; i < 4; i++) {\nfoot_contacts_msg_.contacts[i].contact_positions.resize(1);\nfoot_contacts_msg_.contacts[i].contact_positions[0].x = foot_positions_[i].x();\nfoot_contacts_msg_.contacts[i].contact_positions[0].y = foot_positions_[i].y();\nfoot_contacts_msg_.contacts[i].contact_positions[0].z = foot_positions_[i].z();\nfoot_contacts_msg_.contacts[i].contact_normals.resize(1);\nfoot_contacts_msg_.contacts[i].contact_normals[0].x = foot_normals_[i].x();\nfoot_contacts_msg_.contacts[i].contact_normals[0].y = foot_normals_[i].y();\nfoot_contacts_msg_.contacts[i].contact_normals[0].z = foot_normals_[i].z();\nfoot_contacts_msg_.contacts[i].contact_positions_projected.resize(1);\nfoot_contacts_msg_.contacts[i].contact_positions_projected[0].x = foot_positions_projected_[i].x();\nfoot_contacts_msg_.contacts[i].contact_positions_projected[0].y = foot_positions_projected_[i].y();\nfoot_contacts_msg_.contacts[i].contact_positions_projected[0].z = foot_positions_projected_[i].z();\nfoot_contacts_msg_.contacts[i].contact_depths.resize(1);\nfoot_contacts_msg_.contacts[i].contact_depths[0] = foot_depths_[i];\nfoot_contacts_msg_.contacts[i].is_contact_active.resize(1);\nfoot_contacts_msg_.contacts[i].is_contact_active[0] = foot_contacts[i];\n}\nfoot_contacts_publisher_.publish(foot_contacts_msg_);\n}\n}", "CodeBleu_score": 49.43088602564576}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t#ifndef GAZEBO\n  if (foot_contacts_enabled_ && !in_gazebo_) {\n    foot_contacts_msg_.header.stamp = ros::Time::now();\n    foot_contacts_msg_.left_front = foot_contacts[0];\n    foot_contacts_msg_.left_middle = foot_contacts[1];\n    foot_contacts_msg_.left_rear = foot_contacts[2];\n    foot_contacts_msg_.right_front = foot_contacts[3];\n    foot_contacts_publisher_.publish(foot_contacts_msg_);\n  }\n#endif\n}", "CodeBleu_score": 52.6633379642196}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contact_enabled_ && !in_gazebo_) {\nquadruped_interface::ContactsStamped contacts_msg;\nfor (int leg = 0; leg < 4; leg++) {\nquadruped_interface::Contact contact_msg;\ncontact_msg.contact = foot_contacts[leg];\ncontact_msg.position = leg_positions_[leg];\ncontact_msg.orientation = leg_orientations_[leg];\ncontact_msg.contact_frame = leg_contact_frames_[leg];\ncontacts_msg.contacts.push_back(contact_msg);\n}\nfoot_contacts_publisher_.publish(contacts_msg);\n}\n}", "CodeBleu_score": 41.27847638043786}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t\tif (joints.positions.length != 12) {\n\t\trospy.logerr(\"Invalid number of joint positions: %d\", joints.positions.length);\n\t\treturn;\n\t}\n\n\t// Construct a minimal joints message with the first 12 joint positions\n\tMinimalJoints msg;\n\tmsg.header.stamp = rospy.Time.now();\n\tmsg.header.frame_id = \"base_link\";\n\tmsg.joint_names = self.joint_names;\n\tmsg.velocities = [0.0] * 12;\n\tmsg.accelerations = [0.0] * 12;\n\tmsg.positions = joints.positions.slice(0, 12);\n\n\t// Publish the minimal joints message\n\tself.pub_minimal_joints.publish(msg);\n\n\t// Construct a joint trajectory message with the same positions and a specified duration\n\tJointTrajectory msg_jt;\n\tmsg_jt.header.stamp = rospy.Time.now();\n\tmsg_jt.joint_names = self.joint_names;\n\tJointTrajectoryPoint msg_jt_pt;\n\tmsg_jt_pt.positions = msg.positions;\n\tmsg_jt_pt.velocities = msg.velocities;\n\tmsg_jt_pt.accelerations = msg.accelerations;\n\tmsg_jt_pt.time_from_start = rospy.Duration(2.0);\n\tmsg_jt.points = [msg_jt_pt];\n\n\t// Publish the joint trajectory message\n\tself.pub_joint_trajectory.publish(msg_jt);\n}", "CodeBleu_score": 41.5096625562529}, {"code": "def joints_cmd_callback(self, joints){\n\t\tif (joints.positions.size() < 12) {\n\t\tROS_ERROR(\"Invalid joint positions array size\");\n\t\treturn;\n\t}\n\n\tros::Time t = ros::Time::now();\n\tsensor_msgs::JointState js;\n\tjs.header.stamp = t;\n\tjs.name.resize(12);\n\tjs.position.resize(12);\n\tjs.velocity.resize(12);\n\tjs.effort.resize(12);\n\tfor (int i = 0; i < 12; i++) {\n\t\tjs.name[i] = self.joint_names[i];\n\t\tjs.position[i] = joints.positions[i];\n\t}\n\n\tself.joints_pub.publish(js);\n\n\ttrajectory_msgs::JointTrajectory traj;\n\ttraj.header.stamp = t;\n\ttraj.joint_names = js.name;\n\ttraj.points.resize(1);\n\ttraj.points[0].positions = js.position;\n\ttraj.points[0].velocities.resize(12);\n\ttraj.points[0].accelerations.resize(12);\n\ttraj.points[0].time_from_start = ros::Duration(self.traj_duration);\n\n\tself.traj_pub.publish(traj);\n}", "CodeBleu_score": 40.619164136751564}, {"code": "def joints_cmd_callback(self, joints){\n\t\tself.joints_msg.position = joints.position[:12]\n\tself.joints_msg.header.stamp = rospy.Time.now()\n\tself.joints_pub.publish(self.joints_msg)\n\n\tself.traj_msg.joint_names = self.joints_msg.name\n\tself.traj_msg.points = [trajectory_msgs.msg.JointTrajectoryPoint()]\n\tself.traj_msg.points[0].positions = self.joints_msg.position\n\tself.traj_msg.points[0].velocities = [0.0] * 12\n\tself.traj_msg.points[0].accelerations = [0.0] * 12\n\tself.traj_msg.points[0].time_from_start = rospy.Duration(self.traj_time)\n\tself.traj_pub.publish(self.traj_msg)\n}", "CodeBleu_score": 28.796791423146708}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\t\tif (collision1.find(foot_link_) != std::string::npos) {\n\t\t\tfoot_contact_state_ = true;\n\t\t}\n\t\tif (collision2.find(foot_link_) != std::string::npos) {\n\t\t\tfoot_contact_state_ = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 44.58612081829804}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string collision1 = _msg->contact(i).collision1();\n\t\tstd::string collision2 = _msg->contact(i).collision2();\n\t\tstd::string::size_type loc1 = collision1.find(\"::\");\n\t\tstd::string::size_type loc2 = collision2.find(\"::\");\n\t\tstd::string name1 = collision1.substr(0, loc1);\n\t\tstd::string name2 = collision2.substr(0, loc2);\n\t\tif (name1 == \"left_foot\" || name1 == \"right_foot\") {\n\t\t\tif (name1 == \"left_foot\") {\n\t\t\t\tleft_contact = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tright_contact = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 44.83305692973043}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tstd::string::size_type footLinkIndex;\n\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tfootLinkIndex = _msg->contact(i).collision1_name().find(\"::foot_link\");\n\t\tif (footLinkIndex != std::string::npos) {\n\t\t\tfoot_contact_states_[0] = true;\n\t\t}\n\n\t\tfootLinkIndex = _msg->contact(i).collision2_name().find(\"::foot_link\");\n\t\tif (footLinkIndex != std::string::npos) {\n\t\t\tfoot_contact_states_[1] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 39.24689466502254}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n\n  // Ensure the input and parameters are valid.\n  if (!rotor_velocities) {\n    return;\n  }\n\n  if (!is_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  // Compute the desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust_body_z(acceleration);\n  thrust_body_z.normalize();\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d total_acceleration = thrust_body_z + angular_acceleration;\n\n  // Compute the rotor velocities.\n  Eigen::Vector3d rotor_velocities_body_frame;\n  rotor_velocities_body_frame = vehicle_parameters_.rotor_inertia_moments_ * total_acceleration;\n\n  *rotor_velocities = rotor_velocities_body_frame.cwiseSqrt();\n}", "CodeBleu_score": 49.25687254838772}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.num_rotors_);\n    return;\n  }\n\n  // Get the desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration_des;\n  ComputeDesiredAcceleration(&acceleration_des);\n\n  Eigen::Vector3d angular_acceleration_des;\n  ComputeDesiredAngularAcc(acceleration_des, &angular_acceleration_des);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust_des;\n  thrust_des = acceleration_des.cross(odometry_.position) + vehicle_parameters_.gravity_;\n\n  // Compute the rotor velocities.\n  Eigen::MatrixXd rotor_velocities_matrix = vehicle_parameters_.rotor_inertia_matrix_;\n  rotor_velocities_matrix.noalias() += vehicle_parameters_.rotor_damping_matrix_;\n\n  // Compute the desired rotor velocities.\n  Eigen::VectorXd rotor_velocities_des = rotor_velocities_matrix.inverse() * (\n      -thrust_des.transpose() + angular_acceleration_des.transpose() * vehicle_parameters_.rotor_positions_);\n\n  // Ensure non-negative values.\n  rotor_velocities_des = rotor_velocities_des.cwiseMax(Eigen::VectorXd::Zero(vehicle_parameters_.num_rotors_));\n\n  // Take the square root of the rotor velocities.\n  rotor_velocities_des = rotor_velocities_des.cwiseSqrt();\n\n  *rotor_velocities = rotor_velocities_des;\n}", "CodeBleu_score": 49.754728289653976}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tif (!controller_parameters_.active_) {\n\t\t*rotor_velocities = Eigen::VectorXd::Zero(vehicle_parameters_.num_motors_);\n\t\treturn;\n\t}\n\n\tEigen::Vector3d acceleration;\n\tComputeDesiredAcceleration(&acceleration);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n\tEigen::Vector3d thrust;\n\tthrust = acceleration + vehicle_parameters_.mass_ * vehicle_parameters_.gravity_;\n\n\tEigen::VectorXd rotor_velocities_temp = vehicle_parameters_.thrust_to_rotor_matrix_ * thrust;\n\n\tEigen::VectorXd rotor_velocities_temp_squared = rotor_velocities_temp.cwiseProduct(rotor_velocities_temp);\n\n\tEigen::VectorXd rotor_velocities_squared = rotor_velocities_temp_squared.cwiseSqrt();\n\n\t*rotor_velocities = rotor_velocities_squared;\n}", "CodeBleu_score": 50.75659980236108}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// TODO: Fill in your code here.\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d velocity_world;\n\tEigen::Vector3d acceleration_world;\n\n\tposition_error = m_position_command - m_odometry_data.position;\n\tvelocity_error = m_velocity_command - m_odometry_data.velocity;\n\n\tvelocity_world = m_odometry_data.rotation * m_odometry_data.velocity;\n\tacceleration_world = m_odometry_data.rotation * m_odometry_data.acceleration;\n\n\tacceleration->x() = m_position_gain * position_error.x() + m_velocity_gain * velocity_error.x() - m_vehicle_mass * m_gravity.x() - m_acceleration_command.x();\n\tacceleration->y() = m_position_gain * position_error.y() + m_velocity_gain * velocity_error.y() - m_vehicle_mass * m_gravity.y() - m_acceleration_command.y();\n\tacceleration->z() = m_position_gain * position_error.z() + m_velocity_gain * velocity_error.z() - m_vehicle_mass * m_gravity.z() - m_acceleration_command.z();\n}", "CodeBleu_score": 49.2585784779538}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// TODO: Fill this in with your implementation.\n\tEigen::Vector3d position_error;\n\tEigen::Vector3d velocity_error;\n\tEigen::Vector3d velocity_world;\n\n\tposition_error = command_.position - odometry_.position;\n\tvelocity_error = command_.velocity - odometry_.velocity;\n\tvelocity_world = odometry_.orientation.conjugate().transpose() * odometry_.velocity;\n\n\t// Calculate desired acceleration\n\tacceleration->x() = position_error.x() * position_gain_.x() + velocity_error.x() * velocity_gain_.x() + (gravity_.x() + command_.acceleration.x() * mass_) / mass_;\n\tacceleration->y() = position_error.y() * position_gain_.y() + velocity_error.y() * velocity_gain_.y() + (gravity_.y() + command_.acceleration.y() * mass_) / mass_;\n\tacceleration->z() = position_error.z() * position_gain_.z() + velocity_error.z() * velocity_gain_.z() + (gravity_.z() + command_.acceleration.z() * mass_) / mass_;\n}", "CodeBleu_score": 50.07045495697311}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// TODO: Fill this in.\n\tEigen::Vector3d commanded_acceleration = Eigen::Vector3d::Zero();\n\tEigen::Vector3d current_velocity = Eigen::Vector3d::Zero();\n\tEigen::Vector3d position_error = Eigen::Vector3d::Zero();\n\tEigen::Vector3d velocity_error = Eigen::Vector3d::Zero();\n\tEigen::Vector3d desired_acceleration = Eigen::Vector3d::Zero();\n\tEigen::Vector3d commanded_velocity = Eigen::Vector3d::Zero();\n\tEigen::Vector3d commanded_position = Eigen::Vector3d::Zero();\n\n\t// Compute the commanded acceleration\n\tcommanded_acceleration = commanded_velocity - current_velocity;\n\n\t// Compute the position error\n\tposition_error = commanded_position - position_;\n\n\t// Transform the current velocity to the world frame\n\tcurrent_velocity = transform_.rotation() * current_velocity;\n\n\t// Compute the velocity error\n\tvelocity_error = commanded_velocity - current_velocity;\n\n\t// Compute the desired acceleration\n\tdesired_acceleration = k_p_ * position_error + k_v_ * velocity_error + k_a_ * commanded_acceleration;\n\n\t// Transform the desired acceleration back to the body frame\n\t*acceleration = transform_.rotation().transpose() * desired_acceleration;\n}", "CodeBleu_score": 46.06440045620358}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// check that the input is valid\n\tassert(control_attitude_thrust_reference_.size() == 3);\n\tassert(control_attitude_thrust_reference_.minCoeff() >= -1.0);\n\tassert(control_attitude_thrust_reference_.maxCoeff() <= 1.0);\n\n\t// resize the rotor velocities vector to match the number of rotors\n\trotor_velocities->resize(rotor_velocities_.size());\n\n\t// compute desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// compute the rotor velocities\n\tEigen::VectorXd rotor_velocities_temp = -1 * (thrust_reference_ + angular_acceleration).cwiseProduct(gain_thrust_) + rotor_velocities_.cwiseProduct(gain_rotor_velocities_);\n\trotor_velocities_temp.array() = rotor_velocities_temp.array().max(1.0);\n\trotor_velocities_temp.array().sqrt();\n\t*rotor_velocities = rotor_velocities_temp;\n}", "CodeBleu_score": 46.95474026716851}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// ensure input and parameters are valid\n\tassert(control_attitude_thrust_reference_.size() == 3);\n\tassert(gain_attitude_.size() == 3);\n\tassert(gain_angular_rate_.size() == 3);\n\n\t// resize rotor velocities vector to match number of rotors\n\trotor_velocities->resize(rotor_thrusts_.size());\n\n\t// calculate desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// combine thrust reference and desired angular acceleration into a single vector\n\tEigen::Vector3d desired_acceleration = control_attitude_thrust_reference_ + angular_acceleration;\n\n\t// compute rotor velocities by multiplying with a predefined matrix\n\tfor (int i = 0; i < rotor_velocities->size(); i++) {\n\t\t(*rotor_velocities)[i] = sqrt(max(1.0, desired_acceleration.dot(rotor_thrusts_[i])));\n\t}\n}", "CodeBleu_score": 44.43619015458846}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t assert(rotor_velocities);\n assert(rotor_velocities->size() == kNumRotors);\n\n // check that the input is valid\n assert(control_attitude_thrust_reference_.allFinite());\n assert(control_attitude_thrust_reference_.isApprox(control_attitude_thrust_reference_.cwiseAbs()));\n assert(control_attitude_thrust_reference_.minCoeff() >= 0.0);\n assert(control_attitude_thrust_reference_.maxCoeff() <= 1.0);\n\n // resize the rotor velocities vector\n rotor_velocities->resize(kNumRotors);\n\n // compute the desired angular acceleration\n Eigen::Vector3d angular_acceleration;\n ComputeDesiredAngularAcc(&angular_acceleration);\n\n // compute the desired thrust\n Eigen::Vector3d thrust_des = control_attitude_thrust_reference_.cwiseProduct(kThrustReference);\n\n // compute the desired input\n Eigen::Vector3d input_des = thrust_des + angular_acceleration;\n\n // compute the rotor velocities\n Eigen::MatrixXd rotor_matrix = GetRotorMatrix();\n *rotor_velocities = rotor_matrix * input_des;\n\n // ensure the rotor velocities are at least one\n rotor_velocities->array() += 1.0;\n\n // take the square root of each component\n rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 52.240540046544695}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t, leaving the original object untouched.\n    \"\"\"\n    # Get the indices of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Create a copy of the object\n    new_obj = copy.deepcopy(self)\n    # Slice the data\n    new_obj.time = self.time[start_index:end_index]\n    new_obj.data = self.data[start_index:end_index]\n    new_obj.units = self.units\n    new_obj.name = self.name\n    new_obj.description = self.description\n    return new_obj", "CodeBleu_score": 4.761957520924699}, {"code": "def slice(self, start_time, end_time)\n\t, leaving the original object unchanged.", "CodeBleu_score": 4.732604173024732}, {"code": "def slice(self, start_time, end_time)\n\t.\n    \"\"\"\n    # Find the indices of the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    # Make a deep copy of the object\n    sliced_obj = copy.deepcopy(self)\n    # Slice the data in each attribute\n    for attr in self.__dict__.keys():\n        if attr == 'time':\n            sliced_obj.time = self.time[start_index:end_index]\n        elif attr == 'value':\n            sliced_obj.value = self.value[start_index:end_index]\n        elif attr == 'name':\n            sliced_obj.name = self.name\n        elif attr == 'units':\n            sliced_obj.units = self.units\n        elif attr == 'description':\n            sliced_obj.description = self.description\n        elif attr == 'tags':\n            sliced_obj.tags = self.tags\n        elif attr == 'attributes':\n            sliced_obj.attributes = self.attributes\n        else:\n            sliced_obj.__dict__[attr] = self.__dict__[attr][start_index:end_index]\n    return sliced_obj", "CodeBleu_score": 3.4128289474452163}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    (roll, pitch, yaw) = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n    # Check if the waypoint is different from the last one\n    if self.last_point is None:\n        # If it is the first waypoint, append all the data\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n    else:\n        # If it is not the first waypoint, check if the waypoint is different\n        if self.last_point.x != point.x or self.last_point.y != point.y or self.last_point.z != point.z or self.last_yaw != yaw:\n            # If it is different, append all the data\n            self.append_point(point)\n            self.append_yaw(yaw)\n            self.append_times(msg_time, bag_time)\n    # Update last_point and last_yaw\n    self.last_point = point\n    self.last_yaw = yaw\n", "CodeBleu_score": 30.16830428281651}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.position\n    rotation = waypoint_msg.orientation\n\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion(\n        (rotation.x, rotation.y, rotation.z, rotation.w))\n\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if (self.x.size == 0) or (self.x[-1] != point.x) or (self.y[-1] != point.y) or (self.z[-1] != point.z) or (self.yaw[-1] != euler[2]):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, euler[2])\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 26.352430535293937}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    waypoint_position = waypoint_msg.pose.pose.position\n    waypoint_orientation = waypoint_msg.pose.pose.orientation\n    waypoint_position = Point(waypoint_position.x, waypoint_position.y, waypoint_position.z)\n    waypoint_orientation = Quaternion(waypoint_orientation.x, waypoint_orientation.y, waypoint_orientation.z, waypoint_orientation.w)\n    waypoint_euler = tf.transformations.euler_from_quaternion((waypoint_orientation.x, waypoint_orientation.y, waypoint_orientation.z, waypoint_orientation.w))\n    waypoint_yaw = waypoint_euler[2]\n    if not numpy.array_equal(self.last_waypoint_position, waypoint_position) or not numpy.array_equal(self.last_waypoint_yaw, waypoint_yaw):\n        self.append_point(waypoint_position)\n        self.append_times(msg_time, bag_time)\n        self.last_waypoint_position = waypoint_position\n        self.last_waypoint_yaw = waypoint_yaw\n", "CodeBleu_score": 25.92147384857392}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    # convert the message time to seconds\n    msg_time = msg.header.stamp.to_sec()\n    # append the message time and the bag time to the corresponding attributes\n    self.append_times(msg_time, bag_time)\n    # if the topic matches, append the linear acceleration data to the corresponding attributes\n    if topic == '/imu/data':\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n    elif topic == '/imu/data_raw':\n        self.x = numpy.append(self.x, msg.linear_acceleration.x)\n        self.y = numpy.append(self.y, msg.linear_acceleration.y)\n        self.z = numpy.append(self.z, msg.linear_acceleration.z)\n    elif topic == '/imu/mag':\n        self.x = numpy.append(self.x, msg.magnetic_field.x)\n        self.y = numpy.append(self.y, msg.magnetic_field.y)\n        self.z = numpy.append(self.z, msg.magnetic_field.z)\n    elif topic == '/imu/mag_raw':\n        self.x = numpy.append(self.x, msg.magnetic_field.x)\n        self.y = numpy.append(self.y, msg.magnetic_field.y)\n        self.z = numpy.append(self.z, msg.magnetic_field.z)\n    elif topic == '/imu/temp':\n        self.x = numpy.append(self.x, msg.temperature)\n    elif topic == '/imu/temperature':\n        self.x = numpy.append(self.x, msg.temperature)\n    else:\n        pass\n\n", "CodeBleu_score": 28.672625789834704}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == self.accel_topic:\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n    elif topic == self.gyro_topic:\n        self.gyro_x.append(msg.angular_velocity.x)\n        self.gyro_y.append(msg.angular_velocity.y)\n        self.gyro_z.append(msg.angular_velocity.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 33.61755261919617}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.acceleration.x.append_data(msg.linear_acceleration.x, bag_time)\n        self.acceleration.y.append_data(msg.linear_acceleration.y, bag_time)\n        self.acceleration.z.append_data(msg.linear_acceleration.z, bag_time)\n        self.acceleration.append_times(msg.header.stamp.to_sec(), bag_time)\n    elif topic == '/imu/data_raw':\n        self.acceleration.x.append_data(msg.linear_acceleration.x, bag_time)\n        self.acceleration.y.append_data(msg.linear_acceleration.y, bag_time)\n        self.acceleration.z.append_data(msg.linear_acceleration.z, bag_time)\n        self.acceleration.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 29.579690274671357}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Check if saving plots is enabled\n    if self.save_plots:\n        # Create a filename for the plot\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        # Add file extension\n        filename += \".png\"\n        # Create the full path\n        full_path = os.path.join(self.plots_dir, filename)\n    # Create the figure\n    fig = plt.figure(figsize=(12, 8))\n    # Create the subplot\n    ax = fig.add_subplot(1, 1, 1)\n    # Plot the data\n    for accel_name in self.accelerations:\n        ax.plot(self.accelerations[accel_name].time, self.accelerations[accel_name].x, label=accel_name + \" x\")\n        ax.plot(self.accelerations[accel_name].time, self.accelerations[accel_name].y, label=accel_name + \" y\")\n        ax.plot(self.accelerations[accel_name].time, self.accelerations[accel_name].z, label=accel_name + \" z\")\n    # Set the x and y axis labels\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    # Add a legend\n    ax.legend()\n    # Add a title\n    fig.suptitle(\"Accelerations\")\n    # Save the plot if saving plots is enabled\n    if self.save_plots:\n        fig.savefig(full_path)\n    # Show the plot if plotting is enabled\n    if self.plot_live:\n        plt.show()\n    # Close the figure\n    plt.close(fig)\n\n", "CodeBleu_score": 35.66979054206554}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Generate the figure and subplot\n    fig, ax = plt.subplots()\n    # Plot the acceleration data\n    for i, dataset in enumerate(self.accelerations):\n        ax.plot(dataset.time, dataset.x, label=\"x\" + str(i), color=\"red\")\n        ax.plot(dataset.time, dataset.y, label=\"y\" + str(i), color=\"green\")\n        ax.plot(dataset.time, dataset.z, label=\"z\" + str(i), color=\"blue\")\n    # Add labels and legend\n    ax.set(xlabel=\"Time (s)\", ylabel=\"Acceleration (m/s^2)\", title=\"Accelerations\")\n    ax.legend()\n    # Save the plot if enabled\n    if self.save_plots:\n        # Construct the filename\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        # Save the plot\n        plt.savefig(filename)\n    # Show the plot if enabled\n    if self.show_plots:\n        plt.show()\n\n", "CodeBleu_score": 33.026115921601594}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create figure\n    fig, ax = plt.subplots(3, sharex=True, figsize=(12, 9))\n\n    # Get acceleration data\n    accel_data = self.accel_data\n\n    # Plot each acceleration dataset\n    for accel_name, accel_values in accel_data.items():\n        # Get x, y, and z components\n        x_values = accel_values[0]\n        y_values = accel_values[1]\n        z_values = accel_values[2]\n\n        # Plot x, y, and z components\n        ax[0].plot(x_values, color=self.colors[accel_name], label=accel_name)\n        ax[1].plot(y_values, color=self.colors[accel_name], label=accel_name)\n        ax[2].plot(z_values, color=self.colors[accel_name], label=accel_name)\n\n    # Add labels\n    ax[0].set_ylabel(\"X (m/s^2)\")\n    ax[1].set_ylabel(\"Y (m/s^2)\")\n    ax[2].set_ylabel(\"Z (m/s^2)\")\n    ax[2].set_xlabel(\"Time (s)\")\n\n    # Add legend\n    ax[0].legend()\n\n    # Construct filename\n    if plot_suffix is None:\n        plot_suffix = \"\"\n    filename = f\"{self.filename_prefix}_accelerations{plot_suffix}.png\"\n\n    # Save plot\n    if self.save_plots:\n        plt.savefig(filename)\n\n    # Display plot\n    if self.display_plots:\n        plt.show()\n\n    # Close plot\n    plt.close()\n\n", "CodeBleu_score": 36.906251170067726}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        raise Exception(\"Must have at least two pose indices to compare.\")\n    for i in range(0, len(pose_indeces) - 1):\n        compare_two_xyz(self.poses[pose_indeces[i]].xyz, self.poses[pose_indeces[i + 1]].xyz)\n\n", "CodeBleu_score": 39.03645925540131}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        return\n    for i in range(len(pose_indeces) - 1):\n        compare_two_xyz(self.pose_list[pose_indeces[i]].xyz, self.pose_list[pose_indeces[i + 1]].xyz)\n\n", "CodeBleu_score": 28.527904135536346}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    for i in range(len(pose_indeces) - 1):\n        compare_two_xyz(self.xyz[pose_indeces[i]], self.xyz[pose_indeces[i + 1]])\n\n", "CodeBleu_score": 11.828391992092936}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    if start_time == None:\n        start_time = 0.0\n    if end_time == None:\n        end_time = self.wrench.shape[0]\n    collision_times = []\n    for i in range(self.wrench.shape[0]):\n        if self.wrench[i, 0] >= start_time and self.wrench[i, 0] <= end_time:\n            collision_times.append(self.wrench[i, 0])\n    return collision_times\n\n", "CodeBleu_score": 36.80586837707703}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    if start_time is None:\n        start_time = self.start_time\n    if end_time is None:\n        end_time = self.end_time\n    collision_times = []\n    for i in range(len(self.wrench)):\n        if self.wrench[i][0] >= start_time and self.wrench[i][0] <= end_time:\n            collision_times.append(self.wrench[i][0])\n    return collision_times\n\n", "CodeBleu_score": 36.635451087496016}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision[0] <= end_time:\n            collision_times.append(collision[0])\n    return collision_times\n\n", "CodeBleu_score": 35.233707661425264}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t// Check that the data pointer is valid\n  if (data == nullptr) {\n    return;\n  }\n\n// Calculate the multiplier based on the camera parameters\n  const float multiplier = this->GetMultiplier();\n\n// Map the data to an Eigen vector\n  const Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> data_vec(data,\n                                                                      width *\n                                                                      height);\n\n// Compute the RMS noise\n  const float rms_noise =\n      this->rms_noise_ * multiplier * this->rms_noise_ * multiplier;\n\n// Compute the noise values\n  const Eigen::Matrix<float, Eigen::Dynamic, 1> noise_vec =\n      rms_noise * Eigen::Matrix<float, Eigen::Dynamic, 1>::Random(\n          width * height);\n\n// For each pixel, add noise if the pixel value is in range, otherwise set the\n// pixel to a bad point value\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (this->InRange(data_vec[i])) {\n      data_vec[i] += noise_vec[i];\n    } else {\n      data_vec[i] = this->bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 49.75722681599732}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t if (data == NULL) return;\n const float multiplier = GetMultiplier();\n Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>> data_map(data, height * width);\n const float rms_noise = GetRMSNoise(multiplier);\n const float *noise = GetNoise(rms_noise, height * width);\n for (uint32_t i = 0; i < height * width; ++i) {\n   if (InRange(data_map[i])) {\n     data_map[i] += noise[i];\n   } else {\n     data_map[i] = kBadPoint;\n   }\n }\n}", "CodeBleu_score": 42.47371468650405}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t if (data == NULL) {\n    return;\n  }\n\n  const float multiplier = this->GetMultiplier();\n  const auto data_vec = Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>>(\n      data, width * height);\n  const auto data_vec_noised =\n      this->ApplyNoiseToVector(multiplier, width, height, data_vec);\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, 1>>(data, width * height) =\n      data_vec_noised;\n}", "CodeBleu_score": 33.16574091365211}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n// Get the current simulation time.\n  ros::Time current_time = this->world_->GetSimTime();\n\n// Convert the simulation time to a ROS time.\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n// Write the trajectory message to the bag file.\n  this->bag_.write(this->namespace_ + \"/\" + this->waypoint_topic_,\n                   *trajectory_msg, ros_time);\n}", "CodeBleu_score": 50.00430856119724}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n#if GAZEBO_MAJOR_VERSION >= 8\n  ros::Time current_time = ros::Time::now();\n#else\n  ros::Time current_time = ros::Time::now();\n#endif\n\n  std::string bag_file_name = GetBagFileName();\n  std::string topic_name = GetWaypointTopicName();\n  std::string full_topic_name = bag_file_name + \"::\" + topic_name;\n\n  bag_.write(full_topic_name, current_time, trajectory_msg);\n}", "CodeBleu_score": 46.793724739495076}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\n// Retrieve the current simulation time and convert it to a ROS time.\nconst gazebo::common::Time sim_time = this->world_->GetSimTime();\nconst ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n// Write the trajectory message to the bag file.\nthis->bag_.write(this->namespace_ + \"/\" + this->waypoint_topic_, ros_time,\n                 *trajectory_msg);\n\n}", "CodeBleu_score": 54.68630763942095}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Get the current simulation time\n\tdouble sim_time = now.sec + now.nsec / 1e9;\n\n\t// Convert the simulation time to a ROS time\n\tros::Time ros_time = ros::Time(sim_time);\n\n\t// Prepare a message for actuator velocities\n\tsensor_msgs::JointState msg;\n\tmsg.header.stamp = ros_time;\n\tmsg.name = {\"motor_front_left\", \"motor_front_right\", \"motor_rear_left\", \"motor_rear_right\"};\n\n\t// Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n\tfor (int i = 0; i < 4; i++) {\n\t\t// Get the rotational velocity\n\t\tdouble velocity = joints_[i]->GetVelocity(0);\n\n\t\t// Get the rotational velocity limits\n\t\tdouble vel_lim_min, vel_lim_max;\n\t\tjoints_[i]->GetVelocityLimits(vel_lim_min, vel_lim_max);\n\n\t\t// Calculate the slowed-down rotational velocity\n\t\tdouble slowed_down_velocity = velocity * vel_lim_min / vel_lim_max;\n\n\t\t// Assign the slowed-down rotational velocity to the message\n\t\tmsg.velocity.push_back(slowed_down_velocity);\n\t}\n\n\t// Write the data to a bag file using the specified namespace and motor topic\n\tbag_.write(namespace_ + \"/\" + motor_topic_, ros_time, msg);\n}", "CodeBleu_score": 44.70717217898385}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time ros_now = ros::Time(now.sec, now.nsec);\n\tsensor_msgs::JointState msg;\n\tmsg.header.stamp = ros_now;\n\tmsg.name.resize(num_joints);\n\tmsg.velocity.resize(num_joints);\n\tfor (int i = 0; i < num_joints; i++) {\n\t\tmsg.name[i] = joint_names[i];\n\t\tmsg.velocity[i] = joint_velocities[i] * slowness_factor;\n\t}\n\tbag.write(namespace_ + \"/\" + motor_topic_, ros_now, msg);\n}", "CodeBleu_score": 47.56895695645138}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert the simulation time to a ROS time.\n\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n\t// Create the actuator velocities message.\n\tgazebo_msgs::JointCmd msg;\n\tmsg.header.stamp = ros_time;\n\tmsg.header.frame_id = \"world\";\n\n\t// Iterate through the motor joints and calculate the slowed-down rotational velocities.\n\tfor (int i = 0; i < NUM_MOTORS; i++) {\n\t\tmsg.name.push_back(motor_names[i]);\n\t\tmsg.velocity.push_back(GetSlowedDownRotationalVelocity(i));\n\t}\n\n\t// Write the message to the bag file.\n\tbag.write(motor_topic, ros_time, msg);\n}", "CodeBleu_score": 33.35606104150387}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG_PRINTING\n  gzdbg << \"RollPitchYawrateThrustCallback called\" << std::endl;\n#endif\n\n  // Convert normalized input values to control surface angles for ailerons, elevator, and rudder.\n  double aileron_angle = NormalizedInputToAngle(aileron_, roll_pitch_yawrate_thrust_msg->roll);\n  double elevator_angle = NormalizedInputToAngle(elevator_, roll_pitch_yawrate_thrust_msg->pitch);\n  double rudder_angle = NormalizedInputToAngle(rudder_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value from the thrust message.\n  throttle_.set_value(roll_pitch_yawrate_thrust_msg->thrust);\n\n  // Set the control surface angles for ailerons, elevator, and rudder.\n  aileron_.set_value(aileron_angle);\n  elevator_.set_value(elevator_angle);\n  rudder_.set_value(rudder_angle);\n}", "CodeBleu_score": 40.39165837551947}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG_PRINT\n  gzdbg << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n#endif\n\n  // Convert normalized inputs to control surface angles.\n  double roll_angle = NormalizedInputToAngle(roll_surface_,\n                                           roll_pitch_yawrate_thrust_msg->roll);\n  double pitch_angle = NormalizedInputToAngle(pitch_surface_,\n                                            roll_pitch_yawrate_thrust_msg->pitch);\n  double yawrate_angle = NormalizedInputToAngle(\n      yawrate_surface_, roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the control surface angles.\n  aileron_joint_->SetForce(0, roll_angle);\n  elevator_joint_->SetForce(0, pitch_angle);\n  rudder_joint_->SetForce(0, yawrate_angle);\n\n  // Set the throttle value.\n  thrust_joint_->SetForce(0, roll_pitch_yawrate_thrust_msg->thrust);\n}", "CodeBleu_score": 39.607090898549714}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT\n  gzdbg << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n#endif\n\n  // Convert roll, pitch, and yaw rate to control surface deflections.\n  double roll_angle = NormalizedInputToAngle(\n      roll_pitch_yawrate_thrust_msg->roll_surface,\n      roll_pitch_yawrate_thrust_msg->roll);\n  double pitch_angle = NormalizedInputToAngle(\n      roll_pitch_yawrate_thrust_msg->pitch_surface,\n      roll_pitch_yawrate_thrust_msg->pitch);\n  double yaw_rate = NormalizedInputToAngle(\n      roll_pitch_yawrate_thrust_msg->yaw_rate_surface,\n      roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set control surface deflections.\n  SetControlSurfaceDeflection(roll_pitch_yawrate_thrust_msg->aileron_surface,\n                              roll_angle);\n  SetControlSurfaceDeflection(roll_pitch_yawrate_thrust_msg->elevator_surface,\n                              pitch_angle);\n  SetControlSurfaceDeflection(roll_pitch_yawrate_thrust_msg->rudder_surface,\n                              yaw_rate);\n\n  // Set throttle.\n  SetThrottle(roll_pitch_yawrate_thrust_msg->thrust);\n}", "CodeBleu_score": 38.85431814868736}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  if (serial_enabled_) {\n    if (is_open()) {\n      struct pollfd pollfds[1];\n      pollfds[0].fd = _fd;\n      pollfds[0].events = POLLIN;\n      int ret = poll(pollfds, 1, _timeoutMs);\n      if (ret > 0) {\n        if (pollfds[0].revents & POLLIN) {\n          int bytes_read = recv(_fd, read_buffer_, kReadBufferSize, 0);\n          if (bytes_read > 0) {\n            mavlink_message_t msg;\n            uint16_t total_len = 0;\n            uint16_t offset = 0;\n            while (offset < bytes_read) {\n              uint16_t len = mavlink_parse_char(MAVLINK_COMM_0, &msg,\n                                               read_buffer_ + offset,\n                                               bytes_read - offset);\n              if (len == 0) {\n                break;\n              }\n              offset += len;\n              total_len += len;\n              handle_message(&msg);\n            }\n          }\n        }\n      }\n    }\n  }\n#endif\n}", "CodeBleu_score": 46.13865108637607}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t//  struct timeval timeout;\n//  timeout.tv_sec = _timeoutMs / 1000;\n//  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  struct pollfd pollfds[1];\n  pollfds[0].fd = _fd;\n  pollfds[0].events = POLLIN;\n\n  int ret = poll(pollfds, 1, _timeoutMs);\n\n  if (ret == 0) {\n    return;\n  }\n\n  if (ret < 0) {\n    perror(\"poll\");\n    return;\n  }\n\n  {\n    lock_guard lock(mutex_);\n\n    while (mavlink_parse_char(\n        mavlink_fd_, mavlink_fd_->recv_bytes, &rx_msg_,\n        mavlink_fd_->recv_buffer_length) == MAVLINK_FRAMING_OK) {\n      if (rx_msg_.msgid == MAVLINK_MSG_ID_HIL_ACTUATOR_CONTROLS) {\n        handle_message(&rx_msg_);\n      }\n    }\n  }\n}", "CodeBleu_score": 37.83450081916638}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t#if GAZEBO_MAJOR_VERSION >= 8\n  // Get the time at the start of the poll operation.\n  gazebo::common::Time start_time = world_->SimTime();\n#else\n  gazebo::common::Time start_time = world_->GetSimTime();\n#endif\n\n  // Convert the timeout to a timeval structure.\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data on the serial port.\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n\n  int ret = select(_fd + 1, &fds, nullptr, nullptr, &timeout);\n\n  // If data is available, receive it.\n  if (ret == 1) {\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n    if (len <= 0) {\n      printf(\"Failed receiving mavlink message\n\");\n    }\n\n    mavlink_message_t msg;\n    while (mavlink_parse_char(MAVLINK_COMM_0, buffer[0], &msg, &buffer[1]) > 0) {\n      handle_message(&msg);\n    }\n  }\n\n  // If data is not available, check for timeouts.\n  else if (ret == 0) {\n    // Check for timeouts.\n    if (serial_enabled_) {\n      // If the timeout is greater than the time since the last actuator message,\n      // then send a heartbeat.\n      if (_dt > (world_->SimTime() - last_actuator_time_).Double()) {\n        send_heartbeat();\n      }\n    }\n  }\n\n  // If an error occurs, print the error message.\n  else if (ret == -1) {\n    perror(\"select\");\n  }\n}", "CodeBleu_score": 50.34318315861137}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::mutex::scoped_lock lock(mutex);\n\tif(isOpen())  {\n\t\tstop();\n\t\tcloseSerialDevice();\n\t\tif(isThreadJoinable())  {\n\t\t\tjoinThread();\n\t\t}\n\t}\n}", "CodeBleu_score": 19.560063825901157}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::recursive_mutex::scoped_lock lock(mutex);\n\tif (isOpen())  {\n\t\tstopIO();\n\t\tcloseSerial();\n\t}\n}", "CodeBleu_score": 15.538634631691142}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (is_open_) {\n\t\tstop_io_service();\n\t\tclose_serial();\n\t}\n\tif (io_thread_.joinable()) {\n\t\tio_thread_.join();\n\t}\n}", "CodeBleu_score": 47.233922857116326}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x = pos.x();\ndouble y = pos.y();\ndouble z = pos.z();\ndouble x1 = points[0].x();\ndouble y1 = points[0].y();\ndouble z1 = points[0].z();\ndouble x2 = points[1].x();\ndouble y2 = points[1].y();\ndouble z2 = points[1].z();\ndouble x3 = points[2].x();\ndouble y3 = points[2].y();\ndouble z3 = points[2].z();\ndouble x4 = points[3].x();\ndouble y4 = points[3].y();\ndouble z4 = points[3].z();\ndouble t = (x - x1) * (x - x2) * (x - x3) * (x - x4);\ndouble u = (y - y1) * (y - y2) * (y - y3) * (y - y4);\ndouble v = (z - z1) * (z - z2) * (z - z3) * (z - z4);\ndouble x5 = t * (x1 + x2 - 2 * x3 - 2 * x4) + u * (x1 - 2 * x2 + 2 * x3 + 2 * x4) + v * (x3 - x4);\ndouble y5 = t * (y1 + y2 - 2 * y3 - 2 * y4) + u * (y1 - 2 * y2 + 2 * y3 + 2 * y4) + v * (y3 - y4);\ndouble z5 = t * (z1 + z2 - 2 * z3 - 2 * z4) + u * (z1 - 2 * z2 + 2 * z3 + 2 * z4) + v * (z3 - z4);\nreturn ignition::math::Vector3d(x5, y5, z5);\n}", "CodeBleu_score": 37.56741340545248}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t", "CodeBleu_score": 4.221251976117891}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (m_time != _time) {\n\t\tm_time = _time;\n\t\tif (m_loop) {\n\t\t\tm_time = fmod(m_time, m_length);\n\t\t}\n\t\telse {\n\t\t\tm_time = Clamp(m_time, 0, m_length);\n\t\t}\n\t\tm_time = Clamp(m_time, 0, m_length);\n\t\tm_dirty = true;\n\t}\n}", "CodeBleu_score": 32.43037343265209}, {"code": "void Animation::SetTime(double _time){\n\t\tif (time != _time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\ttime = fmod(time, length);\n\t\t}\n\t\telse {\n\t\t\ttime = Clamp(time, 0.0, length);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.654281410150052}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time != m_time) {\n\t\tm_time = _time;\n\t\tif (m_loop) {\n\t\t\tm_time = fmod(m_time, m_length);\n\t\t}\n\t\telse {\n\t\t\tm_time = clamp(m_time, 0.0, m_length);\n\t\t}\n\t}\n}", "CodeBleu_score": 31.00329054710925}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_raw_pose)\n    print(\"Vehicle type: {}, Vehicle ID: {}, Flight Mode: {}\".format(self.vehicle.type, self.vehicle.id, self.vehicle.mode.name))\n\n", "CodeBleu_score": 43.88126427017695}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.send_target(target_raw_pose)\n    print(\"Vehicle type: {}", "CodeBleu_score": 36.30375022463748}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_raw_pose)\n    print(\"Vehicle type: {}", "CodeBleu_score": 39.168692541476716}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(0, self.flight_mode)\n            self.flight_mode = self.flight_mode\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":Failed to switch to flight mode \"+self.flight_mode)\n            return False\n", "CodeBleu_score": 49.764093764694096}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(self.flight_mode)\n            self.flight_mode = self.flight_mode\n            print(self.vehicle_type+'_'+self.vehicle_id+\":Flight mode changed to \"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":Flight mode change failed\")\n            return False\n", "CodeBleu_score": 53.265469636911874}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(vehicle_name=self.vehicle_name, flight_mode=self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(\"Failed to change flight mode for \"+self.vehicle_type+'_'+self.vehicle_id+\" to \"+self.flight_mode)\n            return False\n", "CodeBleu_score": 55.69689459041787}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n\n    self.hover_state_transition(x=x, y=y, z=z, w=w)\n\n    if self.hover_flag == 0:\n        self.hold_state_transition(x=x, y=y, z=z, w=w, vel_type='enu')\n\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(x=x, y=y, z=z, vx=x, vy=y, vz=z, afx=0, afy=0, afz=0, yaw=0, yaw_rate=w)\n\n", "CodeBleu_score": 39.95448818673624}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = self.construct_target(x=msg.linear.x, y=msg.linear.y, z=msg.linear.z,\n                                                       vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                       afx=0, afy=0, afz=0, yaw=0, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 58.72120740802601}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    x = msg.linear.x\n    y = msg.linear.y\n    z = msg.linear.z\n    w = msg.angular.z\n    self.hover_state_transition(x=x, y=y, z=z, w=w, vel_type='enu')\n    if self.hold_flag == 0:\n        self.hold_state_transition(x=x, y=y, z=z, w=w, vel_type='enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(x=x, y=y, z=z, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0)\n", "CodeBleu_score": 38.99011766049652}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.hover_flag == 0:\n        if self.current_position.x < x - 0.02 or self.current_position.x > x + 0.02 or self.current_position.y < y - 0.02 or self.current_position.y > y + 0.02 or self.current_position.z < z - 0.02 or self.current_position.z > z + 0.02 or self.current_yaw < w - 0.005 or self.current_yaw > w + 0.005:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n    elif self.hover_flag == 1:\n        if self.current_position.x < x + 0.02 and self.current_position.x > x - 0.02 and self.current_position.y < y + 0.02 and self.current_position.y > y - 0.02 and self.current_position.z < z + 0.02 and self.current_position.z > z - 0.02 and self.current_yaw < w + 0.005 and self.current_yaw > w - 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.offboard()\n\n", "CodeBleu_score": 43.66375436772785}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n\n", "CodeBleu_score": 86.80699819509282}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    self.hover_flag = 0\n    if self.flight_mode != \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        if self.hover_flag == 1:\n            self.flight_mode = \"HOVER\"\n            self.hover()\n\n", "CodeBleu_score": 73.54283272323633}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if not isinstance(q, Quaternion):\n        q = Quaternion(q[0], q[1], q[2], q[3])\n    return q.yaw()\n\n", "CodeBleu_score": 28.769115620803454}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw()\n\n", "CodeBleu_score": 19.828110469756748}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.vehicle.location.local_frame.north, y=self.vehicle.location.local_frame.east, z=self.vehicle.location.local_frame.down, yaw=self.vehicle.attitude.yaw)\n    self.vehicle.simple_takeoff(self.target_altitude)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.simple_goto(target_raw_pose)\n    print(\"Vehicle type: {}", "CodeBleu_score": 49.248652836358886}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_raw_pose = self.construct_target()\n    self.print_info()\n\n", "CodeBleu_score": 23.189412714830183}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = self.coordinate_frame_enum[\"BODY_NED\"]\n    self.motion_type = 3\n    self.target_motion = self.construct_target(x=self.local_position[0], y=self.local_position[1], z=self.local_position[2],\n                                               vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=self.attitude[2], yaw_rate=0)\n    print(\"Vehicle Type: {}", "CodeBleu_score": 33.188742081042086}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover_flag = True\n        self.hover_flag_pub.publish(self.hover_flag)\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(custom_mode=self.flight_mode)\n            self.flight_mode_pub.publish(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":Failed to switch flight mode\")\n            return False\n\n", "CodeBleu_score": 61.73703290577929}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":Failed to change flight mode\")\n            return False\n\n", "CodeBleu_score": 58.5770870641602}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.vehicle.flightModeService.setFlightMode(self.flight_modes[self.flight_mode])\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(\"Flight mode switch failed for \" + self.vehicle_type + '_' + self.vehicle_id + \".\")\n            return False\n\n", "CodeBleu_score": 64.6764326668703}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.header.frame_id == self.uav_id:\n        self.local_pose = msg.pose\n        self.local_pose.position.x = self.local_pose.position.x + self.bias[0]\n        self.local_pose.position.y = self.local_pose.position.y + self.bias[1]\n        self.local_pose.position.z = self.local_pose.position.z + self.bias[2]\n        self.global_pose.position.x = self.global_pose.position.x + self.bias[0]\n        self.global_pose.position.y = self.global_pose.position.y + self.bias[1]\n        self.global_pose.position.z = self.global_pose.position.z + self.bias[2]\n        if self.takeoff_target_pose.position.x == 0 and self.takeoff_target_pose.position.y == 0 and self.takeoff_target_pose.position.z == 0:\n            self.takeoff_target_pose.position.x = self.local_pose.position.x\n            self.takeoff_target_pose.position.y = self.local_pose.position.y\n            self.takeoff_target_pose.position.z = self.local_pose.position.z\n            self.hover_target_pose.position.x = self.local_pose.position.x\n            self.hover_target_pose.position.y = self.local_pose.position.y\n            self.hover_target_pose.position.z = self.local_pose.position.z\n        else:\n            self.hover_target_pose.position.x = self.hover_target_pose.position.x + self.bias[0]\n            self.hover_target_pose.position.y = self.hover_target_pose.position.y + self.bias[1]\n            self.hover_target_pose.position.z = self.hover_target_pose.position.z + self.bias[2]\n        self.global_pose.orientation = self.local_pose.orientation\n        self.global_pose.position.x = self.global_pose.position.x + self.bias[0", "CodeBleu_score": 18.350598373066486}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == i:\n        self.local_pose = msg\n        self.local_pose.pose.position.x -= self.bias[0]\n        self.local_pose.pose.position.y -= self.bias[1]\n        self.local_pose.pose.position.z -= self.bias[2]\n        self.global_pose = self.local_pose\n        self.global_pose.pose.position.x += self.bias[0]\n        self.global_pose.pose.position.y += self.bias[1]\n        self.global_pose.pose.position.z += self.bias[2]\n        if self.takeoff_target_pose != None:\n            self.hover_target_pose = self.takeoff_target_pose\n            self.hover_target_pose.pose.position.x -= self.bias[0]\n            self.hover_target_pose.pose.position.y -= self.bias[1]\n            self.hover_target_pose.pose.position.z -= self.bias[2]\n        elif self.hover_target_pose != None:\n            self.hover_target_pose.pose.position.x -= self.bias[0]\n            self.hover_target_pose.pose.position.y -= self.bias[1]\n            self.hover_target_pose.pose.position.z -= self.bias[2]\n\n", "CodeBleu_score": 19.17095278196544}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg.pose\n        self.global_pose.position.x = msg.pose.position.x + self.bias_x\n        self.global_pose.position.y = msg.pose.position.y + self.bias_y\n        self.global_pose.position.z = msg.pose.position.z\n        self.global_pose.orientation = msg.pose.orientation\n    if msg.id == self.id and self.takeoff_target_pose.position.x == 0 and self.takeoff_target_pose.position.y == 0:\n        self.takeoff_target_pose = msg.pose\n        self.hover_target_pose = msg.pose\n    if msg.id == self.id and self.hover_target_pose.position.x == 0 and self.hover_target_pose.position.y == 0:\n        self.hover_target_pose = msg.pose\n\n", "CodeBleu_score": 23.281981617494036}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.local_position.z > 0.2 and self.arming_state == \"ACTIVE\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 65.05532286985591}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.arm_state == \"active\":\n        if self.state.altitude > 0.2:\n            return True\n    else:\n        return False\n\n", "CodeBleu_score": 59.533574504388085}, {"code": "def takeoff_detection(self)\n\t\n    if self.alt > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 62.6464041749083}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # build the distance matrix\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance_matrix[i][j] = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n    return distance_matrix\n\n", "CodeBleu_score": 26.692634408370967}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # construct distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n    # adjust distances and convert to integers\n    dist_matrix = dist_matrix - 50\n    dist_matrix = np.rint(dist_matrix)\n    return dist_matrix\n\n", "CodeBleu_score": 26.962592642183747}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # calculate the pairwise distances between UAVs in the original and changed formations\n    dist_matrix = distance_matrix(orig_formation, change_formation)\n    # adjust the distances by subtracting them from 50 and converting to integers\n    dist_matrix = (50 - dist_matrix).astype(int)\n    return dist_matrix\n\n", "CodeBleu_score": 5.665636091034139}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.n_left):\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n        self.slack_left[i] = 0\n        self.slack_right[i] = 0\n        self.match_right[i] = -1\n    for i in range(self.n_left):\n        if self.find_path(i):\n            continue\n        min_slack_left = min(self.slack_left)\n        for i in range(self.n_left):\n            if self.slack_left[i] == min_slack_left:\n                self.label_left[i] -= min_slack_left\n                self.label_right[self.match_right[i]] += min_slack_left\n        for i in range(self.n_left):\n            if self.find_path(i):\n                break\n    return self.match_right\n\n", "CodeBleu_score": 30.345539019513275}, {"code": "def KM(self)\n\t\n    self.label_left = np.zeros(self.n_left)\n    self.label_right = np.zeros(self.n_right)\n    self.slack_left = np.zeros(self.n_left)\n    self.slack_right = np.zeros(self.n_right)\n    self.match_right = np.full(self.n_right, -1)\n    self.visit_left = np.zeros(self.n_left, dtype=bool)\n    self.visit_right = np.zeros(self.n_right, dtype=bool)\n    for i in range(self.n_left):\n        for j in range(self.n_right):\n            if self.adj_matrix[i][j] == 0:\n                self.slack_left[i] += 1\n                self.slack_right[j] += 1\n    while True:\n        self.find_path = self.find_path_init(self.find_path)\n        if self.find_path:\n            break\n        delta = min(self.slack_left)\n        for i in range(self.n_left):\n            self.label_left[i] -= delta\n        for j in range(self.n_right):\n            self.label_right[j] += delta\n    return self.match_right\n", "CodeBleu_score": 30.66181419301356}, {"code": "def KM(self)\n\t\n    self.label_left = [0] * self.n_left\n    self.label_right = [0] * self.n_right\n    self.slack_left = [0] * self.n_left\n    self.slack_right = [0] * self.n_right\n    self.match_right = [-1] * self.n_right\n    self.visit_left = [False] * self.n_left\n    self.visit_right = [False] * self.n_right\n    for i in range(self.n_left):\n        if not self.find_path(i):\n            delta = min(self.slack_left)\n            for j in range(self.n_left):\n                self.label_left[j] -= delta\n            for j in range(self.n_right):\n                self.label_right[j] += delta\n    return self.match_right\n\n", "CodeBleu_score": 30.488513421243642}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define range of yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 29.440086488580548}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    yellow_lower = np.array([20, 100, 100])\n    yellow_upper = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, yellow_lower, yellow_upper)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 27.40886454804292}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n}", "CodeBleu_score": 0.6648108845887202}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tauto it = standalone_tag_descriptions_.find(tagID);\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tLOG_WARNING(\"TagDetector::findStandaloneTagDescription: No description found for tag ID \" << tagID);\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = it->second;\n\treturn true;\n}", "CodeBleu_score": 38.49204688222062}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\n}", "CodeBleu_score": 0.6648108845887202}]}
