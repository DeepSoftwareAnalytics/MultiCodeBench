{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE *iface_desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE *conf_desc;\n\tuint8_t iface_num;\n\n\tconf_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) desc;\n\tiface_num = conf_desc->bInterfaceNumber;\n\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *) conf_desc->iface;\n\twhile (iface_desc->bLength) {\n\t\tif (iface_desc->bInterfaceNumber == iface_num) {\n\t\t\tif (iface_desc->bDescriptorType == desc_id) {\n\t\t\t\treturn iface_desc;\n\t\t\t}\n\t\t}\n\t\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *) ((uint8_t *) iface_desc +\n\t\t\t\tiface_desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 50.14618253063017}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 35.26810426650343}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.751070650251734}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t i;\n\tuint8_t iface_desc_type;\n\tuint8_t iface_desc_num;\n\tuint8_t iface_desc_setting;\n\n\tif (!udc_cfg.cfg_desc_valid) {\n\t\treturn false;\n\t}\n\tif (iface_num >= udc_cfg.cfg_desc.bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\ti = 0;\n\twhile (i < udc_cfg.cfg_desc.bLength) {\n\t\tiface_desc_type = udc_cfg.cfg_desc.bConfigurationValue[i];\n\t\tiface_desc_num = udc_cfg.cfg_desc.bConfigurationValue[i + 1];\n\t\tiface_desc_setting = udc_cfg.cfg_desc.bConfigurationValue[i + 2];\n\t\tif (iface_desc_type == UDC_DESC_TYPE_INTERFACE && iface_desc_num == iface_num && iface_desc_setting == setting_num) {\n\t\t\treturn true;\n\t\t}\n\t\ti += udc_cfg.cfg_desc.bLength;\n\t}\n\treturn false;\n}", "CodeBleu_score": 39.54123883614076}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tuint8_t *ptr = udc_config_desc_ptr;\n\tuint8_t *end = ptr + (udc_config_desc_ptr[7] & 0x0f);\n\n\t/* Check if there is a valid configuration */\n\tif (!udc_config_desc_ptr)\n\t\treturn false;\n\n\t/* Check if the interface number is within bounds */\n\tif (iface_num >= (ptr[5] & 0x0f))\n\t\treturn false;\n\n\t/* Iterate through the descriptors */\n\twhile (ptr < end) {\n\t\t/* Check if the descriptor is an interface descriptor */\n\t\tif (ptr[1] == 0x04) {\n\t\t\t/* Check if the interface number matches */\n\t\t\tif (ptr[2] == iface_num) {\n\t\t\t\t/* Check if the setting number matches */\n\t\t\t\tif (ptr[4] == setting_num)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t/* Move to the next descriptor */\n\t\tptr += ptr[0];\n\t}\n\n\t/* No matching interface descriptor was found */\n\treturn false;\n}", "CodeBleu_score": 20.325132666079348}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_req_get_wValue() & 0x0F;\n\tuint8_t ep_status;\n\n\tif (udc_req_get_wLength() != 1) {\n\t\treturn false;\n\t}\n\n\tif (ep_num == 0) {\n\t\tep_status = udc_hal_std_ep_get_stall_status(0);\n\t} else {\n\t\tep_status = udc_hal_std_ep_get_stall_status(ep_num);\n\t}\n\n\tudc_req_set_data(0, &ep_status, 1);\n\tudc_req_set_status(UDC_REQ_HANDLED);\n\treturn true;\n}", "CodeBleu_score": 21.22994636221144}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num;\n\tuint8_t ep_status;\n\tuint8_t ep_status_len;\n\n\tep_num = udc_req_get_wValue() & 0x0F;\n\tep_status = 0;\n\tep_status_len = 2;\n\n\tif (ep_num < UDC_EP_NUM) {\n\t\tif (udc_hal_is_endpoint_halted(ep_num)) {\n\t\t\tep_status = 1;\n\t\t}\n\t} else {\n\t\tudc_req_stall();\n\t\treturn false;\n\t}\n\n\tudc_req_set_data(ep_status, ep_status_len);\n\treturn true;\n}", "CodeBleu_score": 30.399846936854747}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_num = udc_req_std_get_ep_num();\n\tuint8_t ep_status = 0;\n\tif (udc_req_std_get_data_len() == sizeof(ep_status)) {\n\t\tif (ep_num == 0) {\n\t\t\tep_status = 1;\n\t\t} else {\n\t\t\tep_status = udc_hal_is_endpoint_halted(ep_num);\n\t\t}\n\t\tudc_hal_std_ep_set_data(ep_status, sizeof(ep_status));\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 28.42139761019634}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool ret = false;\n\n\t// Check if device is in configured state\n\tif (0 == udc_state) {\n\t\treturn false;\n\t}\n\n\t// Get interface and alternate setting number\n\tiface_num = udc_setup_pkt.wIndex;\n\tsetting_num = udc_setup_pkt.wValue;\n\n\t// Check if the interface and alternate setting number are valid\n\tif (udc_update_iface_desc(iface_num, setting_num)) {\n\t\t// Update to the default setting\n\t\tudc_set_interface(iface_num, 0);\n\t\t// Update to the current alternate setting\n\t\tudc_set_interface(iface_num, setting_num);\n\t\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\t\tret = udi_req_std_device_interface();\n\t}\n\treturn ret;\n}", "CodeBleu_score": 50.85217990933387}, {"code": "static bool udc_req_iface(void){\n\t\tusb_setup_pkt_t *ptr_setup;\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\t// Check if the device is in configured state\n\tif (0 == udc_dev_state) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tptr_setup = (usb_setup_pkt_t *) udc_ptr_ctrl_buffer;\n\tiface_num = ptr_setup->wIndex;\n\tsetting_num = ptr_setup->wValue;\n\tif (false == udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (false == udc_set_interface(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (false == udc_set_interface(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tudi_api_setup(ptr_setup);\n\n\treturn true;\n}", "CodeBleu_score": 56.25978220228398}, {"code": "static bool udc_req_iface(void){\n\t\tbool status;\n\n\t// Check if device is in configured state\n\tif (UDC_CONFIGURED != udc_state) {\n\t\treturn false;\n\t}\n\n\t// Check if interface is valid\n\tif (false == udc_update_iface_desc(udc_setup.index, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tstatus = udc_update_iface_desc(udc_setup.index, 0);\n\tif (false == status) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tstatus = udc_update_iface_desc(udc_setup.index,\n\t\t\tudc_setup.value.bAlternateSetting);\n\tif (false == status) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n\tstatus = udi_req_std_req_itf();\n\n\treturn status;\n}", "CodeBleu_score": 52.17353177121573}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t#if (UDI_MSC_DEBUG == 1)\n  uint32_t i;\n  uint8_t *p;\n#endif\n  // Check the transfer status\n  if (status != UDD_EP_TRANSFER_OK) {\n    // Error\n    // STALL the endpoint\n    udd_ep_set_halt(ep);\n    // Wait for a MSC setup reset to restart CBW reception\n    return;\n  }\n  // Check the amount of data sent\n  if (nb_sent > udi_msc_cbw.dCBWDataTransferLength) {\n    // Error\n    // STALL the endpoint\n    udd_ep_set_halt(ep);\n    // Wait for a MSC setup reset to restart CBW reception\n    return;\n  }\n  // Update the data residue in the CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n#if (UDI_MSC_DEBUG == 1)\n  // Print the data sent\n  p = (uint8_t *) udi_msc_cbw.CBWCB;\n  for (i = 0; i < nb_sent; i++) {\n    if (i % 16 == 0) {\n      osal_dbg_str(\"    \");\n    }\n    osal_dbg_str(\" \");\n    osal_dbg_hex(p[i]);\n  }\n  osal_dbg_str(\"\\r\n\");\n#endif\n  // Process the CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 54.54622318167524}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t", "CodeBleu_score": 15.883820043266303}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t", "CodeBleu_score": 15.883820043266303}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t//  uint16_t lun;\n  uint8_t direction;\n  uint8_t residue;\n  uint8_t * ptr;\n\n  // Get the direction of the request\n  direction = udi_msc_cbw.bCBWCB[0] & UDI_MSC_CBW_DIRECTION_MASK;\n\n  // Get the data residue\n  residue = udi_msc_cbw.dCBWDataResidue[0];\n  residue = residue | (udi_msc_cbw.dCBWDataResidue[1] << 8);\n\n  // Stall the appropriate endpoint\n  if (residue) {\n    if (direction == UDI_MSC_CBW_DIRECTION_IN) {\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  }\n\n  // Prepare CSW\n  udi_msc_csw.dCSWSignature[0] = UDI_MSC_CSW_SIGNATURE_0;\n  udi_msc_csw.dCSWSignature[1] = UDI_MSC_CSW_SIGNATURE_1;\n  udi_msc_csw.dCSWSignature[2] = UDI_MSC_CSW_SIGNATURE_2;\n  udi_msc_csw.dCSWSignature[3] = UDI_MSC_CSW_SIGNATURE_3;\n  udi_msc_csw.bCSWTag = udi_msc_cbw.bCBWTag;\n  udi_msc_csw.bCSWDataResidue[0] = residue;\n  udi_msc_csw.bCSWDataResidue[1] = residue >> 8;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 49.588263470697754}, {"code": "static void udi_msc_csw_process(void){\n\t// Process CSW\n  if (udi_msc_cbw.data_residue) {\n    // Data to be sent\n    if (udi_msc_cbw.data_dir) {\n      // IN transfer\n      // Stall the OUT endpoint\n      udi_msc_stall_ep(UDI_MSC_EP_OUT);\n    } else {\n      // OUT transfer\n      // Stall the IN endpoint\n      udi_msc_stall_ep(UDI_MSC_EP_IN);\n    }\n  }\n  // Prepare CSW\n  udi_msc_csw.signature = CSW_SIGNATURE;\n  udi_msc_csw.tag = udi_msc_cbw.tag;\n  udi_msc_csw.data_residue = udi_msc_cbw.data_residue;\n  udi_msc_csw.status = UDD_EP_STATUS(UDI_MSC_EP_IN);\n  udi_msc_csw_send();\n}", "CodeBleu_score": 50.626641389173784}, {"code": "static void udi_msc_csw_process(void){\n\t//  uint8_t residue;\n\n  // Get the data residue\n  // residue = udi_msc_cbw.dCBWDataTransferLength\n  //          - udi_msc_cbw.dCBWTransferLength;\n\n  // If there is a non-zero data residue\n  if (udi_msc_cbw.dCBWDataTransferLength\n          != udi_msc_cbw.dCBWTransferLength) {\n    // Stall the next request from the host on the appropriate endpoint\n    if (udi_msc_cbw.bmCBWFlags & CBW_DIR_IN) {\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  }\n\n  // Prepare CSW\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.bCSWStatus = CSW_STATUS_PASSED;\n  udi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength\n          - udi_msc_cbw.dCBWTransferLength;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 57.991095701728135}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\t// Check if the DTR signal is enabled\n\tif (b_enable) {\n\t\t// Check if the DTR rate is 1200\n\t\tif (cdc_line_coding[port].dwDTERate == 1200) {\n\t\t\t// Check if the DTR signal is disabled\n\t\t\tif (!cdc_dtr_enabled[port]) {\n\t\t\t\t// Enable the DTR signal\n\t\t\t\tcdc_dtr_enabled[port] = true;\n\t\t\t\t// Schedule a delayed system reset\n\t\t\t\treset_delay[port] = 1000;\n\t\t\t\treset_controller.write(RESET_CONTROLLER_RSTOUTn, RESET_CONTROLLER_RSTOUTn_MASK);\n\t\t\t}\n\t\t} else {\n\t\t\t// Disable the DTR signal\n\t\t\tcdc_dtr_enabled[port] = false;\n\t\t\t// Cancel any scheduled reset\n\t\t\treset_delay[port] = 0;\n\t\t\treset_controller.write(RESET_CONTROLLER_RSTOUTn, RESET_CONTROLLER_RSTOUTn_MASK);\n\t\t}\n\t} else {\n\t\t// Disable the DTR signal\n\t\tcdc_dtr_enabled[port] = false;\n\t\t// Cancel any scheduled reset\n\t\treset_delay[port] = 0;\n\t\treset_controller.write(RESET_CONTROLLER_RSTOUTn, RESET_CONTROLLER_RSTOUTn_MASK);\n\t}\n}", "CodeBleu_score": 26.405974714808522}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\n\tif (b_enable) {\n\t\tif (g_usb_cdc_port[port].dtr_rate == 1200) {\n\t\t\tif (!g_usb_cdc_port[port].dtr) {\n\t\t\t\tg_usb_cdc_port[port].dtr = true;\n\t\t\t\tif (g_usb_cdc_port[port].reset_scheduled) {\n\t\t\t\t\tcancelReset(port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (g_usb_cdc_port[port].dtr) {\n\t\t\tg_usb_cdc_port[port].dtr = false;\n\t\t\tif (g_usb_cdc_port[port].dtr_rate == 1200) {\n\t\t\t\tscheduleReset(port);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 34.32712650706991}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (port >= USB_CDC_PORT_COUNT) {\n\t\treturn;\n\t}\n\tif (b_enable) {\n\t\tif (usb_cdc_ports[port].dtr_rate_1200) {\n\t\t\tif (usb_cdc_ports[port].dtr) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusb_cdc_ports[port].dtr = true;\n\t\t\tif (usb_cdc_ports[port].reset_scheduled) {\n\t\t\t\tusb_cdc_ports[port].reset_scheduled = false;\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t} else {\n\t\t\tusb_cdc_ports[port].dtr = true;\n\t\t}\n\t} else {\n\t\tusb_cdc_ports[port].dtr = false;\n\t\tif (usb_cdc_ports[port].dtr_rate_1200) {\n\t\t\tusb_cdc_ports[port].reset_scheduled = true;\n\t\t\tscheduleReset(1000);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.867429570334984}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\tif (usb_control_request.bmRequestType == 0xA1 && usb_control_request.bRequest == 0x04) {\n\t\tif (usb_control_request.wValue == 0x0100 && usb_control_request.wIndex == 0x0004) {\n\t\t\tusb_control_request.payload = (uint8_t *)(&ms_os_20_desc);\n\t\t\tusb_control_request.payload_size = sizeof(ms_os_20_desc);\n\t\t\treturn true;\n\t\t} else if (usb_control_request.wValue == 0x0200 && usb_control_request.wIndex == 0x0004) {\n\t\t\tusb_control_request.payload = (uint8_t *)(&ms_ext_prop_desc);\n\t\t\tusb_control_request.payload_size = sizeof(ms_ext_prop_desc);\n\t\t\treturn true;\n\t\t}\n\t} else if (usb_control_request.bmRequestType == 0xA1 && usb_control_request.bRequest == 0x05) {\n\t\tif (usb_control_request.wValue == 0x0100 && usb_control_request.wIndex == 0x0004) {\n\t\t\tusb_control_request.payload = (uint8_t *)(&ms_os_20_desc);\n\t\t\tusb_control_request.payload_size = sizeof(ms_os_20_desc);\n\t\t\treturn true;\n\t\t} else if (usb_control_request.wValue == 0x0200 && usb_control_request.wIndex == 0x0004) {\n\t\t\tusb_control_request.payload = (uint8_t *)(&ms_ext_prop_desc);\n\t\t\tusb_control_request.payload_size = sizeof(ms_ext_prop_desc);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 20.83386662566457}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tuint8_t i;\n\tuint8_t dummy = 0;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tspiSend(dummy);\n\t\tbuf[i] = spiRec();\n\t}\n\tspiSend(dummy);\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 50.347367534795005}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint8_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 43.74166815898937}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\tuint8_t i;\n\tuint8_t temp;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\ttemp = spiRec();\n\t\tbuf[i] = temp;\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 46.118670107972136}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *pSrc, *pDest;\n\tuint32_t temp;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Get the address of the interrupt vector table\n\tpSrc = (uint32_t *) &__Vectors;\n\n\t// Get the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler) pSrc[irq];\n\n\t// Replace the current handler with the new handler\n\tpDest = (uint32_t *) &newHandler;\n\ttemp = pDest[0];\n\tpSrc[irq] = temp;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 47.900086766375274}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *pVectorTable;\n\n\t// Get the address of the interrupt vector table\n\tpVectorTable = (uint32_t *)SCB->VTOR;\n\n\t// Disable global interrupts to ensure atomic operation\n\t__disable_irq();\n\n\t// Save the current handler for the specified IRQ\n\toldHandler = (pfnISR_Handler)pVectorTable[irq];\n\n\t// Replace the current handler with the new handler\n\tpVectorTable[irq] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 49.03304793913173}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *vectorTable;\n\tuint32_t oldInterruptState;\n\n\t// Retrieve the address of the interrupt vector table\n\tvectorTable = (uint32_t *) SCB->VTOR;\n\n\t// Disable global interrupts\n\toldInterruptState = __get_PRIMASK();\n\t__disable_irq();\n\n\t// Retrieve the original handler for the specified IRQ\n\toldHandler = (pfnISR_Handler) vectorTable[irq];\n\n\t// Replace the old handler with the new handler\n\tvectorTable[irq] = (uint32_t) newHandler;\n\n\t// Re-enable global interrupts\n\t__set_PRIMASK(oldInterruptState);\n\n\t// Return the original handler\n\treturn oldHandler;\n}", "CodeBleu_score": 47.06825696235259}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.enabled) {\n    return emergency_parser.peek();\n  }\n#endif\n  return usb_serial.peek();\n}", "CodeBleu_score": 24.132096188283416}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(USE_USB_SERIAL)\n  if (serial_usb_enabled && serial_usb_connected) {\n    if (serial_usb_parser.available()) return serial_usb_parser.peek();\n    if (UHS_available()) return UHS_peek();\n  }\n#endif\n  return -1;\n}", "CodeBleu_score": 24.571324257212293}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available()) {\n    return emergency_parser.peek();\n  }\n#endif\n\n  if (serial_port.available()) {\n    int c = serial_port.read();\n    if (c >= 0) {\n      if (c == '\n')\n        serial_port.write('\\r');\n      serial_port.write(c);\n    }\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 29.965807496603574}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available()) return emergency_parser.read();\n#endif\n  if (!ENABLED(SERIAL_CDC_ENABLED)) return -1;\n  if (!cdc_serial_port) return -1;\n  if (!cdc_serial_port->is_open()) return -1;\n  if (!cdc_serial_port->available()) return -1;\n  return cdc_serial_port->read();\n}", "CodeBleu_score": 39.09617190351084}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (emergency_parser.enabled) {\n\t\tif (emergency_parser.available()) return emergency_parser.read();\n\t}\n\tif (!enabled) return -1;\n\tif (!configured) return -1;\n\tif (!available()) return -1;\n\tuint8_t c = USB_Read();\n\tif (emergency_parser.enabled) emergency_parser.update(c);\n\treturn c;\n}", "CodeBleu_score": 41.18654034809252}, {"code": "int MarlinSerialUSB::read(){\n\t\tif (rx_buffer_head != rx_buffer_tail) {\n\t\tint c = rx_buffer[rx_buffer_tail];\n\t\trx_buffer_tail = (rx_buffer_tail + 1) & (RX_BUFFER_SIZE - 1);\n\t\treturn c;\n\t}\n\tif (!cdc_enabled) return -1;\n\tif (!cdc_configured) return -1;\n\tif (cdc_rx_bytes_available == 0) return -1;\n\tint c = cdc_rx_buffer[cdc_rx_buffer_head];\n\tcdc_rx_buffer_head = (cdc_rx_buffer_head + 1) & (CDC_RX_BUFFER_SIZE - 1);\n\tcdc_rx_bytes_available--;\n\tif (parser_enabled) {\n\t\tif (c == 0x10) {\n\t\t\tif (parser_state == 0) {\n\t\t\t\tparser_state = 1;\n\t\t\t}\n\t\t\telse if (parser_state == 1) {\n\t\t\t\tparser_state = 2;\n\t\t\t}\n\t\t\telse if (parser_state == 2) {\n\t\t\t\tparser_state = 0;\n\t\t\t}\n\t\t}\n\t\telse if (c == 0x03) {\n\t\t\tparser_state = 0;\n\t\t}\n\t\telse if (parser_state == 1) {\n\t\t\tparser_state = 0;\n\t\t\tif (c == 0x1B) {\n\t\t\t\tparser_state = 1;\n\t\t\t}\n\t\t\telse if (c == 0x5B) {\n\t\t\t\tparser_state = 2;\n\t\t\t}\n\t\t}\n\t\telse if (parser_state == 2) {\n\t\t\tparser_state = 0;\n\t\t\tif (c == 0x33) {\n\t\t\t\tparser_state = 1;\n\t\t\t}\n\t\t\telse if (c == 0x3B) {\n\t\t\t\tparser_state = 2;\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}", "CodeBleu_score": 36.85739004432741}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t#if ENABLED(USE_USB_SERIAL)\n  int n = CDCInterface::available();\n  if (n) return n;\n#endif\n  return 0;\n}", "CodeBleu_score": 31.53893420110787}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (rx_buffer_head != rx_buffer_tail) {\n\t\treturn (rx_buffer_head - rx_buffer_tail + RX_BUFFER_SIZE) % RX_BUFFER_SIZE;\n\t}\n\telse if (cdc_enabled) {\n\t\treturn usb_cdc.available();\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 29.161604115800206}, {"code": "int MarlinSerialUSB::available(){\n\t\t// If there are characters in the receive buffer, return the count\n\tif (Serial.available()) {\n\t\treturn Serial.available();\n\t}\n\t// If the USB CDC is enabled and ready to receive data, return the appropriate status\n\telse if (usb_connected && usb_cdc_enabled && usb_cdc_connected) {\n\t\treturn 1;\n\t}\n\t// If there are no pending characters, return the appropriate status\n\telse {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 39.43757541651957}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n#ifdef PSTORE_DEBUG\n  Serial.print(F(\"Reading \"));\n  Serial.print(size);\n  Serial.print(F(\" bytes from position \"));\n  Serial.println(pos);\n#endif\n\n  // Read each byte\n  while (size--) {\n\n    // Read byte from storage\n    uint8_t data = ee_Read(pos);\n\n    // Update CRC\n    if (crc)\n      crc16(crc, &data, 1);\n\n    // Write to buffer if needed\n    if (value && writing)\n      *value++ = data;\n\n    // Increment position\n    ++pos;\n  }\n\n  return true;\n}", "CodeBleu_score": 50.626408008852216}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n#if defined(ESP8266)\n  uint8_t *pflash = (uint8_t*)getFlashStorage(curPage + curGroup * PagesPerGroup);\n#endif\n\n  // Read each byte from the storage\n  for (size_t i = 0; i < size; ++i) {\n\n    // Get the value from the storage\n    uint8_t v = ee_Read(pos);\n\n    // If we are writing, update the CRC\n    if (writing)\n      crc16(crc, &v, 1);\n\n    // If we are writing, update the value buffer\n    if (value)\n      value[i] = v;\n\n    // Increment the position\n    ++pos;\n  }\n\n  // Return true if we reached the end of the storage\n  return pos >= EEPROMSize;\n}", "CodeBleu_score": 50.98034306947443}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t\n#ifdef PERSISTENT_DEBUG\n  Serial.print(\"Reading data from flash at position \");\n  Serial.print(pos);\n  Serial.print(\" (\");\n  Serial.print(pos + size);\n  Serial.println(\")\");\n#endif\n\n  // Read data from the flash\n  for (uint16_t i = 0; i < size; i++) {\n\n    // Read the byte from the flash\n    uint8_t b = ee_Read(pos + i);\n\n    // If we are writing the data to the buffer\n    if (writing) {\n\n      // Update the value buffer\n      if (value != NULL)\n        value[i] = b;\n\n      // Update the CRC\n      if (crc != NULL)\n        crc16(crc, &b, 1);\n    }\n\n#ifdef PERSISTENT_DEBUG\n    Serial.print(\"Read byte 0x\");\n    Serial.print(b, HEX);\n    Serial.print(\" at position \");\n    Serial.println(pos + i);\n#endif\n  }\n\n  // Update the position\n  pos += size;\n\n  // Return \"false\"\n  return false;\n}", "CodeBleu_score": 44.71385063019518}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if defined(ESP32)\n  if (WITHIN(pin, 32, 39)) {\n    ledcWrite(pin - 32, value);\n    return;\n  }\n#endif\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    uint8_t v = value;\n    if (v > 0) v = (v * 1023) / 65535;\n    ledcWrite(cid, v);\n  }\n}", "CodeBleu_score": 35.73969308933355}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#if defined(ARDUINO_ARCH_ESP32)\n  if (!WITHIN(pin, 1, 34)) return; // Not a hardware PWM pin!\n#else\n  if (!WITHIN(pin, 1, 19)) return; // Not a hardware PWM pin!\n#endif\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n  else {\n    uint8_t *p = pwm_state_for_pin(pin);\n    if (p == NULL) {\n      p = pwm_state_alloc();\n      if (p == NULL) return;\n      pwm_state_init(p, pin, freq, res);\n    }\n    p[PWM_STATE_VALUE] = value;\n    p[PWM_STATE_PIN_COUNT]++;\n  }\n}", "CodeBleu_score": 47.19328771997805}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t#ifdef WITH_SOFTWARE_PWM\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid < 0) return;\n  uint32_t duty = (uint32_t)value * (uint32_t)pwmInfo[cid / 2].res / 256;\n  if (duty == 0) {\n    ledcDetachPin(pin);\n    chan_pin[cid] = 0;\n    pwmInfo[cid / 2].freq = 0;\n    pwmInfo[cid / 2].res = 0;\n  }\n  else {\n    ledcWrite(cid, duty);\n    pwmInfo[cid / 2].duty = duty;\n  }\n#else\n  ledcWrite(pin, value);\n#endif\n}", "CodeBleu_score": 42.63564358219137}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n#ifdef SERVO_DELAY_ARRAY_LENGTH\n  static_assert(SERVO_DELAY_ARRAY_LENGTH >= NUM_SERVOS, \"Servo delay array length is too small. Increase SERVO_DELAY_ARRAY_LENGTH.\");\n#endif\n  if (channel >= 0) {\n    if (value < MIN_ANGLE) value = MIN_ANGLE;\n    if (value > MAX_ANGLE) value = MAX_ANGLE;\n    degrees = value;\n    int us = map(degrees, MIN_ANGLE, MAX_ANGLE, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);\n    int duty = map(us, 0, TAU_USEC, 0, MAX_COMPARE);\n    ledcWrite(channel, duty);\n#ifdef SERVO_DELAY_ARRAY_LENGTH\n    safe_delay(servo_delay[channel]);\n#endif\n  }\n}", "CodeBleu_score": 44.28749549702916}, {"code": "void Servo::move(const int value){\n\t#if (DEACTIVATE_SERVOS_AFTER_MOVE)\n  detach();\n#endif\n#if (SERVO_DELAY_ARRAY_LENGTH > 0)\n  static_assert(SERVO_DELAY_ARRAY_LENGTH >= NUM_SERVOS, \"SERVO_DELAY_ARRAY_LENGTH must be greater than or equal to NUM_SERVOS\");\n#endif\n  if (value < MIN_ANGLE || value > MAX_ANGLE) {\n    return;\n  }\n  if (channel >= 0) {\n    write(value);\n#if (SERVO_DELAY_ARRAY_LENGTH > 0)\n    safe_delay(servo_delay[channel]);\n#else\n    safe_delay(SERVO_DELAY);\n#endif\n  }\n#if (DEACTIVATE_SERVOS_AFTER_MOVE)\n  attach(pin);\n#endif\n}", "CodeBleu_score": 46.62208295232257}, {"code": "void Servo::move(const int value){\n\t#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n  detach();\n#endif\n  static_assert(SERVO_DELAY_ARRAY_LENGTH >= SERVO_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be at least as large as SERVO_COUNT\");\n  safe_delay(SERVO_DELAY_ARRAY[value]);\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n  attach();\n#endif\n}", "CodeBleu_score": 42.38611587012049}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\t// for each pin\n\tfor (uint8_t i = 0; i < NUM_PWM_PINS; i++) {\n\t\t// if the pin has active PWM\n\t\tif (pwm_pin_states[i].duty_cycle) {\n\t\t\t// toggle the pin state\n\t\t\tpwm_pin_states[i].pin_state = !pwm_pin_states[i].pin_state;\n\t\t\t// set the tick count for the next transition\n\t\t\tpwm_pin_states[i].tick_count = pwm_pin_states[i].duty_cycle;\n\t\t}\n\t\t// decrement the tick count\n\t\tpwm_pin_states[i].tick_count--;\n\t\t// store the updated pin state\n\t\tpwm_dma_buffer[pwm_dma_buffer_pos][i] = pwm_pin_states[i].pin_state;\n\t}\n\t// store the updated port data into the current position of the DMA buffer\n\ti2s_write_sample(pwm_dma_buffer[pwm_dma_buffer_pos], 0);\n\t// increment the buffer position\n\tpwm_dma_buffer_pos = (pwm_dma_buffer_pos + 1) % NUM_PWM_DMA_BUFFERS;\n}", "CodeBleu_score": 30.990705750571546}, {"code": "void i2s_push_sample(){\n\t\tfor (int i = 0; i < NUM_PINS; i++) {\n\t\tif (pwm_states[i].duty_cycle > 0) {\n\t\t\tif (pwm_states[i].tick_count == 0) {\n\t\t\t\tpwm_states[i].tick_count = pwm_states[i].duty_cycle;\n\t\t\t\tpwm_states[i].pin_state = !pwm_states[i].pin_state;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpwm_states[i].tick_count--;\n\t\t\t}\n\t\t}\n\t\tport_data[i] = pwm_states[i].pin_state;\n\t}\n\ti2s_write_sample(port_data, port_data_length);\n}", "CodeBleu_score": 34.854244578560326}, {"code": "void i2s_push_sample(){\n\t\tuint8_t i;\n\tuint8_t *port_data;\n\tuint16_t *dma_data;\n\tuint16_t sample;\n\tuint32_t pin_mask;\n\tuint32_t pin_state;\n\tuint32_t pin_duty;\n\n\tport_data = (uint8_t *) &i2s_port_data;\n\tdma_data = (uint16_t *) &i2s_dma_data;\n\n\tfor (i = 0; i < I2S_PIN_COUNT; i++) {\n\t\tpin_mask = 1 << i;\n\t\tpin_state = i2s_port_state & pin_mask;\n\t\tpin_duty = i2s_pin_duty_cycle[i];\n\n\t\tif (pin_duty) {\n\t\t\tif (pin_state) {\n\t\t\t\tif (i2s_pin_tick_count[i] == 0) {\n\t\t\t\t\ti2s_pin_tick_count[i] = pin_duty;\n\t\t\t\t\ti2s_port_state ^= pin_mask;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pin_tick_count[i]--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (i2s_pin_tick_count[i] == 0) {\n\t\t\t\t\ti2s_pin_tick_count[i] = pin_duty;\n\t\t\t\t\ti2s_port_state ^= pin_mask;\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pin_tick_count[i]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsample = (i2s_port_state & pin_mask) << (i * 2);\n\t\t*dma_data = sample;\n\t\tdma_data++;\n\t}\n\n\ti2s_dma_data_count++;\n}", "CodeBleu_score": 31.857185260570116}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\treturn 0;\n}", "CodeBleu_score": 6.769084640356114}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tuint32_t timer_value = 0;\n\tuint32_t prescaler = 0;\n\tuint32_t reload_value = 0;\n\tuint32_t counter_value = 0;\n\tuint32_t timer_clock_freq = 0;\n\tuint32_t reload_value_offset = 0;\n\tuint32_t counter_value_offset = 0;\n\n\tif (timer_num >= HAL_TIMER_NUM) {\n\t\treturn 0;\n\t}\n\n\ttimer_clock_freq = HAL_timer_get_clock_freq(timer_num);\n\tprescaler = HAL_timer_get_prescaler(timer_num);\n\treload_value = HAL_timer_get_reload_value(timer_num);\n\tcounter_value = HAL_timer_get_counter_value(timer_num);\n\n\treload_value_offset = HAL_timer_get_reload_value_offset(timer_num);\n\tcounter_value_offset = HAL_timer_get_counter_value_offset(timer_num);\n\n\ttimer_value = (reload_value - reload_value_offset) * (counter_value - counter_value_offset) / timer_clock_freq;\n\n\treturn timer_value;\n}", "CodeBleu_score": 33.80983081649103}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tif (timer_num >= HAL_TIMER_NUM) {\n\t\treturn HAL_TIMER_ERROR;\n\t}\n\n\treturn HAL_TIMER_COUNT[timer_num];\n}", "CodeBleu_score": 20.38971026653458}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t#ifdef DEBUG\n  Serial.print(\"read_data: pos=\");\n  Serial.print(pos);\n  Serial.print(\", size=\");\n  Serial.print(size);\n  Serial.print(\", writing=\");\n  Serial.println(writing);\n#endif\n  if (pos + size > EEPROM_SIZE) {\n    return false;\n  }\n  if (writing) {\n    for (size_t i = 0; i < size; i++) {\n      value[i] = EEPROM.read(pos + i);\n    }\n  }\n  if (crc != NULL) {\n    crc16(crc, value, size);\n  }\n  pos += size;\n  return true;\n}", "CodeBleu_score": 60.61258254771719}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t#ifdef DEBUG\n  Serial.print(\"Reading data at position \");\n  Serial.print(pos);\n  Serial.print(\" of size \");\n  Serial.println(size);\n#endif\n  uint8_t *ptr = value;\n  for (size_t i = 0; i < size; i++) {\n    if (pos >= EEPROM_SIZE) {\n#ifdef DEBUG\n      Serial.println(\"End of EEPROM reached\");\n#endif\n      return false;\n    }\n    uint8_t data = EEPROM.read(pos);\n    if (writing)\n      *ptr++ = data;\n    if (crc)\n      *crc = (uint16_t)(*crc ^ (uint16_t)(data << 8));\n    pos++;\n  }\n  return true;\n}", "CodeBleu_score": 49.96532392209518}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t#if (defined(ESP32) || defined(ESP8266))\n  uint8_t *ptr = (uint8_t *)value;\n  for (size_t i = 0; i < size; i++) {\n    if (pos + i >= _size)\n      return false;\n    uint8_t v = EEPROM.read(pos + i);\n    if (writing)\n      *ptr++ = v;\n    if (crc)\n      *crc = (uint16_t)(*crc ^ (uint16_t)(v << 8));\n    for (uint8_t j = 0; j < 8; j++)\n      *crc = (uint16_t)((*crc & 0x8000) ? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n  }\n  pos += size;\n#endif\n  return false;\n}", "CodeBleu_score": 53.52702773227771}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (handle == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint32_t retries = 0;\n\tuint32_t ret = 0;\n\n\twhile (retries < 3) {\n\t\tret = HAL_SD_WriteBlocks(handle, (uint8_t *)src, block, 1);\n\t\tif (ret != HAL_OK) {\n\t\t\tretries++;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprintf(\"SD write error: %lu\n\", ret);\n\treturn false;\n}", "CodeBleu_score": 37.966728920615026}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (block == 0 || src == NULL) {\n\t\treturn false;\n\t}\n\n\tuint32_t retry = 0;\n\tbool status = false;\n\n\twhile (retry < 10) {\n\t\tstatus = SDIO_WriteBytes(block, src, 512);\n\t\tif (status) {\n\t\t\tbreak;\n\t\t}\n\t\tretry++;\n\t}\n\n\tif (!status) {\n\t\tprintf(\"Failed to write block %d\n\", block);\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 28.84360667684073}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (!sdio_handle || !src) {\n\t\treturn false;\n\t}\n\n\t// Try to write the block, retrying up to \"SD_MAX_RETRIES\" times\n\tfor (uint32_t i = 0; i < SD_MAX_RETRIES; i++) {\n\t\t// Write the block\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, src, block, 1) == SD_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// If all retries fail, print an error message\n\tprintf(\"SD write error\n\");\n\treturn false;\n}", "CodeBleu_score": 27.83459137158111}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tassert(timer_num < NUM_TIMERS);\n\n\t// Set the timer frequency\n\tTIM_TypeDef *timer = TIM_CHANNEL_TO_TIMER[timer_num];\n\tuint32_t prescaler = (uint32_t)((SystemCoreClock / 1000000) - 1);\n\tuint32_t period = (uint32_t)((SystemCoreClock / frequency) - 1);\n\n\t// Set the timer prescaler and period\n\ttimer->PSC = prescaler;\n\ttimer->ARR = period;\n\n\t// Set the timer channel callback priority\n\tif (timer_num == TEMP_TIMER_CHANNEL) {\n\t\tHAL_timer_set_callback_priority(TEMP_TIMER_CHANNEL, TEMP_TIMER_PRIORITY);\n\t} else if (timer_num == STEP_TIMER_CHANNEL) {\n\t\tHAL_timer_set_callback_priority(STEP_TIMER_CHANNEL, STEP_TIMER_PRIORITY);\n\t} else {\n\t\t// This should never happen\n\t\tassert(0);\n\t}\n\n\t// Enable the timer\n\ttimer->CR1 |= TIM_CR1_CEN;\n}", "CodeBleu_score": 41.23099404410693}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER) {\n\t\tassert(frequency > 0);\n\t\tassert(frequency <= TEMP_TIMER_FREQ_HZ);\n\t\tHAL_TIM_Base_Start_IT(&htim2, TEMP_TIMER_PRESCALE);\n\t\tHAL_NVIC_SetPriority(TIM2_IRQn, TEMP_TIMER_PRIORITY, 0);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tassert(frequency > 0);\n\t\tassert(frequency <= STEP_TIMER_FREQ_HZ);\n\t\tHAL_TIM_Base_Start_IT(&htim1, STEP_TIMER_PRESCALE);\n\t\tHAL_NVIC_SetPriority(TIM1_UP_IRQn, STEP_TIMER_PRIORITY, 0);\n\t} else {\n\t\tassert(0);\n\t}\n}", "CodeBleu_score": 40.509155161617194}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tassert(timer_num < TIMER_CHANNEL_NUM);\n\tassert(frequency > 0);\n\tassert(timer_num != TIMER_CHANNEL_TEMP);\n\n\tif (timer_num == TIMER_CHANNEL_STEP) {\n\t\tHAL_timer_stop(TIMER_CHANNEL_STEP);\n\t\tHAL_timer_stop(TIMER_CHANNEL_TEMP);\n\t\tHAL_timer_start_step(frequency);\n\t} else if (timer_num == TIMER_CHANNEL_TEMP) {\n\t\tHAL_timer_stop(TIMER_CHANNEL_STEP);\n\t\tHAL_timer_stop(TIMER_CHANNEL_TEMP);\n\t\tHAL_timer_start_temp(frequency);\n\t} else {\n\t\tHAL_timer_stop(timer_num);\n\t\tHAL_timer_start_step(frequency);\n\t\tHAL_timer_start_temp(frequency);\n\t}\n}", "CodeBleu_score": 47.149923265615776}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tif (this->eeprom_file.open(this->eeprom_file_name, FILE_READ)) {\n\t\tthis->eeprom_file.seek(0, FILE_END);\n\t\tthis->eeprom_file_size = this->eeprom_file.position();\n\t\tif (this->eeprom_file_size < EEPROM_SIZE) {\n\t\t\tthis->eeprom_file.write(this->eeprom_erase_value);\n\t\t\tthis->eeprom_file.seek(0, FILE_END);\n\t\t}\n\t\tthis->eeprom_file.seek(0);\n\t\tthis->eeprom_file.read(this->eeprom_buffer, EEPROM_SIZE);\n\t\tthis->eeprom_file.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 20.05092361819571}, {"code": "bool PersistentStore::access_start(){\n\t\tif (eeprom.begin(EEPROM_SIZE)) {\n\t\tSerial.println(\"EEPROM initialized\");\n\t\tFile file = SPIFFS.open(EEPROM_FILENAME, \"r+\");\n\t\tif (file) {\n\t\t\tSerial.println(\"File opened\");\n\t\t\tif (file.size() < EEPROM_SIZE) {\n\t\t\t\tSerial.println(\"File too small, filling remainder with default erase value\");\n\t\t\t\tfor (uint16_t i = file.size(); i < EEPROM_SIZE; i++) {\n\t\t\t\t\teeprom.write(i, EEPROM_ERASE_VALUE);\n\t\t\t\t}\n\t\t\t}\n\t\t\teeprom.readBlock(0, file);\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t} else {\n\t\t\tSerial.println(\"File not found\");\n\t\t}\n\t} else {\n\t\tSerial.println(\"EEPROM not initialized\");\n\t}\n\treturn false;\n}", "CodeBleu_score": 30.943416579070682}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open the EEPROM file.\n\tif (access_file == NULL) {\n\t\taccess_file = fopen(access_filename, \"r+b\");\n\t\tif (access_file == NULL) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// Check the file size.\n\tfseek(access_file, 0, SEEK_END);\n\taccess_file_size = ftell(access_file);\n\tfseek(access_file, 0, SEEK_SET);\n\t// If the file is smaller than the expected EEPROM size, fill the remainder of the buffer with a default erase value.\n\tif (access_file_size < EEPROM_SIZE) {\n\t\tmemset(access_buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n\t}\n\t// Read the file's contents into the buffer.\n\tfread(access_buffer, 1, EEPROM_SIZE, access_file);\n\treturn true;\n}", "CodeBleu_score": 35.77908615815559}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t r = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPIx_MOSI_GPIO_Port, SPIx_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPIx_MOSI_GPIO_Port, SPIx_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPIx_MISO_GPIO_Port, SPIx_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tr |= 1 << i;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn r;\n}", "CodeBleu_score": 38.0219247156434}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t data = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPIx_MOSI_GPIO_Port, SPIx_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPIx_MOSI_GPIO_Port, SPIx_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPIx_SCK_GPIO_Port, SPIx_SCK_Pin, GPIO_PIN_SET);\n\t\tdata <<= 1;\n\t\tif (HAL_GPIO_ReadPin(SPIx_MISO_GPIO_Port, SPIx_MISO_Pin) == GPIO_PIN_SET) {\n\t\t\tdata |= 0x01;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn data;\n}", "CodeBleu_score": 37.85824517835439}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t out = 0;\n\tuint8_t in;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI1_MOSI_GPIO_Port, SPI1_MOSI_Pin, GPIO_PIN_RESET);\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(SPI1_SCK_GPIO_Port, SPI1_SCK_Pin, GPIO_PIN_SET);\n\t\tin = HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin);\n\t\tif (in) {\n\t\t\tout |= 1 << i;\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn out;\n}", "CodeBleu_score": 37.93190252335524}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\t/* Enable the AHB clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the AHB clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 84.07596204999733}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\tif (RCC_AHBPeriph > RCC_AHBPeriph_DMA2) {\n\t\treturn;\n\t}\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 53.70656180373332}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState != DISABLE) {\n\t\t/* Enable the AHB clock */\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\t/* Disable the AHB clock */\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 84.07596204999733}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Read the received byte\n\tuint8_t c = obj->serial->read();\n\n\t// Check for a parity error\n\tif (obj->serial->get_status() & US_PAR_ERROR) {\n\t\t// Ignore the received byte\n\t\treturn;\n\t}\n\n\t// Update the receive buffer\n\tif (obj->rx_buffer_head != obj->rx_buffer_tail) {\n\t\t// Update the receive buffer\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\t// Increment the buffer head\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t}\n\n\t// Update the emergency parser\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser->update(c);\n\t}\n}", "CodeBleu_score": 41.135496851015176}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tif (obj->rx_buffer_head != obj->rx_buffer_tail) {\n\t\tif (obj->rx_buffer_head + 1 == obj->rx_buffer_tail) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t} else {\n\t\t\tobj->rx_buffer_head++;\n\t\t}\n\t} else {\n\t\tif (obj->rx_buffer_head == RX_BUFFER_SIZE - 1) {\n\t\t\tobj->rx_buffer_head = 0;\n\t\t} else {\n\t\t\tobj->rx_buffer_head++;\n\t\t}\n\t}\n\tobj->rx_buffer[obj->rx_buffer_head] = obj->rx_buffer_tail;\n\tobj->rx_buffer_tail = 0;\n\tif (obj->rx_emergency_parser_enabled) {\n\t\tobj->rx_emergency_parser.parse(obj->rx_buffer[obj->rx_buffer_head]);\n\t}\n}", "CodeBleu_score": 27.04935100731}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c;\n\n\tc = obj->hw->read(obj->index);\n\tif (obj->rx_buffer.head + 1 >= RX_BUFFER_SIZE) {\n\t\tobj->rx_buffer.head = 0;\n\t} else {\n\t\tobj->rx_buffer.head++;\n\t}\n\tobj->rx_buffer.buffer[obj->rx_buffer.head] = c;\n\tif (obj->emergency_parser) {\n\t\tobj->emergency_parser->input(c);\n\t}\n}", "CodeBleu_score": 35.08223575760743}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t", "CodeBleu_score": 2.7080419141460643}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (HAL_timer_is_initialized(MF_TIMER_STEP) && !HAL_timer_has_interrupt(MF_TIMER_STEP)) {\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_STEP, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (HAL_timer_is_initialized(MF_TIMER_TEMP) && !HAL_timer_has_interrupt(MF_TIMER_TEMP)) {\n\t\t\tHAL_timer_attach_interrupt(MF_TIMER_TEMP, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.62299201600688}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\t//Check if timer is initialized\n\tif (timer_num < MF_TIMER_NUM) {\n\t\t//Check if timer lacks interrupt\n\t\tif (HAL_timer_get_interrupt_flag(timer_num) == 0) {\n\t\t\t//Attach appropriate interrupt handler\n\t\t\tif (timer_num == MF_TIMER_STEP) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t\t}\n\t\t\telse if (timer_num == MF_TIMER_TEMP) {\n\t\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.31010103529637}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\thashsep, pow := HashStrRev(sep)\n\thash := HashStrRev(s[:len(s)-len(sep)])\n\tif hash == hashsep && s[len(s)-len(sep):] == sep {\n\t\treturn len(s) - len(sep)\n\t}\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK - pow*uint32(s[i]) + uint32(s[i+len(sep)])\n\t\tif hash == hashsep && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 45.66332579584157}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tif n == 0 {\n\t\treturn -1\n\t}\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\thsep, pow := HashStrRev(sep)\n\th := uint32(0)\n\tfor i := 0; i < m; i++ {\n\t\th = h*PrimeRK + uint32(s[n-m+i])\n\t}\n\tif h == hsep && Equal(s[n-m:], sep) {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i]) - pow*uint32(s[i+m])\n\t\tif h == hsep && Equal(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 55.34878677823478}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\t// Calculate the hash of the substring.\n\thashsep, pow := HashStrRev[T](sep)\n\t// Calculate the hash of the substring in the main string.\n\tvar hash uint32\n\tfor i := 0; i < m; i++ {\n\t\thash = hash*PrimeRK + uint32(s[n-m+i])\n\t}\n\tif hash == hashsep && s[n-m:] == sep {\n\t\treturn n - m\n\t}\n\t// Calculate the hash of the substring in the main string from the end towards the beginning.\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(s[i]) - pow*uint32(s[i+m])\n\t\tif hash == hashsep && s[i:i+m] == sep {\n\t\t\treturn i\n\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 51.68000134880168}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tusbcdc.ep.DisableOut()\n\tusbcdc.ep.DisableIn()\n\n\t// Check if there is data to send\n\tif len(usbcdc.txBuf) > 0 {\n\t\t// Send the data\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data to send\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore interrupt mask\n\tusbcdc.ep.EnableOut()\n\tusbcdc.ep.EnableIn()\n}", "CodeBleu_score": 38.646881401353426}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tusbcdc.Uart.InterruptDisable()\n\t// Check if there is data in the transmit buffer\n\tif len(usbcdc.txBuf) > 0 {\n\t\t// Send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t}\n\t// No data available\n\tusbcdc.waitTxc = false\n\t// Restore interrupts\n\tusbcdc.Uart.InterruptEnable()\n}", "CodeBleu_score": 32.425893490345175}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tusbcdc.ep.SetIntMask(0)\n\t// Check if there is data to send\n\tif len(usbcdc.txbuf) > 0 {\n\t\t// Send the data\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data to send, so wait for the next time\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore the interrupt mask\n\tusbcdc.ep.SetIntMask(usb.EP_INT_IN)\n}", "CodeBleu_score": 37.33082311492857}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.dev.CTRL.reg = 0\n\ti2c.dev.ADDR.reg = address<<1 | uint32(write)\n\ti2c.dev.CTRL.reg = I2C_CTRL_START\n\tfor i := 0; i < 1000; i++ {\n\t\tif i2c.dev.STATUS.reg&I2C_STATUS_START == 0 {\n\t\t\treturn\n\t\t}\n\t}\n\tpanic(\"I2C: timeout waiting for start condition\")\n}", "CodeBleu_score": 21.82632159125634}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.bus.SetControl(0)\n\ti2c.bus.SetSDA(0)\n\ti2c.bus.SetSCL(0)\n\ti2c.bus.SetControl(I2C_START)\n\tfor i := 0; i < 100000; i++ {\n\t\tif i2c.bus.GetControl()&I2C_START != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tif write {\n\t\ti2c.bus.SetSDA(address << 1)\n\t} else {\n\t\ti2c.bus.SetSDA((address << 1) | 1)\n\t}\n\ti2c.bus.SetSCL(1)\n\ti2c.bus.SetSCL(0)\n}", "CodeBleu_score": 32.48667738232487}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Set the control register to clear the interrupt flag\n\ti2c.control.Set(0)\n\t// Put a start condition on the SDA line\n\ti2c.sda.Set(0)\n\ttime.Sleep(time.Microsecond)\n\t// Enable the I2C module\n\ti2c.enable.Set(1)\n\t// Wait for the start condition to be transmitted\n\tfor i := 0; i < 10000; i++ {\n\t\tif i2c.control.Get()&0x08 != 0 {\n\t\t\treturn\n\t\t}\n\t}\n\tpanic(\"I2C: timeout waiting for start condition\")\n}", "CodeBleu_score": 31.45306893303268}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\n\t// Check if the flash is busy.\n\tif f.busy() {\n\t\treturn errors.New(\"Flash is busy\")\n\t}\n\n\t// Calculate the start address.\n\taddr := start * f.blockSize\n\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Wait for any ongoing flash operations to complete.\n\t\tf.wait()\n\n\t\t// Erase the block.\n\t\tf.flash.EraseBlock(addr)\n\n\t\t// Wait until the flash is no longer busy.\n\t\tf.wait()\n\n\t\t// Increment the address.\n\t\taddr += f.blockSize\n\t}\n\n\t// Set the flash to read mode.\n\tf.flash.SetReadMode()\n\n\t// Return success.\n\treturn nil\n}", "CodeBleu_score": 28.595742819442272}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\n\t// Calculate the start address of the block to erase.\n\tstartAddress := uint32(start * f.blockSize)\n\n\t// Wait for any ongoing flash operations to complete.\n\tf.busy.Wait()\n\n\t// Erase each block.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Set the flash to erase mode.\n\t\terr := f.writeCommand(flashEraseCommand)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Write the start address of the block to erase.\n\t\terr = f.writeAddress(startAddress)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the flash to be ready.\n\t\tf.busy.Wait()\n\t}\n\n\t// Set the flash to read mode.\n\terr := f.writeCommand(flashReadCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 33.99119945099511}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\n\tstartAddress := start * f.blockSize\n\tendAddress := startAddress + len * f.blockSize\n\terr := f.erase(startAddress, endAddress)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 24.346861585694175}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\n\t// Check if the write exceeds the flash memory bounds.\n\tend := off + int64(len(p))\n\tif end > int64(f.size) {\n\t\treturn 0, errors.New(\"write exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\tstart := off &^ (int64(f.blockSize) - 1)\n\n\t// Pad the byte slice to fit the write block size.\n\tpadLen := int(start + int64(f.blockSize) - off)\n\tp = append(p, make([]byte, padLen)...)\n\n\t// Enable write mode on the flash memory controller.\n\terr = f.enableWrite()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Write the data in blocks.\n\tfor i := start; i < end; i += int64(f.blockSize) {\n\t\t// Write a block of data.\n\t\terr = f.writeBlock(i, p[i-start:i-start+int64(f.blockSize)])\n\t\tif err != nil {\n\t\t\treturn int(i - start), err\n\t\t}\n\n\t\t// Wait for the flash memory to be ready after each write operation.\n\t\terr = f.waitForReady()\n\t\tif err != nil {\n\t\t\treturn int(i - start), err\n\t\t}\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 32.54803524098011}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"write exceeds device bounds\")\n\t}\n\tstart := off &^ (f.writeBlockSize - 1)\n\tpadLen := f.writeBlockSize - (len(p) % f.writeBlockSize)\n\tp = append(p, make([]byte, padLen)...)\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tf.enableWrite()\n\t\tf.writeBlock(p[i : i+f.writeBlockSize], start+int64(i))\n\t\tf.waitForReady()\n\t}\n\treturn len(p) - padLen, nil\n}", "CodeBleu_score": 30.45865608262035}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif off+int64(len(p)) > int64(f.Size()) {\n\t\treturn 0, errors.New(\"write exceeds device size\")\n\t}\n\taddr := f.startAddr + uint32(off)\n\tp = padToBlockSize(p, f.blockSize)\n\tf.writeMode()\n\tfor len(p) > 0 {\n\t\tf.writeBlock(addr, p[:f.blockSize])\n\t\taddr += uint32(f.blockSize)\n\t\tp = p[f.blockSize:]\n\t}\n\tf.waitReady()\n\treturn len(p), nil\n}", "CodeBleu_score": 28.994996461835072}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Attempt to duplicate the file descriptor.\n\tfdDup, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %s\", err)\n\t}\n\n\t// Check for errors.\n\tif err = checkFd(fdDup); err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Attempt to open the directory.\n\tdirPtr := syscall.Fdopendir(fdDup)\n\tif dirPtr == 0 {\n\t\terr = syscall.GetErrno()\n\t\tif err == syscall.EINTR {\n\t\t\t// Attempt to open the directory again.\n\t\t\tdirPtr = syscall.Fdopendir(fdDup)\n\t\t\tif dirPtr == 0 {\n\t\t\t\terr = syscall.GetErrno()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Close the duplicated file descriptor.\n\tsyscall.Close(fdDup)\n\n\t// Check for errors.\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %s\", err)\n\t}\n\n\t// Return the directory pointer.\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 52.38826442095088}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Attempt to duplicate the file descriptor.\n\tfdDup, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(fdDup)\n\n\t// Check for errors.\n\tif err = checkError(fdDup); err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory.\n\tdirPtr, err := syscall.Fdopendir(fdDup)\n\tif err != nil && err != syscall.EINTR {\n\t\treturn 0, \"\", err\n\t}\n\n\treturn dirPtr, \"\", nil\n}", "CodeBleu_score": 62.39997823173367}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tif fd < 0 {\n\t\treturn 0, \"\", fmt.Errorf(\"invalid file descriptor: %d\", fd)\n\t}\n\n\t// Duplicate the file descriptor to avoid closing it.\n\tfdDup, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to duplicate file descriptor: %w\", err)\n\t}\n\tdefer syscall.Close(fdDup)\n\n\t// Attempt to open the directory using \"syscall.Fdopendir\".\n\tdirPtr, err := syscall.Fdopendir(fdDup)\n\tif err == nil {\n\t\treturn dirPtr, \"\", nil\n\t}\n\n\t// If an error other than \"syscall.EINTR\" occurs, return the error message.\n\tif err != syscall.EINTR {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %w\", err)\n\t}\n\n\t// If \"syscall.EINTR\" occurs, repeatedly attempt to open the directory until it either succeeds or encounters an error other than \"syscall.EINTR\".\n\tfor {\n\t\tdirPtr, err = syscall.Fdopendir(fdDup)\n\t\tif err == nil {\n\t\t\treturn dirPtr, \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open directory: %w\", err)\n\t\t}\n\t}\n}", "CodeBleu_score": 51.46432187890928}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tuint32_t size = 0;\n\tesp_partition_t *partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, NULL);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\tsize = partition->size - partition->label->offset - partition->label->size;\n\t} else {\n\t\tsize = partition->label->size;\n\t}\n\treturn size;\n}", "CodeBleu_score": 35.884381771321074}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t", "CodeBleu_score": 2.073033576343574}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_partition_t* partition = esp_partition_find_first(ESP_PARTITION_TYPE_DATA, ESP_PARTITION_SUBTYPE_DATA_FAT, NULL);\n\tif (partition == NULL) {\n\t\treturn 0;\n\t}\n\tif (response) {\n\t\treturn partition->size - partition->label->offset - partition->label->size;\n\t}\n\treturn partition->label->size;\n}", "CodeBleu_score": 28.413216145209674}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t\tsize_t required_sectors = msc_update_get_required_disk_sectors();\n\tif (required_sectors == 0) {\n\t\treturn false;\n\t}\n\tuint32_t required_bytes = required_sectors * DISK_SECTOR_SIZE;\n\tlog_d(\"Allocating %u bytes for disk\", required_bytes);\n\tmsc_disk = heap_caps_malloc(required_bytes, MALLOC_CAP_SPIRAM);\n\tif (msc_disk == NULL) {\n\t\tlog_e(\"Failed to allocate %u bytes for disk\", required_bytes);\n\t\treturn false;\n\t}\n\tlog_d(\"Initializing FATFS\");\n\tif (f_mount(&msc_fs, \"\", 1) != FR_OK) {\n\t\tlog_e(\"Failed to initialize FATFS\");\n\t\treturn false;\n\t}\n\tlog_d(\"Initializing boot sector\");\n\tif (mcs_is_fat16) {\n\t\tif (mcs_init_fat16_boot_sector(msc_disk, volume_label, serial_number, required_sectors) != ESP_OK) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (mcs_init_fat12_boot_sector(msc_disk, volume_label, serial_number, required_sectors) != ESP_OK) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (msc_run_partition) {\n\t\tif (mcs_add_file_entry(msc_run_partition, \"firmware.bin\") != ESP_OK) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.682977589172886}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err = ESP_OK;\n\tuint32_t sector_size = esp_partition_get_erase_size(partition);\n\tuint32_t sector_start = offset & ~(sector_size - 1);\n\tuint32_t sector_end = ((offset + size - 1) & ~(sector_size - 1)) + sector_size;\n\tif ((offset % sector_size) != 0) {\n\t\tprintf(\"Offset 0x%x is not aligned with sector size 0x%x\n\", offset, sector_size);\n\t\terr = ESP_FAIL;\n\t} else if (sector_start != sector_end) {\n\t\tprintf(\"Sectors [0x%x, 0x%x) are not aligned with sector size 0x%x\n\", sector_start, sector_end, sector_size);\n\t\terr = ESP_FAIL;\n\t} else if (esp_partition_erase_range(partition, sector_start, sector_size) != ESP_OK) {\n\t\tprintf(\"Erase operation failed at address 0x%x\n\", sector_start);\n\t\terr = ESP_FAIL;\n\t} else if (esp_partition_write(partition, offset, data, size) != ESP_OK) {\n\t\tprintf(\"Write operation failed at address 0x%x\n\", offset);\n\t\terr = ESP_FAIL;\n\t}\n\treturn err;\n}", "CodeBleu_score": 51.064829574856965}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tif (offset % partition->sector_size) {\n\t\tESP_LOGE(TAG, \"Offset 0x%08x is not aligned with the flash sector size 0x%08x\", offset, partition->sector_size);\n\t\treturn ESP_FAIL;\n\t}\n\tif (size % partition->sector_size) {\n\t\tESP_LOGE(TAG, \"Size 0x%08x is not aligned with the flash sector size 0x%08x\", size, partition->sector_size);\n\t\treturn ESP_FAIL;\n\t}\n\tif (esp_partition_erase_range(partition, offset, size) != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase sector at offset 0x%08x\", offset);\n\t\treturn ESP_FAIL;\n\t}\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 46.72463466985109}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tesp_err_t err;\n\tif (offset % SPI_FLASH_SEC_SIZE != 0) {\n\t\tprintf(\"Offset 0x%x is not aligned with sector size (0x%x)\n\", offset, SPI_FLASH_SEC_SIZE);\n\t\treturn ESP_FAIL;\n\t}\n\terr = msc_erase_sector(partition, offset);\n\tif (err != ESP_OK) {\n\t\tprintf(\"Erase failed at offset 0x%x\n\", offset);\n\t\treturn err;\n\t}\n\terr = msc_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tprintf(\"Write failed at offset 0x%x\n\", offset);\n\t}\n\treturn err;\n}", "CodeBleu_score": 52.28793314320457}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0, j = 0;\n\twhile (i < maxlen && in[i] != 0) {\n\t\tuint8_t c = hex_char_to_byte(in[i++]);\n\t\tif (c >= 16) continue;\n\t\tc = hex_char_to_byte(in[i++]);\n\t\tif (c >= 16) continue;\n\t\tout[j++] = (c << 4) | c;\n\t}\n\treturn j;\n}", "CodeBleu_score": 36.96049684501326}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i = 0, j = 0;\n\twhile (i < maxlen && in[i] != 0) {\n\t\tunsigned char c = hex_char_to_byte(in[i]);\n\t\tif (c >= 16)\n\t\t\ti++;\n\t\telse {\n\t\t\tout[j] = c << 4;\n\t\t\ti++;\n\t\t\tc = hex_char_to_byte(in[i]);\n\t\t\tif (c >= 16)\n\t\t\t\ti++;\n\t\t\telse {\n\t\t\t\tout[j] |= c;\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn j;\n}", "CodeBleu_score": 43.23790555530456}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t\tsize_t i, j;\n\tuint8_t c;\n\n\tfor (i = 0, j = 0; i < maxlen && *in; i++, in++) {\n\t\tc = hex_char_to_byte(*in);\n\t\tif (c != 0x10) {\n\t\t\tout[j++] = c;\n\t\t}\n\t}\n\n\treturn j;\n}", "CodeBleu_score": 36.41839794808122}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tif (tx_buf == NULL || tx_lock == NULL)\n\t\treturn 0;\n\tif (tx_lock->take(1000) == 0)\n\t\treturn 0;\n\tint size = tx_buf->availableForWrite();\n\ttx_lock->give();\n\treturn size;\n}", "CodeBleu_score": 45.82144144906653}, {"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSize = 0;\n\n\t// Verify that the transmit ring buffer and lock are initialized\n\tif (txBuffer != NULL) {\n\t\tif (txBufferLock != NULL) {\n\t\t\t// Attempt to take the semaphore lock within a specified timeout period\n\t\t\tif (txBufferLock->take(TX_BUFFER_LOCK_TIMEOUT) == osOK) {\n\t\t\t\t// Retrieve the current free size of the ring buffer\n\t\t\t\tfreeSize = txBuffer->availableForWrite();\n\n\t\t\t\t// Release the lock\n\t\t\t\ttxBufferLock->give();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn freeSize;\n}", "CodeBleu_score": 41.353842187829734}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (this->txLock == NULL) {\n\t\treturn 0;\n\t}\n\tif (this->txLock->take(this->txLockTimeout) == false) {\n\t\treturn 0;\n\t}\n\tint result = this->txRingBuffer.availableForWrite();\n\tthis->txLock->give();\n\treturn result;\n}", "CodeBleu_score": 38.5833102683765}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t// Lock the serial mutex\n\txSemaphoreTake(_mutex, portMAX_DELAY);\n\n\t// Assign the callback function\n\t_onReceiveCB = function;\n\n\t// Set the receive timeout behavior\n\t_onlyOnTimeout = onlyOnTimeout;\n\tif (_onlyOnTimeout) {\n\t\t_rxTimeout = ARDUINO_SERIAL_RX_TIMEOUT;\n\t} else {\n\t\t_rxTimeout = ARDUINO_SERIAL_RX_TIMEOUT_INFINITE;\n\t}\n\n\t// Set the FIFO full threshold\n\tif (_onReceiveCB != NULL) {\n\t\t_fifoFullThreshold = ARDUINO_SERIAL_FIFO_FULL_THRESHOLD;\n\t} else {\n\t\t_fifoFullThreshold = ARDUINO_SERIAL_FIFO_FULL_THRESHOLD_DISABLE;\n\t}\n\n\t// If the event task does not exist, create it\n\tif (_eventTask == NULL) {\n\t\t_createEventTask(NULL);\n\t}\n\n\t// Unlock the serial mutex\n\txSemaphoreGive(_mutex);\n}", "CodeBleu_score": 46.934667265354825}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t", "CodeBleu_score": 2.7481463565249205}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t#if ARDUINO_SERIAL_EVENT_TASK_ENABLE\n  // Lock the serial mutex\n  _mutex.lock();\n\n  // Assign the callback function\n  _onReceiveCB = function;\n\n  // Set the receive timeout behavior\n  _onlyOnTimeout = onlyOnTimeout;\n  if (onlyOnTimeout) {\n    _uart.setRxBufferSize(1);\n    _rxTimeout = ARDUINO_SERIAL_RX_TIMEOUT;\n  } else {\n    _uart.setRxBufferSize(ARDUINO_SERIAL_RX_BUFFER_SIZE);\n    _rxTimeout = 0;\n  }\n\n  // If the callback is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n  if (function != NULL) {\n    _uart.setRxBufferFullThreshold(ARDUINO_SERIAL_RX_BUFFER_FULL_THRESHOLD);\n    if (_eventTask == NULL) {\n      _createEventTask(NULL);\n    }\n  }\n\n  // Unlock the serial mutex\n  _mutex.unlock();\n#endif\n}", "CodeBleu_score": 47.9924518086621}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t_startMillis = millis();\n  size_t index = 0;\n  int c;\n  while (index < length) {\n    c = timedRead();\n    if (c == -1) {\n      break;\n    }\n    if (c == terminator) {\n      break;\n    }\n    buffer[index++] = c;\n  }\n  return index;\n}", "CodeBleu_score": 62.21857813101141}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t_startMillis = millis();\n  size_t index = 0;\n  int c;\n  do {\n    c = timedRead();\n    if (c >= 0) {\n      if (c == terminator) {\n        break;\n      }\n      if (index < length) {\n        buffer[index++] = (char)c;\n      }\n    }\n  } while (millis() - _startMillis < _timeout);\n  return index;\n}", "CodeBleu_score": 57.76229724245767}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t_startMillis = millis();\n  size_t index = 0;\n  char c;\n  while (index < length) {\n    c = timedRead();\n    if (c == -1) {\n      break;\n    }\n    if (c == terminator) {\n      break;\n    }\n    buffer[index++] = c;\n  }\n  return index;\n}", "CodeBleu_score": 61.76928198133687}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (pin >= NUM_DIGITAL_PINS) {\n\t\tlog_e(\"Invalid tone pin: %d\", pin);\n\t\treturn;\n\t}\n\n\tif (digitalRead(pin) == HIGH) {\n\t\tlog_e(\"Tone pin %d is already in use\", pin);\n\t\treturn;\n\t}\n\n\tif (tone_init() == 0) {\n\t\tlog_e(\"Could not initialize tone task\");\n\t\treturn;\n\t}\n\n\ttone_msg_t msg = {\n\t\t.pin = pin,\n\t\t.frequency = frequency,\n\t\t.duration = duration\n\t};\n\n\tif (xQueueSend(_tone_queue, &msg, portMAX_DELAY) != pdPASS) {\n\t\tlog_e(\"Could not send tone message to queue\");\n\t}\n}", "CodeBleu_score": 51.776781299818666}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\t// Check if the pin is available or already in use\n\tif (gpio_get_level(pin) == 1) {\n\t\tlog_e(\"Pin %d is already in use\", pin);\n\t\treturn;\n\t}\n\n\t// Initialize the tone\n\tif (tone_init() == 0) {\n\t\treturn;\n\t}\n\n\t// Log the pin, frequency, and duration\n\tlog_v(\"Tone: pin=%d, freq=%d, duration=%d\", pin, frequency, duration);\n\n\t// Send a start command with the pin, frequency, and duration to the queue\n\ttone_msg_t msg = {\n\t\t.cmd = TONE_START,\n\t\t.pin = pin,\n\t\t.frequency = frequency,\n\t\t.duration = duration\n\t};\n\txQueueSend(_tone_queue, &msg, portMAX_DELAY);\n}", "CodeBleu_score": 54.391847770114055}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tlog_v(\"tone(pin=%d, frequency=%d, duration=%d)\", pin, frequency, duration);\n\n\t// Check if the pin is available\n\tif (gpio_is_free(pin)) {\n\t\t// Set the pin as output\n\t\tgpio_set_direction(pin, GPIO_OUTPUT);\n\t\t// Set the pin to LOW\n\t\tgpio_set_level(pin, 0);\n\t\t// Add the pin to the list of used pins\n\t\tgpio_set_used(pin);\n\t\t// Create a message to send to the tone task\n\t\ttone_msg_t msg;\n\t\tmsg.pin = pin;\n\t\tmsg.frequency = frequency;\n\t\tmsg.duration = duration;\n\t\tmsg.action = TONE_START;\n\t\t// Send the message to the tone task\n\t\txQueueSend(_tone_queue, &msg, portMAX_DELAY);\n\t} else {\n\t\tlog_e(\"Pin %d is already in use\", pin);\n\t}\n}", "CodeBleu_score": 45.129782356149605}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t", "CodeBleu_score": 4.617114260138171}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\tif (enabled) {\n\t\t\tif (usbVersion >= 0x0210) {\n\t\t\t\twebUSBEnabled = true;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\twebUSBEnabled = false;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (enabled) {\n\t\t\tif (usbVersion >= 0x0210) {\n\t\t\t\twebUSBEnabled = true;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\twebUSBEnabled = false;\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.26006227902613}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (usb_mode == USB_MODE_NONE) {\n\t\twebusb_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (usb_version >= 0x0210) {\n\t\t\t\tusb_mode = USB_MODE_WEBUSB;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tusb_mode = USB_MODE_SERIAL;\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 39.08640496835658}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint8_t data;\n\tuint8_t length = 0;\n\tuint8_t i;\n\n\twhile (USBEndpointBufferAvail(EP_CDC_IN)) {\n\t\tdata = USBEndpointBufferRead(EP_CDC_IN);\n\n\t\tif (data == CDC_END_OF_MSG) {\n\t\t\tif (length > 0) {\n\t\t\t\tif (!usbcdc_rx_queue.post(length)) {\n\t\t\t\t\tusbcdc_rx_overflow_event.post(length);\n\t\t\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\t\t\tusbcdc_rx_overflow_event.log();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlength = 0;\n\t\t} else {\n\t\t\tif (length < CDC_RX_BUFFER_SIZE) {\n\t\t\t\tusbcdc_rx_buffer[length] = data;\n\t\t\t\tlength++;\n\t\t\t} else {\n\t\t\t\tusbcdc_rx_overflow_event.post(1);\n\t\t\t\tusbcdc_rx_overflow_event.log();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (length > 0) {\n\t\tusbcdc_rx_event.post(length);\n\t}\n}", "CodeBleu_score": 25.378791128553534}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data;\n\tuint8_t length = 0;\n\twhile (USBEndpointBufferAvailable(CDC_RX_ENDPOINT)) {\n\t\tdata = USBEndpointRead(CDC_RX_ENDPOINT);\n\t\tif (USBEndpointIsStalled(CDC_RX_ENDPOINT)) {\n\t\t\t_rxBuffer.clear();\n\t\t\treturn;\n\t\t}\n\t\t_rxBuffer.push_back(data);\n\t\tlength++;\n\t}\n\tif (length > 0) {\n\t\t_rxEvent.post(length);\n\t}\n}", "CodeBleu_score": 13.96822707710238}, {"code": "void USBCDC::_onRX(){\n\t", "CodeBleu_score": 1.253830987611717}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request\n\tname := mux.Vars(req)[\"name\"]\n\n\t// Check if the robot exists\n\trobot := a.robots.Get(name)\n\tif robot == nil {\n\t\t// If the robot does not exist, return an error response\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"No robot found with the specified name\\\"}\"))\n\t\treturn\n\t}\n\n\t// Create a new JSON object\n\tvar devices []string\n\tfor _, device := range robot.Devices() {\n\t\tdevices = append(devices, device.Name())\n\t}\n\n\t// Create a JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(fmt.Sprintf(\"{\\\"devices\\\":%v}\", devices)))\n}", "CodeBleu_score": 44.00942465511524}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the name of the robot from the URL path.\n\tname := mux.Vars(req)[\"name\"]\n\n\t// Check if a robot with the given name exists.\n\trobot := a.robots.GetRobot(name)\n\tif robot == nil {\n\t\t// If no robot was found, return an error message.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\t// If a robot was found, get its devices and return them as a JSON response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(robot.Devices)\n}", "CodeBleu_score": 31.187843199474536}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Check if the robot name is provided in the URL path.\n\tvars := mux.Vars(req)\n\tif _, ok := vars[\"name\"]; !ok {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tres.Write(jsonError(errors.New(\"robot name not provided\")))\n\t\treturn\n\t}\n\t// Get the robot name from the URL path.\n\tname := vars[\"name\"]\n\t// Check if a robot with the given name exists.\n\trobot, err := a.db.GetRobot(name)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write(jsonError(err))\n\t\treturn\n\t}\n\t// Get the robot's devices.\n\tdevices, err := a.db.GetRobotDevices(robot.ID)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write(jsonError(err))\n\t\treturn\n\t}\n\t// Create a JSON response with the robot's devices.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(jsonDevices(devices))\n}", "CodeBleu_score": 36.68006547556965}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName]; !ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"Robot not found\"))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections, convert them to JSON format, and write them to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(fmt.Sprintf(\"[%s]\", strings.Join(a.robots[robotName].connections, \",\"))))\n}", "CodeBleu_score": 24.785425708641483}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\tname := req.URL.Path[len(\"/robot/connections/\"):]\n\n\t// Check if the robot exists.\n\trobot, err := a.db.GetRobot(name)\n\tif err != nil {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\tres.Write([]byte(\"No robot found with name \" + name))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format.\n\tconnections := make([]map[string]string, len(robot.Connections))\n\tfor i, connection := range robot.Connections {\n\t\tconnections[i] = map[string]string{\n\t\t\t\"Name\": connection.Name,\n\t\t\t\"Type\": connection.Type,\n\t\t}\n\t}\n\n\t// Write the connections to the HTTP response.\n\tres.Write(toJSON(connections))\n}", "CodeBleu_score": 45.296701635546135}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL.\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Check if the robot exists.\n\trobot, err := a.db.GetRobot(name)\n\tif err != nil {\n\t\tres.Write([]byte(\"No robot with that name was found.\"))\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON.\n\tconnections := []Connection{}\n\tfor _, connection := range robot.Connections {\n\t\tconnections = append(connections, Connection{connection.Name, connection.ConnectionType})\n\t}\n\n\t// Write the connections to the HTTP response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(json.Marshal(connections))\n}", "CodeBleu_score": 46.41052856590471}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t", "CodeBleu_score": 2.750661395694159}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot and device names from the URL query parameters\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\tdeviceName := vars[\"device\"]\n\n\t// Get the robot from the robots map\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\twriteError(res, \"robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the device from the robot's devices map\n\tdevice, ok := robot.devices[deviceName]\n\tif !ok {\n\t\twriteError(res, \"device not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the command\n\terr := device.Command(req.FormValue(\"command\"))\n\tif err != nil {\n\t\twriteError(res, err.Error(), http.StatusConflict)\n\t\treturn\n\t}\n\n\t// Write the response\n\twriteResponse(res, \"OK\")\n}", "CodeBleu_score": 42.5048082215029}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t", "CodeBleu_score": 2.750661395694159}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\t\tconst prefix = \"Basic \"\n\t\tif !strings.HasPrefix(auth, prefix) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\t\tb, err := base64.StdEncoding.DecodeString(auth[len(prefix):])\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorized\n\"))\n\t\t\treturn\n\t\t}\n\t\t// Authorization succeeded, call the next handler.\n\t\th.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 45.4864301657917}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Authorization Required\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Authorization Required\"))\n\t\t\treturn\n\t\t}\n\t\tuser, pass, _ := r.BasicAuth()\n\t\tif !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Authorization Required\")\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Authorization Required\"))\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 50.36002845295666}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Authentication credentials\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif len(auth) == 0 {\n\t\t\t// No credentials provided, set WWW-Authenticate header and return 401\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Authorization Required\")\n\t\t\thttp.Error(w, \"Authorization Required\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Verify credentials\n\t\tb, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\tif err != nil {\n\t\t\t// Credentials are not Basic Auth credentials, return 401\n\t\t\thttp.Error(w, \"Invalid Authorization\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\t// Credentials are not valid, return 401\n\t\t\thttp.Error(w, \"Invalid Authorization\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Credentials are valid, call the next handler\n\t\tr.Header.Set(\"Authorization\", auth)\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 49.220870064346656}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.lock.RLock()\n\tdefer a.lock.RUnlock()\n\n\tif a.connection.AnalogSupported() {\n\t\traw, err := a.connection.AnalogRead()\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\n\t\ta.raw = raw\n\t\ta.scaled = a.scale(raw)\n\t\treturn raw, a.scaled, nil\n\t}\n\n\treturn 0, 0, errors.New(\"Analog reading not supported by connection\")\n}", "CodeBleu_score": 45.97052739341585}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the sensor supports analog reading\n\tif !a.analogSupported {\n\t\treturn 0, 0, errors.New(\"analog reading not supported\")\n\t}\n\n\t// Get the raw sensor value\n\traw, err := a.analogSensor.Read()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled := a.analogSensor.Scale(raw)\n\n\t// Update the last read values\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\t// Return the raw and scaled values\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 44.92806391561592}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading.\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the sensor supports analog reading.\n\tif !a.supportsAnalogReading() {\n\t\treturn 0, 0, errors.New(\"The sensor does not support analog reading\")\n\t}\n\n\t// Read the raw sensor value.\n\trawValue, err := a.readRaw()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration.\n\tscaledValue := a.scaleValue(rawValue)\n\n\t// Update the last read values.\n\ta.rawValue = rawValue\n\ta.scaledValue = scaledValue\n\n\t// Return the raw and scaled values.\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 49.20770969144975}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tvar name string\n\tif len(opts) > 0 {\n\t\tname = opts[0].(string)\n\t} else {\n\t\tname = \"GroveSoundSensor\"\n\t}\n\treturn &GroveSoundSensorDriver{\n\t\tname:        name,\n\t\tanalogReader: a,\n\t\tpin:         pin,\n\t}\n}", "CodeBleu_score": 29.702940560601395}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tvar name string\n\tif len(opts) > 0 {\n\t\tname = opts[0].(string)\n\t} else {\n\t\tname = \"GroveSoundSensorDriver\"\n\t}\n\treturn &GroveSoundSensorDriver{\n\t\tname:        name,\n\t\tanalogReader: a,\n\t\tpin:         pin,\n\t\tanalogSensor: NewAnalogSensorDriver(a, pin, nil...),\n\t}\n}", "CodeBleu_score": 31.63861398936711}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\tname := \"GroveSoundSensor\"\n\tfor _, opt := range opts {\n\t\tswitch o := opt.(type) {\n\t\tcase Name:\n\t\t\tname = string(o)\n\t\t}\n\t}\n\treturn &GroveSoundSensorDriver{\n\t\tBaseAnalogSensorDriver{\n\t\t\tname:       name,\n\t\t\tanalogPort: a,\n\t\t\tpin:        pin,\n\t\t\tadc:        NewAnalogSensor(a, pin),\n\t\t},\n\t}\n}", "CodeBleu_score": 32.62424620513079}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeCommand(PCD_RESETPHASE)\n\ttime.Sleep(100 * time.Millisecond)\n\n\tif d.readRegister(PCD_COMMAND) != 0x00 {\n\t\treturn errors.New(\"PCD_COMMAND not 0x00\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 23.687307787929917}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.WriteRegister(CommandReg, SoftResetCommand); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Millisecond * 10)\n\tif d.ReadRegister(CommandReg) != 0x00 {\n\t\treturn ErrSoftReset\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.58348879419659}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Write soft reset command\n\td.WriteRegister(CommandReg, SoftResetCommand)\n\n\t// Wait for the reset\n\ttime.Sleep(time.Duration(d.initDelay) * time.Millisecond)\n\n\t// Check the reset has finished\n\tstatus, err := d.ReadRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status&0x08 != 0 {\n\t\treturn errors.New(\"failed to reset\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.149559408268615}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t", "CodeBleu_score": 2.4614450729887336}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tvar err error\n\tvar status byte\n\tvar length uint8\n\tvar i uint8\n\tlength = uint8(len(backData))\n\tstatus = d.ReadRegister(FIFOLevelReg)\n\tif status&0x78 != 0x70 {\n\t\treturn 0, ErrComm\n\t}\n\tif status&0x07 == 0 {\n\t\treturn 0, ErrEmpty\n\t}\n\tif status&0x07 > length {\n\t\treturn 0, ErrSize\n\t}\n\tfor i = 0; i < status&0x07; i++ {\n\t\tbackData[i] = d.ReadRegister(FIFODataReg)\n\t}\n\treturn d.ReadRegister(ControlReg) & 0x80, err\n}", "CodeBleu_score": 28.698725512172103}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t// Check length of slice is not longer than the FIFO buffer\n\tif len(backData) > d.fifoSize {\n\t\treturn 0, ErrFIFOTooLong\n\t}\n\n\t// First byte is the length of the data\n\tlength, err := d.readByte()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check length of data does not exceed the length of the slice\n\tif uint8(len(backData)) != length {\n\t\treturn 0, ErrFIFOTooShort\n\t}\n\n\t// Read data from FIFO\n\tfor i := range backData {\n\t\tbackData[i], err = d.readByte()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the last bits received\n\tlastBits, err := d.readByte()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 42.280822806278366}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Printf(\"halting PICC\")\n\t}\n\tif err := d.PCD_TransceiveData(PICC_CMD_HALT, nil, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 20.440240921287263}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tfmt.Println(\"halting PICC\")\n\t}\n\n\t// Build command for PICC halt.\n\tcmd := []byte{PICC_CMD_HALT}\n\n\t// Calculate CRC for command.\n\tcrc := d.crcCalculate(cmd[:])\n\n\t// Append CRC to command.\n\tcmd = append(cmd, crc)\n\n\t// Send the command.\n\tif err := d.PCD_Transceive(cmd, nil); err != nil {\n\t\treturn err\n\t}\n\n\t// Check for errors.\n\tif d.lastStatus != STATUS_OK {\n\t\treturn fmt.Errorf(\"halting failed: %s\", d.lastError)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 34.39058231332154}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Printf(\"halting PICC\")\n\t}\n\n\tif err := d.PCD_Transceive(PCD_HALT, []byte{}); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 21.937297053856586}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif d.debug {\n\t\tfmt.Printf(\"piccRead(%02X)\n\", block)\n\t}\n\tif block > 0x07 {\n\t\treturn nil, ErrPICCError\n\t}\n\n\t// Build command for PICC_READ.\n\tcmd := []byte{PICC_READ, block}\n\tcrc := d.crc(cmd[:2])\n\n\t// Send the command.\n\tif err := d.pcsc.Control(pcsc.ControlCodeReset, 0); err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := d.pcsc.Transmit(cmd); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the response.\n\t// The first byte is the status byte.\n\t// If not 0x00, there was an error.\n\t// The second byte is the block number.\n\t// The next 16 bytes are the data bytes.\n\t// The last byte is the CRC for the data, and the CRC status.\n\tdata := make([]byte, 18)\n\tif _, err := d.pcsc.Transmit(data); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the CRC.\n\tif crc != data[len(data)-2] {\n\t\treturn nil, ErrCRCError\n\t}\n\n\t// Return all the data bytes.\n\treturn data[2 : len(data)-2], nil\n}", "CodeBleu_score": 40.11966242823321}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Create a new slice for the data\n\tdata := make([]byte, 18)\n\n\t// Create a new byte array for the command\n\tcommand := make([]byte, 2)\n\n\t// Set the command for PICC_READ\n\tcommand[0] = PICC_CMD_READ\n\n\t// Set the block number\n\tcommand[1] = block & 0x0F\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(command[:])\n\n\t// Set the first byte of the data to the command\n\tdata[0] = command[0]\n\n\t// Set the second byte of the data to the block\n\tdata[1] = command[1]\n\n\t// Set the last byte of the data to the CRC\n\tdata[17] = crc\n\n\t// Send the data to the card\n\tif err := d.PCD_Transceive(data[:], 18); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the status\n\tif data[0] != 0x00 {\n\t\treturn nil, errors.New(\"Received error from the PICC\")\n\t}\n\n\t// Return the data\n\treturn data[1:17], nil\n}", "CodeBleu_score": 36.14762247238533}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t", "CodeBleu_score": 3.9226551888190304}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t", "CodeBleu_score": 3.6650973421215025}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"PICC response is too short\")\n\t}\n\tif reqMode != REQ_MODE_PICC {\n\t\td.clearBitMask(CollReg, 0x80)\n\t}\n\tif reqMode == REQ_MODE_PICC {\n\t\td.setBitMask(TxLastBits, 0x07)\n\t}\n\terr := d.transceive(reqMode, 0, 0, answer)\n\tif reqMode != REQ_MODE_PICC {\n\t\td.clearBitMask(CollReg, 0x80)\n\t}\n\tif reqMode == REQ_MODE_PICC {\n\t\td.clearBitMask(TxLastBits, 0x07)\n\t}\n\treturn err\n}", "CodeBleu_score": 51.80772624875498}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"piccRequest: len(answer) < 2\")\n\t}\n\t// Clear the bits in TxControlReg and RxControlReg.\n\td.clearBitMask(TxControlReg, TxLastBitsMask)\n\td.clearBitMask(RxControlReg, RxLastBitsMask)\n\t// Set the bits in TxControlReg for the request command.\n\tif reqMode == TransmissionTypeAck:\n\t\td.setBitMask(TxControlReg, TxLastBitsMask)\n\t// Prepare the command.\n\tcommand := []byte{reqMode}\n\t// Calculate the CRC for the command.\n\tcrc := d.calculateCRC(command[:1])\n\t// Add the CRC to the command.\n\tcommand = append(command, crc[:2]...)\n\t// Transmit the command.\n\tif err := d.transceive(command, answer); err != nil {\n\t\treturn err\n\t}\n\t// Check that the response is 2 bytes long.\n\tif len(answer) != 2 {\n\t\treturn errors.New(\"piccRequest: len(answer) != 2\")\n\t}\n\t// Check the CRC.\n\tif crc != answer[len(answer)-2:] {\n\t\treturn errors.New(\"piccRequest: crc != answer[len(answer)-2:]\")\n\t}\n\t// Return any error code.\n\treturn errors.New(\"piccRequest: \" + string(answer[0:1]))\n}", "CodeBleu_score": 54.34083475761052}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Write(d.stepPin.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.stepPin.Write(d.stepPin.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == easydriver.Clockwise {\n\t\td.stepNumber += 1\n\t} else {\n\t\td.stepNumber -= 1\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 62.62876861939053}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Write(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\terr = d.stepPin.Write(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}", "CodeBleu_score": 63.84312412124231}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Check if the step pin is already high\n\tif d.stepPin.Read() == gpio.Low {\n\t\t// The step pin is already high, so it is probably already in motion\n\t\treturn ErrAlreadyStepping\n\t}\n\n\t// Set the step pin to low\n\tif err := d.stepPin.Out(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the delay\n\ttime.Sleep(d.delay)\n\n\t// Set the step pin to high\n\tif err := d.stepPin.Out(gpio.High); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction == gpio.Low {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 66.15223167503434}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.distanceMonitorMutex.Lock()\n\tdefer d.distanceMonitorMutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\td.distanceMonitorStopChannel = make(chan bool)\n\td.distanceMonitorWaitGroup = sync.WaitGroup{}\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\n\td.distanceMonitorRunning = true\n\n\treturn nil\n}", "CodeBleu_score": 30.79514140696374}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorRunning = true\n\td.distanceMonitorStop = make(chan bool)\n\td.distanceMonitorWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\n\treturn nil\n}", "CodeBleu_score": 33.79536230962816}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorRunning = true\n\td.distanceMonitorStopChannel = make(chan struct{})\n\td.distanceMonitorWaitGroup = new(sync.WaitGroup)\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 32.512072163464154}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(gpio int, duration time.Duration, channel string, timestamp uint32, nanos uint32) {\n\t\tif gpio == d.echoPin {\n\t\t\td.start = timestamp\n\t\t} else if gpio == d.triggerPin {\n\t\t\td.duration = duration\n\t\t\td.sendDuration(channel, duration)\n\t\t\td.start = 0\n\t\t}\n\t}\n}", "CodeBleu_score": 34.46760036394401}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, channel string, eventID uint32, eventTime uint32) {\n\t\tif channel == \"pulse\" {\n\t\t\td.pulse = duration\n\t\t}\n\t}\n}", "CodeBleu_score": 27.781135634974298}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\treturn func(pin int, duration time.Duration, channel string, id uint32, eventID uint32) {\n\t\tif channel == \"pulse\" {\n\t\t\td.pulse = duration\n\t\t}\n\t}\n}", "CodeBleu_score": 27.341938938699435}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.distanceMutex.Lock()\n\tdefer d.distanceMutex.Unlock()\n\n\terr := d.triggerSensor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = d.waitForMeasurement()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.80873908772593}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access\n\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// Trigger the sensor\n\td.triggerSensor()\n\n\t// Wait for the sensor to complete the measurement\n\tselect {\n\tcase <-d.measureComplete:\n\t\t// The measurement is complete, so we can return\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// The measurement timed out, so we can return an error\n\t\treturn errors.New(\"timeout\")\n\t}\n}", "CodeBleu_score": 26.528747210470023}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measureMutex.Lock()\n\tdefer d.measureMutex.Unlock()\n\n\t// trigger the sensor\n\terr := d.triggerSensor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// wait for the measurement to complete or for a timeout to occur\n\terr = d.waitForMeasurement()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// get the measurement\n\tmeasurement, err := d.getMeasurement()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// store the measurement\n\td.measurement = measurement\n\n\treturn nil\n}", "CodeBleu_score": 51.30308433395216}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if self.access_token is None:\n        if self.refresh_token is None:\n            raise AccountNotAuthorized(\n                \"No access token or refresh token available. Please authorize the application.\"\n            )\n        else:\n            try:\n                response = self.fetch_json_data(\n                    \"https://accounts.spotify.com/api/token\",\n                    method=\"POST\",\n                    headers={\"Authorization\": f\"Basic {self.client_secret}\"},\n                    data={\n                        \"grant_type\": \"refresh_token\",\n                        \"refresh_token\": self.refresh_token,\n                    },\n                )\n            except HTTPClientError as exc:\n                raise AccountNotAuthorized(\n                    \"The refresh token is invalid or expired. Please authorize the application.\"\n                ) from exc\n            else:\n                self.access_token = response[\"access_token\"]\n                self.access_token_expires_at = (\n                    datetime.now() + timedelta(seconds=response[\"expires_in\"])\n                )\n                self.refresh_token = response[\"refresh_token\"]\n                self.refresh_token_expires_at = (\n                    datetime.now() + timedelta(seconds=response[\"refresh_token_expires_in\"])\n                )\n                return self.access_token\n    else:\n        if self.access_token_expires_at < datetime.now():\n            if self.refresh_token is None:\n                raise AccountNotAuthorized(\n                    \"The access token has expired. Please authorize the application.\"\n                )\n            else:\n                try:\n                    response = self.fetch_json_data(\n                        \"https://accounts.spotify.com/api/token\",\n                        method=\"POST\",\n                        headers={\"Authorization\": f\"Basic {self.client_secret}\"},\n                        data={\n                            \"grant_type\": \"refresh_token\",\n                            \"refresh_token\": self.refresh_token,\n                        },\n                    )\n                except HTTPClientError as exc:\n                    raise AccountNotAuthorized(\n                        \"The refresh token is invalid or expired. Please authorize the application.\"\n                    ) from exc\n                else:\n                    self.access_token = response[\"access_token\"]\n                    self.access_token_expires_at = (\n                        datetime.now() + timedelta(seconds=response[\"expires_in\"])\n                    )\n                    self.refresh_token = response[\"refresh_token\"]\n                    self.refresh_token_expires_at = (\n                        datetime.now()\n                        + timedelta(seconds=response[\"refresh_token_expires", "CodeBleu_score": 32.844945106996335}, {"code": "def fetch_authentication_token(self)\n\t\n    if \"AUTHENTICATION_TOKEN\" in os.environ:\n        return os.environ[\"AUTHENTICATION_TOKEN\"]\n    if self.authentication_data:\n        if self.authentication_data[\"expires_at\"] < datetime.utcnow():\n            if \"REFRESH_TOKEN\" in os.environ:\n                try:\n                    refresh_token = os.environ[\"REFRESH_TOKEN\"]\n                    response = self.fetch_json_data(\n                        \"https://api.revolt.chat/auth/refresh\",\n                        json={\"refresh\": refresh_token},\n                    )\n                    self.authentication_data = response[\"data\"]\n                    return self.authentication_data[\"access_token\"]\n                except HTTPClientError:\n                    pass\n            raise AccountNotAuthorized()\n        return self.authentication_data[\"access_token\"]\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 37.56166092188607}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.getenv(\"TOKEN\")\n    if token:\n        return token\n    if self.access_token and self.access_token_expires_at > datetime.now():\n        return self.access_token\n    if self.refresh_token:\n        try:\n            self.fetch_access_token()\n            return self.access_token\n        except AccountError:\n            raise AccountNotAuthorized(\"Failed to authorize account.\")\n    raise AccountNotAuthorized(\"Failed to authorize account.\")\n\n", "CodeBleu_score": 24.85244804988254}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.get_refresh_token()\n    if refresh_token:\n        self.delete_session()\n        try:\n            self.fetch_json_data(\"POST\", \"/v1/logout\", json={\"refresh_token\": refresh_token})\n        except AccountError:\n            pass\n    return True\n\n", "CodeBleu_score": 53.698745644374846}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.refresh_token\n    except AttributeError:\n        return False\n    self.delete_session()\n    try:\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            headers={\"Authorization\": f\"Bearer {refresh_token}\"},\n        )\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 55.99912259025639}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.session.cookies.get(\"refresh_token\")\n        self.session.close()\n        self.session.delete(self.session.url_generator.get_url(\"auth\", \"logout\"))\n        self.session.delete(\n            self.session.url_generator.get_url(\"auth\", \"logout\"),\n            json={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    self.session = None\n    return True\n", "CodeBleu_score": 50.158386256466194}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        if package.external:\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"source\": package.source,\n                }\n            )\n        else:\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                }\n            )\n    return result\n\n", "CodeBleu_score": 24.05513212664671}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.get_packages():\n        if package.is_optional():\n            continue\n        package_info = dict(name=package.name, version=package.version)\n        if package.is_external():\n            package_info['source'] = package.source_url\n        packages.append(package_info)\n    return packages\n\n", "CodeBleu_score": 27.369411451319486}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for p in self.pm.get_packages():\n        if p.optional:\n            continue\n        package_info = {\n            \"name\": p.name,\n            \"version\": p.version,\n            \"optional\": p.optional,\n            \"external\": p.external,\n        }\n        if p.external:\n            package_info[\"source_url\"] = p.source_url\n        packages.append(package_info)\n    return packages\n\n", "CodeBleu_score": 34.28858808872815}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n\n    project_conf = ProjectConf()\n    try:\n        project_conf.read(cls.PROJECT_CONF)\n    except configparser.Error as exc:\n        raise exception.InvalidProjectConfError(cls.PROJECT_CONF, str(exc))\n\n    try:\n        env_platform = project_conf.get_env_platform(env)\n    except exception.UndefinedEnvPlatformError:\n        raise exception.UndefinedEnvPlatformError(env)\n\n    platform_conf = PlatformConf()\n    try:\n        platform_conf.read(env_platform)\n    except configparser.Error as exc:\n        raise exception.InvalidPlatformConfError(env_platform, str(exc))\n\n    try:\n        env_class = platform_conf.get_env_class()\n    except exception.UndefinedEnvClassError:\n        raise exception.UndefinedEnvClassError(env_platform)\n\n    try:\n        env_class = import_string(env_class)\n    except ImportError as exc:\n        raise exception.ImportEnvClassError(env_platform, str(exc))\n\n    env = env_class(env_platform, autoinstall)\n    env.set_targets(targets)\n    env.configure()\n\n    return env\n\n", "CodeBleu_score": 32.60075025578339}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    try:\n        platform_spec = cls.get_platform_spec(env)\n    except exception.UndefinedEnvPlatformError as exc:\n        raise exception.UndefinedEnvPlatformError(\n            \"No platform specification found for the `%s` environment\" % env\n        ) from exc\n    if autoinstall:\n        platform_spec[\"autoinstall\"] = True\n    instance = cls(platform_spec)\n    instance.set_env(env)\n    instance.configure_packages(targets)\n    return instance\n\n", "CodeBleu_score": 30.77826077623657}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    env_spec = cls.get_env_spec(env)\n    if not env_spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    env_spec[\"autoinstall\"] = autoinstall\n    env_spec[\"env\"] = env\n    env_spec[\"targets\"] = targets\n    env_spec[\"config\"] = cls.get_config(env)\n    env_spec[\"packages\"] = cls.get_packages(env)\n    env_obj = cls(**env_spec)\n    return env_obj\n\n", "CodeBleu_score": 32.41033649925269}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\twhile (Wire.available()) {\n\t\t*Buff = Wire.read();\n\t\tBuff++;\n\t}\n}", "CodeBleu_score": 45.24559422339398}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(0x34);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(0x34, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 66.51085749887085}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_SLAVE_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_SLAVE_ADDRESS, Size);\n\tuint8_t i = 0;\n\twhile (Wire.available()) {\n\t\tBuff[i++] = Wire.read();\n\t}\n}", "CodeBleu_score": 48.05082699729267}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.printf(\"Entering deep sleep for %llu us.\n\", time_in_us);\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        SetTimer(time_in_us);\n    } else {\n        Write1Byte(0x3F, Read8bit(0x3F) & 0x7F);  // Disable timer wakeup\n    }\n    Write1Byte(0x12, Read8bit(0x12) & 0x7F);  // Enter deep sleep\n    delay(100);\n    // Serial.printf(\"Entering deep sleep for %llu us.\n\", time_in_us);\n    // delay(100);\n    // ESP.deepSleep(time_in_us);\n}", "CodeBleu_score": 55.96046869557525}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us) {\n\t\tWrite1Byte(0x36, 0x20);\n\t\tWrite4Byte(0x37, time_in_us / 2000);\n\t}\n\tWrite1Byte(0x12, Read8bit(0x12) & 0x7F);  // Enable all outputs\n\tWrite1Byte(0x12, Read8bit(0x12) | 0x80);  // Enter deep sleep\n\tdelay(100);\n\t// If the timer is used, it should be disabled before the device enters deep sleep mode.\n\tWrite1Byte(0x36, 0x00);\n\tWrite1Byte(0x37, 0x00);\n\tWrite1Byte(0x12, Read8bit(0x12) & 0x7F);  // Enable all outputs\n\tWrite1Byte(0x12, Read8bit(0x12) | 0x80);  // Enter deep sleep\n\tdelay(100);\n}", "CodeBleu_score": 30.175948360560433}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t\tSetSleep();\n\tif (time_in_us > 0) {\n\t\tWrite1Byte(0x12, Read8bit(0x12) | 0x80);\n\t\tWrite4Byte(0x13, time_in_us / 1000);\n\t} else {\n\t\tWrite1Byte(0x12, Read8bit(0x12) & 0x7F);\n\t}\n\tWrite1Byte(0x30, Read8bit(0x30) & 0x7F);\n\tWrite1Byte(0x10, Read8bit(0x10) & 0x7F);\n\tWrite1Byte(0x10, Read8bit(0x10) | 0x80);\n}", "CodeBleu_score": 39.80913438646694}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = scroll_y;\n\tscroll_y += font_height;\n\tif (scroll_y > (tft.height() - bottom_fixed_area)) {\n\t\tscroll_y = 0;\n\t\tif (tteBar) {\n\t\t\tscroll_y = top_fixed_area;\n\t\t}\n\t}\n\ttft.fillRect(0, y, tft.width(), font_height, color);\n\tscrollAddress(scroll_y);\n\treturn y;\n}", "CodeBleu_score": 17.714494373452755}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tuint16_t prev_y;\n\tprev_y = scroll_y;\n\tscroll_y += text_height;\n\tif (scroll_y >= (display_height - bottom_fixed_area)) {\n\t\tscroll_y = 0;\n\t\tif (tteBar) {\n\t\t\tscroll_y = top_fixed_area;\n\t\t}\n\t}\n\tfill_rectangle(0, prev_y, display_width, text_height, color);\n\tscrollAddress(scroll_y);\n\treturn prev_y;\n}", "CodeBleu_score": 18.00551358192165}, {"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n  static int yStart = 0;\n  tft.fillrect(0, yStart, tft.width(), 1, color);\n  yStart++;\n  if (yStart >= tft.height() - 20) {\n    yStart = 0;\n    tte.set_scroll_area(0, 20, tft.width(), tft.height() - 20);\n  }\n  scrollAddress(yStart);\n  return yStart;\n#endif\n}", "CodeBleu_score": 15.193787451616622}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\t// setup access points\n\tif (!this->setupAccessPoints(ssids, access_points)) {\n\t\treturn false;\n\t}\n\n\t// setup html content\n\tif (!this->setupHTMLContent()) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startPortal();\n\n\treturn true;\n}", "CodeBleu_score": 63.46966355353284}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t#ifdef DEBUG\n  Serial.println(F(\"Starting Evil Portal\"));\n#endif\n\n  // create access points\n  if (!this->createAPs(ssids, access_points)) {\n    return false;\n  }\n\n  // create html content\n  if (!this->createHtml()) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 61.716905456426765}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t#ifdef DEBUG_PRINTS\n  Serial.println(\"EvilPortal::begin\");\n#endif\n\n  // create access point\n  if (!this->setupAP(ssids, access_points)) {\n    return false;\n  }\n\n  // setup webserver\n  if (!this->setupWebserver()) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 61.71723734055574}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (!queue_enabled_flag) {\n\t\tgps_queue = new Queue<GpsData>(100);\n\t\tgps_text = new char[100];\n\t\tgps_text_in = new char[100];\n\t\tgps_queue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 10.455332399608505}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag == true) {\n\t\tif (gps_queue == NULL) {\n\t\t\tgps_queue = xQueueCreate(GPS_QUEUE_SIZE, sizeof(GPS_DATA));\n\t\t\tif (gps_queue == NULL) {\n\t\t\t\tprintf(\"Error: Unable to create GPS queue.\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (gps_text == NULL) {\n\t\t\tgps_text = (char*)malloc(GPS_TEXT_SIZE);\n\t\t\tif (gps_text == NULL) {\n\t\t\t\tprintf(\"Error: Unable to create GPS text.\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (gps_text_in == NULL) {\n\t\t\tgps_text_in = (char*)malloc(GPS_TEXT_SIZE);\n\t\t\tif (gps_text_in == NULL) {\n\t\t\t\tprintf(\"Error: Unable to create GPS text_in.\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tflush_queue();\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 8.727098433080457}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag == false) {\n\t\tqueue_enabled_flag = true;\n\t\ttext = \"\";\n\t\ttext_in = \"\";\n\t\tflush_queue();\n\t}\n}", "CodeBleu_score": 6.718825357365615}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue != NULL) {\n\t\tdelete nmea_queue;\n\t\tnmea_queue = NULL;\n\t}\n\tnmea_queue = new Queue<String>(10);\n}", "CodeBleu_score": 35.708653649094494}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue) {\n\t\tdelete nmea_queue;\n\t}\n\tnmea_queue = new Queue<String>(100);\n}", "CodeBleu_score": 34.344628098133285}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea != NULL) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new Queue<NmeaSentence>();\n}", "CodeBleu_score": 37.01937698547665}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t#if 0\n    int32_t x;\n    int32_t y;\n\n    /* The parameter of \"color_p\" is an array of pixel colors.\n     * Get the first pixel's coordinates.\n     */\n    x = area->x1;\n    y = area->y1;\n\n    /* Iterate through the pixels in the specified area */\n    while(x <= area->x2 && y <= area->y2) {\n        /* Set the display's pixel color.\n         * In this case, every pixel has the same color.\n         */\n        my_disp_drv.draw_buf->buf[y * my_disp_drv.draw_buf->stride + x] = *color_p;\n\n        /* Go to the next pixel */\n        x++;\n        y++;\n    }\n\n    /* IMPORTANT!\n     * Inform the graphics library that you are ready with the flushing\n     * If you forget it, the library won't know that you are ready and won't display\n     * the new frame.\n     */\n    lv_disp_flush_ready(disp);\n#endif\n}", "CodeBleu_score": 39.221699532108644}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\n/*\n * In this example, \"area\" is the full display area.\n * In other cases, you can use \"area\" to just refresh part of the screen.\n * E.g. if a button is pressed on the screen, you can refresh just the button area.\n */\n\n    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n\n/*\n * The buffer's first row starts at the first line of the area.\n */\n    uint32_t buf_row_start = (area->y1 + disp->ver_res - 1) * disp->hor_res;\n\n/*\n * Iterate through the rows of the area.\n */\n    for (uint32_t y = 0; y < h; y++) {\n\n/*\n * The buffer's first pixel starts at the first column of the area.\n */\n        uint32_t buf_col_start = area->x1 * sizeof(lv_color_t);\n\n/*\n * Iterate through the columns of the area.\n */\n        for (uint32_t x = 0; x < w; x++) {\n\n/*\n * Set the address window to the current pixel.\n */\n            my_disp_drv.set_px_cb(buf_row_start + buf_col_start, *color_p);\n\n/*\n * Increment the column address by one pixel.\n */\n            buf_col_start += sizeof(lv_color_t);\n\n/*\n * Increment the pixel color by one pixel.\n */\n            color_p++;\n        }\n\n/*\n * Increment the row address by one row.\n */\n        buf_row_start -= disp->hor_res * sizeof(lv_color_t);\n    }\n\n/*\n * Finally, notify the graphics library that the flush is complete.\n */\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 46.47097635111076}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu != NULL) {\n\t\tMenu * currentMenu = menu;\n\t\twhile (currentMenu != NULL) {\n\t\t\tfor (int i = 0; i < layer; i++) {\n\t\t\t\tstd::cout << \"\\t\";\n\t\t\t}\n\t\t\tstd::cout << currentMenu->getName() << std::endl;\n\t\t\tcurrentMenu = currentMenu->getNext();\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}", "CodeBleu_score": 44.19673278773614}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tMenuNode * node = menu->getHead();\n\twhile (node != NULL) {\n\t\tcout << setw(layer * 4) << \"\";\n\t\tcout << node->getName() << endl;\n\t\tnode = node->getNext();\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 33.14908517318358}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (int i = 0; i < menu->getSize(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \" \";\n\t\t}\n\t\tcout << menu->getNode(i).getName() << endl;\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 48.88508279367994}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t", "CodeBleu_score": 1.5471157130300377}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i = 0;\n\tfor (i = 0; i < count; i++) {\n\t\tString ssid = \"SSID\";\n\t\tint j = 0;\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tssid += (char)(random(0, 26) + 97);\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tint mac[6];\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tmac[j] = random(0, 255);\n\t\t}\n\t\tssidList.push_back(ssid);\n\t\tchannelList.push_back(channel);\n\t\tmacList.push_back(mac);\n\t\tSerial.println(ssid);\n\t}\n\treturn i;\n}", "CodeBleu_score": 37.411743477801735}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint j;\n\tint k;\n\tint r;\n\tint channel;\n\tint mac[6];\n\tString ssid;\n\tint ssidCount = 0;\n\tfor (i = 0; i < count; i++) {\n\t\t// generate random channel\n\t\tchannel = random(1, 11);\n\t\t// generate random MAC address\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tmac[j] = random(0, 255);\n\t\t}\n\t\t// generate random SSID\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tr = random(0, 255);\n\t\t\tif (r > 90) {\n\t\t\t\tr = 65 + r - 90;\n\t\t\t}\n\t\t\tssid += (char)r;\n\t\t}\n\t\t// add SSID to list\n\t\taddSSID(ssid, channel, mac);\n\t\tssidCount++;\n\t\t// print SSID to serial output\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.println(ssid);\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 40.02157573209185}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode(\"utf-8\"))\n    print(\"Received message '\" + payload + \"' on topic '\"\n        + message.topic + \"' with QoS \" + str(message.qos))\n    if payload == \"on\":\n        path = '/tmp/image.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print(url)\n        publish_message(url)\n    else:\n        print(\"off\")\n", "CodeBleu_score": 31.888454335415922}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload)\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        print('Capturing image.')\n        path = '/tmp/pic.jpg'\n        preview_capture(path)\n        print('Uploading file.')\n        url = upload_file(path, args.bucket_name)\n        print('Publishing message.')\n        publish_message(url)\n    elif payload == 'off':\n        print('Received \"off\" message. Shutting down.')\n        client.disconnect()\n    else:\n        print('Unrecognized message.')\n", "CodeBleu_score": 49.18155574274243}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = message.payload\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        payload, message.topic, str(message.qos)))\n    if payload == b'on':\n        preview_capture('image.jpg')\n        url = upload_file('image.jpg', args.bucket_name)\n        publish_message(url)\n    elif payload == b'off':\n        print('Turning off camera.')\n    else:\n        print('Unrecognized command.')\n\n", "CodeBleu_score": 43.72898646187436}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Example Google Cloud IoT MQTT device connection code.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--registry_id',\n        required=True,\n        help='Cloud IoT registry id')\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Cloud IoT device id')\n    parser.add_argument(\n        '--private_key_file',\n        required=True,\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--num_messages',\n        default=100,\n        type=int,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help=('Indicates whether the message to be published is a '\n              'telemetry event or a device state message.'))\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port', default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help=('Expiration time, in minutes, for JWT tokens.'))\n    parser.add_argument(\n        '--mqtt_topic',\n        default='/devices/{}/{}'.format(\n            registry_id,\n            device_id),\n        help='MQTT topic.')\n\n    return parser.parse_args()\n\n", "CodeBleu_score": 49.05612019048848}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\", required=True, help=\"Path to private key file.\"\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", default=100, type=int, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Type of message to publish. Either 'event' or 'state'.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", default=8883, help=\"MQTT bridge port.\"\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        default=20,\n        type=int,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n    )\n    parser.add_argument(\n        \"--mqtt_topic\",\n        default=\"events\",\n        help=\"MQTT topic name to subscribe to.\",\n    )\n    parser.add_argument(\n        \"--message_payload\",\n        default=\"Hello, World!\",\n        help=\"Message payload to publish.\",\n    )\n    parser", "CodeBleu_score": 35.06129134276101}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description='Example Google Cloud IoT MQTT device connection code.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--registry_id',\n        required=True,\n        help='Cloud IoT registry id')\n    parser.add_argument(\n        '--device_id',\n        required=True,\n        help='Cloud IoT device id')\n    parser.add_argument(\n        '--private_key_file',\n        required=True,\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--num_messages',\n        default=100,\n        type=int,\n        help=('Number of messages to publish. If 0, continues '\n              'to publish messages until the program is terminated'))\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        choices=(8883, 443),\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help=('Indicates whether the message to be published is a '\n              'telemetry event or a device state message.'))\n    parser.add_argument(\n        '--payload_format',\n        choices=('json', 'csv'),\n        default='json',\n        help=('Indicates whether the payload is JSON or CSV.'))\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help=('Expiration time, in minutes, for JWT tokens.'))\n    parser.add", "CodeBleu_score": 46.622532151075966}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    scopes = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    version = \"v1\"\n    discovery_url = \"https://{api}.googleapis.com/$discovery/rest?version={apiVersion}\".format(\n        api=\"cloudiot\", apiVersion=version\n    )\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n    return discovery.build(\n        \"cloudiot\",\n        version,\n        credentials=credentials,\n        discoveryServiceUrl=discovery_url,\n    )\n\n", "CodeBleu_score": 31.753745424361927}, {"code": "def get_client(service_account_json)\n\t\n    # The file \"service_account_json\" is a path to a JSON file containing the private key for a service account.\n    # The service account must have the \"Cloud IoT Core Service Agent\" role.\n    # The service account must have the \"Cloud IoT Core Device\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    # The service account must have the \"Service Account User\" role.\n    # The service account must have the \"Service Account Admin\" role.\n    # The service account must have the \"Service Account Key Admin\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    # The service account must have the \"Service Account User\" role.\n    # The service account must have the \"Service Account Admin\" role.\n    # The service account must have the \"Service Account Key Admin\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    # The service account must have the \"Service Account User\" role.\n    # The service account must have the \"Service Account Admin\" role.\n    # The service account must have the \"Service Account Key Admin\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    # The service account must have the \"Service Account User\" role.\n    # The service account must have the \"Service Account Admin\" role.\n    # The service account must have the \"Service Account Key Admin\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    # The service account must have the \"Service Account User\" role.\n    # The service account must have the \"Service Account Admin\" role.\n    # The service account must have the \"Service Account Key Admin\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    # The service account must have the \"Service Account User\" role.\n    # The service account must have the \"Service Account Admin\" role.\n    # The service account must have the \"Service Account Key Admin\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    # The service account must have the \"Service Account User\" role.\n    # The service account must have the \"Service Account Admin\" role.\n    # The service account must have the \"Service Account Key Admin\" role.\n    # The service account must have the \"Service Account Token Creator\" role.\n    #", "CodeBleu_score": 0.625}, {"code": "def get_client(service_account_json)\n\t\n\n    # Define the required scopes for the Cloud IoT Core service\n    CLOUD_IOT_CORE_SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Use the Cloud IoT Core API Discovery doc to find the URL for the\n    # Cloud IoT Core API\n    CLOUD_IOT_CORE_DISCOVERY_URL = ('https://cloudiot.googleapis.com/$discovery/rest?'\n                                    'version=v1')\n\n    # Use the service account credentials to build the Cloud IoT Core client\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(CLOUD_IOT_CORE_SCOPES)\n\n    return discovery.build(\n        'cloudiot', 'v1', credentials=scoped_credentials,\n        discoveryServiceUrl=CLOUD_IOT_CORE_DISCOVERY_URL)\n\n", "CodeBleu_score": 38.98423909686769}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    hash_method_asn1 = get_hash_method_asn1(hash_method)\n    hash_asn1 = hash_method_asn1 + hash_value\n\n    signature = _pad_for_signing(hash_asn1, 128)\n    signature = priv_key.sign(signature, hash_method)\n\n    return signature\n\n", "CodeBleu_score": 10.215412447652444}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    # Retrieve ASN1 code for hash method\n    asn1_code = HASH_ASN1_CODE[hash_method]\n\n    # Concatenate ASN1 code and hash value\n    to_sign = asn1_code + hash_value\n\n    # Pad for signing\n    padded = _pad_for_signing(to_sign, 1024)\n\n    # Sign padded hash value\n    signature = priv_key.sign(padded, hash_method)\n\n    return signature\n\n\n", "CodeBleu_score": 10.03703112342323}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n\n    hash_method_code = get_hash_method_code(hash_method)\n    if hash_method_code == b'':\n        raise ValueError('Invalid hash method')\n\n    hash_value = asn1_length_and_value(hash_value)\n    hash_value = asn1_sequence(hash_method_code + hash_value)\n    padded_hash = _pad_for_signing(hash_value, 1024)\n    signature = priv_key.sign(padded_hash, hash_method)\n\n    return signature\n\n", "CodeBleu_score": 32.66705424566395}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer\n    signature = int.from_bytes(signature, 'big')\n\n    # Decrypt the signature to get the clear signature\n    clearsig = pub_key.decrypt(signature)\n\n    # Find the hash method\n    hash_method = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_hashing(message_hash, hash_method)\n\n    # Verify the signature\n    if clearsig != expected_padded_hash:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n", "CodeBleu_score": 41.18052710743833}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer.\n    sig_int = asn1_decode(signature)\n\n    # Decrypt the signature to get the clear signature.\n    clearsig = pub_key.decrypt(sig_int)\n\n    # Find the hash method.\n    method_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message.\n    digest = compute_hash(message, method_name)\n\n    # Reconstruct the expected padded hash.\n    expected_hash = _pad_for_hash(digest, method_name)\n\n    # Compare the hashes.\n    if expected_hash != clearsig:\n        raise VerificationError('Verification failed')\n\n    return method_name\n", "CodeBleu_score": 22.81169680148371}, {"code": "def verify(message, signature, pub_key)\n\t\n    pub_key = pub_key.to_cryptography_key()\n    if not isinstance(pub_key, rsa.RSAPublicKey):\n        raise TypeError('pub_key must be an instance of RSAPublicKey')\n\n    # Convert signature to a integer\n    signature = int.from_bytes(signature, 'big')\n\n    # Decrypt signature\n    clearsig = pub_key.encrypt(signature, None)[0]\n\n    # Find hash method\n    hashname = _find_method_hash(clearsig)\n\n    # Compute hash of message\n    hash_ = compute_hash(message, hashname)\n\n    # Reconstruct padded hash\n    expected = _pad_for_hash(hash_, hashname)\n\n    # Compare\n    if clearsig != expected:\n        raise VerificationError('Verification failed')\n\n    return hashname\n", "CodeBleu_score": 43.23513188345672}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\ttime_t t = time(NULL);\n\tdebug_printInfo(\"Time: %s\", ctime(&t));\n\tif (t > 0) {\n\t\tupdateJWT(t);\n\t}\n\tdebug_printInfo(\"MQTT: connecting to %s:%d\", mqttServer, mqttPort);\n\tMQTT_connect(mqttClient, mqttServer, mqttPort, cid, mqttTopic, mqttPassword, PASSWORD_SPACE, 0);\n\tdebug_printInfo(\"MQTT: connected\");\n\tmqttConnected = 1;\n\tMQTT_subscribe(mqttClient, mqttTopic, 1);\n}", "CodeBleu_score": 44.50828114565638}, {"code": "static void connectMQTT(){\n\t\ttime_t now;\n\ttime(&now);\n\tdebug_printInfo(\"MQTT: Connecting at %s\", ctime(&now));\n\n\t// Update JWT\n\tupdateJWT((uint32_t)now);\n\n\t// Connect to MQTT\n\tif (CRYPTO_CLIENT_connectMQTT(cid, mqttTopic, mqttPassword, PASSWORD_SPACE, mqttPort, 10) != 0) {\n\t\tdebug_printError(\"MQTT: Connection failed\");\n\t} else {\n\t\tdebug_printInfo(\"MQTT: Connected\");\n\t\tsubscribeFlag = 1;\n\t}\n}", "CodeBleu_score": 38.55442313796075}, {"code": "static void connectMQTT(){\n\t#if defined(ESP32)\n   if (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_EXT0) {\n      debug_printInfo(\"Woke up from deep sleep\");\n   }\n#endif\n   time_t now = time(NULL);\n   debug_printInfo(\"Current time: %s\", ctime(&now));\n   if (now < 1577836800) {\n      debug_printError(\"Time is not set, or invalid, setting time.\");\n      setTime();\n   }\n   updateJWT(now);\n   debug_printInfo(\"Connecting to MQTT broker\");\n   mqttClient.begin(mqttServer, mqttPort, mqttConnectTimeout, mqttKeepalive, mqttClientID, mqttUser, mqttPassword, mqttLWTTopic, mqttLWTMessage, mqttLWTQoS, mqttLWTretain);\n   mqttClient.onMessage(onMessage);\n   mqttClient.onConnect(onConnect);\n   mqttClient.onDisconnect(onDisconnect);\n   mqttClient.setCallback(onMessage);\n   mqttClient.subscribe(mqttTopic, mqttQoS);\n   mqttClient.loop();\n   mqttConnected = true;\n   debug_printInfo(\"MQTT: Connected\");\n}", "CodeBleu_score": 46.177592685768786}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint8_t c;\n\tuint32_t n = 0;\n\twhile (width--) {\n\t\tc = *str++;\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str - 1;\n\t\t}\n\t\tn = (n * 10) + (c - '0');\n\t}\n\t*num = n;\n\treturn str;\n}", "CodeBleu_score": 22.236617554258842}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tint i;\n\tuint32_t value;\n\n\tvalue = 0;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9')\n\t\t\treturn str;\n\t\tvalue = value * 10 + (str[i] - '0');\n\t}\n\t*num = value;\n\treturn str + width;\n}", "CodeBleu_score": 23.68635235939119}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tuint8_t c = *str++;\n\t\tif (!isdigit(c)) {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + c - '0';\n\t}\n\t*num = n;\n\treturn str;\n}", "CodeBleu_score": 21.92269717765375}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t", "CodeBleu_score": 8.664763911052182}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\n}", "CodeBleu_score": 8.707806121624742}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t//    if(listHead == NULL)\n//    {\n//        return false;\n//    }\n//\n//    if(listHead == timer)\n//    {\n//        listHead = listHead->next;\n//        return true;\n//    }\n//\n//    timerStruct_t *prev = listHead;\n//    timerStruct_t *current = listHead->next;\n//\n//    while(current != NULL)\n//    {\n//        if(current == timer)\n//        {\n//            prev->next = current->next;\n//            return true;\n//        }\n//\n//        prev = current;\n//        current = current->next;\n//    }\n//\n//    return false;\n}", "CodeBleu_score": 4.622184408804685}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ntimerStruct_t * volatile *p = list;\ntimerStruct_t *prev = NULL;\n\nwhile(1)\n{\n    if(*p==timer)\n    {\n        if(prev)\n        {\n            prev->next = timer->next;\n        }\n        else\n        {\n            *list = timer->next;\n        }\n        return true;\n    }\n    else if(*p==NULL)\n    {\n        return false;\n    }\n    else\n    {\n        prev = *p;\n        p = &(*p)->next;\n    }\n}\n\n}", "CodeBleu_score": 33.25129529542016}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t#ifdef DEBUG\n    printf(\"timeout_deleteHelper\n\");\n#endif\n\n    if (list == NULL || timer == NULL)\n    {\n        return false;\n    }\n\n    if (*list == NULL)\n    {\n        return false;\n    }\n\n    if (*list == timer)\n    {\n        *list = (*list)->next;\n        return true;\n    }\n\n    timerStruct_t *prev = *list;\n    timerStruct_t *cur = (*list)->next;\n\n    while (cur != NULL)\n    {\n        if (cur == timer)\n        {\n            prev->next = cur->next;\n            return true;\n        }\n        prev = cur;\n        cur = cur->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 45.88348978884363}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t\tint ret = BSD_ERROR;\n\tif (socket >= 0 && socket < BSD_MAX_SOCKETS) {\n\t\tif (gastrSockets[socket].bIsUsed) {\n\t\t\tret = BSD_SUCCESS;\n\t\t\tif (BSD_close_internal(socket) != SOCK_ERR_NO_ERROR) {\n\t\t\t\tret = BSD_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbsd_setErrNo(EBADF);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 33.47603471887172}, {"code": "int BSD_close(int socket){\n\t", "CodeBleu_score": 1.4458552095808714}, {"code": "int BSD_close(int socket){\n\t\tint ret = 0;\n\ttstrSocket\tstrclose;\n\tstrclose.sock = socket;\n\tstrclose.u16SessionID\t\t= gastrSockets[socket].u16SessionID;\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\tuint8\tu8Cmd = SOCKET_CMD_CLOSE;\n\t\tgastrSockets[socket].bIsUsed = 0;\n\t\tgastrSockets[socket].u16SessionID =0;\n\t\tif(gastrSockets[socket].u8SSLFlags & SSL_FLAGS_ACTIVE)\n\t\t{\n\t\t\tu8Cmd = SOCKET_CMD_SSL_CLOSE;\n\t\t}\n\t\tret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);\n\t\tif(ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tret = SOCK_ERR_INVALID;\n\t\t}\n\t\tm2m_memset((uint8*)&gastrSockets[socket], 0, sizeof(tstrSocket));\n\t}\n\treturn ret;\n}", "CodeBleu_score": 38.13104425778237}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = BSD_ERROR;\n\tsint8 s8Ret = listen(socket, backlog);\n\tif(s8Ret == SOCK_ERR_NO_ERROR)\n\t{\n\t\tret = BSD_SUCCESS;\n\t}\n\telse if(s8Ret == SOCK_ERR_INVALID)\n\t{\n\t\tret = BSD_ERROR;\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t}\n\telse\n\t{\n\t\tret = BSD_ERROR;\n\t\tbsd_setErrNo(BSD_EOPNOTSUPP);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 34.75869636338504}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = BSD_ERROR;\n\tsint8 s8Ret;\n\n\ts8Ret = listen(socket, backlog);\n\tif(s8Ret == SOCK_ERR_NO_ERROR)\n\t{\n\t\tret = BSD_SUCCESS;\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(s8Ret);\n\t}\n\treturn ret;\n}", "CodeBleu_score": 29.813791465465854}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint\t\tiRet = BSD_ERROR;\n\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\tsint8\ts8Ret = listen(socket, backlog);\n\n\t\tif(s8Ret == SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tiRet = BSD_SUCCESS;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t}\n\t}\n\telse\n\t{\n\t\tbsd_setErrNo(SOCK_ERR_INVALID_ARG);\n\t}\n\treturn iRet;\n}", "CodeBleu_score": 30.342677307329847}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t#if defined(ESP8266)\n   struct timeval now;\n   gettimeofday(&now, NULL);\n   time_t t = now.tv_sec;\n#elif defined(ESP32)\n   time_t t = time(NULL);\n#endif\n   debug_printInfo(\"MQTT: Connecting to MQTT broker...\");\n   updateJWT(t);\n   if (CRYPTO_CLIENT_connect() == 0) {\n      debug_printInfo(\"MQTT: Connected to MQTT broker\");\n      mqttConnected = 1;\n      mqttSendSubscribe = 1;\n   } else {\n      debug_printError(\"MQTT: Failed to connect to MQTT broker\");\n   }\n}", "CodeBleu_score": 45.34041574639323}, {"code": "static void connectMQTT(){\n\t\tif (CRYPTO_CLIENT_getTime() == 0) {\n\t\tdebug_printError(\"MQTT: Time not set\");\n\t\treturn;\n\t}\n\ttime_t t = CRYPTO_CLIENT_getTime() - UNIX_OFFSET;\n\tdebug_printInfo(\"MQTT: Time is %s\", ctime(&t));\n\n\tupdateJWT(CRYPTO_CLIENT_getTime());\n\tif (CRYPTO_CLIENT_connect() == 0) {\n\t\tdebug_printInfo(\"MQTT: Connected\");\n\t\tmqtt_subscribe = 1;\n\t}\n}", "CodeBleu_score": 41.82180546541574}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = getEpoch();\n\tdebug_printInfo(\"MQTT: Connecting to %s:%d\", mqttServer, mqttPort);\n\ttime_t t = epoch - UNIX_OFFSET;\n\tdebug_printInfo(\"MQTT: Current time is %s\", ctime(&t));\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t\tdebug_printInfo(\"MQTT: Attempting to connect to %s:%d\", mqttServer, mqttPort);\n\t\tif (MQTT_CLIENT_connect(mqttClient, mqttServer, mqttPort, cid, mqttTopic, mqttPassword, PASSWORD_SPACE, 0) == 0) {\n\t\t\tdebug_printInfo(\"MQTT: Connected\");\n\t\t\tmqttConnected = 1;\n\t\t} else {\n\t\t\tdebug_printError(\"MQTT: Failed to connect\");\n\t\t}\n\t}\n}", "CodeBleu_score": 42.41150814346704}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t#ifdef DEBUG\n   printf(\"Disconnecting from the cloud service...\n\");\n#endif\n\n   if (mqttState == CONNECTED) {\n      mqttDisconnect(&mqttContext);\n   }\n}", "CodeBleu_score": 48.172169578188644}, {"code": "void CLOUD_disconnect(void){\n\t\tif (mqttState == CONNECTED) {\n\t\tMQTT_Disconnect(&connectionInfo);\n\t}\n}", "CodeBleu_score": 37.09943856000342}, {"code": "void CLOUD_disconnect(void){\n\t\tif (mqttState == CONNECTED) {\n\t\tMQTT_Disconnect(&mqttContext);\n\t}\n\n\tif (mqttState == DISCONNECTED) {\n\t\tLOG_INFO(\"MQTT client disconnected\");\n\t}\n}", "CodeBleu_score": 46.11968643557554}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif (passed_wifi_creds) {\n\t\t/* Connect to the AP using new credentials */\n\t\tif (!m2m_wifi_connect((char *)SSID, sizeof(SSID), M2M_WIFI_SEC_WPA_PSK, (void *)PASSWORD, M2M_WIFI_CH_ALL)) {\n\t\t\t/* Failed to connect using new credentials */\n\t\t\tdebug_printError(\"Failed to connect to AP with new credentials\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t/* Connect to the AP using default credentials */\n\t\tif (!m2m_wifi_default_connect()) {\n\t\t\t/* Failed to connect using default credentials */\n\t\t\tdebug_printError(\"Failed to connect to AP with default credentials\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.33098912358435}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t", "CodeBleu_score": 1.603301960152807}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tif(passed_wifi_creds) {\n\t\t/* Connect to the AP using new credentials. */\n\t\tif(m2m_wifi_connect((char*)ssid, sizeof(ssid), M2M_WIFI_SEC_WPA_PSK, (void*)password, M2M_WIFI_CH_ALL) == M2M_SUCCESS) {\n\t\t\t/* Connection succeeded. */\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\t/* Connection failed. */\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\t/* Connect to the AP using default credentials. */\n\t\tif(m2m_wifi_default_connect() == M2M_SUCCESS) {\n\t\t\t/* Connection succeeded. */\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\t/* Connection failed. */\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CodeBleu_score": 47.499690074725606}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t\t// Create a client and send a GraphQL query to fetch sensor data\n\tconst client = new GraphQLClient(\"https://api.ttn.com/v3/graphql\");\n\tconst query = `{\n\t\tsensors(query: \"application_id='${applicationID}'\") {\n\t\t\tname\n\t\t\tdescription\n\t\t\tcoordinates {\n\t\t\t\tlatitude\n\t\t\t\tlongitude\n\t\t\t}\n\t\t}\n\t}`;\n\tconst result = await client.request(query);\n\tconsole.log(result);\n\n\t// If the response contains data, it logs the retrieval of sensors and iterates through each sensor to create a marker\n\tif (result.sensors) {\n\t\tconsole.log(\"Retrieved \" + result.sensors.length + \" sensors\");\n\t\tfor (const sensor of result.sensors) {\n\t\t\t// Create a marker and place it on the map\n\t\t\tconst marker = L.marker([sensor.coordinates.latitude, sensor.coordinates.longitude]);\n\t\t\tmarker.bindPopup(sensor.name + \"<br>\" + sensor.description);\n\t\t\tmap.addLayer(marker);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.059858733836876}, {"code": "async function DisplaySensors(map){\n\t// Create a client using the API key\nconst client = new GraphQLClient(\n\"https://api.sensor.community/v1/graphql\",\n{\nheaders: {\n\"Authorization\": \"Bearer \" + API_KEY\n}\n}\n);\n\n// Send a GraphQL query to fetch sensor data\nconst { data, errors } = await client.request(\n`\nquery {\nsensors(first: 100) {\nnodes {\nid\nname\ndescription\nlocation {\nlatitude\nlongitude\n}\n}\n}\n}\n`\n);\n\n// Log the response from the API\nconsole.log(data);\n\n// If there is an error, log it\nif (errors) {\nconsole.error(errors);\n}\n\n// If there is data, log it\nif (data) {\nconsole.log(\"Retrieved sensors\");\n\n// Iterate through each sensor\ndata.sensors.nodes.forEach(sensor => {\n// Create a marker for the sensor\nconst marker = new mapboxgl.Marker()\n.setLngLat([sensor.location.longitude, sensor.location.latitude])\n.addTo(map);\n\n// Create a popup for the marker\nconst popup = new mapboxgl.Popup()\n.setHTML(`<b>${sensor.name}</b><br>${sensor.description}`)\n.addTo(marker);\n});\n}\n}", "CodeBleu_score": 37.421612628863144}, {"code": "async function DisplaySensors(map){\n\t\n// Create a client and set up the query.\nconst client = new ApolloClient({\nuri: \"https://api.graph.cool/simple/v1/cjz15q16h031401219m60977g\",\n});\nconst query = `\nquery Sensors($lat: Float!, $lon: Float!, $radius: Float!) {\nsensors(lat: $lat, lon: $lon, radius: $radius) {\nid\nname\nlat\nlon\n}\n}\n`;\n\n// Create a GeoJSON point feature with a random color and a circle marker for the sensor.\nconst createMarker = (sensor) => {\nconst color = `#${Math.floor(Math.random() * 16777215).toString(16)}`;\nconst marker = L.circleMarker([sensor.lat, sensor.lon], {\ncolor: color,\nfillColor: color,\nfillOpacity: 1,\nradius: 10,\n});\nmarker.bindPopup(`Sensor: ${sensor.name}`);\nreturn marker;\n};\n\n// Create a GeoJSON feature collection from the sensor data and add it to the map.\nconst createSensorMarkers = (sensors) => {\nconst markers = L.geoJSON(sensors, {\npointToLayer: createMarker,\n});\nmarkers.addTo(map);\n};\n\n// Fetch sensor data from the API.\nconst { data } = await client.query({\nquery,\nvariables: {\nlat: map.getCenter().lat,\nlon: map.getCenter().lng,\nradius: 1000,\n},\n});\n\n// If the response contains data, log the retrieval of sensors and add markers to the map.\nif (data.sensors) {\nconsole.log(`Retrieved ${data.sensors.length} sensors`);\ncreateSensorMarkers(data.sensors);\n}\n}", "CodeBleu_score": 33.6819903776142}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"rgba(255, 255, 255, 0.5)\";\n\tmarker.style.border = \"solid 2px rgba(255, 255, 255, 0.5)\";\n\tmarker.style.borderRadius = \"50%\";\n\treturn marker;\n}", "CodeBleu_score": 46.664133183791314}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"black\";\n\tmarker.style.borderColor = \"black\";\n\tmarker.style.borderStyle = \"solid\";\n\tmarker.style.borderWidth = \"2px\";\n\tmarker.style.borderRadius = \"50%\";\n\tmarker.style.width = \"30px\";\n\tmarker.style.height = \"30px\";\n\tmarker.style.position = \"absolute\";\n\tmarker.style.transform = \"translate(-50%, -50%)\";\n\tmarker.style.zIndex = \"100\";\n\treturn marker;\n}", "CodeBleu_score": 41.71262731099182}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\t// Create the marker element.\n\tconst marker = document.createElement(\"div\");\n\t// Set the marker's id to the sensor's unique ID.\n\tmarker.id = sensor.id;\n\t// Assign the marker a specific class name.\n\tmarker.className = \"sensor\";\n\t// Style the marker with a default color and border.\n\tmarker.style.backgroundColor = \"blue\";\n\tmarker.style.border = \"solid 1px black\";\n\t// Return the created marker element.\n\treturn marker;\n}", "CodeBleu_score": 42.07846343720455}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.auth.mfa_{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load auth mfa module %s: %s\", module_path, err)\n        raise err\n    except Exception as err:\n        _LOGGER.exception(\"Unexpected error loading auth mfa module %s: %s\", module_path, err)\n        raise err\n    return module\n\n", "CodeBleu_score": 36.2700270315289}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    mfa_module_path = f\"homeassistant.auth_providers.{module_name}\"\n    mfa_module = await async_import_module(hass, mfa_module_path)\n    return mfa_module", "CodeBleu_score": 10.828640689062317}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path: str = f\"homeassistant.auth.mfa_{module_name}\"\n    if module_name in hass.data.get(DATA_MFA_MODULES, {}):\n        return hass.data[DATA_MFA_MODULES][module_name]\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(f\"MFA module {module_name} not found\") from err\n    if not hasattr(module, \"async_setup_mfa\"):\n        raise HomeAssistantError(f\"MFA module {module_name} does not define async_setup_mfa\")\n    if not hasattr(module, \"async_setup\"):\n        raise HomeAssistantError(f\"MFA module {module_name} does not define async_setup\")\n    hass.data[DATA_MFA_MODULES][module_name] = module\n    return module", "CodeBleu_score": 42.156004736350226}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    try:\n        pin = setup_data[\"pin\"]\n        if user_id in self.data:\n            self.data[user_id][\"pin\"] = pin\n        else:\n            self.data[user_id] = {\"pin\": pin}\n        return True\n    except Exception as e:\n        _LOGGER.error(f\"async_setup_user error: {e}\")\n        return False\n\n", "CodeBleu_score": 43.94859814609518}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(\"pin\")\n    if not pin:\n        raise InvalidSetupDataError(\n            \"The setup data is missing the PIN for this module.\")\n    self._data_list[user_id] = pin\n    return True\n\n", "CodeBleu_score": 33.77108459161807}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for i in range(len(self.data)):\n        if self.data[i][\"user_id\"] == user_id:\n            self.data[i][\"pin\"] = pin\n            return True\n    self.data.append({\"user_id\": user_id, \"pin\": pin})\n    return True\n\n", "CodeBleu_score": 49.092661310114885}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t import it into the global variable \"hass.data\" and sets the initialization lock.\"\"\"\n    async with self._lock:\n        if self._initialized:\n            return\n\n        if not (data := await self._store.async_load()):\n            data = {}\n\n        if not data:\n            data = {}\n\n        self._states_data = {\n            entity_id: State(\n                entity_id=state[\"entity_id\"],\n                state=state[\"state\"],\n                attributes=state[\"attributes\"],\n                last_changed=state[\"last_changed\"],\n                last_updated=state[\"last_updated\"],\n                context=state[\"context\"],\n                object_id=state[\"object_id\"],\n            )\n            for entity_id, state in data.items()\n        }\n\n        self._initialized = True\n\n", "CodeBleu_score": 14.957634336087015}, {"code": "async def _async_load(self) -> None\n\t def _async_load(self) -> None:\"\"\"\n    if self._init_lock.locked():\n        return\n\n    async with self._init_lock:\n        if self._data is not None:\n            return\n\n        self._data = {}\n\n        if not (data := await self._store.async_load()):\n            self._data = {}\n            return\n\n        # In 2021.9 we fixed validation to disallow a path (because that's never\n        # correct) but this data still lives in storage, so we print a warning.\n        if data.get(\"external_url\") and urlparse(data[\"external_url\"]).path not in (\n            \"\",\n            \"/\",\n        ):\n            _LOGGER.warning(\"Invalid external_url set. It's not allowed to have a path\")\n\n        if data.get(\"internal_url\") and urlparse(data[\"internal_url\"]).path not in (\n            \"\",\n            \"/\",\n        ):\n            _LOGGER.warning(\"Invalid internal_url set. It's not allowed to have a path\")\n\n        self._data = data\n", "CodeBleu_score": 16.764738791842817}, {"code": "async def _async_load(self) -> None\n\t def _async_load(self) -> None:\n    \"\"\"\n    async with self._lock:\n        if self._data is not None:\n            return\n\n        data = await self._store.async_load()\n        if data is None:\n            data = {}\n\n        if \"units\" in data:\n            data[\"unit_system_v2\"] = data.pop(\"units\")\n\n        if \"unit_system\" in data:\n            data[\"unit_system_v2\"] = data.pop(\"unit_system\")\n\n        if \"unit_system_imperial\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.IMPERIAL\n                if data[\"unit_system_imperial\"]\n                else UnitSystem.METRIC\n            )\n\n        if \"unit_system_metric\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.METRIC\n                if data[\"unit_system_metric\"]\n                else UnitSystem.IMPERIAL\n            )\n\n        if \"unit_system_metric\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.METRIC\n                if data[\"unit_system_metric\"]\n                else UnitSystem.IMPERIAL\n            )\n\n        if \"unit_system_length\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.METRIC\n                if data[\"unit_system_length\"] == \"metric\"\n                else UnitSystem.IMPERIAL\n            )\n\n        if \"unit_system_temperature\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.METRIC\n                if data[\"unit_system_temperature\"] == \"metric\"\n                else UnitSystem.IMPERIAL\n            )\n\n        if \"unit_system_volume\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.METRIC\n                if data[\"unit_system_volume\"] == \"metric\"\n                else UnitSystem.IMPERIAL\n            )\n\n        if \"unit_system_weight\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.METRIC\n                if data[\"unit_system_weight\"] == \"metric\"\n                else UnitSystem.IMPERIAL\n            )\n\n        if \"unit_system_currency\" in data:\n            data[\"unit_system_v2\"] = (\n                UnitSystem.METRIC\n                if data[\"unit_system_currency\"] == \"metric\"\n                else UnitSystem.IMPERIAL\n           ", "CodeBleu_score": 11.643037604001098}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if not self._settings_loaded:\n        await self._load_settings()\n\n    if not self._settings_loaded:\n        return False\n\n    user_settings = self._settings.get(user_id)\n    if not user_settings:\n        return False\n\n    if not user_input.get(CONF_OTP):\n        return False\n\n    if not self._validate_otp(user_input[CONF_OTP], user_settings[CONF_SECRET]):\n        return False\n\n    return True", "CodeBleu_score": 49.881617078142774}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if not self._settings_loaded:\n        await self._load_settings()\n    settings = self._settings.get(user_id)\n    if settings is None:\n        return False\n    if user_input.get(CONF_OTP) is None:\n        return False\n    if not await self._verify_otp(user_input[CONF_OTP], settings):\n        return False\n    return True", "CodeBleu_score": 50.729866373452225}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    # Ensure user settings are loaded\n    await self.async_ensure_user_settings_loaded(user_id)\n    # Retrieve notification settings for the specified user\n    settings = self._user_settings.get(user_id)\n    if settings is None:\n        return False\n    # Validate the user input by verifying the OTP using an executor job\n    return await self.hass.async_add_executor_job(\n        self._verify_user_input, user_input, settings\n    )", "CodeBleu_score": 48.095386661825}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 71.85350694065305}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 47.22039460883292}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area_id = device.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.390134801419954}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    # TODO: this function is not used.\n    # It should be removed and the code should be refactored to use the\n    # _merge_policies function instead.\n    policy: PolicyType = None\n    seen: set[str] = set()\n    for source in policies:\n        if source is None:\n            continue\n\n        assert isinstance(source, dict)\n\n        if policy is None:\n            policy = cast(PolicyType, {})\n\n        assert isinstance(policy, dict)\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies if isinstance(src, dict)]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n\n", "CodeBleu_score": 48.63700926453715}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = None\n    seen: set[str] = set()\n    for source in policies:\n        if source is None:\n            continue\n\n        assert isinstance(source, dict)\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies if isinstance(src, dict)]\n\n            if policy is None:\n                policy = cast(PolicyType, {})\n\n            assert isinstance(policy, dict)\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n", "CodeBleu_score": 48.32975714766638}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = None\n    seen: set[str] = set()\n    for source in policies:\n        if source is None:\n            continue\n\n        assert isinstance(source, dict)\n\n        if policy is None:\n            policy = cast(PolicyType, {})\n\n        assert isinstance(policy, dict)\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in policies if isinstance(src, dict)]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy\n\n", "CodeBleu_score": 48.63700926453715}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(f\"Unable to find authentication provider {provider}\") from err\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not module.REQUIREMENTS:\n        return module\n    for requirement in module.REQUIREMENTS:\n        if requirement not in hass.data[DATA_AUTH_PROVIDERS_PROCESSED]:\n            await load_auth_provider_module(hass, requirement)\n    hass.data[DATA_AUTH_PROVIDERS_PROCESSED].add(provider)\n    return module\n", "CodeBleu_score": 38.891272574824924}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in AUTH_PROVIDER_MODULES:\n        return AUTH_PROVIDER_MODULES[provider]\n\n    try:\n        module = await async_import_module(f\"homeassistant.auth_providers.{provider}\")\n    except ImportError as err:\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider} from {err.name}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\"):\n        await async_process_requirements(hass, module.REQUIREMENTS)\n\n    AUTH_PROVIDER_MODULES[provider] = module\n\n    return module", "CodeBleu_score": 33.88714689533548}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    if provider in hass.data[DATA_AUTH_PROVIDERS]:\n        return hass.data[DATA_AUTH_PROVIDERS][provider]\n\n    module = await async_import_module(hass, f\"homeassistant.auth_providers.{provider}\")\n    hass.data[DATA_AUTH_PROVIDERS][provider] = module\n    return module", "CodeBleu_score": 21.731451859407354}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = user.password\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            else:\n                raise InvalidAuth(\"Incorrect password\")\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"User not found\")\n    else:\n        raise InvalidAuth(\"Incorrect password\")\n\n", "CodeBleu_score": 35.860491062382}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    normalized_username = normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == normalized_username:\n            if bcrypt.checkpw(password.encode(\"utf-8\"), user[\"password_hash\"].encode(\"utf-8\")):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password.\")\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"Invalid username.\")\n    else:\n        raise InvalidAuth(\"Invalid username and password.\")\n\n", "CodeBleu_score": 35.65812040024982}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"0\", bcrypt.gensalt(10))\n    for user in self.users:\n        if user[\"username\"] == username:\n            password_hash = user[\"password_hash\"].encode()\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password.\")\n    if bcrypt.checkpw(password.encode(), dummy_hash):\n        raise InvalidAuth(\"Invalid username.\")\n    else:\n        raise InvalidAuth(\"Invalid username and password.\")\n\n", "CodeBleu_score": 38.67694168141958}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(username)\n\n", "CodeBleu_score": 20.314026198076558}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    if username not in self.users:\n        raise InvalidUser(\"user_not_found\")\n    del self.users[username]\n\n", "CodeBleu_score": 17.10722748778741}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = username.lower()\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 26.007322982359536}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        self.async_initialize()\n    try:\n        await self._store.async_remove(credentials.data[\"username\"])\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 43.23056278451679}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        self.async_initialize()\n    try:\n        await self._store.async_remove(credentials.data[CONF_USERNAME])\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 39.72151219295388}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if self._data is None:\n        self.async_initialize()\n    try:\n        await self._store.async_remove(credentials.data[\"username\"])\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 45.660237357247745}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    start_time = time.time()\n    while True:\n        for thread in threads.copy():\n            if not thread.is_alive():\n                threads.remove(thread)\n                joined.add(thread)\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n                continue\n            if thread.ident is None:\n                threads.remove(thread)\n                joined.add(thread)\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n                continue\n            thread.join(timeout=max(0, start_time + timeout - time.time()))\n        if not threads:\n            break\n        timeout = min(1, start_time + timeout - time.time())\n    for thread in threads:\n        if thread.is_alive():\n            thread.raise_exception()\n    return joined\n\n", "CodeBleu_score": 49.967881970657345}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined = set()\n    start_time = time.time()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if not thread.ident:\n            joined.add(thread)\n            continue\n        if timeout is None:\n            thread.join()\n            joined.add(thread)\n            continue\n        remaining_time = start_time + timeout - time.time()\n        if remaining_time <= 0:\n            joined.add(thread)\n            continue\n        thread.join(remaining_time)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    for thread in threads - joined:\n        thread.raise_exception()\n    return joined\n\n", "CodeBleu_score": 49.40633710392489}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    # Calculate the timeout for each thread\n    thread_timeouts = {\n        thread: timeout * thread.daemon for thread in threads\n    }  # type: dict[Thread, float]\n    # Join each thread\n    joined_threads = set()  # type: set[Thread]\n    for thread, timeout in thread_timeouts.items():\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            # Thread has no identifier\n            pass\n        else:\n            if not thread.is_alive():\n                joined_threads.add(thread)\n    # Log any threads that are still running\n    if log:\n        for thread in threads - joined_threads:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n    # Attempt to interrupt any remaining threads\n    for thread in threads - joined_threads:\n        try:\n            thread.raise_exception()\n        except RuntimeError:\n            # Thread has no identifier\n            pass\n    return joined_threads\n\n", "CodeBleu_score": 40.560523547704776}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [\n        t for t in threading.enumerate() if t.name != \"MainThread\" and not t.isDaemon() and t.is_alive()\n    ]\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = int(settings.SHUTDOWN_TIMEOUT / len(threads))\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            logger.warning(f\"Failed to join thread {thread.name}\")\n\n", "CodeBleu_score": 23.515849194365483}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # pylint: disable=global-statement\n    global shutdown_timeout\n    global shutdown_time\n    global shutdown_time_remaining\n    global shutdown_threads\n    global shutdown_thread_timeouts\n\n    shutdown_time = time.time()\n    shutdown_time_remaining = shutdown_timeout\n    shutdown_threads = [t for t in threading.enumerate() if t.name != 'MainThread' and not t.daemon and t.is_alive()]\n    shutdown_thread_timeouts = [shutdown_time_remaining / len(shutdown_threads)] * len(shutdown_threads)\n\n    while shutdown_threads:\n        for thread, timeout in zip(shutdown_threads, shutdown_thread_timeouts):\n            thread.join(timeout)\n            if thread.is_alive():\n                logger.warning(f\"Failed to join thread '{thread.name}' in time. Killing it.\")\n                thread.kill()\n                shutdown_thread_timeouts.remove(timeout)\n                shutdown_threads.remove(thread)\n                break\n        else:\n            break\n", "CodeBleu_score": 33.4454273363745}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [\n        t for t in threading.enumerate() if t != threading.main_thread() and not t.isDaemon() and t.is_alive()\n    ]\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = shutdown_timeout / len(threads)\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        thread.join(timeout=timeout)\n        # Log a warning if joining a thread fails\n        if thread.is_alive():\n            logger.warning(f\"Could not join thread {thread.name}\")\n\n", "CodeBleu_score": 23.832602305801267}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if self._setup_remaining != remaining_with_setup_started:\n      self._setup_remaining = remaining_with_setup_started\n      self._dispatcher_signal.emit(self._setup_remaining)\n    self._has_remaining_setups = bool(self._setup_remaining)\n\n", "CodeBleu_score": 39.886295376584215}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n      self._dispatcher_signal.emit(remaining_with_setup_started)\n    else:\n      self._dispatcher_signal.emit(None)\n    self._has_remaining_with_setup_started = remaining_with_setup_started != {}\n\n", "CodeBleu_score": 35.51909791359725}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started:\n      self._dispatcher_signal.emit(remaining_with_setup_started)\n    self._remaining_setups_flag = bool(remaining_with_setup_started)\n    if self._remaining_setups_flag:\n      self.start_timer()\n    else:\n      self.stop_timer()\n\n  def _async_dispatch_setup(self, setup: Setup) -> None:\n    \"\"\"The function \"_async_dispatch_setup\" dispatches a signal based on the state of the setup.", "CodeBleu_score": 43.04193267235748}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if config.specific_integrations:\n        config.cache[\"bluetooth\"] = generate_and_validate(integrations)\n    else:\n        current_bluetooth = config.cache.get(\"bluetooth\")\n        if current_bluetooth != generate_and_validate(integrations):\n            config.add_error(\n                \"bluetooth\",\n                \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n                fixable=True,\n            )\n", "CodeBleu_score": 49.35754213262415}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    config.cache[\"bluetooth\"] = config.cache.get(\"bluetooth\", {})\n    cache = config.cache[\"bluetooth\"]\n\n    if not cache.get(\"integrations\", None):\n        cache[\"integrations\"] = [domain for domain in integrations]\n\n    if cache[\"integrations\"] != [domain for domain in integrations]:\n        cache[\"integrations\"] = [domain for domain in integrations]\n        config.cache[\"bluetooth\"] = cache\n        config.add_error(\n            \"bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    current_content = config.root / \"homeassistant/components/bluetooth/bluetooth.py\"\n    generated_content = config.root / \"homeassistant/generated/bluetooth.py\"\n\n    if not generated_content.is_file():\n        config.add_error(\n            \"bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    if not current_content.is_file():\n        config.cache[\"bluetooth\"] = cache\n        return\n\n    with open(generated_content, encoding=\"utf-8\") as fp:\n        generated = fp.read()\n\n    with open(current_content, encoding=\"utf-8\") as fp:\n        current = fp.read()\n\n    if generated != current:\n        config.add_error(\n            \"bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    config.cache[\"bluetooth\"] = cache\n", "CodeBleu_score": 49.07488011360891}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    if not config.specific_integrations:\n        config.cache[\"bluetooth\"] = config.cache.get(\"bluetooth\", {})\n        config.cache[\"bluetooth\"][\"content\"] = config.cache[\"bluetooth\"].get(\n            \"content\", _generate_and_validate(integrations)\n        )\n        config.cache[\"bluetooth\"][\"error\"] = config.cache[\"bluetooth\"].get(\n            \"error\", \"\"\n        )\n        config.cache[\"bluetooth\"][\"suggest\"] = config.cache[\"bluetooth\"].get(\n            \"suggest\", \"\"\n        )\n\n    else:\n        config.cache[\"bluetooth\"] = config.cache.get(\"bluetooth\", {})\n        config.cache[\"bluetooth\"][\"error\"] = config.cache[\"bluetooth\"].get(\n            \"error\", \"\"\n        )\n        config.cache[\"bluetooth\"][\"suggest\"] = config.cache[\"bluetooth\"].get(\n            \"suggest\", \"\"\n        )\n\n        if \"bluetooth\" not in config.specific_integrations:\n            return\n\n        config.cache[\"bluetooth\"][\"error\"] = \"\"\n        config.cache[\"bluetooth\"][\"suggest\"] = \"\"\n\n        if config.cache[\"bluetooth\"][\"content\"] != _generate_and_validate(\n            integrations\n        ):\n            config.cache[\"bluetooth\"][\"error\"] = (\n                \"The content of bluetooth.py is not up to date. Run python3 -m script.hassfest\"\n                \" to update the file.\"\n            )\n            config.cache[\"bluetooth\"][\"suggest\"] = \"python3 -m script.hassfest\"\n", "CodeBleu_score": 41.13781077170194}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create the POST request.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s\", d.refreshToken)))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers.\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Basic %s\", base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf(\"%s:%s\", d.appKey, d.appSecret)))))\n\n\t// Send the request.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Close the response body.\n\tdefer resp.Body.Close()\n\n\t// Read the response body.\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the response was successful.\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"failed to refresh access token: %s\", string(body))\n\t}\n\n\t// Parse the response body.\n\tvar token struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\tif err := json.Unmarshal(body, &token); err != nil {\n\t\treturn err\n\t}\n\n\t// Update the access token.\n\td.accessToken = token.AccessToken\n\n\t// Update the expiration time.\n\td.expiration = time.Now().Add(time.Duration(token.ExpiresIn) * time.Second)\n\n\treturn nil\n}", "CodeBleu_score": 47.87487159187076}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret)))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tresp, err := d.Client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode != 200 {\n\t\treturn errors.New(fmt.Sprintf(\"Error refreshing access token: %s\", body))\n\t}\n\tvar respJSON struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tExpiresIn   int    `json:\"expires_in\"`\n\t}\n\terr = json.Unmarshal(body, &respJSON)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.AccessToken = respJSON.AccessToken\n\td.AccessTokenExpires = time.Now().Add(time.Duration(respJSON.ExpiresIn) * time.Second)\n\treturn nil\n}", "CodeBleu_score": 49.08474717560003}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Build the request.\n\treq, err := http.NewRequest(\"POST\", d.oauth2TokenURL, strings.NewReader(url.Values{\n\t\t\"grant_type\":    {\"refresh_token\"},\n\t\t\"refresh_token\": {d.refreshToken},\n\t\t\"client_id\":     {d.appKey},\n\t\t\"client_secret\": {d.appSecret},\n\t}.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the headers.\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body.\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check the status code.\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"bad status code: %d, body: %s\", resp.StatusCode, body)\n\t}\n\n\t// Parse the response body.\n\tvar respBody struct {\n\t\tAccessToken  string `json:\"access_token\"`\n\t\tExpiresIn    int    `json:\"expires_in\"`\n\t\tRefreshToken string `json:\"refresh_token\"`\n\t}\n\tif err := json.Unmarshal(body, &respBody); err != nil {\n\t\treturn err\n\t}\n\n\t// Update the access token.\n\td.accessToken = respBody.AccessToken\n\td.refreshToken = respBody.RefreshToken\n\n\treturn nil\n}", "CodeBleu_score": 48.71142079083035}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t", "CodeBleu_score": 3.0353489072674456}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Create a new request with the given method and URL\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Add the authorization header\n\treq.Header.Add(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\t// Add the parameters for supporting all drives\n\treq.URL.RawQuery = \"supportsAllDrives=true\"\n\n\t// Add the parameters for the drive\n\tif d.DriveID != \"\" {\n\t\treq.URL.RawQuery += \"&driveId=\" + d.DriveID\n\t}\n\n\t// Make the request\n\terr = d.requestWithRetry(req, callback, resp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Return the response body\n\treturn callback.GetBody()\n}", "CodeBleu_score": 35.89495627411522}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Make the request\n\tvar response *http.Response\n\tvar err error\n\tif callback != nil {\n\t\tresponse, err = callback(url, method, d.token)\n\t} else {\n\t\tresponse, err = d.client.Do(base.GetRequest(url, method, d.token))\n\t}\n\n\t// If the request failed, refresh the token and retry the request\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"401\") {\n\t\t\td.token, err = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\t// Get the response body\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If a response structure was provided, unmarshal the response body into it\n\tif resp != nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 56.33747555742298}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tfile, err := stream.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\t// Get the size of the file.\n\tfileSize := stream.Size()\n\n\t// Set the chunk size.\n\tchunkSize := 1024 * 1024 * 1024 // 1GB\n\tif fileSize <= chunkSize {\n\t\tchunkSize = fileSize\n\t}\n\n\t// Create the HTTP request.\n\treq, err := http.NewRequest(\"POST\", url, file)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set the content type.\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t// Set the content range.\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", chunkSize-1, fileSize))\n\t// Set the content length.\n\treq.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", chunkSize))\n\n\t// Create the HTTP client.\n\tclient := http.Client{}\n\n\t// Upload the file in chunks.\n\tfor offset := 0; offset < fileSize; offset += chunkSize {\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Set the content range.\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+chunkSize-1, fileSize))\n\t\t// Set the content length.\n\t\treq.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", chunkSize))\n\n\t\t// Send the request.\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check for errors.\n\t\tif resp.StatusCode != http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"unexpected response code: %d\", resp.StatusCode)\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.98698710821058}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size\n\tfileSize := stream.Size()\n\n\t// Calculate the chunk size\n\tchunkSize := int(math.Ceil(float64(fileSize) / float64(d.chunkSize)))\n\tif chunkSize == 0 {\n\t\tchunkSize = 1\n\n\t}\n\n\t// Upload each chunk\n\tfor i := 0; i < chunkSize; i++ {\n\t\t// Get the chunk\n\t\tchunk, err := stream.Chunk(i, d.chunkSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check for context cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Upload the chunk\n\t\tif err := d.uploadChunk(ctx, chunk, url, fileSize, i, chunkSize); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Return nil\n\treturn nil\n}", "CodeBleu_score": 37.146794604075936}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size.\n\tchunkSize := d.chunkSize(stream)\n\t// Create a new request with the correct headers.\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Length\", strconv.FormatInt(stream.Size(), 10))\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"X-Upload-Content-Length\", strconv.FormatInt(stream.Size(), 10))\n\treq.Header.Set(\"X-Upload-Content-Range\", \"bytes 0-\"+strconv.FormatInt(stream.Size()-1, 10)+\"/*\")\n\treq.Header.Set(\"X-Upload-Chunk-Granularity\", \"bytes\")\n\t// Send the request and check for errors.\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusCreated {\n\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t}\n\t// Start the upload.\n\tif err := d.uploadChunks(ctx, stream, url, chunkSize); err != nil {\n\t\treturn err\n\t}\n\t// Finish the upload.\n\tif err := d.finishUpload(ctx, stream, url); err != nil {\n\t\treturn err\n\t}\n\t// Return nil.\n\treturn nil\n}", "CodeBleu_score": 38.319341204745136}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind the JSON data from the request context.\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn err\n\t}\n\n\t// Check that the mount point is not empty.\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.String(http.StatusBadRequest, \"mount_point must be non-empty\")\n\t}\n\n\t// Attempt to unmount the storage.\n\tif err := mount.Umount(req.MountPoint); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err := config.Delete(req.MountPoint); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.String(http.StatusOK, \"success\")\n}", "CodeBleu_score": 30.923062504971583}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tmountPoint := ctx.FormValue(\"mount_point\")\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": \"mount_point is required\",\n\t\t})\n\t}\n\n\terr := unmountStorage(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\terr = deleteStorageConfig(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"success\",\n\t})\n}", "CodeBleu_score": 36.05813428933746}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Bind the JSON data from the request context.\n\tvar req struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Retrieve the mount point from the request.\n\tmountPoint := req.MountPoint\n\n\t// If the mount point is empty, return a client error response.\n\tif mountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"mount point cannot be empty\")\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := storage.Umount(mountPoint); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the configuration for the specified mount point.\n\tif err := config.Delete(mountPoint); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusOK)\n}", "CodeBleu_score": 36.29709898485981}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"file\")\n\tif len(filePath) == 0 {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"file path missing\",\n\t\t})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"file not found\",\n\t\t})\n\t}\n\n\t// Open the file and return its contents.\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"failed to open file\",\n\t\t})\n\t}\n\tdefer file.Close()\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 43.39847997218791}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif len(filePath) == 0 {\n\t\t// If the path is missing, return an error response\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"missing path parameter\"})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// If the file does not exist, return an error response\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file not found\"})\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\t// If an error occurred, return an error response\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error opening file\"})\n\t}\n\n\t// Get the file size\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\t// If an error occurred, return an error response\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error getting file size\"})\n\t}\n\n\t// Create a byte buffer with the size of the file\n\tfileBytes := make([]byte, fileInfo.Size())\n\n\t// Read the file into the byte buffer\n\t_, err = file.Read(fileBytes)\n\tif err != nil {\n\t\t// If an error occurred, return an error response\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error reading file\"})\n\t}\n\n\t// Close the file\n\terr = file.Close()\n\tif err != nil {\n\t\t// If an error occurred, return an error response\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error closing file\"})\n\t}\n\n\t// Create a response with the file bytes and the appropriate content type\n\treturn ctx.Blob(http.StatusOK, \"application/octet-stream\", fileBytes)\n}", "CodeBleu_score": 41.557711122838995}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"missing file path\"})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"file not found\"})\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error opening file\"})\n\t}\n\tdefer file.Close()\n\n\t// Create a response writer to stream the file content.\n\tw := ctx.Response().Writer\n\tdefer w.Close()\n\n\t// Copy the file content in chunks.\n\tif _, err := io.Copy(w, file); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"error streaming file content\"})\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.48615015116097}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map.\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\terr := notify.Send(name, message)\n\tif err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusOK)\n}", "CodeBleu_score": 48.513679934248735}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Retrieve the \"name\" query parameter from the request context.\n\tname := ctx.QueryParam(\"name\")\n\tif name == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"missing name query parameter\")\n\t}\n\n\t// Bind the request body to a message map.\n\tvar msg map[string]interface{}\n\tif err := ctx.Bind(&msg); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\tif err := notify.Send(name, msg); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.NoContent(http.StatusNoContent)\n}", "CodeBleu_score": 50.52286417115652}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := &Message{}\n\tif err := ctx.Bind(message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\terr := notification.Notify(name, message)\n\tif err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.String(http.StatusOK, \"OK\")\n}", "CodeBleu_score": 43.974105231920966}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tgo sendMessage()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"Received message of type %d and data: %s\n\", mt, message)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}", "CodeBleu_score": 46.041100927597945}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tupgrader := websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Start the message sending service\n\tgo sendMsg()\n\t// Enter a loop to read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\tmsgType, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"%s %s\n\", msgType, msg)\n\t}\n}", "CodeBleu_score": 43.60649722658057}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tupgrader := websocket.Upgrader{\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service\n\tgo messageSendingService()\n\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// Remove the WebSocket connection from the list of connections\n\t\t\tconnections = removeConnection(connections, ws)\n\t\t\treturn err\n\t\t}\n\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Printf(\"Message Type: %d\nMessage: %s\nError: %s\n\", messageType, message, err)\n\t}\n}", "CodeBleu_score": 46.38717878443718}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the CPU information.\n\tcpu := GetCPUInfo()\n\n\t// Get the drive information.\n\tdrive := GetDriveInfo()\n\n\t// Return the response.\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"cpu\": cpu,\n\t\t\"drive\": drive,\n\t\t\"message\": \"Success\",\n\t})\n}", "CodeBleu_score": 13.469516852269836}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Create the response object\n\tresponse := make(map[string]interface{})\n\n\t// Get the system drive model and architecture\n\tdriveModel, driveArchitecture := GetSystemDriveInfo()\n\n\t// Add the drive model and architecture to the response object\n\tresponse[\"driveModel\"] = driveModel\n\tresponse[\"driveArchitecture\"] = driveArchitecture\n\n\t// Get the system CPU information\n\tcpuInfo := GetSystemCPUInfo()\n\n\t// If the CPU information is available, add it to the response object\n\tif cpuInfo != nil {\n\t\tresponse[\"cpuInfo\"] = cpuInfo\n\t}\n\n\t// Return the response object as JSON\n\treturn ctx.JSON(http.StatusOK, response)\n}", "CodeBleu_score": 19.600346502466603}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t", "CodeBleu_score": 1.4766480750698492}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.listServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 71.50952873025211}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t", "CodeBleu_score": 5.331256665505473}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := []string{}\n\tnotRunningServices := []string{}\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service.Name, \"casaos\") {\n\t\t\tif service.ActiveState == \"active\" {\n\t\t\t\trunningServices = append(runningServices, service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 63.61546489181603}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmsgBytes, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"failed to serialize message: %v\", err)\n\t\treturn\n\t}\n\tmsg := string(msgBytes)\n\tlog.Printf(\"sending notification %s with message %s\", name, msg)\n\tresp, err := i.bus.Publish(name, msg)\n\tif err != nil {\n\t\tlog.Printf(\"failed to publish notification: %v\", err)\n\t\treturn\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"notification %s failed with status code %d\", name, resp.StatusCode)\n\t}\n}", "CodeBleu_score": 36.31537178426757}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Create the request object.\n\treq := &notify.NotifyRequest{\n\t\tName: name,\n\t\tMessage: message,\n\t}\n\n\t// Call the service.\n\trsp, err := i.NotifyService.SendNotify(context.Background(), req)\n\tif err != nil {\n\t\t// Log the error.\n\t\tlog.Printf(\"error: %v\", err)\n\t\treturn\n\t}\n\n\t// Handle the response.\n\tif rsp.Status != http.StatusOK {\n\t\t// Log the failure.\n\t\tlog.Printf(\"status: %d\", rsp.Status)\n\t\treturn\n\t}\n}", "CodeBleu_score": 29.661697942769173}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tserializedMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to serialize message: %v\n\", err)\n\t\treturn\n\t}\n\n\t// Publish the message to the message bus.\n\terr = i.client.Publish(name, serializedMessage)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to publish message: %v\n\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 22.419593413717937}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tvar err error\n\tvar client message_bus.ClientWithResponses\n\tclient, err = message_bus.NewClientWithResponses(c.server)\n\tif err != nil {\n\t\tclient.Server = \"ERROR: \" + err.Error()\n\t}\n\treturn &client\n}", "CodeBleu_score": 30.59053844814236}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tif c.messageBus == nil {\n\t\tc.messageBus = message_bus.NewClientWithResponses(c.server)\n\t}\n\treturn c.messageBus\n}", "CodeBleu_score": 20.04785412313879}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\t// Create a new message bus client with responses.\n\tclient := message_bus.NewClientWithResponses(c.server)\n\t// Set the client's server to the retrieved address.\n\tif c.address != \"\" {\n\t\tclient.SetServer(c.address)\n\t}\n\treturn client\n}", "CodeBleu_score": 16.970453644684195}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \", \") {\n\t\tip = strings.Split(ip, \", \")[0]\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.50603603936731}, {"code": "func GetIP(request *http.Request) string{\n\t\t// Get the IP from the \"x-forwarded-for\" header if present\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif len(ip) > 0 {\n\t\t// Split the IPs by comma\n\t\tips := strings.Split(ip, \",\")\n\t\t// Get the first IP\n\t\tip = strings.TrimSpace(ips[0])\n\t} else {\n\t\t// Get the IP from the request's remote address\n\t\tip = request.RemoteAddr\n\t}\n\t// Convert the IP address to a string\n\tip = strings.TrimSpace(ip)\n\t// Check if the IP is a loopback address\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 66.76049351018341}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \",\")[0]\n\tip = strings.TrimSpace(ip)\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = ip[7:]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 65.33301117834864}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tentry := []byte(\"[]\")\n\tmodulesDir := filepath.Join(c.config.Root, \"modules\")\n\tif _, err := os.Stat(modulesDir); os.IsNotExist(err) {\n\t\tc.logger.Warnf(\"Modules directory not found: %s\", modulesDir)\n\t\treturn\n\t}\n\tc.logger.Debug(\"Reading modules directory\")\n\tmodules, err := ioutil.ReadDir(modulesDir)\n\tif err != nil {\n\t\tc.logger.Warnf(\"Error reading modules directory: %s\", err)\n\t\treturn\n\t}\n\tfor _, module := range modules {\n\t\tif module.IsDir() {\n\t\t\tentryFile := filepath.Join(modulesDir, module.Name(), \"entry.json\")\n\t\t\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t\t\tc.logger.Warnf(\"Entry file not found: %s\", entryFile)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.logger.Debug(\"Reading entry file\")\n\t\t\tentryFileBytes, err := ioutil.ReadFile(entryFile)\n\t\t\tif err != nil {\n\t\t\t\tc.logger.Warnf(\"Error reading entry file: %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tentry = append(entry, entryFileBytes...)\n\t\t}\n\t}\n\tc.logger.Debug(\"Writing system entry file\")\n\tif err := ioutil.WriteFile(filepath.Join(c.config.Root, \"entry.json\"), entry, 0644); err != nil {\n\t\tc.logger.Warnf(\"Error writing system entry file: %s\", err)\n\t}\n}", "CodeBleu_score": 41.84235560679791}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tvar err error\n\tvar iface *net.Interface\n\tvar ifaces []net.Interface\n\tvar macAddress string\n\tvar name string\n\tvar names []string\n\n\tifaces, err = net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface = range ifaces {\n\t\tnames, err = iface.Addrs()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, name = range names {\n\t\t\tif strings.Contains(name.String(), \"fe80\") {\n\t\t\t\tmacAddress = strings.Split(name.String(), \"%\")[0]\n\t\t\t\treturn macAddress, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no MAC address found\")\n}", "CodeBleu_score": 48.178497530303545}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tvar err error\n\tvar ifs []net.Interface\n\tifs, err = net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar netNames []string\n\tnetNames, err = c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, ifc := range ifs {\n\t\tfor _, netName := range netNames {\n\t\t\tif ifc.Name == netName {\n\t\t\t\treturn ifc.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 45.43929834731725}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tvar (\n\t\terr error\n\t\tifaces []net.Interface\n\t\taddrs []net.Addr\n\t\tnetName string\n\t\tmacAddr string\n\t)\n\n\tifaces, err = net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\taddrs, err = iface.Addrs()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tif strings.Contains(addr.String(), \"127.0.0.1\") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tnetName = strings.Split(iface.Name, \".\")[0]\n\t\t\tmacAddr = strings.Split(addr.String(), \"/\")[0]\n\n\t\t\tif netName == \"en\" || netName == \"eth\" || netName == \"wlan\" || netName == \"wlp\" {\n\t\t\t\treturn macAddr, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No MAC address found\")\n}", "CodeBleu_score": 44.37135673552201}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t rc = 0;\n\n\tif (pRequest == NULL) {\n\t\trc = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\trc = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Add a reference to the request object.\n\t */\n\tpRequest->refCount++;\n\n\t/*\n\t * Increment the request count for the associated TSC object.\n\t */\n\tpTscObj->requestCount++;\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary.\n\t */\n\tif (pTscObj->appObj != NULL) {\n\t\tpTscObj->appObj->requestCount++;\n\t\tpTscObj->appObj->currentRequestCount++;\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tlog_debug(\"TSC[%d] requestCount=%d currentRequestCount=%d\", pTscObj->tscId, pTscObj->requestCount, pTscObj->appObj->currentRequestCount);\n\ncleanup:\n\n\treturn rc;\n}", "CodeBleu_score": 28.509215842528018}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t status = 0;\n\tSAppObj *pAppObj = NULL;\n\tSRequestSummary *pRequestSummary = NULL;\n\n\tif(pRequest == NULL) {\n\t\tstatus = -1;\n\t\tgoto out;\n\t}\n\n\tif(pTscObj == NULL) {\n\t\tstatus = -1;\n\t\tgoto out;\n\t}\n\n\tpRequest->refCount++;\n\tpTscObj->requestCount++;\n\n\tif(pTscObj->pAppObj != NULL) {\n\t\tpAppObj = pTscObj->pAppObj;\n\t\tpRequestSummary = &(pAppObj->requestSummary);\n\n\t\tpRequestSummary->totalRequestCount++;\n\t\tpRequestSummary->currentRequestCount++;\n\n\t\tif(pRequestSummary->currentRequestCount > pRequestSummary->maxConcurrentRequestCount) {\n\t\t\tpRequestSummary->maxConcurrentRequestCount = pRequestSummary->currentRequestCount;\n\t\t}\n\t}\n\nout:\n\treturn status;\n}", "CodeBleu_score": 29.871721755412644}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = pRequest->pDb;\n\n\tif (pDb == NULL) {\n\t\treturn true;\n\t}\n\n\t/*\n\t * The primary database of the request is not the exception database.\n\t * Iterate through the list of databases in the request, ignoring any schema prefixes.\n\t */\n\twhile (pDb != NULL) {\n\t\tchar *pDbName = pDb;\n\t\tchar *pSchema = strchr(pDb, '.');\n\n\t\tif (pSchema != NULL) {\n\t\t\tpDbName = pSchema + 1;\n\t\t}\n\n\t\tif (strcmp(pDbName, exceptDb) == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tpDb = pRequest->pDbNext;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 47.71887548714652}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = pRequest->pRequestInfo->pDb;\n\tchar *pDbName = pDb + strlen(pDb) - 1;\n\tchar *pExceptDb = exceptDb + strlen(exceptDb) - 1;\n\n\t/* If the primary database of the request is not the exception database, check each database in the request */\n\tif (strncmp(pDb, exceptDb, strlen(exceptDb)) != 0) {\n\t\twhile (pDbName >= pDb) {\n\t\t\tif (strncmp(pExceptDb, pDbName, strlen(pExceptDb)) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpDbName--;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 35.28490756939127}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tif (pRequests == NULL) return;\n\tint64_t rid = 0;\n\tSHashIter *iter = NULL;\n\tSHashObj *obj = NULL;\n\ttaosRequest *pReq = NULL;\n\ttaosReleaseRequest(clientReqRefPool, rid);\n\tfor (iter = s_hash_iter(pRequests); iter != NULL; iter = s_hash_iter_next(iter)) {\n\t\tobj = s_hash_iter_data(iter);\n\t\tpReq = (taosRequest *)obj->data;\n\t\tif (pReq == NULL) continue;\n\t\tif (pReq->rid == 0) continue;\n\t\ttaosReleaseRequest(clientReqRefPool, pReq->rid);\n\t\ttaosStopQuery(pReq->rid);\n\t}\n\treturn;\n}", "CodeBleu_score": 38.38406098319441}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint32_t i;\n\tint32_t n;\n\tint32_t rid;\n\tint32_t ret;\n\tint32_t nRequest;\n\tint64_t *pRids;\n\tint64_t *pRids2;\n\tn = SHashObj_size(pRequests);\n\tif (n == 0) {\n\t\treturn;\n\t}\n\tpRids = malloc(n * sizeof(int64_t));\n\tif (pRids == NULL) {\n\t\treturn;\n\t}\n\tnRequest = 0;\n\tSHashObj_iter(pRequests, (SHashObjIter)taosStopRequest, &nRequest, pRids);\n\tfor (i = 0; i < nRequest; i++) {\n\t\trid = pRids[i];\n\t\tif (rid != 0) {\n\t\t\tret = taosReleaseRef(clientReqRefPool, rid);\n\t\t\tif (ret != 0) {\n\t\t\t\ttaos_log_error(\"taosReleaseRef failed: %d\", ret);\n\t\t\t}\n\t\t}\n\t}\n\tfree(pRids);\n}", "CodeBleu_score": 40.048761820064435}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t", "CodeBleu_score": 4.319414830761173}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscIsCrashReportEnabled()) {\n\t\treturn;\n\t}\n\n\tif (!tscAtomicCompareAndExchange(&clientStop, 0, 1)) {\n\t\ttscLogMessage(\"Crash report thread is already stopped\");\n\t\treturn;\n\t}\n\n\twhile (clientStop != 0) {\n\t\ttscSleep(1);\n\t}\n}", "CodeBleu_score": 53.92848582758182}, {"code": "void tscStopCrashReport(){\n\t\tif (!tscCrashReportEnabled) {\n\t\treturn;\n\t}\n\n\tint32_t success = 0;\n\twhile (!success) {\n\t\tsuccess = __sync_bool_compare_and_swap(&clientStop, 0, 1);\n\t\tif (!success) {\n\t\t\ttscLogMessage(\"Crash report thread already stopped.\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\twhile (clientStop) {\n\t\tusleep(10000);\n\t}\n}", "CodeBleu_score": 56.89363508548341}, {"code": "void tscStopCrashReport(){\n\t\tif (tscCrashReportingEnabled) {\n\t\tif (tscAtomicCompareAndExchange(&clientStop, 0, 1) != 0) {\n\t\t\ttscLogMessage(TSC_LOG_ERROR, \"Crash report thread is already stopped\");\n\t\t\treturn;\n\t\t}\n\t\twhile (clientStop != 0) {\n\t\t\ttscSleep(100);\n\t\t}\n\t}\n}", "CodeBleu_score": 46.437446583028944}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t\tint32_t status;\n\tstruct SViewMetadata *pViewMetadata;\n\tint32_t i;\n\n\tstatus = deserializeViewInfoResponse(value, valueLen, &pViewMetadata);\n\tif (status != HEARTBEAT_SUCCESS) {\n\t\tfree(pViewMetadata);\n\t\treturn status;\n\t}\n\n\tfor (i = 0; i < pViewMetadata->numViews; i++) {\n\t\tif (pViewMetadata->viewMetadata[i].numColumns == 0) {\n\t\t\tstatus = removeViewFromCatalog(pCatalog, pViewMetadata->viewMetadata[i].viewName);\n\t\t\tif (status != HEARTBEAT_SUCCESS) {\n\t\t\t\tfree(pViewMetadata);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = updateViewInCatalog(pCatalog, pViewMetadata->viewMetadata[i].viewName, pViewMetadata->viewMetadata[i].numColumns, pViewMetadata->viewMetadata[i].columnNames);\n\t\t\tif (status != HEARTBEAT_SUCCESS) {\n\t\t\t\tfree(pViewMetadata);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(pViewMetadata);\n\treturn HEARTBEAT_SUCCESS;\n}", "CodeBleu_score": 38.457826853362356}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3Status status = S3StatusOK;\n\tCallbackData *cbData = (CallbackData *) callbackData;\n\n\tif (properties->contentLength > 0) {\n\t\tcbData->contentLength = properties->contentLength;\n\t} else {\n\t\tcbData->contentLength = 0;\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 73.03402618842954}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct callbackData *cbData = (struct callbackData *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tcbData->contentLength = properties->contentLength;\n\t} else {\n\t\tcbData->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 76.05068439447035}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tstruct callbackData *data = (struct callbackData *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 76.32571732613623}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n  if (taosMkdir(tsCheckpointBackupDir, 0700) < 0) {\n    uError(\"[rsync] create checkpoint backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsRsyncConf) < 0) {\n    uError(\"[rsync] generate rsync conf file error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char* cmd = (char*) malloc(PATH_MAX * 4);\n  if (cmd == NULL) {\n    uError(\"[rsync] malloc cmd error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --config=%s\", tsRsyncConf);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  free(cmd);\n  if (ret != 0) {\n    uError(\"[rsync] start rsync daemon error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  uInfo(\"[rsync] rsync daemon started\");\n}", "CodeBleu_score": 44.65215401872211}, {"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  taosMakeDir(path);\n#else\n  taosMakeDir(tsCheckpointBackupDir);\n#endif\n\n  removeEmptyDir();\n  generateConfigFile(tsRsyncConfFile);\n\n  char* command = (char*) malloc(PATH_MAX * 2);\n  if (command == NULL) {\n    uError(\"[rsync] malloc command error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  snprintf(command, PATH_MAX * 2, \"%s -c %s\", tsRsyncBin, tsRsyncConfFile);\n  uDebug(\"[rsync] command:%s\", command);\n\n  int32_t ret = system(command);\n  if (ret != 0) {\n    uError(\"[rsync] start rsync error, ret:%d,\" ERRNO_ERR_FORMAT, ret, ERRNO_ERR_DATA);\n  } else {\n    uInfo(\"[rsync] start rsync success, ret:%d\", ret);\n  }\n\n  free(command);\n}", "CodeBleu_score": 48.292167177762614}, {"code": "void startRsync(){\n\t#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosMakeDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create checkpoint dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsRsyncConfDir) != 0) return;\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"%s -c %srsync.conf\", tsRsyncBin, tsRsyncConfDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n\n  int32_t ret = system(cmd);\n  if (ret == 0) {\n    uInfo(\"[rsync] start rsync server successfully, port:%d\", tsRsyncPort);\n  } else {\n    uError(\"[rsync] start rsync server error, port:%d,\" ERRNO_ERR_FORMAT, tsRsyncPort, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 56.30413683215851}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tdispatchers.get(dispatcherId).shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n\t}\n}", "CodeBleu_score": 47.979438115005}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\tif (dispatcher != null) {\n\t\tdispatcher.shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n}", "CodeBleu_score": 68.83289832193775}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (!dispatchers.containsKey(dispatcherId)) {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n\t}\n\tdispatchers.get(dispatcherId).shutdown();\n\tdispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 43.20400384202394}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t\tif (children.containsKey(parent)) {\n\t\tfor (TbActorId child : children.get(parent)) {\n\t\t\tif (childFilter.test(child)) {\n\t\t\t\ttell(child, msg, highPriority);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.warn(\"[{}] No children for parent {}\", self, parent);\n\t}\n}", "CodeBleu_score": 38.976419063686215}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t List<TbActorId> children = childrenMap.get(parent);\n if (children != null) {\n for (TbActorId child : children) {\n if (childFilter.test(child)) {\n try {\n tell(child, msg, highPriority);\n } catch (Exception e) {\n log.warn(\"Failed to send message to child actor [{}]\", child, e);\n }\n }\n }\n }\n }", "CodeBleu_score": 56.33343887463855}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t // Get the children of the parent actor.\n List<TbActorId> children = childrenMap.get(parent);\n if (children != null) {\n // Filter the children.\n children = children.stream().filter(childFilter).collect(Collectors.toList());\n // Send the message to each filtered child actor.\n for (TbActorId child : children) {\n try {\n tell(child, msg, highPriority);\n } catch (TbNodeException e) {\n log.warn(\"Failed to send message to child actor [{}].\", child, e);\n }\n }\n }\n }", "CodeBleu_score": 59.717754658651664}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t//    if (log.isTraceEnabled()) {\n//        log.trace(\"[{}] Enqueueing msg: {}\", selfId, msg);\n//    }\n    if (destructionInProgress.get()) {\n        if (msg instanceof RuleNodeUpdateMsg) {\n            if (highPriority) {\n                if (initFailed.get()) {\n                    log.info(\"[{}] Reinitializing actor due to failed initialization\", selfId);\n                    initFailed.set(false);\n                    initActor();\n                } else {\n                    log.trace(\"[{}] Actor is being destroyed, ignoring high priority message: {}\", selfId, msg);\n                }\n            } else {\n                log.trace(\"[{}] Actor is being destroyed, ignoring normal priority message: {}\", selfId, msg);\n            }\n        } else {\n            log.trace(\"[{}] Actor is being destroyed, notifying message: {}\", selfId, msg);\n            msg.onTbActorStopped(selfId);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    }\n}", "CodeBleu_score": 62.71688273367533}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t\tif (isReady()) {\n\t\tif (isBusy()) {\n\t\t\tlog.trace(\"[{}] MessageBox is busy, new msg: {}\", selfId, msg);\n\t\t} else {\n\t\t\tif (highPriority) {\n\t\t\t\tif (isFailed()) {\n\t\t\t\t\tif (msg.getActorMsg() == RULE_NODE_UPDATED_MSG) {\n\t\t\t\t\t\tif (initAttempts < MAX_INIT_ATTEMPTS) {\n\t\t\t\t\t\t\tinitAttempts++;\n\t\t\t\t\t\t\tlog.debug(\"[{}] Actor initialization attempt {}. Reinitializing...\", selfId, initAttempts);\n\t\t\t\t\t\t\ttryInit(initAttempts);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlog.debug(\"[{}] Actor initialization attempts exhausted.\", selfId);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog.debug(\"[{}] Actor is failed. Not processing msg: {}\", selfId, msg);\n\t\t\t\t\t\tmsg.onActorStopped(selfId);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thighPriorityMsgs.add(msg);\n\t\t\t\t\ttryProcessQueue(true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnormalPriorityMsgs.add(msg);\n\t\t\t\ttryProcessQueue(true);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, msg);\n\t\tmsg.onActorStopped(selfId);\n\t}\n}", "CodeBleu_score": 45.59014459601136}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t//        log.trace(\"[{}] Enqueueing msg: {}\", selfId, msg);\n        if (destroyed.get() == DESTROYED) {\n            if (msg instanceof RuleNodeUpdateMsg) {\n                if (highPriority) {\n                    log.trace(\"[{}] Actor is destroyed, reinitializing...\", selfId);\n                    tryInit(1);\n                } else {\n                    log.trace(\"[{}] Actor is destroyed, notifying msg: {}\", selfId, msg);\n                    msg.onActorStopped(selfId);\n                }\n            } else {\n                log.trace(\"[{}] Actor is destroyed, ignoring msg: {}\", selfId, msg);\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 62.619372279639954}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\ttry {\n    if (actor.isSystem()) {\n        processSystemMessages();\n    } else {\n        processUserMessages();\n    }\n    if (actor.isReady()) {\n        if (actor.isIdle()) {\n            actor.onIdle();\n        }\n        ready.set(READY);\n        tryProcessQueue(false);\n    } else {\n        ready.set(NOT_READY);\n    }\n} catch (ActorInitializationException e) {\n    log.error(\"[{}] Failed to initialize actor: {}\", selfId, e.getMessage());\n    actor.initFailure(e);\n    ready.set(NOT_READY);\n} catch (Throwable t) {\n    log.error(\"[{}] Failed to process mailbox: {}\", selfId, t.getMessage());\n    actor.processFailure(t);\n    ready.set(NOT_READY);\n}\n}", "CodeBleu_score": 22.655817246345073}, {"code": "private void processMailbox(){\n\ttry {\n    if (stopReason == null) {\n        try {\n            while (ready.get() == READY && !highPriorityMsgs.isEmpty() && actor.process(highPriorityMsgs.poll())) {\n                // Processing succeeded, continue\n            }\n        } catch (ActorInitializationException e) {\n            log.warn(\"[{}] Failed to initialize actor: {}\", selfId, e.getMessage());\n            stopReason = TbActorStopReason.INIT_FAILED;\n            actor.destroy(stopReason, e);\n            return;\n        } catch (Throwable e) {\n            log.warn(\"[{}] Failed to process message: {}\", selfId, e.getMessage());\n            TbActorStopReason stopReason = actor.onProcessFailure(e, highPriorityMsgs.poll());\n            if (stopReason != null) {\n                this.stopReason = stopReason;\n                actor.destroy(stopReason, e);\n                return;\n            }\n        }\n        try {\n            while (ready.get() == READY && !normalPriorityMsgs.isEmpty() && actor.process(normalPriorityMsgs.poll())) {\n                // Processing succeeded, continue\n            }\n        } catch (ActorInitializationException e) {\n            log.warn(\"[{}] Failed to initialize actor: {}\", selfId, e.getMessage());\n            stopReason = TbActorStopReason.INIT_FAILED;\n            actor.destroy(stopReason, e);\n            return;\n        } catch (Throwable e) {\n            log.warn(\"[{}] Failed to process message: {}\", selfId, e.getMessage());\n            TbActorStopReason stopReason = actor.onProcessFailure(e, normalPriorityMsgs.poll());\n            if (stopReason != null) {\n                this.stopReason = stopReason;\n                actor.destroy(stopReason, e);\n                return;\n            }\n        }\n        if (ready.get() == READY && (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty())) {\n            ready.set(FREE);\n            dispatcher.schedule(this::tryProcessQueue, 0);\n        }\n    } else {\n        actor.destroy(stopReason, null);\n    }\n} catch (Throwable e) {\n    log.error(\"[{}] Failed to process mailbox: {}\", selfId, e.getMessage(), e);\n    actor.destroy(TbActorStopReason.FATAL_ERROR, e);\n}\n}", "CodeBleu_score": 36.86152949935978}, {"code": "private void processMailbox(){\n\t\n}", "CodeBleu_score": 0.8065760456678428}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\nstopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\ntry {\nready.set(NOT_READY);\nactor.destroy(stopReason, cause);\nhighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\nnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n} catch (Throwable t) {\nlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n}\n});\n}", "CodeBleu_score": 92.21611858393564}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t//        if (tenantId.isNullUid()) {\n//            return true;\n//        }\n//\n//        TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n//        if (tenantProfile == null) {\n//            if (ignoreTenantNotFound) {\n//                return true;\n//            } else {\n//                throw new TenantProfileNotFoundException(tenantId);\n//            }\n//        }\n//\n//        RateLimit rateLimit = tenantProfile.getRateLimit(api);\n//        if (rateLimit == null) {\n//            return true;\n//        }\n//\n//        long now = System.currentTimeMillis();\n//        long count = rateLimit.getCount(now);\n//        long time = rateLimit.getTime(now);\n//        long limit = rateLimit.getLimit(now);\n//\n//        if (count >= limit) {\n//            processRateLimitNotification(api, tenantId, level, count, time, limit);\n//            return false;\n//        }\n//\n//        rateLimit.increment(now);\n//        return true;\n}", "CodeBleu_score": 5.316843381303938}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\n/**\n * If the tenant ID corresponds to the system tenant, it always returns true.\n */\nif (tenantId.isNullUid()) {\nreturn true;\n}\n\n/**\n * It retrieves the tenant's profile; if not found and ignoring missing tenants is allowed, it returns true, otherwise, it throws a TenantProfileNotFoundException.\n */\ntry {\nTenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n} catch (CacheLoadingException e) {\nif (ignoreTenantNotFound) {\nreturn true;\n} else {\nthrow new TenantProfileNotFoundException(tenantId);\n}\n}\n\n/**\n * It fetches the rate limit configuration from the tenant profile and checks the rate limit.\n */\nRateLimitConfig rateLimitConfig = tenantProfile.getRateLimitConfig();\nif (!rateLimitConfig.isEnabled()) {\nreturn true;\n}\n\nlong now = System.currentTimeMillis();\n\n/**\n * If the rate limit is exceeded, it processes a rate limit notification.\n */\nif (!rateLimitConfig.checkRateLimit(api, level, now)) {\nif (rateLimitConfig.isNotifyIfExceeded()) {\nrateLimitConfig.processRateLimitNotification(api, level, now);\n}\nreturn false;\n}\n\nreturn true;\n}", "CodeBleu_score": 44.97555531431933}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t//        if (tenantId.getId().equals(SystemTenantId.SYS_TENANT_ID)) {\n//            return true;\n//        }\n//        TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n//        if (tenantProfile == null) {\n//            if (ignoreTenantNotFound) {\n//                return true;\n//            } else {\n//                throw new TenantProfileNotFoundException(tenantId);\n//            }\n//        }\n//        RateLimit rateLimit = tenantProfile.getRateLimit(api);\n//        if (rateLimit == null) {\n//            return true;\n//        }\n//        return checkRateLimit(api, rateLimit, level);\n//    }", "CodeBleu_score": 5.262946726493438}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\tlong now = System.currentTimeMillis();\n\tlong expirationTime = now - timeout;\n\tsynchronized (dtlsSessions) {\n\t\tIterator<Entry<Long, DtlsSession>> it = dtlsSessions.entrySet().iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Long, DtlsSession> entry = it.next();\n\t\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\t\tit.remove();\n\t\t\t\tlogger.info(\"Removed expired DTLS session from map: \" + entry.getValue());\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.79453371434677}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tSet<String> keys = sessions.keySet();\n\tfor (String key : keys) {\n\t\tif (sessions.get(key).getLastActivityTime() < expirationTime) {\n\t\t\tremoveSession(key);\n\t\t}\n\t}\n}", "CodeBleu_score": 32.25726687875644}, {"code": "public void evictTimeoutSessions(){\n\t\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - timeout;\n\tfor (Map.Entry<String, DtlsSession> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tlog.info(\"Removing expired session with peer: \" + entry.getKey());\n\t\t\tsessions.remove(entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 41.3174099757258}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t_\n    if (timeseries == null || timeseries.isEmpty()) {\n        return Collections.emptyList();\n    } else {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                result.add(parseValue(key, value));\n            }\n        }\n        return result;\n    }\n}", "CodeBleu_score": 48.8498487130621}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t_\n    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    } else {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                TsKvEntry tsKvEntry = parseValue(key, value);\n                result.add(tsKvEntry);\n            }\n        }\n        return result;\n    }\n}", "CodeBleu_score": 51.698694755311806}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t_\n    if (timeseries == null || timeseries.isEmpty()) {\n        return Collections.emptyList();\n    } else {\n        List<TsKvEntry> tsKvEntries = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            for (JsonNode value : entry.getValue()) {\n                tsKvEntries.add(parseValue(key, value));\n            }\n        }\n        return tsKvEntries;\n    }\n}", "CodeBleu_score": 43.95584441243543}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tString url = this.authEndpoint + \"/refresh\";\n\tMap<String, String> request = new HashMap<String, String>();\n\trequest.put(\"refreshToken\", this.refreshToken);\n\ttry {\n\t\tHttpResponse<String> response = Unirest.post(url).header(\"Content-Type\", \"application/json\").body(request).asString();\n\t\tif (response.getStatus() != 200) {\n\t\t\tthrow new Exception(\"Error refreshing token: \" + response.getBody());\n\t\t}\n\t\tthis.setTokenInfo(System.currentTimeMillis(), new ObjectMapper().readTree(response.getBody()));\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 36.38003333474737}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\ttry {\n\t\tHttpResponse<String> response = Unirest.post(this.authEndpoint + \"/refreshToken\").body(requestMap).asString();\n\t\tif (response.getStatus() == 200) {\n\t\t\tsetTokenInfo(System.currentTimeMillis(), new ObjectMapper().readTree(response.getBody()));\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Refreshing the token failed with status code: \" + response.getStatus());\n\t\t}\n\t} catch (UnirestException e) {\n\t\tthrow new RuntimeException(\"Refreshing the token failed\", e);\n\t}\n}", "CodeBleu_score": 45.72605770965284}, {"code": "public void refreshToken(){\n\t", "CodeBleu_score": 1.4566164722189525}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t try {\n    // Capture the current timestamp\n    long ts = Instant.now().toEpochMilli();\n\n    // Create a login request map with the credentials\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n\n    // Send the request to the \"/api/auth/login\" URL\n    HttpResponse<String> response = Unirest.post(authUrl + \"/api/auth/login\")\n        .header(\"Content-Type\", \"application/json\")\n        .body(loginRequest)\n        .asString();\n\n    // Update the token information with the response data and the timestamp\n    setTokenInfo(ts, new ObjectMapper().readTree(response.getBody()));\n\n    // Print the response data\n    System.out.println(response.getBody());\n } catch (UnirestException | IOException e) {\n    System.out.println(\"Error: \" + e.getMessage());\n }\n }", "CodeBleu_score": 57.20332775320711}, {"code": " private void doLogin(){\n\t\n// 1. Get the current timestamp\n        long ts = System.currentTimeMillis();\n\n// 2. Create a login request map with the credentials\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n\n// 3. Send the request to the \"/api/auth/login\" URL\n        HttpResponse<String> response = Unirest.post(baseUrl + \"/api/auth/login\")\n                .header(\"Content-Type\", \"application/json\")\n                .body(loginRequest)\n                .asString();\n\n// 4. Update the token information with the response data and the timestamp\n        setTokenInfo(ts, new ObjectMapper().readTree(response.getBody()));\n\n}", "CodeBleu_score": 70.38939291627179}, {"code": " private void doLogin(){\n\t\t// Get current timestamp in milliseconds\n\tlong ts = System.currentTimeMillis();\n\t// Create a map with the credentials\n\tHashMap<String, String> loginRequest = new HashMap<String, String>();\n\tloginRequest.put(\"username\", username);\n\tloginRequest.put(\"password\", password);\n\t// Send the request\n\tString response = null;\n\ttry {\n\t\tresponse = HttpUtils.post(authUrl + \"/api/auth/login\", loginRequest, \"application/json\");\n\t} catch (Exception e) {\n\t\tthrow new RuntimeException(\"Error while logging in\", e);\n\t}\n\t// Update the token information with the response data and the timestamp\n\tsetTokenInfo(ts, Json.parse(response));\n}", "CodeBleu_score": 56.83495809499767}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tHttpResponse<String> response = Unirest.get(\"{baseUrl}/api/device/{deviceId}\")\n\t\t\t.routeParam(\"deviceId\", deviceId.toString())\n\t\t\t.asString();\n\t\tif (response.getStatus() == 200) {\n\t\t\treturn Optional.of(new ObjectMapper().readValue(response.getBody(), Device.class));\n\t\t} else if (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else {\n\t\t\tthrow new RuntimeException(response.getBody());\n\t\t}\n\t} catch (UnirestException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 51.87360874671803}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tHttpResponse<String> response = Unirest.get(String.format(\"%s/api/device/%s\", baseUrl, deviceId.getId()))\n\t\t\t\t.asString();\n\t\tif (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(mapper.readValue(response.getBody(), Device.class));\n\t} catch (UnirestException e) {\n\t\tthrow new RuntimeException(e);\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 47.79202205715228}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tHttpResponse<String> response = Unirest.get(url + \"/api/device/\" + deviceId.toString())\n\t\t\t.asString();\n\t\tif (response.getStatus() == 404) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tif (response.getStatus() != 200) {\n\t\t\tthrow new RuntimeException(response.getStatus() + \" \" + response.getStatusText());\n\t\t}\n\t\treturn Optional.of(new ObjectMapper().readValue(response.getBody(), Device.class));\n\t} catch (UnirestException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 46.89440571656406}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tRequest request = new Request.Builder()\n\t\t\t.url(BASE_URL + \"/api/device-with-credentials\")\n\t\t\t.post(RequestBody.create(JSON, device.toJSON() + credentials.toJSON()))\n\t\t\t.build();\n\t\tResponse response = client.newCall(request).execute();\n\t\tif (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else if (response.code() == 201) {\n\t\t\treturn Optional.of(new Device(response.body().string()));\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Unexpected response code: \" + response.code());\n\t\t}\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 44.971534206841966}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tRequest request = new Request.Builder()\n\t\t.url(serverUrl + \"/api/device-with-credentials\")\n\t\t.post(RequestBody.create(JSON, device.toJson() + credentials.toJson()))\n\t\t.build();\n\n\ttry {\n\t\tResponse response = client.newCall(request).execute();\n\t\tif (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t} else if (response.code() != 200) {\n\t\t\tthrow new RuntimeException(\"Unexpected response code: \" + response.code());\n\t\t}\n\t\treturn Optional.of(Device.fromJson(response.body().string()));\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(\"An error occurred while communicating with the server: \" + e.getMessage());\n\t}\n}", "CodeBleu_score": 42.26430427953811}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tRequest request = new Request.Builder()\n\t\t\t\t.url(BASE_URL + \"/api/device-with-credentials\")\n\t\t\t\t.post(RequestBody.create(JSON, device.toJson() + credentials.toJson()))\n\t\t\t\t.addHeader(\"Content-Type\", \"application/json\")\n\t\t\t\t.build();\n\t\tResponse response = client.newCall(request).execute();\n\t\tif (response.code() == 404) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(Device.fromJson(response.body().string()));\n\t} catch (IOException e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}", "CodeBleu_score": 42.28801574570651}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n  val = addr;\n  this.each(function(device) {\n    this.brightness(device, val);\n  });\n} else {\n  this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n}\nreturn this;\n}", "CodeBleu_score": 97.49137623160196}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n  val = addr;\n  this.each(function(device) {\n    this.brightness(device, val);\n  });\n} else {\n  this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n}\nreturn this;\n}", "CodeBleu_score": 97.49137623160196}, {"code": "brightness(addr, val){\n\t}", "CodeBleu_score": 2.8022481803282675}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\nbound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\nif (this[key] && typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n});\nreturn bound;\n}", "CodeBleu_score": 96.20205970950842}, {"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\nbound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\nif (this[key] && typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n});\nreturn bound;\n}", "CodeBleu_score": 96.20205970950842}, {"code": "device(addr){\n\tconst bound = {};\n\n/* keys from prototype */\nObject.keys(LedControl.prototype).forEach(key => {\nbound[key] = this[key].bind(this, addr);\n});\n\n/* functions from interface */\nObject.getOwnPropertyNames(this).forEach(key => {\nif (this[key] && typeof this[key] === \"function\") {\nbound[key] = this[key].bind(this, addr);\n}\n});\nreturn bound;\n}", "CodeBleu_score": 96.20205970950842}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tconst callbackReconciliation = {};\n\tfor (const method of methods) {\n\t\tconst originalMethod = target[method];\n\t\tconst reconciledMethod = (...args) => {\n\t\t\tconst callback = args.pop();\n\t\t\tconst duration = args.pop();\n\t\t\tif (typeof callback !== \"function\") {\n\t\t\t\tthrow new Error(`The last argument of ${method} must be a function`);\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tfor (const element of target) {\n\t\t\t\tconst promise = originalMethod.call(element, ...args);\n\t\t\t\tif (promise) {\n\t\t\t\t\tpromises.push(promise);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tcallback();\n\t\t\t\t}, duration || 1000);\n\t\t\t});\n\t\t};\n\t\tcallbackReconciliation[method] = reconciledMethod;\n\t}\n\tObject.assign(target, callbackReconciliation);\n}", "CodeBleu_score": 31.588081628277216}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t", "CodeBleu_score": 3.6909120196701934}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\tconst callbackMethod = `${method}Callback`;\n\t\tconst promiseMethod = `${method}Promise`;\n\t\tconst durationMethod = `${method}Duration`;\n\t\tconst callbackDuration = target[durationMethod] || 1000;\n\t\tconst callback = target[callbackMethod] || (() => {});\n\t\tconst methodPromise = target[promiseMethod];\n\t\ttarget[method] = (...args) => {\n\t\t\tconst promises = [];\n\t\t\tconst elements = Array.from(target);\n\t\t\telements.forEach(element => {\n\t\t\t\tconst promise = methodPromise(element, ...args);\n\t\t\t\tpromises.push(promise);\n\t\t\t});\n\t\t\treturn Promise.all(promises).then(() => {\n\t\t\t\tsetTimeout(callback, callbackDuration);\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 28.184883444065218}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t\nconst state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 91.30552758648074}, {"code": "listen(){\n\t\nconst state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\ninput += new Buffer(data).toString(\"ascii\");\nconst sentences = input.split(\"\\r\n\");\n\nif (sentences.length > 1) {\nfor (let i = 0; i < sentences.length - 1; i++) {\nthis.parseNmeaSentence(sentences[i]);\n}\ninput = sentences[sentences.length - 1];\n}\n});\n}", "CodeBleu_score": 88.75775554292667}, {"code": "listen(){\n\t\n}", "CodeBleu_score": 1.3739519390252413}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint8_t buffer_size = 0;\n\n\tfor (uint8_t i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i].channel_id < config->num_channels) {\n\t\t\tactive_channels++;\n\t\t\tbuffer_size += sizeof(uint16_t);\n\t\t}\n\t}\n\n\tif (buffer_size > config->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.88359370348499}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tu32_t channel_count = 0;\n\tu32_t sample_size = 0;\n\tu32_t buffer_size = 0;\n\tu32_t i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tchannel_count++;\n\t\t\tsample_size = max(sample_size,\n\t\t\t\t\t  sizeof(sequence->buffer[i]));\n\t\t}\n\t}\n\n\tbuffer_size = channel_count * sample_size;\n\n\tif (buffer_size > config->buffer_size) {\n\t\tLOG_ERR(\"Insufficient memory. Required: %d, Available: %d\",\n\t\t\tbuffer_size, config->buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 36.280022715056816}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 8.153997662966383}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint err;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Requested resolution does not match ADC resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~config->channels) {\n\t\tLOG_ERR(\"Invalid channel selected\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->channels = sequence->channels;\n\tdata->channel_count = POPCOUNT(data->channels);\n\tdata->buffer_index = 0;\n\tdata->buffer_remaining = data->channel_count;\n\tdata->buffer_repeat_count = 0;\n\n\tadc_ad559x_start_read_context(dev);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 51.46929014152061}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint error;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution for %s (requested %d, expected %d)\", dev->name, sequence->resolution, config->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels & ~BIT(config->channel)) {\n\t\tLOG_ERR(\"Invalid channels for %s (requested 0x%x, expected 0x%x)\", dev->name, sequence->channels, BIT(config->channel));\n\t\treturn -EINVAL;\n\t}\n\n\terror = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->channel = config->channel;\n\n\tadc_context_start_read(&data->ctx, sequence);\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 61.9140266489194}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.478133658581989}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tint err;\n\n\t/*\n\t * Check parameters\n\t */\n\tif (!ctx) {\n\t\treturn;\n\t}\n\n\t/*\n\t * Start the sampling.\n\t */\n\terr = adc_read(ctx, ctx->buffer, ctx->buffer_size);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"adc_read() failed with error %d\n\", err);\n\t\tadc_context_destroy(ctx);\n\t\treturn;\n\t}\n\n\t/*\n\t * Release the semaphore.\n\t */\n\terr = xSemaphoreGive(ctx->sem);\n\tif (err != pdPASS) {\n\t\tfprintf(stderr, \"xSemaphoreGive() failed with %d\n\", err);\n\t\tadc_context_destroy(ctx);\n\t\treturn;\n\t}\n}", "CodeBleu_score": 32.081096834127486}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tint status;\n\n\t/* Retrieve the ADC configuration from the context */\n\tstruct adc_config *config = &ctx->config;\n\n\t/* Set the channel to be sampled */\n\tstatus = adc_set_channel(config->adc_dev, config->channel_mask, config->ref_sel);\n\tif (status != 0) {\n\t\tprintf(\"Error: Could not set channel!\n\");\n\t\treturn;\n\t}\n\n\t/* Initialize the ADC data buffer */\n\tfor (size_t i = 0; i < config->buffer_size; i++) {\n\t\tctx->buffer[i] = 0;\n\t}\n\n\t/* Set the data buffer in the ADC data structure */\n\tconfig->buffer = ctx->buffer;\n\n\t/* Set the sample rate */\n\tstatus = adc_set_sample_rate(config->adc_dev, config->sample_rate);\n\tif (status != 0) {\n\t\tprintf(\"Error: Could not set sample rate!\n\");\n\t\treturn;\n\t}\n\n\t/* Set the repeat mode */\n\tstatus = adc_set_repeat_mode(config->adc_dev, config->repeat_mode);\n\tif (status != 0) {\n\t\tprintf(\"Error: Could not set repeat mode!\n\");\n\t\treturn;\n\t}\n\n\t/* Release the semaphore to signal the start of sampling */\n\tk_sem_give(&ctx->sampling_sem);\n}", "CodeBleu_score": 45.04341491915421}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t", "CodeBleu_score": 6.762733993289692}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->buffer_repeat;\n\t} else {\n\t\tctx->buffer = ctx->buffer_raw;\n\t}\n}", "CodeBleu_score": 45.848371447784615}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->buffer_repeat;\n\t} else {\n\t\tctx->buffer = ctx->buffer_raw;\n\t}\n}", "CodeBleu_score": 45.848371447784615}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tif (repeat_sampling) {\n\t\t/* Update buffer pointer to point to the repeated buffer */\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\t/* Update buffer pointer to point to the single buffer */\n\t\tctx->buffer = ctx->single_buffer;\n\t}\n}", "CodeBleu_score": 46.85724995274003}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels;\n\tuint8_t channel;\n\tuint16_t val;\n\tint ret;\n\n\twhile (true) {\n\t\t/* Wait for the semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Read the active channels */\n\t\tret = mfd_ad559x_read_reg(config->mfd_dev, AD559X_REG_SEQ_ADC, &active_channels);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read active channels: %d\", ret);\n\t\t\tdata->complete = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Iterate through the active channels and read the ADC value.\n\t\t * If reading fails, log an error and mark the ADC context as complete.\n\t\t */\n\t\tfor (channel = 0; channel < AD559X_ADC_CHANNEL_COUNT; channel++) {\n\t\t\tif ((active_channels & BIT(channel)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(dev, channel, &val);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\tdata->complete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = val;\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tdata->complete = true;\n\t}\n}", "CodeBleu_score": 50.93405375311497}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *ctx = data->ctx;\n\tuint8_t active_channels = data->active_channels;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for the semaphore to be released */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/*\n\t\t * Iterate through the active channels.\n\t\t * For each channel, read the ADC value and store the result in a buffer.\n\t\t * If reading from a channel fails, log an error and mark the ADC context as complete.\n\t\t */\n\t\tfor (channel = 0; channel < config->channels; channel++) {\n\t\t\tif ((active_channels & BIT(channel)) == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = adc_ad559x_read_channel(dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"ADC read failed (err %d)\", ret);\n\t\t\t\tadc_context_complete(ctx, ret);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdata->buffer[channel] = result;\n\t\t}\n\n\t\t/* Signal that the sampling is done */\n\t\tadc_context_on_sampling_done(ctx, data->buffer, config->channels);\n\t}\n}", "CodeBleu_score": 45.84995592037893}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tconst struct device *dev = data->dev;\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = data->active_channels;\n\tuint8_t channel;\n\tuint16_t result;\n\tint ret;\n\n\twhile (data->thread_active) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->num_channels; channel++) {\n\t\t\tif (active_channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"ADC channel %d read failed (err %d)\", channel, ret);\n\t\t\t\t\tdata->status = ret;\n\t\t\t\t\tdata->active_channels = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdata->buffer[channel] = result;\n\t\t\t}\n\t\t}\n\n\t\tdata->acq_done = true;\n\t}\n}", "CodeBleu_score": 46.963965595985826}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t config_reg = 0;\n\tint rc = 0;\n\tint timeout = config->ready_time_ms;\n\n\tk_busy_wait(100000);\n\n\twhile (timeout) {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (config_reg & ADS1112_CONFIG_OS_BIT) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tk_busy_wait(100000);\n\t\ttimeout--;\n\t}\n\n\treturn -ETIMEDOUT;\n}", "CodeBleu_score": 44.44855278153898}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t config_reg = 0;\n\tint rc = 0;\n\n\tk_busy_wait(config->ready_time);\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config_reg);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\tif (!(config_reg & ADS1112_CONFIG_OS)) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 37.963398632607074}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\tuint32_t ready_time = config->ready_time;\n\n\twhile (ready_time > 0) {\n\t\tk_usleep(100);\n\t\tready_time--;\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (reg_val & ADS1112_CONFIG_OS_MASK) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ready_time == 0) {\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.5247423505967}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint buffer_size = 0;\n\n\t/*\n\t * Calculate the minimum buffer size required to store the ADC samples.\n\t * This is the sum of the following:\n\t *   - the number of samples in the ADC sequence\n\t *   - the number of extra samples requested in the ADC sequence\n\t *   - the number of samples in the ADC sequence that are needed to\n\t *     perform the requested conversions (e.g. for differential mode,\n\t *     two samples are needed per conversion)\n\t */\n\tbuffer_size = sequence->options.extra_samplings + sequence->options.n_samplings;\n\tbuffer_size += (sequence->options.mode == ADC_DIFF_MODE) ? 2 : 1;\n\n\t/*\n\t * Check if the buffer size is sufficient.\n\t */\n\tif (buffer_size < sequence->options.n_samplings) {\n\t\tdev_err(&client->dev, \"Buffer size %d is too small for %d samples\n\",\n\t\t\tbuffer_size, sequence->options.n_samplings);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 45.267968479368484}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint num_samplings = sequence->num_samplings;\n\tint buffer_size = sequence->options.extra_samplings + num_samplings;\n\tint required_size = num_samplings + sequence->options.extra_samplings;\n\tif (buffer_size < required_size) {\n\t\tLOG_ERR(\"Buffer size %d is less than the required size %d\", buffer_size, required_size);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 40.97556773143252}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t", "CodeBleu_score": 4.778215576071295}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_length = sequence->buffer_length;\n\n\t/*\n\t * Start the ADC read operation by writing the config register\n\t * with the desired configuration.\n\t */\n\trc = ads1112_write_config(dev, config->gain, config->mode, config->rate);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Enable the ADS1112 device.\n\t */\n\trc = ads1112_enable(dev);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\tif (wait) {\n\t\t/*\n\t\t * Wait for the ADC read to complete.\n\t\t */\n\t\trc = ads1112_read_result(dev);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 67.9219293358186}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint err_code = 0;\n\n\terr_code = ads1112_validate_sequence(dev, sequence);\n\tif (err_code) {\n\t\treturn err_code;\n\t}\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->buffer_idx = 0;\n\n\tif (wait) {\n\t\tk_sem_init(&data->sem, 0, UINT_MAX);\n\t\tdata->async = true;\n\t\terr_code = ads1112_start_conversion(dev);\n\t\tif (err_code) {\n\t\t\treturn err_code;\n\t\t}\n\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\t} else {\n\t\tdata->async = false;\n\t\terr_code = ads1112_start_conversion(dev);\n\t}\n\n\treturn err_code;\n}", "CodeBleu_score": 57.142164683651764}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_config *config = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\tint rc;\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->buffer_index = 0;\n\tdata->async = !wait;\n\n\trc = ads1112_start_conversion(dev, sequence->channels);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\tif (wait) {\n\t\trc = ads1112_read_result(dev);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 61.27522085748814}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t", "CodeBleu_score": 34.52460135924148}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tstruct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_print(sh, \"Usage: %s <audio_codec_dev_name>\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Cannot get the device (%s)\", argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_set_property(dev, argv[2], argv[3]);\n\tif (ret != 0) {\n\t\tshell_error(sh, \"Cannot set the property (%s) to the device (%s)\", argv[2], argv[1]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.75555763669753}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t", "CodeBleu_score": 4.702895929663203}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_config *config = dev->config;\n\tstruct mpxxdtyy_data *data = dev->data;\n\tint err;\n\n\t/* Check the device state */\n\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t/* The device is already active; no action needed */\n\t\t\treturn 0;\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\t/* Set the stop command and transition to inactive */\n\t\t\terr = mpxxdtyy_i2s_set_stop(dev);\n\t\t\tif (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tdata->state = MPXXDTYY_STATE_INACTIVE;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* Invalid command for active state */\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t} else if (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t/* Set the start command and transition to active */\n\t\t\terr = mpxxdtyy_i2s_set_start(dev);\n\t\t\tif (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\treturn 0;\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\t/* The device is already configured; no action needed */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* Invalid command for configured state */\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t} else {\n\t\t/* Invalid state */\n\t\treturn -ENOTSUP;\n\t}\n}", "CodeBleu_score": 42.98295057295249}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t", "CodeBleu_score": 4.702895929663203}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (config->rw_gpio.port) {\n\t\tcmd |= BIT(RW_BIT);\n\t}\n\n\tif (config->backlight_gpio.port) {\n\t\tcmd |= BIT(BL_BIT);\n\t}\n\n\tif (config->cursor_blink_on) {\n\t\tcmd |= BIT(CURSOR_BLINK_ON_BIT);\n\t}\n\n\tif (config->display_blink_on) {\n\t\tcmd |= BIT(DISPLAY_BLINK_ON_BIT);\n\t}\n\n\tif (enabled) {\n\t\tcmd |= BIT(DISPLAY_ON_BIT);\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 52.98017496383343}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (config->rw_gpio.port) {\n\t\tcmd |= BIT(RW);\n\t}\n\n\tif (enabled) {\n\t\tcmd |= BIT(E);\n\t\tconfig->flags |= AUXDISPLAY_HD44780_FLAG_ENABLED;\n\t} else {\n\t\tconfig->flags &= ~AUXDISPLAY_HD44780_FLAG_ENABLED;\n\t}\n\n\tif (config->cursor_blink_on) {\n\t\tcmd |= BIT(BLINK);\n\t}\n\n\tif (config->cursor_on) {\n\t\tcmd |= BIT(CURSOR);\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 57.63062790247457}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (config->display_mode == AUXDISPLAY_HD44780_DISPLAY_MODE_4_BIT) {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_MODE_4_BIT_CMD;\n\t} else {\n\t\tcmd = AUXDISPLAY_HD44780_DISPLAY_MODE_8_BIT_CMD;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_CMD;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_BLINK_ON_CMD;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CURSOR_ON_CMD;\n\t}\n\n\tif (config->display_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_CMD;\n\t}\n\n\tauxdisplay_hd44780_command(dev, 0, cmd, config->display_mode);\n}", "CodeBleu_score": 64.14499142205801}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = 0;\n\n\tif (config->busy_gpio == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_read(config->busy_gpio);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 71.15965164152097}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tuint32_t busy_port = config->busy_port;\n\tuint32_t busy_pin = config->busy_pin;\n\tuint32_t busy_mask = 1 << busy_pin;\n\tuint32_t busy_status;\n\tint err;\n\n\tif (busy_port == 0) {\n\t\treturn -ENOTSUP;\n\t}\n\n\terr = gpio_pin_read(busy_port, busy_pin, &busy_status);\n\tif (err < 0) {\n\t\treturn err;\n\t}\n\n\treturn busy_status & busy_mask ? 0 : -EBUSY;\n}", "CodeBleu_score": 59.32023902777348}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret = -ENOTSUP;\n\n\tif (config->busy_gpio != NULL) {\n\t\tret = gpio_pin_get(config->busy_gpio);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 66.93765693071845}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tuint8_t buffer[2];\n\tconst struct auxdisplay_serlcd_config *cfg = DEV_CFG(dev);\n\n\tbuffer[0] = cfg->special_command_prefix;\n\tbuffer[1] = command;\n\n\treturn i2c_write(dev, buffer, sizeof(buffer), cfg->i2c_addr);\n}", "CodeBleu_score": 52.058181924052846}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tuint8_t buf[2];\n\n\tbuf[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuf[1] = command;\n\n\treturn i2c_write(dev, &buf, 2, AUXDISPLAY_SERLCD_I2C_ADDR);\n}", "CodeBleu_score": 40.29258718223384}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tconst struct auxdisplay_serlcd_dev_cfg *dev_cfg = DEV_CFG(dev);\n\tuint8_t command_buffer[2];\n\tint err;\n\n\tcommand_buffer[0] = dev_cfg->special_command_prefix;\n\tcommand_buffer[1] = command;\n\n\terr = i2c_write(dev_cfg->i2c, dev_cfg->i2c_address, command_buffer, sizeof(command_buffer),\n\t\t       dev_cfg->i2c_write_delay);\n\n\treturn err;\n}", "CodeBleu_score": 50.950557242084216}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tconst struct bbram_emul_config *config_dev = dev->config;\n\tint err_code = 0;\n\n\tif (offset >= config_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > config_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(data, data_dev->memory + offset, size);\n\n\treturn err_code;\n}", "CodeBleu_score": 66.31989546453148}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tint err = 0;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, data_dev->mem + offset, size);\n\n\treturn err;\n}", "CodeBleu_score": 63.306352709674144}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tuint8_t *mem = data_dev->mem;\n\tint ret = 0;\n\n\tif (offset + size > data_dev->size) {\n\t\tLOG_ERR(\"Read size exceeds the BBRAM memory size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Read from invalid memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_dev->size) {\n\t\tLOG_ERR(\"Read exceeds the BBRAM memory size\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < size; i++) {\n\t\tdata[i] = mem[offset + i];\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 42.396770406235305}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *mem = data_->mem;\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_->status.is_invalid) {\n\t\treturn -EPERM;\n\t}\n\n\tmemcpy(&mem[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 51.80353196399459}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tuint8_t *memory_dev = data_dev->memory;\n\n\tif (offset > data_dev->size || offset + size > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_dev->status.is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tfor (size_t i = 0; i < size; i++) {\n\t\tmemory_dev[offset + i] = data[i];\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 51.05076447705355}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data_dev = dev->data;\n\tsize_t end_offset = offset + size;\n\tbool is_invalid = data_dev->status.is_invalid;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (end_offset > data_dev->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset > data_dev->size - size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data_dev->memory + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 59.683736817424005}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\n\tif (argc == 1) {\n\t\tshell_error(sh, \"No BBRAM device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Cannot find BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = bbram_init(*bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Cannot initialize BBRAM device\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 73.48454400205017}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tARG_UNUSED(sh);\n\n\tif (argc > 1) {\n\t\t*bbram_dev = device_get_binding(argv[1]);\n\t\tif (*bbram_dev == NULL) {\n\t\t\tLOG_ERR(\"Invalid device: %s\", argv[1]);\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Device name not provided.\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 48.56123205031334}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tARG_UNUSED(sh);\n\n\tif (argc == 0) {\n\t\tshell_error(sh, \"No device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[0]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Cannot find BBRAM device\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 72.42355367747057}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint rc;\n\tuint32_t nbytes;\n\tuint8_t *hdr_buf = h4_hdr_buf;\n\tuint8_t *hdr_buf_end = hdr_buf + sizeof(h4_hdr_buf);\n\n\t/* Calculate the number of bytes already read. */\n\tnbytes = h4_hdr_nbytes_read;\n\n\t/* Attempt to read the remaining bytes from the UART FIFO into the header buffer. */\n\trc = uart_fifo_read(dev, hdr_buf + nbytes, hdr_buf_end - hdr_buf - nbytes);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Failed to read H4 header data\");\n\t} else {\n\t\t/* Update the remaining byte count based on the number of bytes successfully read. */\n\t\tnbytes += rc;\n\t}\n\n\t/* Update the number of bytes already read. */\n\th4_hdr_nbytes_read = nbytes;\n}", "CodeBleu_score": 37.84661141332347}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tuint8_t *hdr_buf = h4_hdr_buf;\n\tuint16_t hdr_buf_len = H4_HDR_BUF_LEN;\n\tuint16_t hdr_buf_off = h4_hdr_buf_off;\n\tuint16_t hdr_buf_rem = h4_hdr_buf_rem;\n\tint hdr_buf_read = 0;\n\n\t/*\n\t * Calculate the number of bytes already read.\n\t */\n\tif (h4_hdr_buf_rem) {\n\t\thdr_buf_len = h4_hdr_buf_rem;\n\t}\n\n\t/*\n\t * Attempt to read the remaining bytes from the UART FIFO into the header buffer.\n\t */\n\thdr_buf_read = uart_fifo_read(dev, hdr_buf + hdr_buf_off, hdr_buf_len);\n\tif (hdr_buf_read < 0) {\n\t\tLOG_ERR(\"Failed to read %d bytes from the UART FIFO into the header buffer\", hdr_buf_len);\n\t} else {\n\t\thdr_buf_rem = hdr_buf_len - hdr_buf_read;\n\t}\n\n\t/*\n\t * Update the remaining byte count.\n\t */\n\th4_hdr_buf_rem = hdr_buf_rem;\n}", "CodeBleu_score": 36.82044258058626}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tuint8_t hdr_bytes_read = 0;\n\tuint8_t hdr_bytes_remaining = H4_HDR_SIZE;\n\tuint8_t hdr_byte = 0;\n\tuint8_t *hdr_buffer = h4_hdr_buffer;\n\tuint8_t hdr_buffer_index = 0;\n\n\t/*\n\t * Calculate the number of bytes already read, then attempt to read the remaining bytes from the UART FIFO.\n\t */\n\thdr_bytes_read = h4_bytes_read - h4_hdr_bytes_read;\n\twhile (hdr_bytes_remaining) {\n\t\t/*\n\t\t * Attempt to read a byte from the UART FIFO.\n\t\t */\n\t\thdr_byte = uart_fifo_read(dev, &hdr_buffer[hdr_buffer_index]);\n\t\tif (hdr_byte == 0) {\n\t\t\t/*\n\t\t\t * If the read operation fails, log an error message.\n\t\t\t */\n\t\t\tLOG_ERR(\"UART FIFO read failed\");\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\t/*\n\t\t\t * Update the remaining byte count based on the number of bytes successfully read.\n\t\t\t */\n\t\t\thdr_bytes_remaining--;\n\t\t\thdr_buffer_index++;\n\t\t}\n\t}\n\n\t/*\n\t * Update the number of bytes read from the header buffer.\n\t */\n\th4_hdr_bytes_read += H4_HDR_SIZE;\n}", "CodeBleu_score": 28.483058530211245}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tsize_t n;\n\tuint8_t buf[33];\n\n\twhile (len > 0) {\n\t\tn = uart_fifo_read(uart, buf, min(len, sizeof(buf)));\n\t\tif (n == 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART device %s\", uart->name);\n\t\t\treturn 0;\n\t\t}\n\t\tlen -= n;\n\t}\n\n\treturn n;\n}", "CodeBleu_score": 47.456818872699294}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tchar buf[33];\n\tsize_t n;\n\n\tif (len > sizeof(buf)) {\n\t\treturn 0;\n\t}\n\n\tn = uart_fifo_read(uart, buf, len);\n\tif (n != len) {\n\t\tLOG_ERR(\"Unable to read %d bytes from UART device %s\", len, uart->name);\n\t\treturn 0;\n\t}\n\n\treturn n;\n}", "CodeBleu_score": 55.771978880095}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t i, bytes_read;\n\n\tfor (i = 0, bytes_read = 0; i < len; i += bytes_read) {\n\t\tbytes_read = uart_fifo_read(uart, buf, sizeof(buf));\n\t\tif (bytes_read == 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART device\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn len;\n}", "CodeBleu_score": 40.57967183566211}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = chan->hop;\n\tstruct zbus_observer *obs;\n\n\tzbus_channel_lock(chan);\n\n\tfor (obs = chan->observers; obs != NULL; obs = obs->next) {\n\t\tif (obs->priority < hop && obs->enabled) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\n\tchan->hop = hop;\n\n\tzbus_channel_unlock(chan);\n}", "CodeBleu_score": 20.067973385738917}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tzbus_mutex_lock(&chan->mutex);\n\tuint8_t hop = 0;\n\tstruct zbus_observer *o;\n\tdlist_foreach_entry(o, &chan->observers, list) {\n\t\tif (o->enabled && o->priority < hop)\n\t\t\thop = o->priority;\n\t}\n\tchan->hop = hop;\n\tzbus_mutex_unlock(&chan->mutex);\n}", "CodeBleu_score": 13.461223586033071}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint8_t hop = 0;\n\tuint8_t i;\n\tstruct zbus_observer *obs;\n\n\tzbus_channel_lock(chan);\n\tfor (i = 0; i < ZBUS_MAX_OBSERVERS; i++) {\n\t\tobs = &chan->observers[i];\n\t\tif (obs->priority > hop && obs->enabled) {\n\t\t\thop = obs->priority;\n\t\t}\n\t}\n\tchan->hop = hop;\n\tzbus_channel_unlock(chan);\n}", "CodeBleu_score": 23.423321177936344}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t.\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = 0; i < _zbus_chan_num_channels; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tif (observation->obs != obs) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!observation->obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchan_update_hop(observation->chan);\n\t}\n}", "CodeBleu_score": 31.146703059511506}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t,\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint chan_highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tstruct zbus_channel *chan = observation->chan;\n\n\t\t\tif (chan->data->highest_observer_priority > chan_highest_observer_priority) {\n\t\t\t\tchan_highest_observer_priority = chan->data->highest_observer_priority;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\t\tstruct zbus_channel *chan = observation->chan;\n\n\t\t\t\tif (chan->data->highest_observer_priority > chan_highest_observer_priority) {\n\t\t\t\t\tchan_highest_observer_priority = chan->data->highest_observer_priority;\n\t\t\t\t}\n\n\t\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchan_update_hop(chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 16.63916882069995}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t_zbus_chan_update_hop(obs); }", "CodeBleu_score": 8.770246420108894}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (zbus_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->thread = k_current_get();\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 21.26568263963031}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (z_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\n\tz_spin_lock(&obs->lock);\n\tobs->priority = K_THREAD_PRIORITY_COOP(0);\n\tupdate_all_channels_hop(obs);\n\treturn 0;\n}", "CodeBleu_score": 23.38501390069873}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\tint rc;\n\n\tassert(obs != NULL);\n\tassert(k_is_in_isr() == false);\n\n\trc = k_spinlock_key_take(&obs->lock);\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Set the observer's priority to the minimum thread priority.\n\t */\n\tobs->priority = K_THREAD_PRIORITY_COOP(CONFIG_MAIN_THREAD_PRIORITY);\n\n\t/*\n\t * Update all channels associated with the observer.\n\t */\n\tupdate_all_channels_hop(obs);\n\n\treturn 0;\n}", "CodeBleu_score": 49.02231025381832}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\tk_timeout_t adjusted_timeout = timeout;\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n#if defined(CONFIG_ZBUS_PRIORITY_BOOST)\n\tif (k_is_in_isr()) {\n\t\tadjusted_timeout = k_is_preempt_thread() ? K_NO_WAIT : K_TICKS_FOREVER;\n\t}\n#endif /* CONFIG_ZBUS_PRIORITY_BOOST */\n\n\tk_time_t end_time = k_uptime_get() + k_ticks_to_ms_floor64(adjusted_timeout);\n\n\treturn _zbus_vded_exec(chan, end_time);\n}", "CodeBleu_score": 31.00586231898633}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan must not be NULL\");\n\n\tk_timeout_t end_time = timeout;\n\tint prio = ZBUS_MIN_THREAD_PRIORITY;\n\n\tif (k_is_in_isr()) {\n\t\tend_time = k_is_preempt_thread() ? K_NO_WAIT : K_TICKS_FOREVER;\n\t} else if (timeout != K_NO_WAIT) {\n\t\tend_time = k_uptime_add(timeout);\n\t}\n\n\tint err = chan_lock(chan, end_time, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 57.90233873208277}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err = 0;\n\tk_timeout_t adjusted_timeout = timeout;\n\tint prio = 0;\n\n\t_ZBUS_ASSERT(chan != NULL, \"channel must not be null\");\n\n\tif (k_is_in_isr()) {\n\t\tadjusted_timeout = k_is_preempt_thread() ? K_NO_WAIT : K_MSEC(1);\n\t}\n\n\terr = chan_lock(chan, adjusted_timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, sys_clock_deadline_get(adjusted_timeout));\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 56.015085387036144}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tuint32_t tmpreg = 0;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT(Int));\n\n\t/* Get the ETHERNET IT enable register value */\n\ttmpreg = ETH->MACIMR;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT_MASKED(Int));\n\n\tif (enable != (uint32_t)RESET) {\n\t\t/* Set the corresponding bit */\n\t\ttmpreg |= Int;\n\t} else {\n\t\t/* Clear the corresponding bit */\n\t\ttmpreg &= ~Int;\n\t}\n\n\t/* Write to the ETHERNET IT enable register */\n\tETH->MACIMR = tmpreg;\n}", "CodeBleu_score": 33.436123559209285}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (Int == ETH_INT_RX) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_RXIE;\n\t\t\tif (ETH->INTEN & ETH_INTEN_RXIE) {\n\t\t\t\tETH->INTEN |= ETH_INTEN_RXIE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tETH->INTEN &= ~ETH_INTEN_RXIE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tETH->INTEN &= ~ETH_INTEN_RXIE;\n\t\t}\n\t}\n\telse if (Int == ETH_INT_TX) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_TXIE;\n\t\t\tif (ETH->INTEN & ETH_INTEN_TXIE) {\n\t\t\t\tETH->INTEN |= ETH_INTEN_TXIE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tETH->INTEN &= ~ETH_INTEN_TXIE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tETH->INTEN &= ~ETH_INTEN_TXIE;\n\t\t}\n\t}\n\telse if (Int == ETH_INT_ERR) {\n\t\tif (enable) {\n\t\t\tETH->INTEN |= ETH_INTEN_ERIE;\n\t\t\tif (ETH->INTEN & ETH_INTEN_ERIE) {\n\t\t\t\tETH->INTEN |= ETH_INTEN_ERIE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tETH->INTEN &= ~ETH_INTEN_ERIE;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tETH->INTEN &= ~ETH_INTEN_ERIE;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.16912896207468}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tuint32_t i;\n\tETH_TX_DESC *pTxDesc;\n\n\t/* Get the current transmit descriptor address. */\n\tpTxDesc = (ETH_TX_DESC *) ETH_TxDescList.pTxDesc;\n\n\t/* Check if the descriptor is owned by the device. */\n\tif (pTxDesc->status & ETH_DMASR_BDS) {\n\t\t/* Get the next transmit descriptor address. */\n\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->next;\n\t}\n\n\t/* Check if the descriptor is owned by the device. */\n\twhile ((pTxDesc->status & ETH_DMASR_BDS) && (pTxDesc != (ETH_TX_DESC *) ETH_TxDescList.pTxDesc)) {\n\t\t/* Get the next transmit descriptor address. */\n\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->next;\n\t}\n\n\t/* Check if the descriptor is owned by the device. */\n\tif (pTxDesc == (ETH_TX_DESC *) ETH_TxDescList.pTxDesc) {\n\t\treturn 0;\n\t}\n\n\t/* Set the descriptor to owned by the device. */\n\tpTxDesc->status |= ETH_DMASR_BDS;\n\n\t/* Return the transmit descriptor address. */\n\treturn pTxDesc;\n}", "CodeBleu_score": 46.050441691186}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tu32_t i;\n\tETH_TX_DESC *tx_desc;\n\n\t/* Get the current transmit descriptor address. */\n\ttx_desc = (ETH_TX_DESC *)ETH_TX_DESC_BASE;\n\n\t/* Search for a free descriptor. */\n\tfor (i = 0; i < ETH_TX_DESCRIPTORS; i++) {\n\t\t/* If the descriptor is owned by the device, continue searching. */\n\t\tif (tx_desc->status & ETH_TX_DESC_OWN) {\n\t\t\ttx_desc++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* If the descriptor is not owned by the device, return it to the caller. */\n\t\telse {\n\t\t\treturn tx_desc;\n\t\t}\n\t}\n\n\t/* If no free descriptor was found, return 0. */\n\treturn 0;\n}", "CodeBleu_score": 33.10531638027701}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\tint i;\n\n\t/* Get the current transmit descriptor address */\n\tpTxDesc = (ETH_TX_DESC *) ETH_TxDescList.pHead;\n\n\t/* Check if the descriptor is owned by the device */\n\tif (pTxDesc->Status & ETH_DMATXDESC_OWN) {\n\t\t/* Get the next transmit descriptor address */\n\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->NextDescAddr;\n\n\t\t/* Check if we looped back to the starting address */\n\t\tif (pTxDesc == (ETH_TX_DESC *) ETH_TxDescList.pHead) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Check if the descriptor is free */\n\tif (pTxDesc->Status & ETH_DMATXDESC_TDES0_TTSE) {\n\t\treturn (0);\n\t}\n\n\t/* Set the descriptor to owned by the device */\n\tpTxDesc->Status |= ETH_DMATXDESC_OWN;\n\n\t/* Return the acquired descriptor */\n\treturn (pTxDesc);\n}", "CodeBleu_score": 45.390053263273}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t", "CodeBleu_score": 14.149251500080561}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t", "CodeBleu_score": 14.149251500080561}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t", "CodeBleu_score": 14.149251500080561}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i = 0;\n\trt_uint32_t temp = 0;\n\trt_uint32_t count = 0;\n\n\tif (addr > FLASH_END_ADDR) {\n\t\trt_kprintf(\"addr is invalid!\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\ttemp = *(rt_uint32_t *)(addr + i * 4);\n\t\tbuf[i] = temp & 0xFF;\n\t\tcount++;\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 46.245460954856064}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t", "CodeBleu_score": 5.618627102069132}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t ret = 0;\n\trt_uint32_t *buf_32 = (rt_uint32_t *)buf;\n\n\t/* Check if the address is valid */\n\tif (addr + size > FLASH_END_ADDRESS) {\n\t\trt_kprintf(\"ifx_flash_read_32k: Address out of range\n\");\n\t\treturn -1;\n\t}\n\n\t/* Read the specified size of data from the flash memory address into the buffer */\n\tfor (i = 0; i < size; i++) {\n\t\tbuf_32[i] = ifx_flash_read_word(addr + i * 4);\n\t\tret++;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 44.62880931523072}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t *timer_obj;\n\trt_uint32_t count;\n\n\tif (timer == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\ttimer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\tcount = cyhal_timer_read(timer_obj);\n\n\treturn count;\n}", "CodeBleu_score": 67.20337489479643}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tif (timer == NULL) {\n\t\treturn 0;\n\t}\n\tcyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(obj);\n}", "CodeBleu_score": 23.91426591851508}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tcyhal_timer_t* timer_obj = (cyhal_timer_t*)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 20.440318388246254}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\twhile (mutex_lock(&fs_mutex) != 0) {\n\t\t;\n\t}\n}", "CodeBleu_score": 9.488339761878487}, {"code": "void dfs_lock(void){\n\t\tint ret;\n\tint i;\n\tfor (i = 0; i < 10000; i++) {\n\t\tret = pthread_mutex_trylock(&mutex);\n\t\tif (ret == 0) {\n\t\t\treturn;\n\t\t}\n\t\tassert(ret == EBUSY);\n\t}\n\tassert(0);\n}", "CodeBleu_score": 29.200067239922124}, {"code": "void dfs_lock(void){\n\t\tint i;\n\tfor (i = 0; i < DFS_LOCK_MAX_TRIES; i++) {\n\t\tif (!mutex_trylock(&dfs_lock))\n\t\t\treturn;\n\t\t/*\n\t\t * We were unable to take the lock.  Wait for a bit and try again.\n\t\t */\n\t\tmutex_sleep(DFS_LOCK_SLEEP_TIME);\n\t}\n\t/*\n\t * We were unable to take the lock.  This should never happen.\n\t */\n\tpanic(\"Unable to acquire the filesystem lock.\");\n}", "CodeBleu_score": 24.15615694552041}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t#define DFS_FD_ALLOC_STEP 10\n    int fd;\n    int index;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, expand the fd table */\n    if (fd_slot_expand(fdt, fd) < 0)\n    {\n        return -1;\n    }\n\n    /* try to find an empty slot again */\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n\n    /* still no empty slot, try to expand the fd table again */\n    if (fd_slot_expand(fdt, fd + DFS_FD_ALLOC_STEP) < 0)\n    {\n        return -1;\n    }\n\n    /* try to find an empty slot again */\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, return an error */\n    return -1;\n}", "CodeBleu_score": 50.41112744706202}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t#define DFS_FD_ALLOC_STEP 8\n    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (!fdt->fds[fd])\n        {\n            return fd;\n        }\n    }\n\n    /* no empty slot found, expand the fd table */\n    return fd_slot_expand(fdt, startfd + DFS_FD_ALLOC_STEP);\n}", "CodeBleu_score": 31.109674785736868}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint i;\n\tint nr;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\t/* find an empty slot */\n\tfor (fd = startfd; fd < DFS_FD_MAX; fd++) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* expand the fd table */\n\tnr = ((fd + 4) & ~3);\n\tif (nr > DFS_FD_MAX) {\n\t\tnr = DFS_FD_MAX;\n\t}\n\n\tstruct dfs_file **fds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\n\tif (!fds) {\n\t\treturn -1;\n\t}\n\n\t/* clean the new allocated fds */\n\tfor (i = fd; i < nr; i++) {\n\t\tfds[i] = NULL;\n\t}\n\tfdt->fds   = fds;\n\tfdt->maxfd = nr;\n\n\treturn fd;\n}", "CodeBleu_score": 39.02518868317199}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (int i = 0; i < sizeof(rt_error_strings) / sizeof(rt_error_strings[0]); i++) {\n\t\tif (rt_error_strings[i].error == error) {\n\t\t\treturn rt_error_strings[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 60.64222424167731}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tint index;\n\tchar *error_str;\n\n\tif (error < 0) {\n\t\terror = -error;\n\t}\n\n\tfor (i = 0; i < RT_ERR_UNKNOWN; i++) {\n\t\tif (error == rt_err_str[i].err_code) {\n\t\t\terror_str = rt_err_str[i].err_str;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == RT_ERR_UNKNOWN) {\n\t\terror_str = rt_err_str[RT_ERR_UNKNOWN].err_str;\n\t}\n\n\treturn error_str;\n}", "CodeBleu_score": 49.7886265255026}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tif (error < 0)\n\t\terror = -error;\n\tfor (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++) {\n\t\tif (error == rt_err_str[i].code)\n\t\t\treturn rt_err_str[i].str;\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 62.78992806443158}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\trt_thread_idle_hook_t *idle_hook;\n\n\tlevel = rt_hw_interrupt_disable();\n\tidle_hook = &idle_hooks[0];\n\twhile (idle_hook->func != RT_NULL) {\n\t\tif (idle_hook == &idle_hooks[IDLE_HOOK_SIZE]) {\n\t\t\tresult = -RT_EFULL;\n\t\t\tbreak;\n\t\t}\n\t\tidle_hook++;\n\t}\n\n\tif (result == RT_EOK) {\n\t\tidle_hook->func = hook;\n\t\tidle_hook->param = RT_NULL;\n\t\tresult = RT_EOK;\n\t}\n\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 42.569667682503365}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (rt_thread_idle_hook_list.next == RT_NULL) {\n\t\tresult = -RT_EFULL;\n\t} else {\n\t\trt_thread_idle_hook_list.next->data = hook;\n\t\tresult = RT_EOK;\n\t}\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 23.609623441988298}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_err_t result;\n\trt_base_t level;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* lock scheduler */\n\tif (rt_thread_self()) {\n\t\tresult = -RT_ERROR;\n\t} else {\n\t\tif (idle_hook_size >= IDLE_HOOK_SIZE) {\n\t\t\tresult = -RT_EFULL;\n\t\t} else {\n\t\t\tidle_hook_list[idle_hook_size] = hook;\n\t\t\tidle_hook_size++;\n\t\t\tresult = RT_EOK;\n\t\t}\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 30.717493210641788}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_thread_idle_hook_t *hook_ptr;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (idle_hook_list == RT_NULL) {\n\t\trt_hw_interrupt_enable(level);\n\t\treturn -RT_ERROR;\n\t}\n\n\thook_ptr = idle_hook_list;\n\twhile (hook_ptr != RT_NULL) {\n\t\tif (hook_ptr->hook == hook) {\n\t\t\thook_ptr->hook = RT_NULL;\n\t\t\trt_hw_interrupt_enable(level);\n\t\t\treturn RT_EOK;\n\t\t}\n\t\thook_ptr = hook_ptr->next;\n\t}\n\trt_hw_interrupt_enable(level);\n\treturn -RT_ERROR;\n}", "CodeBleu_score": 40.61931553318028}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_uint8_t found = 0;\n\trt_base_t level;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (hook != RT_NULL) {\n\t\tfor (rt_uint8_t i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n\t\t\tif (idle_hook_list[i] == hook) {\n\t\t\t\tidle_hook_list[i] = RT_NULL;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found == 0) {\n\t\t\tresult = -RT_ERROR;\n\t\t}\n\t} else {\n\t\tresult = -RT_ERROR;\n\t}\n\n\trt_hw_interrupt_enable(level);\n\treturn result;\n}", "CodeBleu_score": 55.44288686354113}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_err_t result = RT_EOK;\n\trt_uint32_t hook_index;\n\n\t/* check hook */\n\tif (hook == RT_NULL) {\n\t\treturn -RT_EINVAL;\n\t}\n\n\t/* disable interrupt */\n\trt_hw_interrupt_disable();\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* find the hook */\n\tfor (hook_index = 0; hook_index < RT_THREAD_IDLE_HOOK_MAX; hook_index++) {\n\t\tif (rt_thread_idle_hook_list[hook_index] == hook) {\n\t\t\trt_thread_idle_hook_list[hook_index] = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable();\n\n\t/* check result */\n\tif (hook_index == RT_THREAD_IDLE_HOOK_MAX) {\n\t\tresult = -RT_ENOSYS;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 43.89614396626167}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\trt_list_t *list_node;\n\trt_err_t result = RT_EOK;\n\trt_base_t level;\n\n\t/*\n\t * Check the \"susp_list\" parameter.\n\t */\n\tRT_ASSERT(susp_list != RT_NULL);\n\n\t/*\n\t * Ensure the scheduler is unlocked.\n\t */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/*\n\t * Resume all threads in the list.\n\t */\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\t/*\n\t\t * Dequeue a thread from the list.\n\t\t */\n\t\tlist_node = rt_list_first(susp_list);\n\t\tthread = rt_list_entry(list_node, struct rt_thread, tlist);\n\t\trt_list_remove(list_node);\n\n\t\t/*\n\t\t * Resume the thread.\n\t\t */\n\t\tthread->error = thread_error;\n\t\trt_thread_resume(thread);\n\n\t\t/*\n\t\t * Check if the thread was successfully resumed.\n\t\t */\n\t\tif (thread->error != RT_EOK) {\n\t\t\t/*\n\t\t\t * Set the error code and stop resuming other threads.\n\t\t\t */\n\t\t\tresult = thread->error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Restore the scheduler lock level.\n\t */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}", "CodeBleu_score": 26.43182302729301}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t err;\n\trt_thread_t thread;\n\trt_list_t *pos;\n\trt_uint8_t need_schedule;\n\n\t/* make sure the scheduler is unlocked */\n\trt_enter_critical();\n\n\t/* resume all threads in the list */\n\twhile (!rt_list_isempty(susp_list)) {\n\t\t/* dequeue the thread */\n\t\tpos = rt_list_first(susp_list);\n\t\tthread = rt_list_entry(pos, struct rt_thread, tlist);\n\t\trt_list_remove(pos);\n\n\t\t/* resume the thread */\n\t\tneed_schedule = rt_thread_resume(thread, thread_error);\n\n\t\t/* check error */\n\t\tif (thread_error != RT_EOK) {\n\t\t\terr = thread_error;\n\t\t} else if (need_schedule == RT_TRUE) {\n\t\t\t/* set the error code */\n\t\t\terr = RT_EOK;\n\t\t} else {\n\t\t\t/* set the error code */\n\t\t\terr = RT_ERROR;\n\t\t}\n\n\t\t/* check error */\n\t\tif (err != RT_EOK) {\n\t\t\t/* resume the thread */\n\t\t\trt_schedule();\n\n\t\t\t/* set the error code */\n\t\t\tthread_error = err;\n\t\t}\n\t}\n\n\t/* release the scheduler */\n\trt_exit_critical();\n\n\treturn thread_error;\n}", "CodeBleu_score": 36.07832209117174}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_err_t ret = RT_EOK;\n\trt_thread_t thread;\n\n\t/* check parameter */\n\tRT_ASSERT(susp_list != RT_NULL);\n\n\t/* resume all threads in the list */\n\twhile (rt_list_isempty(susp_list) == RT_FALSE) {\n\t\t/* get thread from list */\n\t\tthread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n\t\t/* resume thread */\n\t\tret = rt_thread_resume(thread, thread_error);\n\t\tif (ret != RT_EOK) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 42.193277146191896}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device;\n\trt_device_t old_device;\n\n\t/* get current console device */\n\told_device = rt_console_get_device();\n\n\t/* find new console device by name */\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\t/* find failed */\n\t\treturn old_device;\n\t}\n\n\t/* check if new console device is the same as the current console device */\n\tif (device == old_device) {\n\t\t/* new console device is the same as the current console device */\n\t\treturn old_device;\n\t}\n\n\t/* close current console device if it is not RT_NULL */\n\tif (old_device != RT_NULL) {\n\t\trt_device_close(old_device);\n\t}\n\n\t/* open new console device with read/write and stream flags */\n\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)) {\n\t\t/* open failed */\n\t\treturn RT_NULL;\n\t}\n\n\t/* set new console device */\n\trt_console_set_device(device);\n\n\t/* return old console device */\n\treturn old_device;\n}", "CodeBleu_score": 54.64378995237882}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t device, old_device;\n\trt_device_t console_device = RT_NULL;\n\trt_size_t count;\n\tconst char *old_name;\n\n\told_device = console_device_get();\n\told_name = old_device ? old_device->parent.name : \"\";\n\tif (old_name && !rt_strcmp(old_name, name)) {\n\t\treturn old_device;\n\t}\n\n\t/* find the console device by its name */\n\tcount = rt_device_find_count(name);\n\tif (count == 0) {\n\t\treturn RT_NULL;\n\t}\n\n\tdevice = rt_device_find(name);\n\tif (device == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* check if the device is a console device */\n\tconsole_device = rt_console_get_device();\n\tif (console_device == device) {\n\t\treturn old_device;\n\t}\n\n\t/* close the current console device */\n\tif (console_device) {\n\t\trt_device_close(console_device);\n\t}\n\n\t/* open the new console device */\n\tif (rt_device_open(device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM)) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* set the new console device */\n\tconsole_device_set(device);\n\n\treturn old_device;\n}", "CodeBleu_score": 51.63304005725884}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_device;\n\trt_device_t new_device;\n\tint fd;\n\tint flags;\n\tchar *tmp;\n\n\told_device = rt_console_get_device();\n\tif (old_device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\tnew_device = rt_device_find(name);\n\tif (new_device == RT_NULL) {\n\t\treturn old_device;\n\t}\n\n\tif (old_device == new_device) {\n\t\treturn old_device;\n\t}\n\n\t/* close old device */\n\tif (old_device->type == RT_Device_Class_Char) {\n\t\tfd = ((struct rt_device_char *)old_device)->parent.fd;\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t}\n\t}\n\n\t/* open new device */\n\tfd = open(new_device->parent.name, O_RDWR | O_NOCTTY | O_NONBLOCK);\n\tif (fd == -1) {\n\t\treturn old_device;\n\t}\n\n\tflags = fcntl(fd, F_GETFL);\n\tif (flags == -1) {\n\t\tclose(fd);\n\t\treturn old_device;\n\t}\n\n\tflags &= ~(O_RDWR | O_WRONLY | O_RDONLY);\n\tflags |= O_RDWR | O_NOCTTY | O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, flags) == -1) {\n\t\tclose(fd);\n\t\treturn old_device;\n\t}\n\n\t/* set new device */\n\ttmp = rt_console_device_name;\n\trt_console_device_name = rt_strdup(new_device->parent.name);\n\trt_free(tmp);\n\n\tif (new_device->type == RT_Device_Class_Char) {\n\t\t((struct rt_device_char *)new_device)->parent.fd = fd;\n\t}\n\n\treturn old_device;\n}", "CodeBleu_score": 53.364528815406786}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint i = 0;\n\trt_object_information_t *object_information;\n\trt_object_information_t *object_information_temp;\n\trt_object_information_t *object_information_head;\n\n\t/*\n\t * If the object class type is invalid, return -1.\n\t */\n\tif (type >= RT_OBJECT_CLASS_TYPE_MAX) {\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Get the object information head.\n\t */\n\tobject_information_head = rt_object_information_get_head(type);\n\n\t/*\n\t * If the object information head is NULL, return 0.\n\t */\n\tif (object_information_head == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Lock the spinlock.\n\t */\n\trt_enter_critical();\n\n\t/*\n\t * Get the object information head.\n\t */\n\tobject_information_head = rt_object_information_get_head(type);\n\n\t/*\n\t * If the object information head is NULL, return 0.\n\t */\n\tif (object_information_head == RT_NULL) {\n\t\trt_exit_critical();\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Get the object information.\n\t */\n\tobject_information = object_information_head;\n\n\t/*\n\t * Iterate through the object list.\n\t */\n\twhile (object_information != RT_NULL) {\n\t\t/*\n\t\t * Increase the count by 1.\n\t\t */\n\t\ti++;\n\n\t\t/*\n\t\t * Get the next object information.\n\t\t */\n\t\tobject_information_temp = object_information->next;\n\n\t\t/*\n\t\t * If the next object information is not the object information head, release the object information.\n\t\t */\n\t\tif (object_information_temp != object_information_head) {\n\t\t\trt_object_information_release(object_information);\n\t\t}\n\n\t\t/*\n\t\t * Set the object information.\n\t\t */\n\t\tobject_information = object_information_temp;\n\t}\n\n\t/*\n\t * Release the spinlock.\n\t */\n\trt_exit_critical();\n\n\t/*\n\t * Return the count.\n\t */\n\treturn i;\n}", "CodeBleu_score": 38.404958635958444}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\trt_object_information_t *information;\n\trt_object_information_t *information_next;\n\trt_object_information_t *information_last;\n\n\t/*\n\t * Get the object information list.\n\t */\n\tinformation = rt_object_information_get(type);\n\n\t/*\n\t * If the list is empty, then there are no objects of the specified type.\n\t */\n\tif (information == RT_NULL) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Lock the object information list.\n\t */\n\trt_enter_critical();\n\n\t/*\n\t * Iterate through the list.\n\t */\n\tinformation_next = information;\n\tdo {\n\t\t/*\n\t\t * Increment the count.\n\t\t */\n\t\tcount++;\n\n\t\t/*\n\t\t * Get the next object information.\n\t\t */\n\t\tinformation_next = information_next->next;\n\t} while (information_next != information);\n\n\t/*\n\t * Unlock the object information list.\n\t */\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 47.47547307798262}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_object_information *information;\n\n\t/* get the object information */\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL) {\n\t\treturn count;\n\t}\n\n\t/* lock the object information */\n\trt_enter_critical();\n\n\t/* get the object count */\n\tcount = information->object_count;\n\n\t/* release the object information */\n\trt_exit_critical();\n\n\treturn count;\n}", "CodeBleu_score": 31.9753990985847}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_information_t info;\n\trt_object_t *list;\n\trt_uint8_t type;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* check object */\n\tif (object == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* get object information */\n\tinfo = object->information;\n\n\t/* check object information */\n\tif (info == RT_NULL) {\n\t\treturn;\n\t}\n\n\t/* get object type */\n\ttype = object->type;\n\n\t/* check object type */\n\tif (type == RT_Object_Class_Unknown) {\n\t\treturn;\n\t}\n\n\t/* lock object */\n\trt_enter_critical();\n\n\t/* detach object */\n\tlist = info->object_list[type];\n\trt_object_detach_nolock(object, list);\n\n\t/* unlock object */\n\trt_exit_critical();\n\n\t/* invoke detach hook */\n\tif (info->detach != RT_NULL) {\n\t\tinfo->detach(object);\n\t}\n}", "CodeBleu_score": 41.62449903414649}, {"code": "void rt_object_detach(rt_object_t object){\n\t", "CodeBleu_score": 1.5020509296100257}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_DEBUG_NOT_IN_INTERRUPT;\n\tRT_DEBUG_NULL_POINTER(object);\n\n\trt_object_information_t info;\n\trt_list_t *list;\n\trt_object_t object_temp;\n\trt_object_t object_next;\n\n\t/* get object's information */\n\tinfo = (rt_object_information_t)object;\n\n\t/* check object's type */\n\tif (info->type == RT_Object_Class_Unknown) {\n\t\trt_kprintf(\"object detach: object is unknown type!\n\");\n\t\treturn;\n\t}\n\n\t/* get object's list */\n\tlist = (rt_list_t *)info->list;\n\n\t/* lock object's spinlock */\n\trt_enter_critical();\n\n\t/* detach object */\n\trt_list_remove(list, object);\n\tobject->type = RT_Object_Class_Unknown;\n\n\t/* unlock object's spinlock */\n\trt_exit_critical();\n\n\t/* call object's detach hook function */\n\tif (info->deinit != RT_NULL) {\n\t\tinfo->deinit(object);\n\t}\n\n\t/* detach all sub-object */\n\tobject_temp = (rt_object_t)object->parent.next;\n\twhile (object_temp != (rt_object_t)object) {\n\t\tobject_next = (rt_object_t)object_temp->parent.next;\n\t\trt_object_detach(object_temp);\n\t\tobject_temp = object_next;\n\t}\n}", "CodeBleu_score": 37.88519230935624}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\trt_object_information_t information;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* object check */\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information != RT_NULL);\n\n\tif (information->object_destroy != RT_NULL) {\n\t\tresult = information->object_destroy(obj);\n\t}\n\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 42.09689138308391}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\trt_object_information_t information;\n\n\t/* object check */\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\t/* get object information */\n\tinformation = rt_object_get_information((enum rt_object_class_type)obj->type);\n\tRT_ASSERT(information != RT_NULL);\n\n\t/* call destroy function */\n\tif (information->object_destroy != RT_NULL) {\n\t\tresult = information->object_destroy(obj);\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 42.66635579452907}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t\trt_err_t result = RT_EOK;\n\trt_object_information_t information;\n\n\t/* object check */\n\tRT_ASSERT(obj != RT_NULL);\n\tRT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n\tinformation = rt_object_get_information(obj->type);\n\tRT_ASSERT(information != RT_NULL);\n\n\t/* if the object has a destroy method */\n\tif (information->object_destroy != RT_NULL) {\n\t\tresult = information->object_destroy(obj);\n\t}\n\n\t/* delete the object */\n\trt_object_delete(obj);\n\n\treturn result;\n}", "CodeBleu_score": 43.71994849875513}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t#ifdef RT_USING_COMPONENTS_INIT\n    extern void rt_components_exit(void);\n#endif\n\n    /* get current thread */\n    rt_thread_t thread = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* add to defunct thread list */\n    rt_list_insert_before(&rt_object_container_get(RT_Object_Class_Thread)->defunct, &thread->parent);\n\n    /* leave critical */\n    rt_exit_critical();\n\n#ifdef RT_USING_COMPONENTS_INIT\n    /* invoke components exit function */\n    rt_components_exit();\n#endif\n\n    /* schedule */\n    rt_schedule();\n\n    /* never be here */\n    RT_ASSERT(0);\n}", "CodeBleu_score": 54.54329966148239}, {"code": "static void _thread_exit(void){\n\t", "CodeBleu_score": 3.326153796004938}, {"code": "static void _thread_exit(void){\n\t#ifndef RT_USING_SMP\n    rt_base_t level;\n    rt_thread_t thread;\n    rt_thread_t self;\n\n    /* get current thread */\n    self = rt_thread_self();\n\n    /* change thread status */\n    level = rt_hw_interrupt_disable();\n    self->stat = RT_THREAD_CLOSE;\n    rt_hw_interrupt_enable(level);\n\n    /* release thread timer */\n    rt_timer_detach(&(self->thread_timer));\n\n    /* remove from schedule */\n    rt_sched_lock();\n    rt_sched_remove_thread(self);\n    rt_sched_unlock();\n\n    /* cleanup thread stack */\n    rt_hw_stack_free(&(self->stack));\n\n    /* release thread object */\n    rt_object_delete(&(self->parent));\n\n#elif defined (ARCH_USING_HW_THREAD_EXIT)\n    ARCH_THREAD_EXIT();\n\n#else /* !ARCH_USING_HW_THREAD_EXIT */\n    rt_base_t level;\n    rt_thread_t thread;\n    rt_thread_t self;\n\n    /* get current thread */\n    self = rt_thread_self();\n\n    /* change thread status */\n    level = rt_hw_interrupt_disable();\n    self->stat = RT_THREAD_CLOSE;\n    rt_hw_interrupt_enable(level);\n\n    /* release thread timer */\n    rt_timer_detach(&(self->thread_timer));\n\n    /* remove from schedule */\n    rt_sched_lock();\n    rt_sched_remove_thread(self);\n    rt_sched_unlock();\n\n    /* cleanup thread stack */\n    rt_hw_stack_free(&(self->stack));\n\n    /* release thread object */\n    rt_object_delete(&(self->parent));\n\n    /* change to next thread */\n    rt_schedule();\n#endif /* ARCH_USING_HW_THREAD_EXIT */\n}", "CodeBleu_score": 50.69468943566604}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct thread *thread = (struct thread *)parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tif (thread->state != THREAD_SUSPENDED) {\n\t\treturn;\n\t}\n\n\tthread->error_number = ETIMEDOUT;\n\t_scheduler_lock();\n\t_scheduler_remove_suspend(thread);\n\t_scheduler_insert_ready(thread);\n\t_scheduler_unlock();\n}", "CodeBleu_score": 35.9211607701259}, {"code": "static void _thread_timeout(void *parameter){\n\t\tstruct _thread *thread = (struct _thread *)parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tif (thread->state != THREAD_STATE_SUSPENDED) {\n\t\treturn;\n\t}\n\n\tthread->error_number = ERROR_THREAD_TIMEOUT;\n\n\t_scheduler_lock();\n\t_scheduler_remove_thread_from_suspend_list(thread);\n\t_scheduler_insert_thread_into_ready_list(thread);\n\t_scheduler_unlock();\n}", "CodeBleu_score": 37.78800636859101}, {"code": "static void _thread_timeout(void *parameter){\n\t\tthread_t *thread = (thread_t *)parameter;\n\tint error = ETIMEDOUT;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tif (scheduler_lock() != 0) {\n\t\treturn;\n\t}\n\n\tif (thread->state != THREAD_STATE_SUSPENDED) {\n\t\tscheduler_unlock();\n\t\treturn;\n\t}\n\n\tthread->error = error;\n\tthread_remove_from_suspend_list(thread);\n\tthread_insert_into_ready_list(thread);\n\tscheduler_unlock();\n}", "CodeBleu_score": 34.72644336041936}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_t thread_to_resume;\n\trt_thread_t thread_to_resume_next;\n\trt_thread_t thread_to_resume_prev;\n\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check if thread is waiting on a mutex */\n\tif (thread->object.take_object != RT_NULL) {\n\t\t/* remove thread from the mutex waiting list */\n\t\tif (thread->object.take_object->owner == thread) {\n\t\t\tthread->object.take_object->owner = thread->object.take_object->owner->object.next;\n\t\t} else {\n\t\t\tthread_to_resume_prev = thread->object.take_object->owner;\n\t\t\tthread_to_resume = thread_to_resume_prev->object.next;\n\n\t\t\twhile (thread_to_resume != thread->object.take_object) {\n\t\t\t\tif (thread_to_resume == thread) {\n\t\t\t\t\tthread_to_resume_prev->object.next = thread_to_resume->object.next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tthread_to_resume_prev = thread_to_resume;\n\t\t\t\tthread_to_resume = thread_to_resume->object.next;\n\t\t\t}\n\t\t}\n\n\t\t/* clear pending object */\n\t\tthread->object.take_object = RT_NULL;\n\t}\n\n\t/* release all mutexes the thread has taken */\n\twhile (thread->object.owner != RT_NULL) {\n\t\t_mutex_release(thread->object.owner);\n\t}\n\n\t/* restore interrupt level */\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 37.914410530120925}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_base_t level;\n\trt_thread_t owner;\n\n\tlevel = rt_hw_interrupt_disable();\n\tif (thread->object_type == RT_Object_Class_Mutex) {\n\t\towner = thread->owner;\n\t\tif (owner != RT_NULL) {\n\t\t\tif (owner->object_type == RT_Object_Class_Thread) {\n\t\t\t\trt_list_remove(&(owner->wait_list), &(thread->list));\n\t\t\t\towner->wait_option = 0;\n\t\t\t\towner->suspend_tick = 0;\n\t\t\t\towner->cleanup = RT_NULL;\n\t\t\t\tthread->owner = RT_NULL;\n\t\t\t}\n\t\t}\n\t}\n\trt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 36.918858447789574}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t", "CodeBleu_score": 1.5259533266411016}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_rt_thread_startup:\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* set thread's priority */\n    rt_thread_set_priority(thread, thread->init_priority);\n\n    /* reset thread's stack */\n    rt_hw_stack_init(thread->stack_addr, thread->stack_size, thread->entry, thread->parameter);\n\n    /* reset thread's state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    return rt_thread_resume(thread);\n}", "CodeBleu_score": 56.29659425887963}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t_rt_thread_startup:\n    rt_err_t result;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* set the thread's priority */\n    thread->current_priority = thread->init_priority;\n\n    /* reset thread's stack */\n    rt_hw_stack_init(thread);\n\n    /* set thread's stack size */\n    thread->stack_size = thread->init_stack_size;\n\n    /* set thread's stat */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    result = rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    if (result == RT_EOK) {\n        rt_schedule();\n    }\n\n    return result;\n}", "CodeBleu_score": 58.21308943573561}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t.\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* set thread's priority */\n    thread->current_priority = thread->init_priority;\n\n    /* reset thread's stack */\n    rt_hw_stack_init(thread->stack_addr, thread->stack_size, thread->entry, thread->parameter);\n\n    /* set thread's stat as suspend */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    return RT_EOK;\n}", "CodeBleu_score": 61.82829488892343}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_err_t result = RT_EOK;\n\trt_uint8_t i;\n\n\tfor (i = 0; i < RT_TIMER_SKIPLIST_LEVELS; i++) {\n\t\tif (!rt_list_isempty(timer_list[i])) {\n\t\t\trt_timer_t timer;\n\n\t\t\ttimer = rt_list_entry(timer_list[i].next, struct rt_timer, list);\n\t\t\t*timeout_tick = timer->timeout_tick;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == RT_TIMER_SKIPLIST_LEVELS) {\n\t\tresult = -RT_ETIMEOUT;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 39.719750625159364}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_timer_t timer;\n\trt_uint8_t level;\n\n\t/* Check if the highest level of the timer skip list is not empty. */\n\tfor (level = RT_TIMER_SKIP_LIST_LEVELS - 1; level >= 0; level--) {\n\t\tif (rt_list_isempty(&(timer_list[level]))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Get the first timer entry from the highest level of the timer skip list. */\n\t\ttimer = rt_list_entry(timer_list[level].next, struct rt_timer, list);\n\n\t\t/* Set the provided timeout tick to the timer's timeout value. */\n\t\t*timeout_tick = timer->timeout_tick;\n\n\t\t/* Return success. */\n\t\treturn RT_EOK;\n\t}\n\n\t/* Return error code. */\n\treturn -RT_ETIMEOUT;\n}", "CodeBleu_score": 43.16089187804559}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_err_t result = RT_EOK;\n\n\tif (timer_list[0].next == RT_NULL) {\n\t\tresult = -RT_ETIMEOUT;\n\t}\n\telse {\n\t\trt_timer_t timer = (rt_timer_t)timer_list[0].next;\n\t\t*timeout_tick = timer->timeout_tick;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 31.744305534044216}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n\n    /* allocate memory for timer object */\n    timer = (rt_timer_t) rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer object */\n    rt_timer_init(timer, timeout, parameter, time, flag);\n\n    /* insert timer object to timer system */\n    if (rt_timer_insert(timer) != RT_EOK)\n    {\n        /* release memory */\n        rt_free(timer);\n\n        return RT_NULL;\n    }\n\n    return timer;\n#else\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check parameter */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n\n    /* allocate memory for timer object */\n    rt_enter_critical();\n    if (rt_object_is_systemobject((rt_object_t)rt_timer_table))\n    {\n        rt_exit_critical();\n\n        return RT_NULL;\n    }\n\n    rt_object_allocate((rt_object_t)rt_timer_table, name, RT_Object_Class_Timer);\n    rt_exit_critical();\n\n    /* initialize timer object */\n    rt_timer_init(rt_timer_table->parent.name, timeout, parameter, time, flag);\n\n    /* insert timer object to timer system */\n    if (rt_timer_insert(rt_timer_table->parent.name) != RT_EOK)\n    {\n        /* release memory */\n        rt_object_delete((rt_object_t)rt_timer_table);\n\n        return RT_NULL;\n    }\n\n    return rt_timer_table->parent.name;\n#endif /* RT_USING_HEAP */\n}", "CodeBleu_score": 64.51433439593698}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n#endif\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check parameter */\n    RT_DEBUG_NULL_POINTER(timeout);\n\n    /* check timer name */\n    RT_DEBUG_NAME_EX(RT_OBJECT_TIMER, name);\n\n    /* check timer flag */\n    RT_DEBUG_IN_INTERRUPT;\n\n    /* check timer flag */\n    RT_DEBUG_IN_INTERRUPT;\n\n    /* check timer flag */\n    RT_DEBUG_IN_INTERRUPT;\n\n#ifdef RT_USING_HEAP\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n#else\n    timer = &_timer_pool[0];\n    rt_memset(timer, 0, sizeof(struct rt_timer));\n    timer->parent.type = RT_Object_Class_Timer;\n#endif /* RT_USING_HEAP */\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* insert to timer list */\n    rt_list_insert_before(&(rt_timer_list), &(timer->parent.list));\n\n    return timer;\n}", "CodeBleu_score": 57.880698656769944}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_HEAP\n    rt_timer_t timer;\n\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    rt_timer_init(timer, timeout, parameter, time, flag);\n\n    /* insert to timer list */\n    rt_list_insert_after(&(rt_timer_list), &(timer->parent.list));\n\n    return timer;\n#else\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time != 0);\n\n    return RT_NULL;\n#endif\n}", "CodeBleu_score": 66.62427230491318}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tif a.isUnauthorized(res, req) {\n\t\treturn\n\t}\n\trecorder := newRecorder(res)\n\tdefer func() {\n\t\tfor k, v := range recorder.HeaderMap {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\ta.sendError(res, req, http.StatusUnauthorized, \"Not Authorized\")\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(recorder, req)\n}", "CodeBleu_score": 67.55901598153093}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := &httptest.ResponseRecorder{\n\t\tCode:        200,\n\t\tBody:        &bytes.Buffer{},\n\t\tHeaderMap:   make(http.Header),\n\t\tFlushed:     false,\n\t\twroteHeader: false,\n\t}\n\n\ta.Router.ServeHTTP(recorder, req)\n\n\tfor k, v := range recorder.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\tres.WriteHeader(recorder.Code)\n\t_, _ = res.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 45.79547029018614}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a new recorder to record the response\n\trec := httptest.NewRecorder()\n\t// Create a new context\n\tctx := context.New(req, rec)\n\t// Create a new router\n\trouter := mux.NewRouter()\n\n\t// Create a new API instance\n\tapi := NewAPI(ctx, router)\n\n\t// Mount the routes\n\tapi.Mount()\n\n\t// Execute the router\n\trouter.ServeHTTP(rec, req)\n\n\t// Copy the headers to the original response\n\tfor k, v := range rec.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\n\t// Write the response\n\tres.WriteHeader(rec.Code)\n\t_, _ = res.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 42.662681203621396}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tfile, err := a.assets.Open(path)\n\tif err != nil {\n\t\thttp.Error(res, \"Not Found\", 404)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tinfo, err := file.Stat()\n\tif err != nil {\n\t\thttp.Error(res, \"Not Found\", 404)\n\t\treturn\n\t}\n\thttp.ServeContent(res, req, info.Name(), info.ModTime(), file)\n}", "CodeBleu_score": 42.931277157132655}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\text := path[strings.LastIndex(path, \".\"):len(path)]\n\tif ext == \".html\" {\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t} else if ext == \".js\" {\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t} else if ext == \".css\" {\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t} else if ext == \".png\" {\n\t\tres.Header().Set(\"Content-Type\", \"image/png\")\n\t} else if ext == \".jpg\" {\n\t\tres.Header().Set(\"Content-Type\", \"image/jpeg\")\n\t} else if ext == \".svg\" {\n\t\tres.Header().Set(\"Content-Type\", \"image/svg+xml\")\n\t} else {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tasset, err := a.Assets.Asset(path[1:])\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tres.Write(asset)\n}", "CodeBleu_score": 46.47870989740256}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the path of the requested asset\n\tpath := req.URL.Path\n\t// If the path is empty, set it to \"/\"\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n\t// If the path is longer than 1 character, remove the leading \"/\"\n\tif len(path) > 1 {\n\t\tpath = path[1:]\n\t}\n\t// If the path is \"index.html\", set it to \"/\"\n\tif path == \"index.html\" {\n\t\tpath = \"/\"\n\t}\n\t// Get the file extension from the path\n\text := path[strings.LastIndex(path, \".\"):]\n\t// If the file extension is empty, set it to \"html\"\n\tif ext == \"\" {\n\t\text = \".html\"\n\t}\n\t// Try to open the file\n\tfile, err := a.assets.Open(path)\n\t// If an error occurs, return a 404 error\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Close the file when the function exits\n\tdefer file.Close()\n\t// Get the file contents\n\tcontent, err := ioutil.ReadAll(file)\n\t// If an error occurs, return a 404 error\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Set the Content-Type header based on the file extension\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tdefault:\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\t// Write the file contents to the response\n\tres.Write(content)\n}", "CodeBleu_score": 49.20701168157315}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL.\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Find the robot with the specified name.\n\trobot := a.master.FindRobot(name)\n\tif robot == nil {\n\t\t// The robot was not found.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"robot not found\"})\n\t\treturn\n\t}\n\n\t// Gather the robot's connections.\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format.\n\tjsonConnections := make([]map[string]string, len(connections))\n\tfor i, c := range connections {\n\t\tjsonConnections[i] = map[string]string{\n\t\t\t\"name\": c.Name(),\n\t\t\t\"type\": c.Type(),\n\t\t}\n\t}\n\n\t// Write the JSON response containing the connections.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(jsonConnections)\n}", "CodeBleu_score": 42.92799667322061}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvar err error\n\tvar connections []string\n\tvar robotName string\n\tvar robot *robot.Robot\n\n\t// Get the robot name from the request URL\n\trobotName = strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Get the robot with the specified name from the master instance\n\trobot, err = a.master.GetRobot(robotName)\n\tif err != nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name\n\t\ta.writeJSONError(res, http.StatusNotFound, fmt.Sprintf(\"No robot found with name '%s'\", robotName))\n\t\treturn\n\t}\n\n\t// Get the connections of the robot\n\tconnections = robot.GetConnections()\n\n\t// Write the JSON response containing the connections\n\ta.writeJSONResponse(res, http.StatusOK, connections)\n}", "CodeBleu_score": 40.26057580056603}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the request URL\n\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\t// Find the robot with the specified name\n\trobot, err := a.master.GetRobot(name)\n\tif err != nil {\n\t\t// If the robot is not found, write an error message and return\n\t\ta.writeError(res, http.StatusNotFound, \"Robot not found\")\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections := robot.GetConnections()\n\n\t// Convert the connections to JSON format\n\tjsonConnections, err := json.Marshal(connections)\n\tif err != nil {\n\t\t// If the connections cannot be converted to JSON format, write an error message and return\n\t\ta.writeError(res, http.StatusInternalServerError, \"Error converting connections to JSON format\")\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\ta.writeJSON(res, http.StatusOK, jsonConnections)\n}", "CodeBleu_score": 34.07665568324125}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Basic Authentication credentials\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif len(auth) == 0 {\n\t\t\t// No credentials were provided, so ask the client to authenticate\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(401)\n\t\t\treturn\n\t\t}\n\t\t// Verify the credentials\n\t\tif !secureCompare(auth, \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))) {\n\t\t\t// The credentials are not valid, so ask the client to authenticate\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(401)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 56.7784854732998}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t", "CodeBleu_score": 2.4688481363070753}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Min(math.Max(slope*input + intercept, toMin), toMax))\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.390501206081865}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) int {\n\t\tvalue := int(slope * input + intercept)\n\t\tif value > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\tif value < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 62.4563495973647}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(float64(toMin), math.Min(float64(toMax), slope*input + intercept)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 52.09963226233416}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.conn == nil {\n\t\treturn 0, 0, errors.New(\"connection is nil\")\n\t}\n\n\tif a.conn.AnalogInputPins() == nil {\n\t\treturn 0, 0, errors.New(\"connection does not support analog input\")\n\t}\n\n\tif a.pin == nil {\n\t\treturn 0, 0, errors.New(\"pin is nil\")\n\t}\n\n\traw, err := a.conn.AnalogInput(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 52.22529821095382}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.isValid() {\n\t\treturn 0, 0, errors.New(\"connection is invalid\")\n\t}\n\n\tif !a.isAnalog() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.conn.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn raw, 0, err\n\t}\n\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 51.7182130460603}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"Connection is not open\")\n\t}\n\n\tif a.connection.SupportsAnalogRead() == false {\n\t\treturn 0, 0, errors.New(\"Connection does not support analog read\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 54.12133097253701}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m * fromMin\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 43.50987638483896}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(v int) float64 {\n\t\treturn m*float64(v) + n\n\t}\n}", "CodeBleu_score": 50.023829605567286}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\treturn m*float64(input) + n\n\t}\n}", "CodeBleu_score": 42.79973249779121}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tname := DefaultName\n\tfor _, opt := range opts {\n\t\tif n, ok := opt.(string); ok {\n\t\t\tname = n\n\t\t\tbreak\n\t\t}\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: name,\n\t\ta:    a,\n\t\tpin:  pin,\n\t}\n\td.AddEventListener(d.handleDataEvent)\n\tif err := d.a.AddEventListener(d.handleAnalogDataEvent); err != nil {\n\t\tpanic(err)\n\t}\n\treturn d\n}", "CodeBleu_score": 43.217858718477146}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tvar (\n\t\tname   = \"GrovePiezoVibrationSensor\"\n\t\tvEvent = NewVibrationEvent()\n\t)\n\tfor _, opt := range opts {\n\t\tswitch opt := opt.(type) {\n\t\tcase Name:\n\t\t\tname = string(opt)\n\t\tcase VibrationEvent:\n\t\t\tvEvent = opt\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"unexpected option type %T\", opt))\n\t\t}\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:    name,\n\t\tanalog:  a,\n\t\tpin:     pin,\n\t\tvEvent:  vEvent,\n\t\tvReader: NewAnalogSensorReader(a, pin),\n\t}\n\td.vReader.AddEventListener(d.vibrationEvent)\n\treturn d\n}", "CodeBleu_score": 35.84483331767846}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:    gopigo3.GROVE_PIEZO_VIBRATION_SENSOR_NAME,\n\t\tpin:     pin,\n\t\tanalog:  a,\n\t\thandler: nil,\n\t}\n\n\td.SetName(d.name)\n\td.AddVibrationEvent()\n\n\tif err := d.AddDataEventHandler(d.handleDataEvent); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 37.40850400148189}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\n\tif hz < 0 {\n\t\treturn errors.New(\"invalid frequency\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"invalid duration\")\n\t}\n\tperiod := 1.0 / hz\n\tdelay := period / 2\n\tfor i := 0.0; i < duration; i++ {\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil\n}", "CodeBleu_score": 54.92495873026893}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\n\tperiod := 1.0 / hz\n\ttempo := 60.0 / d.bpm\n\tdelay := period / tempo\n\tfor i := 0.0; i < duration; i += delay {\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t\terr = d.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(delay)\n\t}\n\treturn nil\n}", "CodeBleu_score": 49.68900864709735}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\n\t// Calculate the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm)\n\tperiod := 60.0 / d.bpm * 10000000000.0 / hz\n\t// Tone period must be at least 100 ns\n\tif period < 100 {\n\t\tperiod = 100\n\t}\n\t// Tone period must be less than 2621440000 ns (262144000000 ns = 2621440000 us = 262.144 ms = 262 s)\n\tif period > 2621440000 {\n\t\tperiod = 2621440000\n\t}\n\t// Calculate the number of times the tone period must be repeated to achieve the desired duration\n\treps := int(duration * 1000000000.0 / period)\n\t// Tone duration must be less than 2621440000 ns (262144000000 ns = 2621440000 us = 262.144 ms = 262 s)\n\tif reps > 2621440000 {\n\t\treps = 2621440000\n\t}\n\t// Repeat the tone period the required number of times\n\tfor i := 0; i < reps; i++ {\n\t\t// Turn the buzzer on\n\t\terr := d.On()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the tone period\n\t\ttime.Sleep(time.Duration(period) * time.Nanosecond)\n\t\t// Turn the buzzer off\n\t\terr = d.Off()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Sleep for the tone period\n\t\ttime.Sleep(time.Duration(period) * time.Nanosecond)\n\t}\n\treturn nil\n}", "CodeBleu_score": 48.98286972043908}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == 0 {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\tif d.sleepPin.Read() == 0 {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.Write(0)\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 36.62231393848588}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\n\tif err := d.sleepPin.WaitForEdge(0); err != nil {\n\t\treturn fmt.Errorf(\"error waiting for sleep pin to go high: %w\", err)\n\t}\n\n\tif err := d.sleepPin.Out(0); err != nil {\n\t\treturn fmt.Errorf(\"error setting sleep pin to low: %w\", err)\n\t}\n\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 43.18146134089614}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\tif d.sleepPin.Get() == 0 {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.SetLow()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 37.07491892432786}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins map is not initialized\")\n\t}\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\tparams := a.translate(id)\n\tif params == nil {\n\t\treturn nil, errors.New(\"Analog pin with id '\" + id + \"' not found\")\n\t}\n\tpin = gobot.NewAnalogPin(params[\"pin\"])\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 53.70272872090217}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"AnalogPins map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.initAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.52087167308242}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins map not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpin, err := a.initPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.42902005048212}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id, PinOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpin.Write(val)\n\treturn nil\n}", "CodeBleu_score": 65.95594825653028}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, gobot.DigitalOutput)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}", "CodeBleu_score": 66.80748793235074}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.digitalPins == nil {\n\t\treturn errors.New(\"DigitalPinsAdaptor: Digital pins have not been initialized\")\n\t}\n\n\tpin, err := a.digitalPins.GetDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\n\treturn nil\n}", "CodeBleu_score": 58.728855760728685}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.digitalPins == nil {\n\t\ta.digitalPins = make(map[int]gobot.DigitalPin)\n\t}\n\n\tif _, ok := a.digitalPins[id]; !ok {\n\t\tpin, err := a.connectDigitalPin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.digitalPins[id] = pin\n\t}\n\n\tpin, _ := a.digitalPins[id]\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 36.85523881436373}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connect() == false {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\tpin, err := a.pin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\tif pin.DigitalPin == nil {\n\t\tpin.DigitalPin = &gobot.DigitalPin{\n\t\t\tID:        id,\n\t\t\tName:      id,\n\t\t\tConnector: a,\n\t\t\tDigitalRead: func() (int, error) {\n\t\t\t\treturn pin.read()\n\t\t\t},\n\t\t\tPwmWrite: func(duty int) error {\n\t\t\t\treturn pin.write(duty)\n\t\t\t},\n\t\t}\n\t\tpin.DigitalPin.Set(pin.State)\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.DigitalPin.Set(pin.State)\n\t}\n\n\treturn pin.DigitalPin, nil\n}", "CodeBleu_score": 47.70422258211211}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connection == nil {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor is not connected\")\n\t}\n\n\tpin, err := a.Connection().DigitalPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif pin == nil {\n\t\tchip, line, err := a.parsePinID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = &gobot.Pin{\n\t\t\tName: id,\n\t\t\tID:   id,\n\t\t\tDigitalPin: &gobot.DigitalPin{\n\t\t\t\tDriver:   a,\n\t\t\t\tChip:     chip,\n\t\t\t\tLine:     line,\n\t\t\t\tMode:     gobot.UNKNOWN,\n\t\t\t\tInterval: a.interval,\n\t\t\t},\n\t\t}\n\n\t\tif err := a.initDigitalPin(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 59.44193182286506}]}
