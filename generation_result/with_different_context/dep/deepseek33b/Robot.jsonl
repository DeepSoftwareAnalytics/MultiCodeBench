{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Get the list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n        for (const auto &file : files) {\n            // Check if the file exists locally\n            if (!FileTransfer::FileExists(file)) {\n                // If the file does not exist, request the file from the server\n                RequestFile(file);\n                // Log the download action\n                spdlog::info(\"Downloaded {}\", file);\n            } else {\n                // If the file exists, log that the file is found in the cache\n                spdlog::info(\"Found {} in cache\", file);\n            }\n        }\n    }\n\n    // Return the list of required files\n    return files;\n}", "CodeBleu_score": 66.2077042345617}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Get a list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if each file exists locally\n    for (auto &file : files) {\n        // Construct the path to the file\n        std::string path = folder + \"/\" + file;\n\n        // Check if the file exists\n        if (!FileTransfer::FileExists(path)) {\n            // If the file does not exist, request it from the server\n            if (download) {\n                RequestFile(path);\n                std::cout << \"Downloaded \" << path << std::endl;\n            } else {\n                // If the file does not exist and the download flag is not set, log an error\n                std::cerr << \"File \" << path << \" not found in cache\" << std::endl;\n            }\n        } else {\n            // If the file exists, log that it was found in the cache\n            std::cout << \"Found \" << path << \" in cache\" << std::endl;\n        }\n    }\n\n    // Return the list of required files\n    return files;\n}", "CodeBleu_score": 53.688276710399684}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t    // Retrieve the list of required files from the server\n    auto requiredFiles = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // Check if each file exists locally\n    for (const auto &file : requiredFiles) {\n        // If the file is not found, request it and log the download action\n        if (!FileTransfer::FileExists(file)) {\n            RequestFile(file);\n            std::cout << \"Downloaded file: \" << file << std::endl;\n        }\n        // If the file exists, log that it is found in the cache\n        else {\n            std::cout << \"Found file in cache: \" << file << std::endl;\n        }\n    }\n\n    // Return the list of required files\n    return requiredFiles;\n}", "CodeBleu_score": 61.54820578502349}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f && transform.location.z != 0.0f) {\n      GetDisplay()->ShowWarning(\"Attaching an actor to a SpringArm or SpringArmGhost with a translation only in the 'z' axis is not supported. Use a rotation instead.\");\n    }\n  }\n  rpc::Actor actor = SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n  return actor;\n}", "CodeBleu_score": 45.46748524803572}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f &&\n        transform.location.z != 0.0f) {\n      // Issue a warning if the translation is only in the 'z' axis\n      utils::log_warning(\"SpringArm attachment type with only translation in the 'z' axis is ill-formed. \"\n                         \"Use the attachment type SpringArmGhost for this case.\");\n    }\n  }\n\n  // Call an internal function to complete the actor spawning process\n  return SpawnActorWithParentImpl(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 43.70832133435454}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0 &&\n        transform.location.y == 0.0 &&\n        transform.location.z != 0.0 &&\n        transform.rotation.pitch == 0.0 &&\n        transform.rotation.yaw == 0.0 &&\n        transform.rotation.roll == 0.0) {\n      GetEpisode().GetInstance().GetLogger()->warn(\n          \"Actor with SpringArm or SpringArmGhost attachment \"\n          \"type should not have zero translation in the 'z' axis. \"\n          \"Use the attachment type 'Rigid' instead.\");\n    }\n  }\n\n  rpc::Actor actor = SpawnActor(description, transform);\n\n  if (parent != 0) {\n    AttachActor(actor.id, parent, attachment_type, socket_name);\n  }\n\n  return actor;\n}", "CodeBleu_score": 47.51704113246296}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t   // Retrieve the token for the G-buffer\n   rpc::Token token = GetGBufferToken(ActorId, GBufferId);\n\n   // Copy the token data\n   rpc::Token token_copy = token;\n\n   // Subscribe to the streaming client using the provided callback function\n   streaming_client_.Subscribe(token_copy, callback);\n}", "CodeBleu_score": 33.89492469680098}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t   auto token = GetGBufferToken(ActorId, GBufferId);\n   auto tokenData = token.GetData();\n   streamingClient.Subscribe(\n         tokenData.c_str(),\n         tokenData.size(),\n         [callback](const std::vector<uint8_t>& data) {\n            Buffer buffer;\n            buffer.data = data;\n            callback(buffer);\n         });\n}", "CodeBleu_score": 44.91864246570304}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t  \n  // Retrieve the token for the G-buffer\n  auto token = m_GbufferTokens[ActorId][GBufferId];\n\n  // Copy the token data\n  auto tokenData = token.GetData();\n\n  // Subscribe to the streaming client using the provided callback function\n  m_StreamingClient.SubscribeToStream(\n      tokenData,\n      [callback](Buffer buffer) {\n        // Call the provided callback function with the received buffer\n        callback(buffer);\n      });\n}", "CodeBleu_score": 40.732493886513595}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    if (!navigation) {\n        navigation = std::make_shared<WalkerNavigation>();\n        if (!navigation->Set(this)) {\n            navigation = nullptr;\n        }\n    }\n    return navigation;\n}", "CodeBleu_score": 35.2980149831927}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t    if (navigation_ == nullptr) {\n        navigation_ = std::make_shared<WalkerNavigation>();\n        navigation_->SetWalker(walker_);\n    }\n    return navigation_;\n}", "CodeBleu_score": 35.08399118132917}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t  if (navigation_ == nullptr) {\n    auto navigation = std::make_shared<WalkerNavigation>();\n    if (navigation->SetEpisode(shared_from_this())) {\n      navigation_ = navigation;\n    }\n  }\n  return navigation_;\n}", "CodeBleu_score": 41.894520984865544}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const uint64_t timeout_ticks = timeout.total_milliseconds() / SECOND_MILLIS;\n  for (uint64_t i = 0; i < timeout_ticks; ++i) {\n    if (episode.GetFrame() < frame) {\n      TrafficManager::GetInstance()->Tick();\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 28.444597320320497}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  const uint64_t timeout_ticks = timeout.total_milliseconds() / TIME_TO_SYNCHRONIZE_FRAME;\n  uint64_t ticks = 0u;\n  while (episode.GetFrame() < frame) {\n    if (++ticks > timeout_ticks) {\n      return false;\n    }\n    std::this_thread::sleep_for(TIME_TO_SYNCHRONIZE_FRAME);\n  }\n  TrafficManager::GetInstance()->TriggerTick();\n  return true;\n}", "CodeBleu_score": 34.61048286655677}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t  constexpr time_duration sleep_time(0, 0, 0, 1000);\n  const auto start_time = std::chrono::system_clock::now();\n  while (episode.GetFrame() < frame) {\n    std::this_thread::sleep_for(sleep_time);\n    if (std::chrono::system_clock::now() - start_time > timeout) {\n      return false;\n    }\n  }\n  TrafficManager::Instance()->TriggerTick();\n  return true;\n}", "CodeBleu_score": 42.50617919219907}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    std::string episode_id = GetEpisodeId();\n    // Load new episode\n    std::string new_episode_id = GetNewEpisodeId();\n    if (episode_id == new_episode_id) {\n        throw std::runtime_error(\"Failed to load new episode\");\n    }\n    // Wait for episode to load\n    int attempts = 0;\n    while (episode_id == GetEpisodeId()) {\n        if (attempts > kMaxAttempts) {\n            throw std::runtime_error(\"Failed to connect to new episode\");\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(kWaitTime));\n        attempts++;\n    }\n    return GetCurrentEpisode();\n}", "CodeBleu_score": 33.038303207761594}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    GetReadyCurrentEpisode();\n    std::string episode_id = GetCurrentEpisode().GetId();\n    std::string episode_id_new;\n    int attempt = 0;\n    while (attempt < _timeout) {\n      if (attempt > 0) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n      }\n      episode_id_new = _client.LoadEpisode(map_name, reset_settings, map_layers).GetId();\n      if (episode_id_new != episode_id) {\n        break;\n      }\n      attempt += 1;\n    }\n    if (episode_id_new != episode_id) {\n      return GetCurrentEpisode();\n    } else {\n      throw std::runtime_error(\"Unable to load episode\");\n    }\n  }", "CodeBleu_score": 44.76040724595079}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t    std::string map_name_ = map_name;\n    bool reset_settings_ = reset_settings;\n    rpc::MapLayer map_layers_ = map_layers;\n    if (map_name_.empty()) {\n        map_name_ = \"Town02\";\n    }\n    if (!reset_settings_) {\n        reset_settings_ = true;\n    }\n    if (map_layers_ == rpc::MapLayer::NONE) {\n        map_layers_ = rpc::MapLayer::NORMAL_AND_MASKS;\n    }\n    GetReadyCurrentEpisode();\n    std::string command = \"simulator/command/load_new_episode\";\n    nlohmann::json command_json;\n    command_json[\"map_name\"] = map_name_;\n    command_json[\"reset_settings\"] = reset_settings_;\n    command_json[\"map_layers\"] = map_layers_;\n    auto response = Call(command, command_json);\n    if (!response.empty()) {\n        if (response.find(\"episode_id\") != response.end()) {\n            auto episode_id = response[\"episode_id\"];\n            if (episode_id != episode_id_) {\n                episode_id_ = episode_id;\n                auto timeout = 5.0;\n                auto start_time = std::chrono::system_clock::now();\n                while (episode_id_ != episode_id) {\n                    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n                    auto current_time = std::chrono::system_clock::now();\n                    auto elapsed_time = std::chrono::duration<double>(current_time - start_time).count();\n                    if (elapsed_time >= timeout) {\n                        throw std::runtime_error(\"Failed to connect to new episode\");\n                    }\n                }\n            }\n            return EpisodeProxy{shared_from_this()};\n        }\n    }\n    throw std::runtime_error(\"Failed to load new episode\");\n  }", "CodeBleu_score": 41.95196322547851}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t  auto walker = GetWalkerByID(controller.GetID());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetID()) + \" not found.\");\n  }\n  assert(episode != nullptr);\n  if (walker->navigation == nullptr) {\n    walker->navigation = std::make_shared<WalkerNavigation>();\n  }\n  walker->navigation->Register(controller.GetID());\n}", "CodeBleu_score": 53.11859104593933}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    auto walker = GetWalkerByID(controller.GetID());\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker not found\");\n    }\n    assert(episode != nullptr);\n    if (walker->GetNavigation() == nullptr) {\n        walker->SetNavigation(std::make_shared<Navigation>(walker));\n    }\n    walker->GetNavigation()->RegisterAIController(controller);\n}", "CodeBleu_score": 52.88527743906363}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t    const auto &walker = GetWalker(controller.GetID());\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker not found\");\n    }\n\n    assert(episode != nullptr);\n    if (walker->GetNavigation() == nullptr) {\n        walker->SetNavigation(std::make_shared<WalkerAIController::Navigation>(walker->GetTransform()));\n    }\n\n    walker->GetNavigation()->RegisterController(controller);\n}", "CodeBleu_score": 47.47914965732534}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Get the current episode.\n    auto episode = GetCurrentEpisode();\n\n    // Spawn the actor.\n    auto actor = episode.SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n\n    // Apply garbage collection policy.\n    if (gc == GarbageCollectionPolicy::Exclude) {\n      episode.AddActor(actor);\n    }\n\n    // Log the creation details.\n    auto actor_id = actor->GetId();\n    log_debug(\n        \"Actor created: id =\", actor_id,\n        \", blueprint =\", blueprint.GetId(),\n        \", transform =\", transform,\n        \", parent =\", parent ? parent->GetId() : 0,\n        \", attachment type =\", static_cast<int>(attachment_type),\n        \", socket name =\", socket_name,\n        \", garbage collection policy =\", static_cast<int>(gc));\n\n    // Return the actor.\n    return actor;\n  }", "CodeBleu_score": 50.39534511392009}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    // Create the actor.\n    auto actor = std::make_shared<Actor>(\n        blueprint,\n        transform,\n        parent,\n        attachment_type,\n        gc,\n        socket_name);\n\n    // Register the actor in the current episode.\n    auto episode = GetCurrentEpisode();\n    episode->RegisterActor(actor);\n\n    // Apply the garbage collection policy.\n    switch (gc) {\n      case GarbageCollectionPolicy::EXTERNAL:\n        // The actor is managed externally, so we don't need to do anything.\n        break;\n      case GarbageCollectionPolicy::EPISODE:\n        // The actor belongs to the episode, so we add it to the episode's garbage collection list.\n        episode->AddActorToGarbageCollection(actor);\n        break;\n      case GarbageCollectionPolicy::SCENARIO:\n        // The actor belongs to the scenario, so we add it to the scenario's garbage collection list.\n        episode->GetScenario()->AddActorToGarbageCollection(actor);\n        break;\n      default:\n        // Unknown garbage collection policy.\n        throw std::runtime_error(\"Unknown garbage collection policy\");\n    }\n\n    // Log the creation details.\n    log_debug(\n        \"Actor created: id =\",\n        actor->GetId(),\n        \", blueprint =\",\n        blueprint.GetId(),\n        \", transform =\",\n        transform,\n        \", parent =\",\n        (parent ? parent->GetId() : \"None\"),\n        \", attachment type =\",\n        static_cast<int>(attachment_type),\n        \", socket name =\",\n        socket_name);\n\n    return actor;\n  }", "CodeBleu_score": 42.62658550440882}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t    auto actor = std::make_shared<Actor>(\n        blueprint,\n        transform,\n        parent,\n        attachment_type,\n        gc,\n        socket_name);\n    _current_episode->RegisterActor(actor);\n    return actor;\n  }", "CodeBleu_score": 24.630360360024735}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (!_episode.IsValid()) {\n    throw std::runtime_error(\"The episode is not valid\");\n  }\n  _client.SubscribeToStream(\n      sensor.GetToken(),\n      [this, callback](Buffer buffer) {\n        auto sensor_data = buffer.Deserialize<sensor::SensorData>();\n        sensor_data->SetEpisodeId(_episode.GetId());\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 45.405365725911196}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (episode == nullptr) {\n    throw std::runtime_error(\"Attempting to subscribe to sensor without an active episode\");\n  }\n\n  client->SubscribeToStream(\n      sensor.GetToken(),\n      [this, callback](Buffer buffer) {\n        auto sensor_data = buffer.Deserialize<SensorData>();\n        sensor_data->episode_id = episode->GetId();\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 44.78664791915977}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t  if (Episode == nullptr) {\n    throw std::runtime_error(\"The episode is not initialized!\");\n  }\n\n  Client.SubscribeToStream(\n      sensor.GetStreamName(),\n      [this, callback](Buffer buffer) {\n        SharedPtr<sensor::SensorData> sensor_data = DeserializeSensorData(buffer);\n        sensor_data->SetEpisodeId(Episode->GetId());\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 43.8764903894353}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // load the current walkers\n    std::vector<WalkerHandle> walkers = GetCurrentWalkers();\n\n    // check if the list is empty\n    if (walkers.empty()) return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove walkers that no longer exist\n    RemoveWalkersThatNoLongerExist(walkers, *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd\n    UpdateCrowd(walkers, *state);\n\n    // apply states in a batch\n    ApplyBatchStateToSimulator(walkers, *state);\n\n    // check if any walker has been killed\n    CheckIfAnyWalkerHasBeenKilled(walkers, *state);\n  }", "CodeBleu_score": 23.829245374102175}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t    // load current walkers\n    std::vector<WalkerHandle> walkers = GetCurrentWalkers();\n\n    // check if empty\n    if (walkers.empty()) return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove walkers that no longer exist\n    RemoveIfWalkerDoesNotExist(walkers, state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update crowd\n    _nav.UpdateCrowd();\n\n    // get the transform and speed of each walker\n    for (auto &&walker : walkers) {\n      // get the transform\n      carla::geom::Transform transform = state->GetActorSnapshot(walker.walker).transform;\n      // get the speed\n      carla::geom::Vector3D speed = state->GetActorSnapshot(walker.walker).velocity;\n      // apply the states in a batch\n      _simulator.lock()->SetTransform(walker.walker, transform);\n      _simulator.lock()->SetVelocity(walker.walker, speed);\n    }\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      // check if the walker is dead\n      if (state->GetActorSnapshot(walker.walker).is_alive == false) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 46.375945560510054}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n    // load the current walkers\n    std::vector<WalkerHandle> walkers = GetCurrentWalkers();\n\n    // check if the list is empty\n    if (walkers.empty()) return;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove any walkers that no longer exist\n    for (auto &&walker : walkers) {\n      if (!state->ContainsActorSnapshot(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd itself\n    _nav.UpdateCrowd();\n\n    // apply states in batch\n    for (auto &&walker : walkers) {\n      // get the transform and speed\n      const ActorSnapshot &snapshot = state->GetActorSnapshot(walker.walker);\n      const carla::geom::Transform &transform = snapshot.transform;\n      const float speed = snapshot.velocity.Length();\n      // apply to the simulator\n      _simulator.lock()->SetActorTransform(walker.controller, transform);\n      _simulator.lock()->SetActorTargetVelocity(walker.controller, speed);\n    }\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      if (IsWalkerDead(walker.walker)) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n\n  }", "CodeBleu_score": 53.227550981348095}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = UID;\n    description.id = ID;\n    description.attributes.reserve(Attributes.size());\n    for (const auto& attribute : Attributes) {\n        description.attributes.push_back(attribute.second);\n    }\n    return description;\n}", "CodeBleu_score": 72.25400282480558}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = m_uid;\n    description.id = m_id;\n    description.attributes.reserve(m_attributes.size());\n    for (const auto& attribute : m_attributes) {\n        description.attributes.push_back(attribute.second);\n    }\n    return description;\n}", "CodeBleu_score": 72.42809165037585}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t    rpc::ActorDescription description;\n    description.uid = m_uid;\n    description.id = m_id;\n    description.attributes.reserve(m_attributes.size());\n    for (auto& attribute : m_attributes) {\n        description.attributes.push_back(attribute);\n    }\n    return description;\n}", "CodeBleu_score": 77.8827058850936}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto& blueprint : blueprints_) {\n    if (blueprint->HasAttribute(name)) {\n      if (blueprint->GetAttribute(name).value == value ||\n          blueprint->GetAttribute(name).recommendedValues.find(value) !=\n              blueprint->GetAttribute(name).recommendedValues.end()) {\n        result->AddBlueprint(blueprint);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 38.485249328785414}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t   SharedPtr<BlueprintLibrary> result = std::make_shared<BlueprintLibrary>();\n\n   for (const auto& blueprint : blueprints_) {\n      if (blueprint.second->HasAttribute(name)) {\n         const auto& attribute = blueprint.second->GetAttribute(name);\n         if (attribute.HasValue() && attribute.GetValue() == value) {\n            result->AddBlueprint(blueprint.second);\n         } else if (attribute.HasRecommendedValues() &&\n                    std::find(attribute.GetRecommendedValues().begin(),\n                               attribute.GetRecommendedValues().end(),\n                               value) != attribute.GetRecommendedValues().end()) {\n            result->AddBlueprint(blueprint.second);\n         }\n      }\n   }\n\n   return result;\n}", "CodeBleu_score": 49.50948843875595}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t  auto result = std::make_shared<BlueprintLibrary>();\n  for (auto& blueprint : blueprints_) {\n    if (blueprint.second->HasAttribute(name)) {\n      if (blueprint.second->GetAttribute(name).value == value ||\n          blueprint.second->GetAttribute(name).recommendedValues.count(value)) {\n        result->AddBlueprint(blueprint.second);\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 36.34741936448271}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    // Construct the full file path using the base folder and version information\n    std::string fullPath = baseFolder + \"/\" + path + \"_\" + std::to_string(version);\n\n    // Validate the file path\n    if (fullPath.find(\"..\") != std::string::npos) {\n        std::cerr << \"Invalid file path: \" << fullPath << std::endl;\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\n    // Check if the file is successfully opened\n    if (file.is_open()) {\n        // Write the content to the file\n        file.write(reinterpret_cast<char*>(content.data()), content.size());\n\n        // Close the file\n        file.close();\n\n        return true;\n    } else {\n        std::cerr << \"Failed to open file: \" << fullPath << std::endl;\n        return false;\n    }\n}", "CodeBleu_score": 45.33584602592732}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    std::string fullPath = baseFolder + \"/\" + path + \"_\" + std::to_string(version);\n    if (!ValidateFilePath(fullPath)) {\n        return false;\n    }\n\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n        file.write(reinterpret_cast<char*>(content.data()), content.size());\n        file.close();\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 46.25401319376091}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t    // Construct the full file path using the base folder and version information\n    std::string fullPath = baseFolder + \"/\" + path + \".\" + std::to_string(version);\n\n    // Validate the file path to prevent directory traversal attacks\n    if (fullPath.find(\"..\") != std::string::npos) {\n        return false;\n    }\n\n    // Open the file in binary mode to truncate its contents\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n        // Write the content to the file\n        file.write(reinterpret_cast<const char*>(content.data()), content.size());\n        file.close();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 44.96731870549524}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const geom::Location location = transform.location + parent_bounds->location;\n    const geom::Rotation rotation = transform.rotation * parent_bounds->rotation;\n    const float yaw = rotation.yaw;\n    const auto &extent = parent_bounds->extent;\n    const geom::Location front = Rotate(yaw, {extent.x, extent.y, 0.0f});\n    const geom::Location back = Rotate(yaw, {-extent.x, -extent.y, 0.0f});\n    const geom::Location corners[4] = {\n        location + front,\n        location + back,\n        location + geom::Location{front.x, back.y, 0.0f},\n        location + geom::Location{back.x, front.y, 0.0f},\n    };\n    return std::make_shared<const Bounds>(frame, corners);\n  }", "CodeBleu_score": 47.265256498251404}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t    const auto location = transform.location + parent_bounds.location;\n    const auto extents = parent_bounds.extents;\n    const auto yaw = transform.rotation.yaw;\n    const auto corners = {\n        Rotate(yaw, {extents.x, extents.y, 0.0f}),\n        Rotate(yaw, {extents.x, -extents.y, 0.0f}),\n        Rotate(yaw, {-extents.x, -extents.y, 0.0f}),\n        Rotate(yaw, {-extents.x, extents.y, 0.0f})};\n    return std::make_shared<Bounds>(frame, location, corners);\n  }", "CodeBleu_score": 52.68881795505056}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t\n    geom::Location location = transform.location + parent_bounds->location;\n    const float yaw = transform.rotation.yaw;\n\n    const geom::Location front = Rotate(yaw, geom::Location(parent_bounds->extent.x, parent_bounds->extent.y, 0.0f));\n    const geom::Location rear = Rotate(yaw, geom::Location(-parent_bounds->extent.x, -parent_bounds->extent.y, 0.0f));\n\n    const geom::Location corners[4] = {\n      front + location,\n      rear + location,\n      Rotate(yaw, geom::Location(front.x, -parent_bounds->extent.y, 0.0f)) + location,\n      Rotate(yaw, geom::Location(rear.x, parent_bounds->extent.y, 0.0f)) + location\n    };\n\n    return std::make_shared<const Bounds>(frame, corners);\n  }", "CodeBleu_score": 55.89497890179496}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    // Query the current state of lights from the server\n    std::vector<Light> light_states = _server->GetLightStates();\n\n    // Update the local light states\n    for (const auto& light : light_states) {\n        auto it = _lights.find(light.GetId());\n        if (it != _lights.end()) {\n            it->second.UpdateState(light);\n        } else {\n            _lights.emplace(light.GetId(), light);\n        }\n    }\n}", "CodeBleu_score": 34.648241340791685}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    std::vector<LightState> light_states = _server->GetLightStates();\n    for (const LightState& light_state : light_states) {\n        if (_lights.count(light_state.id) == 0) {\n            _lights[light_state.id] = std::make_shared<Light>(light_state.id, light_state.name);\n        }\n        _lights[light_state.id]->UpdateState(light_state);\n    }\n}", "CodeBleu_score": 33.68952807719356}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t    std::lock_guard<std::mutex> lock(_mutex);\n    std::vector<LightState> lightStates = _server->GetLightStates();\n    for (const LightState& lightState : lightStates) {\n        if (_lights.find(lightState.id) == _lights.end()) {\n            _lights[lightState.id] = std::make_shared<Light>(lightState.id, lightState.state, lightState.color, lightState.brightness);\n        } else {\n            _lights[lightState.id]->SetState(lightState.state);\n            _lights[lightState.id]->SetColor(lightState.color);\n            _lights[lightState.id]->SetBrightness(lightState.brightness);\n        }\n    }\n}", "CodeBleu_score": 36.89254555155612}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t  std::lock_guard<std::mutex> lock(mutex_);\n  if (dirty_) {\n    auto msg = std::make_shared<Message>();\n    msg->set_type(MessageType::LIGHT_STATE);\n    for (const auto& light : lights_) {\n      auto light_state = msg->add_light_state();\n      light_state->set_name(light.first);\n      light_state->set_on(light.second.on);\n      light_state->set_brightness(light.second.brightness);\n      light_state->set_color(light.second.color);\n    }\n    msg->set_discard_client(discard_client);\n    client_->SendMessage(msg);\n    dirty_ = false;\n  }\n}", "CodeBleu_score": 42.38161722252579}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(m_mutex);\n    if (m_dirty) {\n        std::vector<LightState> light_states;\n        for (auto& light : m_lights) {\n            light_states.push_back(light.second.GetState());\n        }\n        Message message;\n        message.type = MessageType::LightState;\n        message.data = light_states;\n        if (!discard_client) {\n            m_client->SendMessage(message);\n        }\n        m_server->SendMessage(message);\n        m_changes.clear();\n        m_dirty = false;\n    }\n}", "CodeBleu_score": 43.69446566990482}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t    std::lock_guard<std::mutex> lock(lights_mutex_);\n    if (dirty_ || discard_client) {\n        std::string message;\n        for (auto& light : lights_) {\n            message += std::to_string(light.second.id) + \",\" + std::to_string(light.second.state) + \";\";\n        }\n        message.pop_back(); // Remove the last semicolon\n        std::cout << \"Sending message: \" << message << std::endl;\n        // Send the message to the server\n        // ...\n        dirty_ = false;\n    }\n}", "CodeBleu_score": 36.16434253193287}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    CARLA_LOG_WARNING(\"ServerSideSensor::Send: sensor.other.v2x_custom is not set!\");\n    return;\n  }\n  GetEpisode().Lock()->Send(std::move(message), GetContext());\n}", "CodeBleu_score": 54.522258373093266}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    CARLA_LOG_WARNING(\"Sending message from {} sensor. This sensor is not implemented yet.\", GetId());\n    return;\n  }\n\n  GetEpisode().Lock()->Send(std::move(message));\n}", "CodeBleu_score": 53.54659190957861}, {"code": "void ServerSideSensor::Send(std::string message){\n\t  if (GetId() != \"sensor.other.v2x_custom\") {\n    CARLA_LOG_WARNING(\"ServerSideSensor::Send: sensor.other.v2x_custom is not the ID of the sensor\");\n    return;\n  }\n\n  carla::client::detail::EpisodeProxy episode = GetEpisode();\n  episode.Lock()->SendV2XMessage(std::move(message), GetContext());\n}", "CodeBleu_score": 53.646005367903285}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        // Register the vehicle with the traffic manager\n        TrafficManager::RegisterVehicle(this, tm_port);\n    } else {\n        // Unregister the vehicle from the traffic manager\n        TrafficManager::UnregisterVehicle(this);\n    }\n}", "CodeBleu_score": 36.18387689241621}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        // Register the vehicle with the traffic manager\n        traffic_manager_->RegisterVehicle(this, tm_port);\n    } else {\n        // Unregister the vehicle from the traffic manager\n        traffic_manager_->UnregisterVehicle(this, tm_port);\n    }\n}", "CodeBleu_score": 49.08698539340462}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t    if (enabled) {\n        this->autopilot_enabled = true;\n        this->tm_port = tm_port;\n        this->tm_socket.connect(this->tm_port);\n    } else {\n        this->autopilot_enabled = false;\n        this->tm_socket.close();\n    }\n}", "CodeBleu_score": 35.416272728196944}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t    Super::Start();\n    auto* Walker = Cast<AWalker>(GetPawn());\n    if (Walker) {\n        auto* NavSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n        if (NavSystem) {\n            NavSystem->RegisterComponentWithNavigation(*Walker->GetRootComponent());\n        }\n    }\n    Walker->DisablePhysics();\n    Walker->GetMesh()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 41.14416194918979}, {"code": "void WalkerAIController::Start(){\n\t    Super::Start();\n    if (GEngine) {\n        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Green, TEXT(\"WalkerAIController::Start\"));\n    }\n    UWorld* World = GetWorld();\n    if (World) {\n        APawn* Pawn = World->GetFirstPlayerController()->GetPawn();\n        if (Pawn) {\n            AActor* Actor = Cast<AActor>(Pawn);\n            if (Actor) {\n                UNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(World);\n                if (NavSys) {\n                    NavSys->RegisterActorWithNavigation(Actor, FPathFollowingRequestResult::AlreadyAtGoal, *FNavAgentProperties());\n                }\n            }\n        }\n    }\n    UWorld* World = GetWorld();\n    if (World) {\n        APawn* Pawn = World->GetFirstPlayerController()->GetPawn();\n        if (Pawn) {\n            AActor* Actor = Cast<AActor>(Pawn);\n            if (Actor) {\n                AActor* Actor = Cast<AActor>(Pawn);\n                if (Actor) {\n                    UPrimitiveComponent* PrimitiveComponent = Actor->GetRootComponent();\n                    if (PrimitiveComponent) {\n                        PrimitiveComponent->SetSimulatePhysics(false);\n                        PrimitiveComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 27.530061947877492}, {"code": "void WalkerAIController::Start(){\n\t    Super::Start();\n\n    // Register the AI controller with the episode\n    UWorld* World = GetWorld();\n    if (World) {\n        AEpisode01GameModeBase* GameMode = Cast<AEpisode01GameModeBase>(World->GetAuthGameMode());\n        if (GameMode) {\n            GameMode->RegisterAIController(this);\n        }\n    }\n\n    // Get the walker actor and add it to the navigation system\n    ACharacter* Walker = Cast<ACharacter>(GetPawn());\n    if (Walker) {\n        FVector WalkerLocation = Walker->GetActorLocation();\n        UNavigationSystemV1* NavSystem = UNavigationSystemV1::GetCurrent(World);\n        if (NavSystem) {\n            NavSystem->RegisterComponentWithNavigation(*Walker->GetRootComponent(), FPathFollowingRequest(*Walker, *Walker, EPathFollowingRequestResult::RequestSuccessful));\n            NavSystem->SimpleMoveToLocation(Walker->GetController(), WalkerLocation);\n        }\n    }\n\n    // Disable physics simulation and collisions for the walker actor\n    Walker->GetMesh()->SetSimulatePhysics(false);\n    Walker->GetMesh()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}", "CodeBleu_score": 34.66167024937888}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (GetEpisode().GetNavigationSystem() == nullptr) {\n    return;\n  }\n\n  auto* walker = GetParentWalker();\n  if (walker == nullptr) {\n    return;\n  }\n\n  if (!GetEpisode().GetNavigationSystem()->SetMaxSpeed(*walker, max_speed)) {\n    UE_LOG(\n        LogCarla,\n        Warning,\n        TEXT(\"WalkerAIController: failed to set max speed to %f\"),\n        max_speed);\n  } else {\n    UE_LOG(\n        LogCarla,\n        Log,\n        TEXT(\"WalkerAIController: max speed set to %f\"),\n        max_speed);\n  }\n}", "CodeBleu_score": 53.01662665063424}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  auto navigation = GetEpisode().Lock()->GetNavigationSystem();\n  if (!navigation) {\n    return;\n  }\n\n  auto parent_walker = boost::static_pointer_cast<cc::Walker>(GetPawn());\n  if (!parent_walker) {\n    return;\n  }\n\n  if (!navigation->SetMaxSpeed(parent_walker, max_speed)) {\n    GetEpisode().Lock()->GetLogger()->LogWarning(\n      \"WalkerAIController::SetMaxSpeed: Failed to set max speed\");\n    return;\n  }\n}", "CodeBleu_score": 50.78556221536876}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t  if (nav_instance_ == nullptr) {\n    nav_instance_ = episode_.Lock()->GetNavigationInstance();\n  }\n  if (nav_instance_ != nullptr) {\n    auto walker = nav_instance_->GetWalker();\n    if (walker != nullptr) {\n      walker->SetMaxSpeed(max_speed);\n    } else {\n      log_warning(\"Walker is not found\");\n    }\n  } else {\n    log_warning(\"Navigation instance is not found\");\n  }\n}", "CodeBleu_score": 60.51175040423933}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n\n    for (auto waypoint : _parent->GetWaypoints()) {\n        if (Distance(waypoint) < distance && ((unsigned int)waypoint->GetLaneId() == _laneId || _laneId == 0)) {\n            result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 50.78038211468825}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<Waypoint*> waypoints = map->GetPrevious(this, distance);\n    for (auto waypoint : waypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n    }\n    return result;\n}", "CodeBleu_score": 54.81921042647251}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<Waypoint*> prevWaypoints = parentMap->GetPrevious(this, distance);\n    for (Waypoint* waypoint : prevWaypoints) {\n        SharedPtr<Waypoint> newWaypoint = std::make_shared<Waypoint>(waypoint->GetTransform(), waypoint->GetParentMap());\n        result.push_back(newWaypoint);\n    }\n    return result;\n}", "CodeBleu_score": 57.434788544883084}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::vector<SharedPtr<Signal>> unique_signals;\n\n  for (auto signal : signals) {\n    bool found = false;\n    for (auto unique_signal : unique_signals) {\n      if (signal->GetId() == unique_signal->GetId()) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      unique_signals.push_back(signal);\n    }\n  }\n\n  for (auto signal : unique_signals) {\n    SharedPtr<Waypoint> landmark_waypoint = signal->GetWaypoint();\n    SharedPtr<Landmark> landmark =\n        boost::static_pointer_cast<Landmark>(landmark_waypoint);\n    result.push_back(landmark);\n  }\n\n  return result;\n}", "CodeBleu_score": 49.75341124803121}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n  std::unordered_set<SharedPtr<Signal>> signals;\n\n  // Retrieve all signals within the specified distance\n  GetSignalsInDistance(distance, stop_at_junction, signals);\n\n  // Iterate through the signals and create Waypoint and Landmark objects\n  for (auto signal : signals) {\n    // Check if the signal is already in the result (to avoid duplicates)\n    bool is_in_result = false;\n    for (auto landmark : result) {\n      if (landmark->GetSignal()->GetId() == signal->GetId()) {\n        is_in_result = true;\n        break;\n      }\n    }\n\n    // If the signal is not in the result, create a new Waypoint and Landmark\n    if (!is_in_result) {\n      SharedPtr<Waypoint> wp =\n          std::make_shared<Waypoint>(signal->GetWaypoint()->GetTransform());\n      SharedPtr<Landmark> landmark = std::make_shared<Landmark>(wp, signal);\n      result.push_back(landmark);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 51.6596430793897}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t  std::vector<SharedPtr<Landmark>> result;\n\n  std::vector<SharedPtr<Signal>> signals =\n      GetSignalsInDistance(distance, stop_at_junction);\n\n  std::unordered_set<SharedPtr<Signal>> unique_signals;\n  for (auto &signal : signals) {\n    if (unique_signals.insert(signal).second) {\n      SharedPtr<Waypoint> wp =\n          std::make_shared<Waypoint>(signal->GetWaypoint());\n      SharedPtr<Landmark> lm = std::make_shared<Landmark>(wp, signal);\n      result.push_back(lm);\n    }\n  }\n\n  return result;\n}", "CodeBleu_score": 47.45827525556727}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n\n    _episode.Lock()->ApplySettings(settings, local_timeout);\n\n    if (settings.has_fixed_delta_seconds()) {\n      constexpr int max_attempts = 5;\n      const float delta_seconds = settings.fixed_delta_seconds();\n      constexpr float epsilon = 0.0001f;\n      constexpr float threshold = 0.001f;\n      for (int attempt = 0; attempt < max_attempts; ++attempt) {\n        _episode.Lock()->Tick(local_timeout);\n        const auto world_snapshot = _episode.Lock()->GetWorldSnapshot();\n        const float delta = world_snapshot.GetTimestamp().delta_seconds;\n        if (std::abs(delta - delta_seconds) < epsilon) {\n          break;\n        }\n        if (std::abs(delta - delta_seconds) < threshold) {\n          _episode.Lock()->LogInfo(\n              \"Fixed delta time is not accurate. \"\n              \"Desired: \" + std::to_string(delta_seconds) +\n              \" seconds. \"\n              \"Applied: \" + std::to_string(delta) + \" seconds.\");\n          break;\n        }\n        _episode.Lock()->LogWarning(\n            \"Fixed delta time is not accurate. \"\n            \"Desired: \" + std::to_string(delta_seconds) +\n            \" seconds. \"\n            \"Applied: \" + std::to_string(delta) + \" seconds.\");\n      }\n    }\n\n    return settings.id();\n  }", "CodeBleu_score": 50.334222989446545}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n\n    uint64_t settings_id = _episode.Lock()->ApplyEpisodeSettings(settings);\n\n    if (settings.has_fixed_delta_seconds()) {\n      constexpr uint32_t max_attempts = 10;\n      constexpr double threshold = 0.001;\n      const double fixed_delta_seconds = settings.fixed_delta_seconds();\n      const double expected_delta_seconds = 1.0 / _episode.Lock()->GetFPS();\n      const double min_delta_seconds = expected_delta_seconds - threshold;\n      const double max_delta_seconds = expected_delta_seconds + threshold;\n      for (uint32_t attempt = 0; attempt < max_attempts; ++attempt) {\n        Tick(local_timeout);\n        double delta_seconds = GetSnapshot().GetTimestamp().delta_seconds;\n        if (delta_seconds >= min_delta_seconds && delta_seconds <= max_delta_seconds) {\n          return settings_id;\n        }\n      }\n      log_warning(\n          \"Fixed delta seconds was not applied correctly. Expected: \",\n          expected_delta_seconds,\n          \" Actual: \",\n          delta_seconds);\n    }\n    return settings_id;\n  }", "CodeBleu_score": 56.0915298939014}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    const uint64_t settings_id = _episode.Lock()->ApplySettings(settings, local_timeout);\n    if (settings.fixed_delta_seconds > 0.0) {\n      constexpr uint64_t MAX_ATTEMPTS = 5;\n      constexpr uint64_t MAX_WAIT_TIME = 5000;\n      const uint64_t wait_time = std::min(MAX_WAIT_TIME, static_cast<uint64_t>(settings.fixed_delta_seconds * 1000));\n      for (uint64_t attempt = 0; attempt < MAX_ATTEMPTS; ++attempt) {\n        const double delta_time = _episode.Lock()->Tick(wait_time);\n        if (std::abs(delta_time - settings.fixed_delta_seconds) < 0.001) {\n          return settings_id;\n        }\n      }\n      _logger->warn(\"Could not verify fixed delta time. Expected: {} s, Measured: {} s\",\n          settings.fixed_delta_seconds, delta_time);\n    }\n    return settings_id;\n  }", "CodeBleu_score": 52.217128957473705}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    float sqrLen = (segment.end - segment.start).SqrMagnitude();\n    float len = sqrLen.Sqrt();\n    if (len == 0) {\n        return { 0, (point - segment.start).Magnitude() };\n    }\n    float proj = ((point - segment.start) * (segment.end - segment.start)) / sqrLen;\n    proj = proj.Clamp(0, 1);\n    float distAlong = proj * len;\n    float distFromProj = (point - (segment.start + proj * (segment.end - segment.start))).Magnitude();\n    return { distAlong, distFromProj };\n}", "CodeBleu_score": 31.1060952874032}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    // Calculate the squared length of the segment\n    float segmentLengthSquared = Math::LengthSegmentSquared(segment);\n    // If the segment length is zero, return zero and the distance from the point to one endpoint\n    if (segmentLengthSquared == 0.0f) {\n        return std::make_pair(0.0f, Math::LengthPointToPoint(point, segment.first));\n    }\n    // Calculate the length of the segment\n    float segmentLength = std::sqrt(segmentLengthSquared);\n    // Project the point onto the segment\n    float t = Math::DotProduct(Math::SubtractPoints(point, segment.first), Math::SubtractPoints(segment.second, segment.first)) / segmentLengthSquared;\n    // Clamp the projection\n    t = std::max(0.0f, std::min(1.0f, t));\n    // Calculate the distance along the segment\n    float distanceAlongSegment = t * segmentLength;\n    // Calculate the distance from the projection to the point\n    float distanceFromProjectionToPoint = Math::LengthPointToPoint(point, Math::AddPoints(segment.first, Math::MultiplyPoint(Math::SubtractPoints(segment.second, segment.first), t)));\n    // Return the distance along the segment and the distance from the projection to the point\n    return std::make_pair(distanceAlongSegment, distanceFromProjectionToPoint);\n}", "CodeBleu_score": 38.64169539942682}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t    // Calculate the squared length of the segment\n    float segmentLengthSq = Math::DistanceSq(segment.first, segment.second);\n\n    // If the segment length is zero, return zero and the distance from the point to one endpoint\n    if (segmentLengthSq == 0.0f) {\n        return std::make_pair(0.0f, Math::Distance(point, segment.first));\n    }\n\n    // Calculate the length of the segment\n    float segmentLength = sqrt(segmentLengthSq);\n\n    // Calculate the projection of the point onto the segment\n    float projection = Math::Dot(point - segment.first, segment.second - segment.first) / segmentLengthSq;\n\n    // Clamp the projection to the range [0, 1]\n    projection = Math::Clamp(projection, 0.0f, 1.0f);\n\n    // Calculate the distance along the segment\n    float distanceAlongSegment = projection * segmentLength;\n\n    // Calculate the distance from the projection to the point\n    float distanceFromProjection = Math::Distance(segment.first + projection * (segment.second - segment.first), point);\n\n    // Return the distance along the segment and the distance from the projection to the point\n    return std::make_pair(distanceAlongSegment, distanceFromProjection);\n}", "CodeBleu_score": 37.70345187754388}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    index_type initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 49.53669190456296}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    size_t initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i);\n      AddIndex(initial_index + i + 1);\n    }\n  }", "CodeBleu_score": 50.8489493796223}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t    assert(vertices.size() >= 3);\n    index_type initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i + 1);\n      AddIndex(initial_index + i + 2);\n    }\n  }", "CodeBleu_score": 51.59349928425219}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t    // Ensure message is valid\n    if (!message->Verify()) {\n        // Log error and close connection\n        LOG_ERROR(\n            \"invalid message size: {}\",\n            message->size());\n        Close();\n        return;\n    }\n\n    // Post a lambda to the strand for execution\n    _strand.post([this, message]() {\n        // Check if socket is open\n        if (!_socket.is_open()) {\n            // Log error and close connection\n            LOG_ERROR(\n                \"socket is not open, cannot write message\");\n            Close();\n            return;\n        }\n\n        // Set a timeout\n        _socket.expires_after(std::chrono::seconds(10));\n\n        // Initiate an asynchronous write\n        boost::asio::async_write(\n            _socket,\n            boost::asio::buffer(message->data(), message->size()),\n            [this, message](const boost::system::error_code &ec, std::size_t bytes_transferred) {\n                // Handle the result\n                handle_sent(ec, bytes_transferred, message);\n            });\n    });\n}", "CodeBleu_score": 37.90667585666542}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t    if (!message->IsValid()) {\n        // Log an error message indicating that the message is invalid.\n        log_error(\"message is invalid\");\n        return;\n    }\n\n    // Post a lambda function to the strand for execution.\n    _strand.post([\n        // Capture the message and the shared pointer to the Primary instance.\n        message = std::move(message),\n        self = shared_from_this()\n    ]() mutable {\n        // Check if the socket is open.\n        if (!self->_socket.is_open()) {\n            // Log an error message indicating that the socket is not open.\n            log_error(\"socket is not open\");\n            return;\n        }\n\n        // Set a timeout for the write operation.\n        self->_socket.expires_after(std::chrono::seconds(10));\n\n        // Initiate an asynchronous write operation.\n        self->_socket.async_write_some(\n            asio::buffer(message->GetData(), message->GetSize()),\n            [\n                // Capture the shared pointer to the message and the shared pointer to the Primary instance.\n                message = std::move(message),\n                self = std::move(self)\n            ](const std::error_code ec, std::size_t) {\n                // Handle the result of the write operation.\n                self->_handle_sent(ec, message);\n            }\n        );\n    });\n}", "CodeBleu_score": 38.00496256677236}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t    if (!message->Verify()) {\n        log_error(\"message verification failed\");\n        return;\n    }\n    _strand.post([this, message]() {\n        if (!_socket.is_open()) {\n            return;\n        }\n        _socket.expires_after(std::chrono::seconds(1));\n        _socket.async_write_some(\n            asio::buffer(*message),\n            [this, message](const asio::error_code &ec, std::size_t bytes_transferred) {\n                HandleSent(ec, bytes_transferred, message);\n            });\n    });\n}", "CodeBleu_score": 30.613797105539}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t  // Cancel the timer\n  deadline_.cancel();\n\n  // If there's no error, and the socket is still open\n  if (!ec && socket_.is_open()) {\n    // Shut down the socket\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n    // Close the socket\n    socket_.close();\n  }\n\n  // Trigger the on_closed callback\n  on_closed();\n\n  // Log that the session has been closed\n  LOG(INFO) << \"Closed connection to \" << remote_endpoint_ << \".\";\n}", "CodeBleu_score": 46.08556826710102}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    if (ec) {\n        return;\n    }\n    if (socket_.is_open()) {\n        boost::system::error_code ec;\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        socket_.close(ec);\n    }\n    on_closed();\n    Logger::Info(\"Session closed\");\n}", "CodeBleu_score": 49.45161346812906}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t    // Cancel the timer\n    timer_.expires_at(boost::posix_time::pos_infin);\n\n    // If the socket is open\n    if (socket_.is_open()) {\n        // Shut down the socket\n        boost::system::error_code ec;\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        socket_.close(ec);\n\n        // If there is no error\n        if (ec) {\n            // Log the error\n            std::cout << \"Error shutting down socket: \" << ec.message() << std::endl;\n        }\n    }\n\n    // Trigger the on_closed callback\n    on_closed_();\n\n    // Log that the session has been closed\n    std::cout << \"Session closed\" << std::endl;\n}", "CodeBleu_score": 52.477983660678426}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t    char *buffer = new char[strlen(\"Are you alive?\") + 1];\n    strcpy(buffer, \"Are you alive?\");\n    log.Log(Log::LogLevel::LOG_LEVEL_INFO, \"Sending IsAlive\");\n    command.Write(buffer, Command::CommandType::YOU_ALIVE);\n    delete[] buffer;\n    log.Log(Log::LogLevel::LOG_LEVEL_INFO, \"Waiting for response\");\n    command.Read(Command::CommandType::YOU_ALIVE);\n}", "CodeBleu_score": 42.818903953037406}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t    char buffer[256];\n    sprintf(buffer, \"Are you alive?\");\n    Logger::Log(LogLevel::INFO, \"Sending message: %s\", buffer);\n    WriteMessage(buffer, Commands::YOU_ALIVE);\n    Logger::Log(LogLevel::INFO, \"Waiting for response from system...\");\n    ReadMessage();\n}", "CodeBleu_score": 30.740526426271476}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar buffer[BUFFER_SIZE];\n\tsprintf(buffer, \"Are you alive?\");\n\tLogger::Log(LogLevel::INFO, \"Sending: %s\", buffer);\n\t\n\tRouter::GetInstance()->Write(Router::GetInstance()->GetNextRouter(), Router::Command::YOU_ALIVE, buffer);\n\t\n\tLogger::Log(LogLevel::INFO, \"Waiting for response...\");\n\tRouter::GetInstance()->Read(Router::GetInstance()->GetNextRouter(), buffer);\n\tLogger::Log(LogLevel::INFO, \"Received: %s\", buffer);\n}", "CodeBleu_score": 33.6911523105164}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    // Check if the sensor is on any server\n    for (int i = 0; i < server_count; i++) {\n        if (server_list[i].sensor_list.find(sensor_id) != server_list[i].sensor_list.end()) {\n            // Sensor found on this server\n            // Create a buffer with the sensor ID\n            char buffer[sizeof(sensor_id)];\n            memcpy(buffer, &sensor_id, sizeof(sensor_id));\n\n            // Send an ENABLE_ROS command to the server using the router\n            router.SendCommand(server_list[i].server_ip, ENABLE_ROS, buffer, sizeof(sensor_id));\n\n            // Wait for and process the server's response\n            char response_buffer[1024];\n            size_t response_size = router.WaitForResponse(response_buffer, sizeof(response_buffer));\n            ProcessServerResponse(response_buffer, response_size);\n            return;\n        }\n    }\n\n    // Sensor not found on any server\n    // Log an error message\n    Logger::LogError(\"Sensor not found on any server\");\n}", "CodeBleu_score": 46.63888414080905}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t  // Check if the sensor is activated on any secondary server\n  for (int i = 0; i < num_secondary_servers; i++) {\n    if (secondary_servers[i]->IsSensorActive(sensor_id)) {\n      // Create a buffer with the sensor ID\n      uint8_t buffer[2];\n      buffer[0] = (sensor_id >> 8) & 0xFF;\n      buffer[1] = sensor_id & 0xFF;\n\n      // Send an ENABLE_ROS command to the server using the router\n      router->SendCommand(secondary_servers[i], ENABLE_ROS, buffer, 2);\n\n      // Wait for and process the server's response\n      uint8_t response[1];\n      router->WaitForResponse(secondary_servers[i], response, 1);\n\n      // Check the response\n      if (response[0] == SUCCESS) {\n        // The sensor was successfully enabled\n        return;\n      } else {\n        // The sensor was not successfully enabled\n        // Log an error message\n        logger->LogError(\"Failed to enable sensor on server\");\n        return;\n      }\n    }\n  }\n\n  // The sensor was not found on any server\n  // Log an error message\n  logger->LogError(\"Sensor not found on any server\");\n}", "CodeBleu_score": 45.53849699773236}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t    bool found = false;\n    for (auto& server : servers_) {\n        if (server.second->IsSensorActivated(sensor_id)) {\n            found = true;\n            // Create a buffer with the sensor ID\n            uint8_t buffer[2];\n            buffer[0] = sensor_id;\n            buffer[1] = 0;\n\n            // Send the ENABLE_ROS command to the server using the router\n            if (!router_->SendCommand(server.first, Command::ENABLE_ROS, buffer, 2)) {\n                logger_->LogError(\"Failed to send ENABLE_ROS command to server \" + std::to_string(server.first));\n            }\n\n            // Wait for the server's response\n            if (!router_->WaitForResponse(server.first, Command::ENABLE_ROS)) {\n                logger_->LogError(\"Failed to receive ENABLE_ROS response from server \" + std::to_string(server.first));\n            }\n\n            // Process the server's response\n            if (!router_->ProcessResponse(server.first, Command::ENABLE_ROS)) {\n                logger_->LogError(\"Failed to process ENABLE_ROS response from server \" + std::to_string(server.first));\n            }\n\n            break;\n        }\n    }\n\n    if (!found) {\n        logger_->LogError(\"Sensor \" + std::to_string(sensor_id) + \" not found on any server\");\n    }\n}", "CodeBleu_score": 43.768350745677765}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _active_sensors.find(sensor_id);\n  if (it != _active_sensors.end()) {\n    log_info(\"token already active for sensor: \", sensor_id);\n    return it->second;\n  }\n  auto token = SendGetToken(sensor_id);\n  _active_sensors.emplace(sensor_id, token);\n  _sensor_to_server.emplace(sensor_id, _router->GetServerId());\n  return token;\n}", "CodeBleu_score": 45.78233974407658}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  if (auto it = _active_sensors.find(sensor_id); it != _active_sensors.end()) {\n    log_info(\"sensor \", sensor_id, \" is already activated\");\n    return it->second;\n  }\n\n  log_info(\"sensor \", sensor_id, \" is not activated\");\n  if (auto it = _secondary_servers.find(sensor_id); it != _secondary_servers.end()) {\n    log_info(\"sensor \", sensor_id, \" is on server \", it->second);\n    auto token = SendGetToken(sensor_id);\n    _active_sensors.insert({sensor_id, token});\n    _tokens_to_sensor.insert({token, sensor_id});\n    return token;\n  }\n\n  log_info(\"sensor \", sensor_id, \" is not on any server\");\n  return token_type();\n}", "CodeBleu_score": 54.72650418492151}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"sensor already activated\");\n    return it->second;\n  }\n\n  auto token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = token;\n  _sensors[token.get_stream_id()] = sensor_id;\n  return token;\n}", "CodeBleu_score": 50.80419012631284}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t    std::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }", "CodeBleu_score": 97.74225201289511}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.76847140907317}, {"code": "bool Navigation::Load(const std::string &filename){\n\t  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.76847140907317}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!_isReady) {\n        return false;\n    }\n\n    assert(_crowd != nullptr);\n\n    auto walker = _walkerManager.find(id);\n    if (walker != _walkerManager.end()) {\n        _crowdMutex.lock();\n        _crowd->removeAgent(walker->second);\n        _walkerManager.erase(id);\n        _crowdMutex.unlock();\n        return true;\n    }\n\n    auto vehicle = _vehicleManager.find(id);\n    if (vehicle != _vehicleManager.end()) {\n        _crowdMutex.lock();\n        _crowd->removeAgent(vehicle->second);\n        _vehicleManager.erase(id);\n        _crowdMutex.unlock();\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 56.68598904540894}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!is_ready_) {\n        return false;\n    }\n\n    assert(crowd_ != nullptr);\n\n    if (walker_map_.find(id) != walker_map_.end()) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        crowd_->removeAgent(walker_map_[id]);\n        walker_manager_->removeAgent(walker_map_[id]);\n        walker_map_.erase(id);\n        return true;\n    } else if (vehicle_map_.find(id) != vehicle_map_.end()) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        crowd_->removeAgent(vehicle_map_[id]);\n        vehicle_manager_->removeAgent(vehicle_map_[id]);\n        vehicle_map_.erase(id);\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 53.37756750806556}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t    if (!IsReady()) {\n        return false;\n    }\n\n    assert(m_crowd != nullptr);\n\n    // Try to find the agent in the walker and vehicle mappings\n    auto walkerIt = m_walkerMapping.find(id);\n    auto vehicleIt = m_vehicleMapping.find(id);\n\n    // If the agent is not found in either mapping, return false\n    if (walkerIt == m_walkerMapping.end() && vehicleIt == m_vehicleMapping.end()) {\n        return false;\n    }\n\n    // Enter a critical section to safely remove the agent from the crowd\n    std::lock_guard<std::mutex> lock(m_mutex);\n\n    // If the agent is a walker, remove it from the walker manager\n    if (walkerIt != m_walkerMapping.end()) {\n        m_walkerManager->removeAgent(walkerIt->second);\n        m_walkerMapping.erase(walkerIt);\n    }\n    // If the agent is a vehicle, remove it from the vehicle manager\n    else {\n        m_vehicleManager->removeAgent(vehicleIt->second);\n        m_vehicleMapping.erase(vehicleIt);\n    }\n\n    // Remove the agent from the crowd\n    m_crowd->removeAgent(id);\n\n    return true;\n}", "CodeBleu_score": 56.6383679729579}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n\n  // collect the ids of currently mapped vehicles\n  std::set<ActorId> mapped_vehicles;\n  for (auto it = _mapped_vehicles_id.begin(); it != _mapped_vehicles_id.end(); ++it) {\n    mapped_vehicles.insert(it->first);\n  }\n\n  // add or update vehicles from the list\n  for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n    AddOrUpdateVehicle(*it);\n    mapped_vehicles.erase(it->id);\n  }\n\n  // remove vehicles not marked as updated\n  for (auto it = mapped_vehicles.begin(); it != mapped_vehicles.end(); ++it) {\n    RemoveAgent(*it);\n  }\n\n  return true;\n}", "CodeBleu_score": 52.68494209253274}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t", "CodeBleu_score": 4.305317046370039}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\t\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // collect all currently mapped vehicles\n    std::set<ActorId> current_vehicles;\n    for (auto &pair : _mapped_vehicles_id) {\n      current_vehicles.insert(pair.first);\n    }\n\n    // add or update vehicles\n    for (auto &vehicle : vehicles) {\n      if (!AddOrUpdateVehicle(vehicle)) {\n        return false;\n      }\n      // mark as updated\n      current_vehicles.erase(vehicle.id);\n    }\n\n    // remove vehicles not updated\n    for (auto &id : current_vehicles) {\n      RemoveAgent(id);\n    }\n\n    return true;\n  }", "CodeBleu_score": 51.025471897486064}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t    // Search for the actor in the mapped walkers and vehicles\n    auto search = _actor_to_vehicle.find(id);\n    if (search != _actor_to_vehicle.end()) {\n        // Enter a critical section\n        std::lock_guard<std::mutex> lock(search->second->GetMutex());\n        // Compute the squared distance\n        float squared_distance = distance * distance;\n        // Use the crowd system to determine if a vehicle is nearby\n        return search->second->GetCrowd()->IsVehicleNear(squared_distance, direction);\n    }\n    // Return false if the actor is not found\n    return false;\n}", "CodeBleu_score": 44.46154907673895}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t    // Search for the actor in the mapped walkers and vehicles.\n    auto walker_it = _walkers.find(id);\n    if (walker_it != _walkers.end()) {\n        // Enter a critical section to access the actor's location.\n        std::lock_guard<std::mutex> lock(walker_it->second->GetMutex());\n        // Compute the squared distance between the actor and the vehicle.\n        const float squared_distance = walker_it->second->GetLocation().SquaredLength();\n        // Use the crowd system to determine if a vehicle is nearby.\n        return _crowd_system.IsVehicleNear(walker_it->second->GetLocation(), walker_it->second->GetForwardVector(), distance, squared_distance);\n    }\n\n    auto vehicle_it = _vehicles.find(id);\n    if (vehicle_it != _vehicles.end()) {\n        // Enter a critical section to access the actor's location.\n        std::lock_guard<std::mutex> lock(vehicle_it->second->GetMutex());\n        // Compute the squared distance between the actor and the vehicle.\n        const float squared_distance = vehicle_it->second->GetLocation().SquaredLength();\n        // Use the crowd system to determine if a vehicle is nearby.\n        return _crowd_system.IsVehicleNear(vehicle_it->second->GetLocation(), vehicle_it->second->GetForwardVector(), distance, squared_distance);\n    }\n\n    // Return false if the actor is not found.\n    return false;\n}", "CodeBleu_score": 46.839167054742134}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t  // Search for the actor in the mapped walkers and vehicles\n  auto walkers_it = walkers_.find(id);\n  auto vehicles_it = vehicles_.find(id);\n\n  if (walkers_it != walkers_.end() || vehicles_it != vehicles_.end()) {\n    std::lock_guard<std::mutex> lock(mutex_);\n    // Compute the squared distance\n    float distance_squared = distance * distance;\n    // Use the crowd system to determine if a vehicle is nearby\n    return crowd_->IsVehicleNear(id, distance_squared, direction);\n  }\n  return false;\n}", "CodeBleu_score": 49.827320331136264}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  const RoutePoint &point = info.GetCurrentRoutePoint();\n  WalkerEventVisitor visitor(info.GetContext());\n  return boost::variant2::visit(visitor, point.GetEvent(), delta);\n}", "CodeBleu_score": 48.23786691112542}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  const auto &current_route_point = info.route.at(info.current_route_point_index);\n  WalkerEventVisitor visitor(info.context);\n  return boost::variant2::visit(visitor, current_route_point.event, delta);\n}", "CodeBleu_score": 46.534271923616075}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t  // Get the current route point for the walker.\n  const RoutePoint &point = info.GetRoute().at(info.GetCurrentRouteIndex());\n\n  // Create a WalkerEventVisitor with the current context.\n  WalkerEventVisitor visitor(info.GetContext(), delta);\n\n  // Use boost::variant2::visit to process the event at the current route point.\n  return boost::variant2::visit(visitor, point.GetEvent());\n}", "CodeBleu_score": 48.43828857573995}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n    // Extract the road ID\n    const int road_id = road_node.attribute(\"id\").as_int();\n\n    // Process each lane section within the lanes node\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\n      // Get the left, center, and right lane nodes\n      pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n      pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n      pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n      // Parse the left, center, and right lanes\n      ParseLanes(left_lane_node, center_lane_node, right_lane_node, map_builder, road_id);\n    }\n  }\n}", "CodeBleu_score": 44.177205045351506}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n\n    // Extract road ID\n    const int road_id = road_node.attribute(\"id\").as_int();\n\n    // Iterate through each lane section\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\").children(\"laneSection\")) {\n\n      // Get left, center, and right lane nodes\n      pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n      pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n      pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n      // Parse left lane\n      if (left_lane_node) {\n        ParseLanes(left_lane_node, road_id, map_builder);\n      }\n\n      // Parse center lane\n      if (center_lane_node) {\n        ParseLanes(center_lane_node, road_id, map_builder);\n      }\n\n      // Parse right lane\n      if (right_lane_node) {\n        ParseLanes(right_lane_node, road_id, map_builder);\n      }\n    }\n  }\n}", "CodeBleu_score": 58.1098436550758}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n    // Get the root node\n    const pugi::xml_node root_node = xml.child(\"OpenDRIVE\");\n\n    // Iterate through each road node\n    for (pugi::xml_node road_node : root_node.children(\"road\")) {\n      const int id = road_node.attribute(\"id\").as_int();\n      const std::string name = road_node.attribute(\"name\").value();\n      const double length = road_node.attribute(\"length\").as_double();\n      const std::string junction = road_node.attribute(\"junction\").value();\n      const std::string rule = road_node.attribute(\"rule\").value();\n\n      // Call map builder for road\n      map_builder.CreateRoad(id, name, length, junction, rule);\n\n      // Iterate through each lane section node\n      for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n        const double s = lane_section_node.attribute(\"s\").as_double();\n\n        // Get the left, center, and right lane nodes\n        pugi::xml_node left_lane_node = lane_section_node.child(\"left\");\n        pugi::xml_node center_lane_node = lane_section_node.child(\"center\");\n        pugi::xml_node right_lane_node = lane_section_node.child(\"right\");\n\n        // Parse the left, center, and right lane nodes\n        ParseLanes(left_lane_node, map_builder, id, s);\n        ParseLanes(center_lane_node, map_builder, id, s);\n        ParseLanes(right_lane_node, map_builder, id, s);\n      }\n    }\n  }", "CodeBleu_score": 64.53657000256374}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        // shouldn't get here\n        std::cerr << \"on_publication_matched: invalid change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 58.5189118002631}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cout << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 69.35360323362852}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 71.10309940676105}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Subscriber matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 64.22916729419825}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Subscriber matched.\" << std::endl;\n        if (matched_ > 1 && first_connected_) {\n            first_connected_ = false;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n        if (matched_ == 0) {\n            done_ = true;\n        }\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}", "CodeBleu_score": 67.51619670887902}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t    if (info.current_count_change == 1) {\n        matched_++;\n        if (matched_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        if (matched_ == 0) {\n            //destroy_subscriber();\n        }\n    } else {\n        //log_error(\"Error in SubscriberListenerImpl::on_subscription_matched\");\n    }\n}", "CodeBleu_score": 48.88159870478079}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.02370031557412}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 98.51696483682669}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 97.01569280410635}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}", "CodeBleu_score": 95.95739996321375}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if the target has already been set\n    if (target.system_id != 0) {\n        return;\n    }\n\n    // decode the message\n    mavlink_status_t status;\n    mavlink_message_t msg_copy = msg;\n    uint8_t msgid = mavlink_msg_to_send_buffer((uint8_t*)&msg_copy, &status);\n\n    // exit immediately if this is not a message that should be tracked\n    if (msgid != MAVLINK_MSG_ID_ATTITUDE &&\n        msgid != MAVLINK_MSG_ID_LOCAL_POSITION_NED &&\n        msgid != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n        msgid != MAVLINK_MSG_ID_SCALED_PRESSURE) {\n        return;\n    }\n\n    // if the target system ID is not set, set it and request data\n    // streams from the target\n    if (target.system_id == 0) {\n        target.system_id = msg.sysid;\n        gcs().request_datastream_position(target.system_id);\n        gcs().request_datastream_airpressure(target.system_id);\n    }\n\n    // flag that the target has been set\n    target.set_active();\n}", "CodeBleu_score": 42.0371494964767}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    if (target_set) {\n        return;\n    }\n    if (msg.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n        if (target_sysid == -1) {\n            target_sysid = msg.sysid;\n            gcs().send_message(MSG_NEXT_WAYPOINT);\n            gcs().request_datastream_position(target_sysid);\n            gcs().request_datastream_airpressure(target_sysid);\n        }\n        target_set = true;\n    }\n}", "CodeBleu_score": 35.52708978016584}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t    // exit immediately if the target has already been set\n    if (target_set) {\n        return;\n    }\n\n    // decode message\n    mavlink_status_t status;\n    mavlink_message_t rmsg;\n    mavlink_msg_decode(&msg, &status, &rmsg);\n\n    // exit immediately if this is not a message that should be tracked\n    if (rmsg.msgid != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n        rmsg.msgid != MAVLINK_MSG_ID_SCALED_PRESSURE) {\n        return;\n    }\n\n    // if target's sysid is zero, this indicates that the target\n    // should be whatever the sender is:\n    if (target_system == 0) {\n        // set target_system based on sender of message\n        target_system = msg.sysid;\n        // send a request message for desired datastream\n        if (rmsg.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n            // request global position\n            mavlink_request_data_stream(MAV_DATA_STREAM_POSITION, target_system, 0, 1);\n        } else if (rmsg.msgid == MAVLINK_MSG_ID_SCALED_PRESSURE) {\n            // request air pressure\n            mavlink_request_data_stream(MAV_DATA_STREAM_RAW_SENSORS, target_system, 0, 1);\n        }\n    }\n\n    // set target has been set\n    target_set = true;\n}", "CodeBleu_score": 35.41019567826869}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        AP_Notify::flags.pre_arm_rc_calibration_required = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.0980007297845}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        barometer.set_calibration_needed(true);\n    }\n    return result;\n}", "CodeBleu_score": 64.79696865549606}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        barometer.set_calibration_needed(true);\n    }\n    return result;\n}", "CodeBleu_score": 64.79696865549606}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0f) {\n        // arm\n        AP_Notify::flags.armed = true;\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0f) {\n        // disarm\n        AP_Notify::flags.armed = false;\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        // unsupported\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 55.75672711677046}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1) {\n        // arm\n        AP_Notify::events.user_input_lock = 1;\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0) {\n        // disarm\n        AP_Notify::events.user_input_lock = 0;\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 64.21607802053488}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t    if (packet.param1 == 1.0f) {\n        // arm\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0f) {\n        // disarm\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 79.42615140917901}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (chan(i).initialised) {\n            // check for available space in the GCS queue:\n            if (HAVE_PAYLOAD_SPACE((mavlink_channel_t)i, POSITION)) {\n                mavlink_msg_request_data_stream_send(\n                    (mavlink_channel_t)i,\n                    sysid,\n                    compid,\n                    MAV_DATA_STREAM_POSITION,\n                    _rate_position,\n                    1);\n            }\n        }\n    }\n}", "CodeBleu_score": 81.25810908925676}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (hal.util->get_available_memory() < (160 + GCS_MAVLINK::packet_overflow_margin-MAVLINK_NUM_NON_PAYLOAD_BYTES)) {\n            gcs_chan[i].request_datastream_position();\n        }\n    }\n}", "CodeBleu_score": 41.28290703316481}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (chan(i).initialised) {\n            uint16_t max_size = chan(i).get_available_tx_space();\n            if (max_size < MAVLINK_MSG_ID_POSITION_LEN) {\n                continue;\n            }\n            chan(i).request_datastream(MAVLINK_MSG_ID_POSITION, sysid, compid, 1000000/GCS_MAVLINK::stream_rates[MAVLINK_MSG_ID_POSITION]);\n        }\n    }\n}", "CodeBleu_score": 59.83168782451176}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    // get AHRS\n    AP_AHRS &ahrs = AP::ahrs();\n\n    // get cosine of pitch\n    float cos_pitch = ahrs.cos_pitch();\n\n    // check for divide by zero\n    if (is_zero(cos_pitch)) {\n        return false;\n    }\n\n    // calculate earth frame angles\n    ef_pitch = RAD_TO_DEG(atan2f(ahrs.sin_roll() * cos_pitch, -ahrs.sin_pitch()));\n    ef_yaw = RAD_TO_DEG(atan2f(ahrs.cos_roll() * cos_pitch, -ahrs.sin_pitch()));\n\n    // return success\n    return true;\n}", "CodeBleu_score": 54.128580847966155}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    AP_AHRS &ahrs = AP::ahrs();\n    const float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch < 0.7f) {\n        return false;\n    }\n    const float sin_pitch = sqrtf(1 - cos_pitch * cos_pitch);\n    ef_pitch = degrees(atan2f(cos_pitch, sin_pitch * cosf(radians(yaw)))) - 90;\n    ef_yaw = degrees(atan2f(-sin_pitch * sinf(radians(yaw)), cos_pitch));\n    return true;\n}", "CodeBleu_score": 55.2765915448296}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t    const AP_AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch < 0.7f) {\n        return false;\n    }\n    ef_pitch = radians(wrap_180(degrees(atan2f(ahrs.sin_roll(), cos_pitch))));\n    ef_yaw = wrap_360(yaw - radians(ahrs.yaw));\n    return true;\n}", "CodeBleu_score": 58.39777945627046}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t    // get yaw and pitch target in centidegrees\n    const AP_AHRS &ahrs = AP::ahrs();\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float pitch = nav_status.pitch;\n    float yaw = nav_status.bearing + tracker.g.yaw_trim;\n\n    // check if the vehicle is outside the tracker's range\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // if the target is valid or no minimum distance is set, update the pitch and yaw servos\n    if (nav_status.target_valid || is_zero(tracker.g.min_distance)) {\n        // update pitch and yaw servos\n        tracker.pitch_servo_out = tracker.g.pidPitch2Srv.get_pid();\n        tracker.yaw_servo_out = tracker.g.pidYaw2Srv.get_pid();\n    }\n}", "CodeBleu_score": 46.74078724997581}, {"code": "void Mode::update_auto(void){\n\t    // set yaw and pitch targets to current position + angle_bf_yaw_pitch * 100\n    // To-Do: should we do separate P and D on _rate_bf_yaw_pitch?\n    // To-Do: should we do separate P and D on _accel_yaw?\n\n    // get yaw and pitch targets in centidegrees\n    const AP_AHRS &ahrs = AP::ahrs();\n    float yaw_angle = ahrs.yaw_sensor;\n    float pitch_angle = ahrs.pitch_sensor;\n    yaw_angle += tracker.angle_bf_yaw_pitch.y * 100.0f;\n    pitch_angle += tracker.angle_bf_yaw_pitch.x * 100.0f;\n\n    // check if we should reverse the servo direction\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(pitch_angle, yaw_angle, direction_reversed);\n\n    // get target distance in centimeters\n    float target_dist = tracker.nav_status.target_distance;\n\n    // if the target distance is valid or no minimum distance is set, update pitch and yaw servos\n    if (is_positive(target_dist) || tracker.g.min_distance <= 0) {\n        tracker.servo_yaw.set_angle(yaw_angle);\n        tracker.servo_pitch.set_angle(pitch_angle);\n    }\n}", "CodeBleu_score": 39.95039226402015}, {"code": "void Mode::update_auto(void){\n\t    // get yaw and pitch angle targets in centi-degrees\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float yaw_angle_target = nav_status.bearing + tracker.g.yaw_trim;\n    float pitch_angle_target = nav_status.pitch;\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    calc_angle_error(pitch_angle_target, yaw_angle_target, direction_reversed);\n\n    // if the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n    if (nav_status.target_valid || (tracker.g.min_distance_cm <= 0)) {\n        tracker.pitch_servo_out_filt.set_target_rate(nav_status.angle_error_pitch);\n        tracker.yaw_servo_out_filt.set_target_rate(nav_status.angle_error_yaw);\n    }\n}", "CodeBleu_score": 41.4060384948186}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t", "CodeBleu_score": 1.8359599812427831}, {"code": "void Tracker::update_GPS(void){\n\t    // Update GPS data\n    gps.encode(GPS_SERIAL.read());\n\n    // Check if last message time has changed\n    if (last_message_time != gps.time.value()) {\n        last_message_time = gps.time.value();\n\n        // Check if GPS status is at least 3D fix\n        if (gps.location.isValid() && gps.location.age() < 2000 &&\n            gps.hdop.isValid() && gps.hdop.value() <= 300 &&\n            gps.hdop.age() < 2000 &&\n            gps.altitude.isValid() && gps.altitude.age() < 2000) {\n            // Handle initialization for setting home location\n            if (gps.location.isUpdated()) {\n                if (gps.location.isValid()) {\n                    if (gps.hdop.isValid()) {\n                        if (gps.altitude.isValid()) {\n                            if (gps.satellites.isValid()) {\n                                if (gps.satellites.value() >= 5) {\n                                    if (ground_start_countdown > 0) {\n                                        ground_start_countdown--;\n                                        if (ground_start_countdown == 0) {\n                                            // Set home location\n                                            home_location = gps.location;\n                                            home_location_set = true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 34.390306899672716}, {"code": "void Tracker::update_GPS(void){\n\t    // Update GPS data\n    gps.update();\n\n    // Handle initialization for setting home location\n    if (last_message_time != gps.last_message_time()) {\n        last_message_time = gps.last_message_time();\n\n        // Check if the GPS status is at least 3D fix\n        if (gps.status() >= 3) {\n            // Decrement ground start countdown\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n\n            // Set home location if ground start countdown reaches one and current location is valid\n            if (ground_start_countdown == 1 && gps.valid()) {\n                set_home_location();\n            }\n        } else {\n            // Reset ground start countdown if GPS status is not at least 3D fix\n            ground_start_countdown = ground_start_countdown_init;\n        }\n    }\n}", "CodeBleu_score": 43.55768963540808}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > 0) {\n        // Set the servo to 180 degrees\n        servo_pitch_onoff.write(180);\n    } else {\n        // Set the servo to 0 degrees\n        servo_pitch_onoff.write(0);\n    }\n}", "CodeBleu_score": 13.485445723846508}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    if (pitch > PITCH_ON_ANGLE) {\n        servo_pitch_onoff.write(PITCH_ON_ANGLE);\n    } else if (pitch < PITCH_OFF_ANGLE) {\n        servo_pitch_onoff.write(PITCH_OFF_ANGLE);\n    } else {\n        servo_pitch_onoff.write(pitch);\n    }\n}", "CodeBleu_score": 23.11439923583136}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t    // Set the servo to the appropriate position based on the pitch\n    if (pitch < -10) {\n        // Set the servo to the \"on\" position\n        servo.writeMicroseconds(1500);\n    } else {\n        // Set the servo to the \"off\" position\n        servo.writeMicroseconds(1000);\n    }\n}", "CodeBleu_score": 13.447933292439677}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // call parent class checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro reference\n    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform == ARMING_CHECK_BARO)) {\n        // check baro vs inav altitude\n        if (fabsf(inertial_nav.get_altitude() - baro_alt) > ARMING_MAX_BARO_ALT_DISPARITY_CM) {\n            if (display_failure) {\n                gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Check Baro\");\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 36.94219757065751}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    // return true if already armed\n    if (_copter.ap.armed) {\n        return true;\n    }\n\n    // perform barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro vs inav altitude\n    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform == ARMING_CHECK_BARO)) {\n        if (_copter.ekf_alt_ok) {\n            const float baro_alt = _copter.baro_alt;\n            const float inav_alt = _copter.inertial_nav.get_position_z_up_cm();\n            const float baro_alt_above_inav = baro_alt - inav_alt;\n            const float acceptable_error_cm = _copter.g.fs_batt_voltage_filt_hz > 0 ? AC_ATTITUDE_CONTROL_BARO_DEVIATION_CM : 0;\n            if (fabsf(baro_alt_above_inav) > acceptable_error_cm) {\n                if (display_failure) {\n                    gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Check barometer\");\n                }\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 54.901172777740406}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro vs inav altitude\n    if ((checks_to_perform & ARMING_CHECK_ALL) ||\n        (checks_to_perform & ARMING_CHECK_BARO)) {\n        if (copter.ap.using_interlock && !copter.ap.motor_interlock_switch) {\n            check_failed(ARMING_CHECK_NONE, display_failure, \"Motor Interlock\");\n            return false;\n        }\n\n        // check baro vs inav altitude\n        if (copter.ap.baro_alt_ok) {\n            // calculate disparity between baro and inav alt\n            int32_t baro_alt_in_cm = copter.baro_alt * 100.0f;\n            int32_t inav_alt_in_cm = copter.inertial_nav.get_altitude() * 100.0f;\n            int32_t baro_alt_diff = baro_alt_in_cm - inav_alt_in_cm;\n            if (baro_alt_diff > 500 || baro_alt_diff < -500) {\n                check_failed(ARMING_CHECK_BARO, display_failure, \"Altitude disparity\");\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 56.76052400247432}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    switch (copter.g2.rtl_alt_type) {\n    case RTL_ALT_TYPE_TERRAIN:\n        return true;\n    default:\n        return AP_Arming::terrain_database_required();\n    }\n}", "CodeBleu_score": 29.211999229744777}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    if (copter.terrain_source != TerrainSourceType::TERRAIN_SOURCE_TERRAINDATABASE) {\n        return false;\n    }\n    if (copter.rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 55.866804415491934}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t    // if rangefinder is the terrain source, then no terrain database is required\n    if (copter.rangefinder_alt_ok()) {\n        return false;\n    }\n\n    // if terrain database is the terrain source and RTL altitude type is terrain, then a terrain database is required\n    if (copter.terrain_enabled() && (copter.g.rtl_alt_type == RTL_ALT_TERRAIN)) {\n        return true;\n    }\n\n    // otherwise defer to the base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 60.678921450805376}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t    // call rate controllers that only require IMU input\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 11.784195927124605}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time for controllers\n    motors->set_loop_rate(scheduler.get_loop_rate_hz());\n\n    // run low level rate controllers\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 16.572013774134085}, {"code": "void Copter::run_rate_controller(){\n\t    // set loop time for controllers\n    motors->set_dt(scheduler.get_loop_period_s());\n\n    // run low level rate controllers that use pilot inputs\n    attitude_control->rate_controller_run();\n}", "CodeBleu_score": 16.060305617106348}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // get next waypoint location\n    Location next_loc = mode_guided.get_wp_location();\n\n    // exit if old location is not the same as next waypoint location\n    if (!next_loc.same_latlon_as(old_loc)) {\n        return false;\n    }\n\n    // exit if altitude frames are different\n    if (next_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set new location as target\n    set_target_location(new_loc);\n\n    return true;\n}", "CodeBleu_score": 68.69604037101223}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    Location next_waypoint_loc;\n    if (!get_next_waypoint_location(next_waypoint_loc)) {\n        return false;\n    }\n\n    // Check if the old location matches the next waypoint\n    if (!next_waypoint_loc.same_latlon_as(old_loc)) {\n        return false;\n    }\n\n    // Check if the altitude frames of the old and new locations are the same\n    if (next_waypoint_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // Set the new location as the target\n    set_target_location(new_loc);\n\n    return true;\n}", "CodeBleu_score": 65.1402262205408}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t    // retrieve the next waypoint location\n    Location next_waypoint_loc = mode_guided.get_next_destination();\n\n    // check if the old location matches the next waypoint location\n    if (!old_loc.same_latlon_as(next_waypoint_loc)) {\n        return false;\n    }\n\n    // check if the altitude frames of the old and new locations are the same\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    if (!set_target_location(new_loc)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 67.0276693585709}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 69.34280080899627}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    // return immediately if we are already in the desired mode\n    if (copter.flightmode == &copter.mode_number[mode]) {\n        return;\n    }\n\n    // if the user has just pushed the change mode switch,\n    // set the mode to the new flight mode\n    // note that we don't use change_mode() or set_mode() here to ensure\n    // the change happens immediately and also doesn't break recording which\n    // the pilot may be doing.  We use change_mode() in the else condition\n    // below to ensure the log message is sent.\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode == &copter.mode_number[mode]) {\n        // the user has just released the mode change switch so\n        // we reset the mode change switch state\n        copter.reset_mode_switch();\n    } else {\n        // we are in a non-mode-change condition (we are in\n        // non-guided mode and the mode-change switch is in the\n        // HIGH position). We reset the mode change switch\n        // state so that the next time the pilot tries to arm\n        // the switch will behave as the pilot had just changed\n        // modes.\n        copter.reset_mode_switch();\n    }\n}", "CodeBleu_score": 52.639810971173205}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t    if (ch_flag == AuxSwitchPos::HIGH) {\n        // engage mode (if not possible we remain in current flight mode)\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else {\n        // return to flight mode switch if we are currently in this mode\n        if (copter.flightmode->mode_number() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 73.49815815991316}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t    // save roll and pitch trim\n    float roll_trim = (channel_roll->control_in - SRV_CHANNEL_LOW_MIN) / ((float)(SRV_CHANNEL_HIGH_MAX - SRV_CHANNEL_LOW_MIN)) * radians(45);\n    float pitch_trim = (channel_pitch->control_in - SRV_CHANNEL_LOW_MIN) / ((float)(SRV_CHANNEL_HIGH_MAX - SRV_CHANNEL_LOW_MIN)) * radians(45);\n    ahrs.add_trim(roll_trim, pitch_trim);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 61.941730011303584}, {"code": "void Copter::save_trim(){\n\t    // save roll and pitch trim\n    float roll_trim = ToRad((float)channel_roll->get_control_in()/100.0f);\n    float pitch_trim = ToRad((float)channel_pitch->get_control_in()/100.0f);\n    ahrs.add_trim(roll_trim, pitch_trim);\n    Log_Write_Event(DATA_SAVEWP);\n    gcs_send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 84.76739589406228}, {"code": "void Copter::save_trim(){\n\t    if (channel_roll->get_control_in() == 0 && channel_pitch->get_control_in() == 0) {\n        ahrs.save_trim();\n        Log_Write_Event(DATA_SAVE_TRIM);\n        gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n    }\n}", "CodeBleu_score": 36.087337255596665}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    const Vector3f &velocity = inertial_nav.get_velocity();\n    float speed_sq = velocity.length_squared();\n    if (!inertial_nav.get_filter_status().flags.horiz_pos_abs &&\n        !inertial_nav.get_filter_status().flags.pred_horiz_pos_abs &&\n        speed_sq > sq(AC_WP_SPEED_MIN)) {\n        // if we have a good speed estimate then we can use the position and velocity\n        // to calculate a target yaw to look ahead\n        yaw_look_ahead = degrees(atan2f(-velocity.y, -velocity.x))*100.0f;\n    }\n    return yaw_look_ahead;\n}", "CodeBleu_score": 46.850569883979446}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // get current velocity\n    const Vector3f& vel = inertial_nav.get_velocity();\n\n    // calculate speed squared\n    const float speed_sq = vel.length_squared();\n\n    // if we have sufficient speed\n    if (rover.is_positive(speed_sq) && (speed_sq >= AUTO_YAW_SPEED_MIN)) {\n        // calculate unit vector from vehicle to target\n        const Vector3f unit_target = location_offset.unit();\n\n        // get the yaw target\n        const float yaw_target = atan2f(-unit_target.y,unit_target.x);\n\n        // update look ahead yaw\n        look_ahead_yaw = wrap_PI(yaw_target - M_PI_2);\n    }\n\n    // return yaw\n    return look_ahead_yaw;\n}", "CodeBleu_score": 56.14069791727702}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t    // get copter's velocity vector\n    Vector3f velocity = inertial_nav.get_velocity();\n\n    // calculate speed squared\n    float speed_sq = velocity.length_squared();\n\n    // if copter's position is valid and speed exceeds minimum threshold\n    if (copter.position_ok() && (speed_sq > MIN_AUTO_YAW_SPEED_SQ)) {\n        // update look-ahead yaw angle using arctangent of velocity components\n        look_ahead_yaw = atan2f(-velocity.y, velocity.x);\n    }\n\n    // return computed look-ahead yaw angle\n    return look_ahead_yaw;\n}", "CodeBleu_score": 46.465747382000444}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arm_disarm == 0) {\n            // if disarmed, allow arming via rudder arming\n            return true;\n        }\n        if (throttle_zero) {\n            // if throttle is zero, allow arming via rudder arming\n            return true;\n        }\n        return false;\n    }\n    if (method == AP_Arming::Method::AUTO) {\n        // allow arming via AUTO if we have already been armed\n        if (armed) {\n            return true;\n        }\n    }\n\n    // call parent class checks\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 48.11964079749828}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_dis_chk() == false) {\n            return false;\n        }\n        if (throttle_checks() == false) {\n            return false;\n        }\n        if (AP_Arming::is_armed() &&\n            (AP_Arming::rc_calibration_checks() == false)) {\n            return false;\n        }\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 49.371741377072375}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_disabled()) {\n            return false;\n        }\n        if (plane.get_throttle_input() > 0) {\n            return false;\n        }\n    }\n\n    if (armed) {\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.625696873916}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (armed) {\n        return true;\n    }\n\n    if (!_arming.arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    if (do_arming_checks) {\n        // update home location\n        Location loc;\n        if (!AP::ahrs().get_location(loc)) {\n            return false;\n        }\n        set_home_persistently(loc);\n\n        // update current location\n        AP::ahrs().set_home(loc);\n    }\n\n    // change armed state\n    change_arm_state();\n\n    // set armed to true to prevent\n    // warnings from GCS about arming\n    armed = true;\n\n    // set arming flag\n    set_arm_state(ARMED);\n\n    // log arming to dataflash\n    Log_Write_Event(DATA_ARMED);\n\n    // send text of status\n    if (plane.g.arming_beep == ARMING_BEEP_ALL) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n    }\n\n    // update notify object\n    AP_Notify::flags.armed = true;\n    AP::logger().set_vehicle_armed(true);\n\n    return true;\n}", "CodeBleu_score": 54.988915325081756}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t    if (hal.util->was_watchdog_armed()) {\n        // don't allow arming if we were armed with the watchdog\n        return false;\n    }\n\n    if (!hal.util->safety_switch_state()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Safety Switch\");\n        return false;\n    }\n\n    // return true if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    if (do_arming_checks && !all_checks_passing(method)) {\n        return false;\n    }\n\n    // do pre-arm checks\n    if (do_arming_checks && !plane.pre_arm_checks(true)) {\n        return false;\n    }\n\n    // remember home location\n    AP::ahrs().set_home(plane.home);\n\n    // update current location\n    plane.update_current_loc();\n\n    // change status to armed\n    change_arm_state();\n\n    // flag that we are delaying the arming\n    set_delayed_arming(true);\n\n    // arm gimbal\n    plane.g2.gimbal.set_lock(true);\n\n    // send text of final arming status\n    if (plane.ap.in_arming_delay) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Throttle Arm: Delaying\");\n    } else {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Throttle Arm: Arming\");\n    }\n\n    // log arming to dataflash\n    Log_Write_Event(DATA_ARMING_ARMED);\n\n    return true;\n}", "CodeBleu_score": 51.51143579747344}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.845175084025651}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (sub.motors.armed()) {\n        return true;\n    }\n\n    // if disarm button is not configured, fail\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    // call parent class checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.9958753477824}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (sub.motors.armed()) {\n        return true;\n    }\n\n    // check if disarm function is assigned to a button\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm function not assigned\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.9759131509534}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t    if (sub.motors.armed()) {\n        return true;\n    }\n\n    // check if disarm button is configured\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm not configured\");\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 70.9958753477824}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n    float ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 62.41280822119546}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    // Calculate the rotation matrix using the yaw angle from the AHRS\n    float cos_yaw = cos(ahrs.yaw);\n    float sin_yaw = sin(ahrs.yaw);\n    float rotation_matrix[2][2] = {{cos_yaw, -sin_yaw}, {sin_yaw, cos_yaw}};\n\n    // Apply the rotation matrix to the coordinates x and y\n    float ne_x = rotation_matrix[0][0] * x + rotation_matrix[0][1] * y;\n    float ne_y = rotation_matrix[1][0] * x + rotation_matrix[1][1] * y;\n\n    // Update the coordinates x and y with the new values\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 51.635059672635464}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t    float ne_x = cos(yaw)*x + sin(yaw)*y;\n    float ne_y = -sin(yaw)*x + cos(yaw)*y;\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 56.06990040479931}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // decode\n    float angle_deg = packet.param1;\n    uint8_t turn_rate_dps = packet.param2;\n    uint8_t direction = packet.param3;\n    uint8_t relative_angle = packet.param4;\n\n    // check if yaw angle and param4 values are within acceptable ranges\n    if (direction != MAV_YAW_ANGLE_ABSOLUTE &&\n        (relative_angle < MAV_MOUNT_MODE_MAVLINK_TARGETING ||\n         relative_angle > MAV_MOUNT_MODE_RC_TARGETING)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set yaw heading\n    sub.guided_set_angle(Quaternion(Vector3f(0.0f, 0.0f, 1.0f), angle_deg * DEG_TO_RAD),\n                         turn_rate_dps, direction, relative_angle);\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 36.49674108771392}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // store the condition\n    if (packet.param4 > 0) {\n        copter.g2.auto_yaw.set_fixed_yaw(\n            packet.param1,\n            packet.param2,\n            packet.param3,\n            packet.param4,\n            GCS_MAVLINK::set_attitude_target_auto_yaw_rate_cds);\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_DENIED;\n}", "CodeBleu_score": 49.9752430153744}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t    // sanity check location\n    if (!sub.control_check_barometer()) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // param1 : target angle [0-360]\n    // param2 : speed during change [deg per second]\n    // param3 : direction (-1:ccw, +1:cw)\n    // param4 : relative offset (1) or absolute angle (0)\n    if ((packet.param1 < 0.0f) || (packet.param1 > 360.0f)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // param5 : custom controller\n    // param6 : custom controller\n    // param7 : custom controller\n    if (packet.param5 < 0.0f || packet.param5 > 1.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // exit immediately if vehicle is not in Guided mode\n    if (sub.control_mode != GUIDED) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // if param4 is zero the angle is an absolute angle otherwise it is relative to the current heading\n    if (packet.param4 == 0) {\n        sub.guided_set_angle(ROTATION_PITCH, packet.param1);\n    } else {\n        sub.guided_adjust_angle(ROTATION_PITCH, packet.param1);\n    }\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 49.63134170413297}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(wp_bearing/200)/2;\n    }\n    return 0;\n}", "CodeBleu_score": 40.1714389331108}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(wp_bearing_cd) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 40.591103488613754}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360(wp_bearing_cd) / 2;\n    }\n    return 0;\n}", "CodeBleu_score": 40.11253405020829}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (logger.logging_enabled()) {\n        DataFlash_Class::data_log_structure log_data;\n        log_data.time_ms = AP_HAL::millis();\n        log_data.id = (uint16_t)id;\n        log_data.data = value;\n        logger.WriteCriticalBlock(&log_data, sizeof(log_data));\n    }\n}", "CodeBleu_score": 46.245519855656966}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (logger.get_status() == ap_logger::STATUS_ACTIVE) {\n        struct log_Data data;\n        data.id = id;\n        data.value = value;\n        data.time_us = AP_HAL::micros64();\n        logger.WriteCriticalBlock((void *)&data, sizeof(data));\n    }\n}", "CodeBleu_score": 44.331148875228166}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t    if (!logger.is_enabled()) {\n        return;\n    }\n\n    uint64_t time = AP_HAL::micros64();\n\n    struct log_Data_Int {\n        LOG_PACKET_HEADER;\n        uint64_t time_us;\n        uint8_t id;\n        int32_t data_value;\n    };\n\n    struct log_Data_Int pkt = {\n        LOG_PACKET_HEADER_INIT(LOG_DATA_INT_MSG),\n        time_us   : time,\n        id        : (uint8_t)id,\n        data_value: value\n    };\n\n    logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n}", "CodeBleu_score": 62.79936582773532}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t    if (ap.home_state != HOME_UNSET) {\n        // if home is set, exit immediately\n        return;\n    }\n\n    if (motors.armed()) {\n        // if motors are armed, set home to current location\n        set_home_to_current_location_inflight();\n    } else {\n        // if motors are not armed, set home to current EKF location\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 50.43327712808456}, {"code": "void Sub::update_home_from_EKF(){\n\t    // exit immediately if home is already set\n    if (ap.home_state != HOME_UNSET) {\n        return;\n    }\n\n    // if disarmed, set home to current location\n    if (!motors.armed()) {\n        set_home_to_current_location_inflight();\n    }\n}", "CodeBleu_score": 31.406364969296007}, {"code": "void Sub::update_home_from_EKF(){\n\t    if (home_is_set == HOME_SET_NOT_LOCKED) {\n        if (motors.armed()) {\n            set_home_to_current_location_inflight();\n        } else {\n            set_home_to_current_location(false);\n        }\n    }\n}", "CodeBleu_score": 45.53219850801501}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}, {"code": "void ModeAcro::run(){\n\t", "CodeBleu_score": 1.7451934810065097}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set to position control mode\n    sub.guided_mode = Guided_PosVel;\n\n    // initialise waypoint controller\n    sub.wp_nav->wp_and_spline_init();\n\n    // set the destination\n    Vector3f stopping_point;\n    sub.wp_nav->get_wp_stopping_point(stopping_point);\n\n    if (!sub.wp_nav->set_wp_destination(stopping_point)) {\n        // failure to set destination can only be because of missing terrain data\n        failsafe_terrain_on_event();\n        return;\n    }\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 66.8212616206939}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // initialise waypoint and spline controller\n    wp_nav->wp_and_spline_init();\n\n    // set the destination\n    Vector3f stopping_point;\n    wp_nav->get_wp_stopping_point(stopping_point);\n    wp_nav->set_wp_destination(stopping_point, false);\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 56.87658097997458}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t    // set to position control mode\n    sub.guided_mode = Guided_WP;\n\n    // initialise waypoint controller\n    wp_nav->wp_and_spline_init();\n\n    // initialise wpnav to stopping point\n    Vector3f stopping_point;\n    sub.wp_nav->get_wp_stopping_point(stopping_point);\n\n    if (!sub.wp_nav->set_wp_destination(stopping_point, false)) {\n        // this should never happen because guided mode always has a valid stopping point\n        return;\n    }\n\n    // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 69.92287049724001}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    if (sub.guided_set_speed_xy(wp_nav->get_speed_xy())) {\n        // wpnav failed to set the speed\n        return;\n    }\n    if (sub.guided_set_accel_xy(wp_nav->get_wp_acceleration())) {\n        // wpnav failed to set the acceleration\n        return;\n    }\n\n    // initialize vertical maximum speeds and acceleration\n    sub.pos_control->set_max_speed_accel_z(-sub.get_pilot_speed_dn(), sub.wp_nav->get_default_speed_down(), sub.wp_nav->get_default_speed_up(), sub.wp_nav->get_accel_z());\n\n    // initialise the vertical position controller\n    if (!sub.pos_control->is_active_z()) {\n        sub.pos_control->init_z_controller();\n    }\n\n    // set vertical speed and acceleration\n    if (sub.guided_set_speed_z(wp_nav->get_speed_down(), wp_nav->get_speed_up())) {\n        // wpnav failed to set the speed\n        return;\n    }\n    if (sub.guided_set_accel_z(wp_nav->get_accel_z())) {\n        // wpnav failed to set the acceleration\n        return;\n    }\n\n    // set yaw mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 43.633947222002725}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    pos_control->set_max_speed_z(-get_pilot_speed_dn(), g.pilot_speed_up);\n    pos_control->set_max_accel_z(g.pilot_accel_z);\n\n    // initialise velocity controller\n    pos_control->init_vel_controller_xyz();\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 38.74555880856574}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t    // set vertical speed and acceleration\n    sub.pos_control.set_max_speed_z(-sub.get_pilot_speed_dn(), sub.g.pilot_speed_up);\n    sub.pos_control.set_max_accel_z(sub.g.pilot_accel_z);\n\n    // initialise the vertical position controller\n    if (!sub.pos_control.is_active_z()) {\n        sub.pos_control.init_z_controller();\n    }\n\n    // initialise the demanded velocity\n    sub.pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());\n\n    // initialise the vertical position controller\n    if (!sub.pos_control.is_active_xy()) {\n        sub.pos_control.init_xy_controller();\n    }\n\n    // set horizontal speed and acceleration\n    sub.pos_control.set_max_speed_xy(sub.g.pilot_speed_xy);\n    sub.pos_control.set_max_accel_xy(sub.g.pilot_accel_xy);\n\n    // set yaw speed and acceleration\n    sub.pos_control.set_max_turn_rate(sub.g.pilot_yaw_rate);\n    sub.pos_control.set_max_yaw_accel(sub.g.pilot_yaw_accel);\n\n    // pilot always controls yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 35.0032824856262}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have breached any limits\n    if (guided_mode == SubMode::TakeOff || guided_mode == SubMode::WP) {\n        // check if we have topped out\n        if (current_loc.alt > next_WP_loc.alt) {\n            return true;\n        }\n        // check if we have gone below min alt\n        if (current_loc.alt < guided_min_alt) {\n            return true;\n        }\n    }\n\n    // check if we have gone above max alt\n    if (current_loc.alt > guided_max_alt) {\n        return true;\n    }\n\n    // check distance from starting point\n    if (get_distance(current_loc, next_WP_loc) > guided_wp_radius) {\n        return true;\n    }\n\n    // if we got this far we must be in auto mode and haven't breached any limits\n    return false;\n}", "CodeBleu_score": 36.83498993956149}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    if (guided_timeout_ms != 0 &&\n        millis() - state.time_started_ms > guided_timeout_ms) {\n        return true;\n    }\n\n    // check if we have gone below min alt\n    if (guided_alt_min > 0 && current_loc.alt < guided_alt_min) {\n        return true;\n    }\n\n    // check if we have gone above max alt\n    if (guided_alt_max > 0 && current_loc.alt > guided_alt_max) {\n        return true;\n    }\n\n    // check distance from origin\n    if (guided_distance_max > 0) {\n        float dist = get_horizontal_distance_cm(current_loc, state.guided_origin)/100.0f;\n        if (dist > guided_distance_max) {\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 43.01304154978856}, {"code": "bool ModeGuided::guided_limit_check(){\n\t    // check if we have passed the timeout\n    if (guided_state.time_start_ms != 0 &&\n        millis() - guided_state.time_start_ms > guided_state.timeout_ms) {\n        return true;\n    }\n\n    // check if we have gone below min alt\n    if (guided_state.alt_min > 0 && current_loc.alt < guided_state.alt_min) {\n        return true;\n    }\n\n    // check if we have gone above max alt\n    if (guided_state.alt_max > 0 && current_loc.alt > guided_state.alt_max) {\n        return true;\n    }\n\n    // check distance from origin\n    if (guided_state.auto_mode == Auto_CircleMoveToEdge &&\n        guided_state.circle_radius > 0 &&\n        get_distance(current_loc, guided_state.origin) > guided_state.circle_radius) {\n        return true;\n    }\n\n    // if we got this far we must be in auto mode\n    return false;\n}", "CodeBleu_score": 49.16744844910508}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t    // check if motor test is enabled\n    if (!motor_test_enable) {\n        return true;\n    }\n\n    // check if motor test requests are received at least every 2 Hz\n    if (AP_HAL::millis() - last_test_req_ms < 500) {\n        return true;\n    }\n\n    // send timeout message\n    gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Motor test timed out\");\n\n    // set pass flag to false\n    motor_test_pass = false;\n\n    // disable motor test\n    motor_test_enable = false;\n\n    // disarm system\n    init_disarm_motors();\n\n    // record failure time\n    motor_test_failure_ms = AP_HAL::millis();\n\n    // return false\n    return false;\n}", "CodeBleu_score": 57.45311373374309}, {"code": "bool Sub::verify_motor_test(){\n\t    if (motor_test_mode == MOTOR_TEST_DISARMED) {\n        return true;\n    }\n\n    if (motor_test_mode == MOTOR_TEST_ARMED && motor_test_mode_timer.get_running() == false) {\n        motor_test_mode_timer.reset();\n        motor_test_mode_timer.start();\n        return true;\n    }\n\n    if (motor_test_mode == MOTOR_TEST_ARMED && motor_test_mode_timer.get_running() == true && motor_test_mode_timer.get_elapsed() > 500) {\n        // timeout\n        motor_test_mode_timer.stop();\n        motor_test_mode = MOTOR_TEST_DISARMED;\n        gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n        return false;\n    }\n\n    if (motor_test_mode == MOTOR_TEST_RUNNING && motor_test_mode_timer.get_running() == false) {\n        motor_test_mode_timer.reset();\n        motor_test_mode_timer.start();\n        return true;\n    }\n\n    if (motor_test_mode == MOTOR_TEST_RUNNING && motor_test_mode_timer.get_running() == true && motor_test_mode_timer.get_elapsed() > 500) {\n        // timeout\n        motor_test_mode_timer.stop();\n        motor_test_mode = MOTOR_TEST_DISARMED;\n        gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Motor test timed out\");\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 44.789940986011025}, {"code": "bool Sub::verify_motor_test(){\n\t    if (motor_test_timer.get_dt() < 0.5f) {\n        return false;\n    }\n    if (motor_test_timer.get_dt() > 2.0f) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timed out\");\n        set_disarmed_and_landed();\n        failsafe_motor_test_complete_ms = AP_HAL::millis();\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 45.38418289299012}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    float lateral = wp_nav->get_roll();\n    float forward = -wp_nav->get_pitch(); // output is reversed\n\n    // constrain target forward/lateral values\n    // The outputs of wp_nav's get_roll and get_pitch methods are\n    // actual angle values in centidegrees.  They are constrained to\n    // our MAX_ANGLE_TARGET.\n    lateral = constrain_float(lateral, -MAX_ANGLE_TARGET, MAX_ANGLE_TARGET);\n    forward = constrain_float(forward, -MAX_ANGLE_TARGET, MAX_ANGLE_TARGET);\n\n    // Normalize the roll/pitch values from centidegrees to -1 to 1\n    lateral_out = lateral / MAX_ANGLE_TARGET;\n    forward_out = forward / MAX_ANGLE_TARGET;\n}", "CodeBleu_score": 52.60596929314138}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets from wp_nav in centidegrees\n    lateral_out = wp_nav->get_roll();\n    forward_out = -wp_nav->get_pitch(); // output is reversed\n\n    // constrain target angles\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize them\n    lateral_out =  lateral_out / aparm.angle_max;\n    forward_out = forward_out / aparm.angle_max;\n}", "CodeBleu_score": 52.08057573792405}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav->get_roll();\n    forward_out = wp_nav->get_pitch();\n\n    // constrain target angles\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out  /= aparm.angle_max;\n    forward_out /= aparm.angle_max;\n}", "CodeBleu_score": 46.89479782849357}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t", "CodeBleu_score": 2.5263458681211657}, {"code": "void Sub::read_barometer(){\n\t", "CodeBleu_score": 2.5263458681211657}, {"code": "void Sub::read_barometer(){\n\t", "CodeBleu_score": 2.5263458681211657}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t", "CodeBleu_score": 1.8482588980119046}, {"code": "bool Sub::ekf_position_ok(){\n\t", "CodeBleu_score": 1.8482588980119046}, {"code": "bool Sub::ekf_position_ok(){\n\t    // return false immediately if ekf not yet initialised\n    if (!ahrs.healthy()) {\n        return false;\n    }\n\n    // all modes except INITIALISING have EKF data\n    if (ahrs.initialised() && !ahrs.healthy()) {\n        return false;\n    }\n\n    // get EKF filter status\n    nav_filter_status filt_status = ahrs.get_filter_status();\n\n    // if disarmed we accept a predicted position\n    if (!motors.armed()) {\n        return (filt_status.flags.horiz_pos_abs ||\n                (filt_status.flags.pred_horiz_pos_abs && filt_status.flags.pred_horiz_pos_rel));\n    }\n\n    // if in const_pos_mode, EKF's altitude is absolute\n    if (filt_status.flags.const_pos_mode) {\n        return filt_status.flags.horiz_pos_abs;\n    }\n\n    // return true if EKF's altitude is (predicted to be) good\n    return filt_status.flags.horiz_pos_abs && filt_status.flags.pred_horiz_pos_abs;\n}", "CodeBleu_score": 63.29999237026003}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t", "CodeBleu_score": 1.9477481621875286}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // Check EKF compass is healthy\n    if (_ahrs.get_compass_health() < 1) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Compass not healthy\");\n        }\n        return false;\n    }\n\n    // ensure position esimate is ok\n    if (!_ahrs.get_position_ok()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Need position estimate\");\n        }\n        return false;\n    }\n\n    // check home and EKF origin are set\n    if (!AP::ahrs().home_is_set()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Home not set\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 50.968320872572505}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure ahrs is healthy\n    if (!rover.ahrs.healthy()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: AHRS not healthy\");\n        }\n        return false;\n    }\n\n    // ensure ekf has enough position information\n    if (!rover.ekf_position_ok()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: EKF does not have position estimate\");\n        }\n        return false;\n    }\n\n    // check home position is set\n    if (!AP::ahrs().home_is_set()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Home position not set\");\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 54.942101691946135}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t    if (method == AP_Arming::Method::MAVLINK) {\n        const bool do_arm = do_arming_checks;\n        if (!AP_Arming::arm(method, do_arm)) {\n            return false;\n        }\n        if (do_arm) {\n            // set simple mode heading\n            rover.mode_simple.set_desired_heading_to_current_heading();\n\n            // record home position\n            rover.set_home_to_current_location(false);\n\n            // set rtl home location\n            rover.rtl_home = true;\n\n            // set and save the smart_rtl's home location\n            rover.smart_rtl.set_home(true);\n\n            // Save Home to EEPROM\n            rover.smart_rtl.save_home();\n\n            // Save prev_WP_loc to EEPROM\n            rover.prev_WP_loc.save();\n\n            // Save wp_nav to eeprom\n            rover.wp_nav->save();\n\n            // record baro alt start for altitude check\n            baro_alt_start = rover.barometer.get_altitude();\n\n            // update armed flag\n            AP_Notify::flags.armed = true;\n            AP::logger().Write_Event(LogEvent::ARMED);\n\n            gcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n        }\n        return true;\n    }\n\n    return AP_Arming::arm(method, do_arming_checks);\n}", "CodeBleu_score": 53.73349194963652}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            // Enable charging\n            if (!charging_enabled) {\n                charging_enabled = true;\n                charging_start_time = millis();\n                charging_start_v_battery = status_message.v_battery;\n                charging_start_v_charge = status_message.v_charge;\n                charging_start_charging_current = status_message.charging_current;\n            }\n        } else {\n            // Disable charging\n            if (charging_enabled) {\n                charging_enabled = false;\n                charging_disabled_time = millis();\n            }\n        }\n    } else {\n        // Retry enabling charging after a delay\n        if (millis() - charging_disabled_time >= CHARGING_RETRY_DELAY) {\n            if (checkShouldCharge()) {\n                charging_allowed = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 57.63784950968726}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                digitalWrite(CHARGE_ENABLE, HIGH);\n                charging_start_time = millis();\n            }\n        } else {\n            if (charging_enabled) {\n                charging_enabled = false;\n                digitalWrite(CHARGE_ENABLE, LOW);\n                charging_stop_time = millis();\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            digitalWrite(CHARGE_ENABLE, LOW);\n            charging_stop_time = millis();\n        } else {\n            if (millis() - charging_stop_time > CHARGING_RETRY_DELAY) {\n                charging_allowed = checkShouldCharge();\n            }\n        }\n    }\n}", "CodeBleu_score": 65.4718339476269}, {"code": "void updateChargingEnabled(){\n\t    if (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                charging_allowed_start_time = millis();\n            }\n        } else {\n            if (charging_enabled) {\n                charging_enabled = false;\n                charging_allowed_start_time = millis();\n            }\n        }\n    } else {\n        if (millis() - charging_allowed_start_time > CHARGING_RETRY_DELAY) {\n            if (checkShouldCharge()) {\n                charging_allowed = true;\n                charging_enabled = true;\n                charging_allowed_start_time = millis();\n            }\n        }\n    }\n}", "CodeBleu_score": 55.11167104545742}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_connected) {\n    if (size < 4) {\n      return;\n    }\n    uint16_t crc = calculateCRC(message, size - 2);\n    memcpy((uint8_t *)message + size - 2, &crc, 2);\n    packetSerial.send((uint8_t *)message, size);\n  }\n}", "CodeBleu_score": 48.78905501968001}, {"code": "void sendMessage(void *message, size_t size){\n\t  // Check if ROS is running\n  if (nh.connected()) {\n    // Check if message size is at least 4 bytes\n    if (size >= 4) {\n      // Calculate CRC for the message\n      uint16_t crc = crc16(message, size - 2);\n\n      // Append CRC to the message\n      uint8_t *ptr = (uint8_t *)message;\n      ptr[size - 2] = crc >> 8;\n      ptr[size - 1] = crc & 0xFF;\n\n      // Send the message\n      packetSerial.send(message, size);\n    }\n  }\n}", "CodeBleu_score": 60.092286140222264}, {"code": "void sendMessage(void *message, size_t size){\n\t  if (ros_connected && size >= 4) {\n    uint16_t crc = calculateCRC(message, size);\n    uint8_t *ptr = (uint8_t *)message + size;\n    ptr[0] = crc >> 8;\n    ptr[1] = crc & 0xFF;\n    packetSerial.send((uint8_t *)message, size + 2);\n  }\n}", "CodeBleu_score": 51.267784148535725}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t  Serial.begin(9600);\n  Serial.flush();\n  clearBuffer();\n  if (initSoundModule()) {\n    numSounds = getNumSounds();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 32.37996188930629}, {"code": "bool MP3Sound::begin(){\n\t  Serial.begin(9600);\n  Serial.flush();\n  clearBuffer();\n\n  if (initSound()) {\n    numSounds = getNumSounds();\n    if (numSounds > 0) {\n      return true;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 39.178332856832654}, {"code": "bool MP3Sound::begin(){\n\t  // Initialize the serial communication for the sound module\n  Serial.begin(9600);\n  Serial.flush();\n  delay(100);\n\n  // Clear any existing data in the buffer\n  while (Serial.available()) {\n    Serial.read();\n  }\n\n  // Initialize the sound module\n  sendCommand(0x3F, 0x00, 0x00);\n  delay(200);\n\n  // Retrieve the number of sound files available on the SD card\n  sendCommand(0x48, 0x00, 0x00);\n  delay(200);\n\n  // Check if there are one or more sound files available\n  if (Serial.available()) {\n    return true;\n  } else {\n    return false;\n  }\n}", "CodeBleu_score": 50.468385888414765}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t  if (activeSounds.size() == 0) {\n    return 0;\n  }\n\n  if (mp3.isPlaying()) {\n    return activeSounds.size();\n  }\n\n  String sound = activeSounds.back();\n  activeSounds.pop_back();\n\n  mp3.play(sound);\n\n  return activeSounds.size();\n}", "CodeBleu_score": 51.18505772385083}, {"code": "int MP3Sound::processSounds(){\n\t  if (numActiveSounds == 0) {\n    return 0;\n  }\n  if (mp3->isPlaying()) {\n    return numActiveSounds;\n  }\n  String sound = activeSounds.get(numActiveSounds - 1);\n  activeSounds.remove(numActiveSounds - 1);\n  numActiveSounds--;\n  mp3->play(sound);\n  return numActiveSounds;\n}", "CodeBleu_score": 48.00242332662739}, {"code": "int MP3Sound::processSounds(){\n\t    if (activeSounds.size() == 0) {\n        return 0;\n    }\n\n    if (mp3.isPlaying()) {\n        return activeSounds.size();\n    }\n\n    String sound = activeSounds.back();\n    activeSounds.pop_back();\n\n    mp3.play(sound);\n\n    return activeSounds.size();\n}", "CodeBleu_score": 50.64036856463737}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_cleanup_memory_mapped_file(camera);\n      wb_abstract_camera_set_memory_mapped_file(camera, r);\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 37.240069309996144}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (camera->file_name)\n      free(camera->file_name);\n    camera->file_name = wb_request_read_string(r);\n    camera->file_size = wb_request_read_int(r);\n    camera->file_descriptor = wb_request_read_int(r);\n    camera->file_pointer = wb_request_read_pointer(r);\n    camera->file_map_handle = wb_request_read_pointer(r);\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 42.164836829614195}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_cleanup_memory_mapped_file(d);\n      wb_abstract_camera_set_memory_mapped_file(d, r);\n      return true;\n    default:\n      r->command_handled = false;\n      return false;\n  }\n}", "CodeBleu_score": 40.55302336756538}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int h;\n  WbAbstractCamera *camera;\n  camera = wb_device_get_user_data(d);\n  wb_mutex_lock(&(camera->mutex));\n  h = camera->height;\n  wb_mutex_unlock(&(camera->mutex));\n  return h;\n}", "CodeBleu_score": 44.02641369849747}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height = -1;\n  if (d->data) {\n    AbstractCamera *ac = (AbstractCamera *)d->data;\n    pthread_mutex_lock(&ac->mutex);\n    height = ac->height;\n    pthread_mutex_unlock(&ac->mutex);\n  }\n  return height;\n}", "CodeBleu_score": 48.83701312466637}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t  int height;\n  wb_mutex_lock(&d->mutex);\n  if (d->data != NULL)\n    height = d->data[0];\n  else\n    height = -1;\n  wb_mutex_unlock(&d->mutex);\n  return height;\n}", "CodeBleu_score": 43.48979564109117}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period;\n  WbAccelerometer *accelerometer;\n\n  accelerometer = wb_accelerometer_get_device_pointer(tag);\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\n\", __FUNCTION__);\n    return -1;\n  }\n\n  pthread_mutex_lock(&accelerometer->mutex);\n  sampling_period = accelerometer->sampling_period;\n  pthread_mutex_unlock(&accelerometer->mutex);\n\n  return sampling_period;\n}", "CodeBleu_score": 49.36453238875926}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int period = -1;\n  WbAccelerometer *accelerometer;\n\n  wb_robot_mutex_lock();\n  accelerometer = wb_robot_get_accelerometer_with_tag(tag);\n  if (accelerometer)\n    period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s() called for an invalid device tag.\n\", __FUNCTION__);\n  wb_robot_mutex_unlock();\n\n  return period;\n}", "CodeBleu_score": 46.55100242365877}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t  int sampling_period = 0;\n  WbAccelerometer *accelerometer = wb_accelerometer_get_device(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s() called for an invalid device tag.\n\", __FUNCTION__);\n  }\n  return sampling_period;\n}", "CodeBleu_score": 48.50511386166791}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    std::string dmsString(dms);\n    free(dms);\n    return dmsString;\n}", "CodeBleu_score": 43.110020827080355}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}", "CodeBleu_score": 39.5819190193797}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t    // Convert the decimal degree value to DMS format\n    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\n    // Store the result in a std::string\n    string result(dms);\n\n    // Free the allocated memory\n    free(dms);\n\n    // Return the DMS string\n    return result;\n}", "CodeBleu_score": 39.86073057155409}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t  dVector3 p, n;\n  dReal d;\n  dGeomBoxGetLengths (g, n);\n  p[0] = x - dGeomGetPosition (g)[0];\n  p[1] = y - dGeomGetPosition (g)[1];\n  p[2] = z - dGeomGetPosition (g)[2];\n  d = dGeomBoxPointDepth (g, x, y, z);\n  if (fabs (p[0] - n[0]) < d) {\n    plane[0] = 1;\n    plane[1] = 0;\n    plane[2] = 0;\n    plane[3] = n[0];\n  }\n  else if (fabs (p[0] + n[0]) < d) {\n    plane[0] = -1;\n    plane[1] = 0;\n    plane[2] = 0;\n    plane[3] = -n[0];\n  }\n  else if (fabs (p[1] - n[1]) < d) {\n    plane[0] = 0;\n    plane[1] = 1;\n    plane[2] = 0;\n    plane[3] = n[1];\n  }\n  else if (fabs (p[1] + n[1]) < d) {\n    plane[0] = 0;\n    plane[1] = -1;\n    plane[2] = 0;\n    plane[3] = -n[1];\n  }\n  else if (fabs (p[2] - n[2]) < d) {\n    plane[0] = 0;\n    plane[1] = 0;\n    plane[2] = 1;\n    plane[3] = n[2];\n  }\n  else {\n    plane[0] = 0;\n    plane[1] = 0;\n    plane[2] = -1;\n    plane[3] = -n[2];\n  }\n}", "CodeBleu_score": 29.32964253443634}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t    dGeomBoxGetLengths(g, plane);\n    plane[3] = -dGeomBoxPointDepth(g, x, y, z);\n}", "CodeBleu_score": 9.51354111703695}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t  int result;\n  sBoxImmersionData data;\n\n  assert (box);\n  assert (box->body);\n  assert (flags & (dIMMERSE_BOX_FULL_IMMERSE | dIMMERSE_BOX_PARTIAL_IMMERSE));\n\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.immersion = immersion;\n  data.flags = flags;\n\n  result = dImmerseBoxInternal (&data);\n\n  return result;\n}", "CodeBleu_score": 45.31864527815607}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t", "CodeBleu_score": 7.193979290691487}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (o1 && o2);\n  dIASSERT (dGeomGetClass(o1) == dBoxClass);\n  dIASSERT (dGeomGetClass(o2) == dCapsuleClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  // Check if the box is in the fluid\n  dxBox *box = (dxBox *) o1;\n  dReal *fluidPlane = (dReal *) dGeomGetData(o2);\n  if (dBoxImmerse (box, fluidPlane, flags, immersion) < 0)\n    return -1;\n\n  // Check if the capsule is in the fluid\n  dReal *capsulePlane = (dReal *) dGeomGetData(o1);\n  if (dCapsuleImmerse (capsulePlane, fluidPlane, flags, immersion) < 0)\n    return -1;\n\n  // Check if the capsule is immersed in the fluid\n  return dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 51.87938894049977}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (o1->type == dBoxClass);\n  dIASSERT (o2->type == dCapsuleClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  dReal fluidPlane[4];\n  dReal p1[3], p2[3];\n  dReal r1, r2;\n  dReal r, rr;\n  dReal p[3], q[3];\n  dReal v[3];\n  dReal l;\n\n  // Get the immersion plane of the capsule.\n  dGeomCapsuleGetParams(o2, p1, p2, &r1, &r2);\n\n  // Compute the immersion plane of the capsule.\n  r = (r1 + r2) / 2.0;\n  rr = r1 * r1;\n  l = dGeomCapsulePointDepth (o2, p1);\n  dCopy (p1, p, 3);\n  dCopy (p2, q, 3);\n  dSubtractVectors3 (q, p, v);\n  dNormalize3 (v);\n  dScaleVector3 (v, l, v);\n  dAddVectors3 (p, v, p);\n  dSubtractVectors3 (p, capsule->pos, v);\n  dNormalize3 (v);\n  dCopy (v, fluidPlane, 3);\n  fluidPlane[3] = -dDOT (p, fluidPlane, 3);\n\n  // Perform immersion checking.\n  return dImmerseBox (box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 51.93656356657377}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t    dReal x0 = zIOverR * tanTheta0;\n    dReal x1 = zIOverR * sinTheta1;\n    dReal y0 = sqrt(zIOverR * zIOverR - x0 * x0);\n    dReal y1 = sqrt(zIOverR * zIOverR - x1 * x1);\n\n    dReal volume0 = (x0 * y0 + x1 * y1) * 0.5;\n    dReal volume1 = (x1 * y1 - x0 * y0) * 0.5;\n\n    return volume0 + volume1;\n}", "CodeBleu_score": 36.636203965718096}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t\n    // Define the function to be integrated\n    auto integrand = [=](dReal theta) {\n        dReal cosTheta = cos(theta);\n        dReal sinTheta = sin(theta);\n        dReal tanTheta = tanTheta0 * cosTheta + sinTheta1 * sinTheta;\n        dReal z = zIOverR * tanTheta;\n        dReal x = sqrt(1 - z * z);\n        dReal rho = sqrt(x * x + z * z);\n        dReal xBuoyancyCenter = x * rho;\n        return xBuoyancyCenter;\n    };\n\n    // Define the integration limits\n    dReal theta0 = 0;\n    dReal theta1 = M_PI / 2;\n\n    // Calculate the integral using Simpson's rule\n    int n = 1000; // number of subintervals\n    dReal h = (theta1 - theta0) / n;\n    dReal sum = integrand(theta0) + integrand(theta1);\n    for (int i = 1; i < n; i += 2) {\n        sum += 4 * integrand(theta0 + i * h);\n    }\n    for (int i = 2; i < n - 1; i += 2) {\n        sum += 2 * integrand(theta0 + i * h);\n    }\n    dReal integral = h / 3 * sum;\n\n    // Scale and adjust the result\n    dReal xBuoyancyCenter = volume / (2 * M_PI * radius) * integral;\n    return xBuoyancyCenter;\n}", "CodeBleu_score": 39.54605232294251}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t    // Calculate the buoyancy center of the hemisphere\n    dReal xBuoyancyCenter = 0.0;\n    dReal theta0 = atan(tanTheta0);\n    dReal theta1 = asin(sinTheta1);\n    dReal thetaStep = (theta1 - theta0) / (dReal) (nTheta - 1);\n    for (int i = 0; i < nTheta - 1; i++) {\n        dReal theta = theta0 + i * thetaStep;\n        dReal nextTheta = theta0 + (i + 1) * thetaStep;\n        dReal sinTheta = sin(theta);\n        dReal nextSinTheta = sin(nextTheta);\n        dReal cosTheta = cos(theta);\n        dReal nextCosTheta = cos(nextTheta);\n        dReal x0 = r * sinTheta * (zIOverR - cosTheta);\n        dReal x1 = r * nextSinTheta * (zIOverR - nextCosTheta);\n        dReal y0 = r * cosTheta;\n        dReal y1 = r * nextCosTheta;\n        dReal area = 0.5 * (x0 * y1 - x1 * y0);\n        dReal xCenter = 0.5 * (x0 + x1);\n        xBuoyancyCenter += area * xCenter;\n    }\n    return xBuoyancyCenter / volume;\n}", "CodeBleu_score": 38.350782665846886}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 4.191970305576363}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT (dGeomGetClass(o1) == dCapsuleClass);\n  dIASSERT (dGeomGetClass(o2) == dTriMeshClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(dGeomGetBody(o1), \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 37.463780745310046}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This trimesh has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.839010216173904}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t  getInput(\"sleep_duration_ms\", sleep_duration_ms_);\n\n  if (sleep_duration_ms_ <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n  timer_ = std::make_shared<rclcpp::TimerBase>(\n    getNode()->get_clock(),\n    [this]() {\n      timer_waiting_ = false;\n      emitWakeUpSignal(\"wakeup\");\n    },\n    std::chrono::milliseconds(sleep_duration_ms_));\n\n  getNode()->get_clock()->add_timer(timer_, nullptr);\n\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 56.13313656567222}, {"code": "NodeStatus SleepNode::onStart(){\n\t  int64_t sleep_ms = 0;\n  if (!getInput(\"sleep_ms\", sleep_ms)) {\n    return NodeStatus::SUCCESS;\n  }\n  if (sleep_ms <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n  timer_ = node_->create_wall_timer(std::chrono::milliseconds(sleep_ms), [this]() {\n    timer_waiting_ = false;\n    emitWakeUpSignal();\n  });\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 60.402363821072015}, {"code": "NodeStatus SleepNode::onStart(){\n\t  auto duration_ms = getInput<int>(\"duration_ms\");\n  if (!duration_ms) {\n    return NodeStatus::SUCCESS;\n  }\n  if (*duration_ms <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_.start(std::chrono::milliseconds(*duration_ms));\n  timer_.setCallback([this]() {\n    timer_.stop();\n    timer_waiting_ = false;\n    emitWakeUpSignal();\n  });\n  if (timer_waiting_) {\n    timer_.stop();\n    timer_waiting_ = false;\n  }\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 56.098904710174565}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t    auto entry = blackboard()->get<int>(key_);\n    std::lock_guard<std::mutex> lock(entry->mutex);\n    if (entry->seq_num != last_seq_num_) {\n        last_seq_num_ = entry->seq_num;\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 31.6262020586871}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  std::unique_lock<std::mutex> lock(blackboard_mutex_);\n  auto entry = blackboard_->get<EntryType>(entry_name_);\n  if (entry) {\n    if (entry->sequence_id != last_sequence_id_) {\n      last_sequence_id_ = entry->sequence_id;\n      lock.unlock();\n      return NodeStatus::SUCCESS;\n    }\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 38.25994293611645}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t  auto entry = blackboard()->get<int>(key_);\n  if (entry) {\n    std::lock_guard<std::mutex> lock(entry->mutex);\n    if (entry->seq_num != seq_num_) {\n      seq_num_ = entry->seq_num;\n      return NodeStatus::SUCCESS;\n    }\n  }\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 32.33335557069187}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t    size_t threshold = static_cast<size_t>(m_successThreshold);\n    if (threshold < 0) {\n        threshold = m_children.size() - static_cast<size_t>(-threshold);\n    }\n    return threshold;\n}", "CodeBleu_score": 47.92427910271615}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (m_successThreshold < 0) {\n        return std::max(0, static_cast<int>(m_children.size()) + m_successThreshold);\n    }\n    return static_cast<size_t>(m_successThreshold);\n}", "CodeBleu_score": 54.537240352711656}, {"code": "size_t ParallelNode::successThreshold() const{\n\t    if (m_successThreshold < 0) {\n        return std::max(0, static_cast<int>(m_children.size()) + m_successThreshold);\n    }\n    return static_cast<size_t>(m_successThreshold);\n}", "CodeBleu_score": 54.537240352711656}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    if (std::chrono::steady_clock::now() - _p->last_heartbeat > std::chrono::milliseconds(2000)) {\n      std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n      if (_p->heartbeat_active) {\n        _p->heartbeat_active = false;\n        _p->enableAllHooks(false);\n      }\n    }\n  }\n}", "CodeBleu_score": 37.38192196553259}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n        if (_p->heartbeat_active) {\n            auto now = std::chrono::steady_clock::now();\n            if (now - _p->last_heartbeat > std::chrono::seconds(1)) {\n                _p->heartbeat_active = false;\n                enableAllHooks(false);\n            }\n        }\n    }\n}", "CodeBleu_score": 43.95709750120959}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t    while(true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        if (_p->heartbeat_active != _p->heartbeat_ok) {\n            _p->heartbeat_active = _p->heartbeat_ok;\n            enableAllHooks(_p->heartbeat_active);\n        }\n    }\n}", "CodeBleu_score": 31.7496793248993}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    // Split the input string of blackboard names into a vector of strings\n    std::vector<std::string> bb_names = split(bb_list, ',');\n\n    // Create a JSON object to store the blackboards\n    json blackboards;\n\n    // Iterate through the blackboard names\n    for (const std::string& bb_name : bb_names) {\n        // Find the corresponding subtree and lock it\n        std::lock_guard<std::mutex> lock(mutex_);\n        auto subtree = tree_.getSubTree(bb_name);\n\n        // Check if the subtree is valid\n        if (subtree) {\n            // Export the blackboard to JSON\n            json j = subtree->exportAsJSON();\n\n            // Add the JSON to the blackboards object\n            blackboards[bb_name] = j;\n        }\n    }\n\n    // Convert the JSON object to MessagePack format\n    std::vector<uint8_t> msgpack_dump = json::to_msgpack(blackboards);\n\n    return msgpack_dump;\n}", "CodeBleu_score": 49.42981010842584}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    // Split the input string of blackboard names into a vector of names\n    std::vector<std::string> bb_names = split(bb_list, ',');\n\n    // Create a JSON object to store the blackboards\n    json j;\n\n    // Iterate through the blackboard names\n    for (const std::string& bb_name : bb_names) {\n        // Find the corresponding subtree\n        auto subtree = blackboard_tree.find(bb_name);\n        if (subtree == blackboard_tree.end()) {\n            // If the subtree is not found, skip to the next blackboard\n            continue;\n        }\n\n        // Lock the subtree\n        std::lock_guard<std::mutex> lock(subtree->second.second);\n\n        // Export the blackboard to JSON\n        json bb_json = subtree->second.first.export_json();\n\n        // Add the blackboard JSON to the JSON object\n        j[bb_name] = bb_json;\n    }\n\n    // Convert the JSON object to MessagePack format\n    std::vector<uint8_t> msgpack_data = json::to_msgpack(j);\n\n    return msgpack_data;\n}", "CodeBleu_score": 49.24757638714073}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t    std::vector<std::string> bb_names;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        bb_names.push_back(bb_name);\n    }\n\n    std::vector<uint8_t> msgpack_dump;\n    json blackboards;\n\n    for (const auto& bb_name : bb_names) {\n        auto subtree = blackboard::Blackboard::getInstance().getTree(bb_name);\n        if (subtree) {\n            std::lock_guard<std::recursive_mutex> lock(subtree->mutex);\n            auto json_bb = subtree->exportToJson();\n            blackboards[bb_name] = json_bb;\n        }\n    }\n\n    if (!blackboards.empty()) {\n        msgpack::pack(msgpack_dump, blackboards);\n    }\n\n    return msgpack_dump;\n}", "CodeBleu_score": 45.30312089315074}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if(!hook) {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->mode == HookMode::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 47.239420313717886}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if(!hook)\n    return false;\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if (hook->status == NodeStatus::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 42.97227888015575}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\t  auto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status == NodeStatus::BREAKPOINT)\n  {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 47.33739201696773}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n    auto future = std::async(std::launch::async, [this]() {\n      try {\n        tick();\n      } catch (std::exception& ex) {\n        this->setStatus(NodeStatus::FAILURE);\n        halt_requested_.store(true);\n        throw ex;\n      }\n    });\n  }\n\n  if (!halt_requested_ && prev_status == NodeStatus::RUNNING) {\n    if (future_.wait_for(std::chrono::milliseconds(1)) == std::future_status::ready) {\n      try {\n        future_.get();\n      } catch (std::exception& ex) {\n        this->setStatus(NodeStatus::FAILURE);\n        halt_requested_.store(true);\n        throw ex;\n      }\n    }\n  }\n\n  if (halt_requested_) {\n    setStatus(NodeStatus::IDLE);\n  }\n\n  return status();\n}", "CodeBleu_score": 50.18762672819038}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_.store(false);\n\n    // Launch a new asynchronous thread to run the tick function\n    std::thread thread([this]() {\n      try {\n        // Run the tick function\n        NodeStatus status = tick_functor_(*this);\n        if (!halt_requested_ && status != prev_status) {\n          setStatus(status);\n        }\n      } catch (const std::exception& e) {\n        // Log the error and set the node status to IDLE\n        std::cerr << \"Exception thrown from ThreadedAction tick function: \" << e.what() << std::endl;\n        setStatus(NodeStatus::IDLE);\n      }\n    });\n\n    // Detach the thread to allow it to run independently\n    thread.detach();\n  }\n\n  // Check for any stored exceptions\n  if (exception_ptr_) {\n    std::rethrow_exception(exception_ptr_);\n  }\n\n  return status();\n}", "CodeBleu_score": 47.20883609536509}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\t  NodeStatus prev_status = status();\n\n  if (prev_status == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  try {\n    halt_requested_.store(false);\n    std::future<NodeStatus> future = std::async(std::launch::async, [this]() {\n      return tick_functor_(*this);\n    });\n\n    while (future.wait_for(std::chrono::milliseconds(10)) == std::future_status::timeout) {\n      if (halt_requested_.load()) {\n        future.wait();\n        return NodeStatus::IDLE;\n      }\n    }\n\n    NodeStatus status = future.get();\n    if (status != prev_status) {\n      setStatus(status);\n    }\n    return status;\n  }\n  catch (std::exception& ex) {\n    BT_ROS_ERROR(\"ThreadedAction::executeTick() failed with exception %s\", ex.what());\n    setStatus(NodeStatus::IDLE);\n  }\n\n  if (std::current_exception()) {\n    std::rethrow_exception(std::current_exception());\n  }\n\n  return status();\n}", "CodeBleu_score": 50.26109124740616}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    static const std::string line_separator = \"_____________________________________________________________________\n\";\n    stream << line_separator;\n    std::function<void(const TreeNode*, int)> printTree;\n    printTree = [&](const TreeNode* node, int indent) {\n        for (int i = 0; i < indent; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n        if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children()) {\n                printTree(child, indent + 1);\n            }\n        }\n        else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            printTree(decorator_node->child(), indent + 1);\n        }\n    };\n    printTree(root_node, 0);\n    stream << line_separator;\n}", "CodeBleu_score": 55.12728489555728}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t    auto printTree = [&](const TreeNode* node, int depth) {\n        if (!node) {\n            return;\n        }\n        for (int i = 0; i < depth; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n        if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children()) {\n                printTree(child, depth + 1);\n            }\n        }\n        else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            printTree(decorator_node->child(), depth + 1);\n        }\n    };\n\n    stream << std::endl;\n    stream << \"----------------\" << std::endl;\n    printTree(root_node, 0);\n    stream << \"----------------\" << std::endl;\n}", "CodeBleu_score": 61.445271696009264}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t  static const char* g_separator = \"--------------------------------\";\n  stream << g_separator << \"\n\";\n\n  std::function<void(const TreeNode*, int)> printTabs = [&](const TreeNode* node, int depth) {\n    for (int i = 0; i < depth; ++i) {\n      stream << \"  \";\n    }\n    stream << node->name() << \"\n\";\n    if (auto decorator = dynamic_cast<const DecoratorNode*>(node)) {\n      printTabs(decorator->child(), depth + 1);\n    } else if (auto control = dynamic_cast<const ControlNode*>(node)) {\n      for (const auto& child : control->children()) {\n        printTabs(child, depth + 1);\n      }\n    }\n  };\n  printTabs(root_node, 0);\n  stream << g_separator << \"\n\";\n}", "CodeBleu_score": 50.25796294609724}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 93.0591372626442}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  // Check if the node is null\n  if (!node) {\n    // If the node is null, throw a LogicError\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  // Apply the visitor function to the given node\n  visitor(node);\n\n  // Check if the node is a ControlNode\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    // If the node is a ControlNode, recursively apply the visitor to all its children\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  // Check if the node is a DecoratorNode\n  else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    // If the node is a DecoratorNode, recursively apply the visitor to its single child\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 93.29851200285084}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t  if (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 93.0591372626442}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  // Check if the registration ID already exists in the builders map\n  if (builders_.count(manifest.registration_ID) > 0) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n\n  // Insert the builder and manifest into their respective maps\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 59.51566371880287}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  auto it = builders_.find(manifest.registration_ID);\n  if (it != builders_.end()) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                 \"] already registered\");\n  }\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 70.15157667078209}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t  if (builders_.count(manifest.registration_ID) != 0) {\n    auto tmp = std::string(\"Mismatching Builder registration. A builder with ID [\") +\n               manifest.registration_ID + \"] already exists\";\n    throw BehaviorTreeException(tmp);\n  }\n\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}", "CodeBleu_score": 52.056954063534874}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = std::move(ports);\n  manifest.registration_ID = ID;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 68.30458138938171}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = std::move(ports);\n  manifest.registration_ID = ID;\n\n  registerBuilder(manifest, std::move(builder));\n}", "CodeBleu_score": 75.21347618499416}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t  auto builder = [tick_functor, ports](const std::string& name, const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = std::move(ports);\n  manifest.registration_ID = ID;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 69.60484656606968}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.GetChildren().size());\n    for (const auto& subtree : tree.GetChildren()) {\n        Blackboard::Ptr backup = Blackboard::Create();\n        *backup = *subtree->blackboard_;\n        backups.push_back(std::move(backup));\n    }\n    return backups;\n}", "CodeBleu_score": 52.03443883399306}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.subtrees.size());\n\n    for (const auto& subtree : tree.subtrees) {\n        Blackboard::Ptr backup = std::make_shared<Blackboard>();\n        *backup = *subtree.blackboard;\n        backups.push_back(backup);\n    }\n\n    return backups;\n}", "CodeBleu_score": 56.02120078605197}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.GetChildren().size());\n    for (const auto& subtree : tree.GetChildren()) {\n        Blackboard::Ptr backup = Blackboard::Create();\n        *backup = *subtree->GetBlackboard();\n        backups.push_back(std::move(backup));\n    }\n    return backups;\n}", "CodeBleu_score": 52.16762211465085}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t    auto executor = ParseScript(script);\n    if (executor) {\n        return executor.value()(env);\n    } else {\n        return nonstd::make_unexpected(executor.error());\n    }\n}", "CodeBleu_score": 92.72121218184945}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (executor.has_value()) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 87.52241845705038}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t  auto executor = ParseScript(script);\n  if (executor.has_value()) {\n    return executor.value()(env);\n  } else {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 87.52241845705038}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex_);\n    if (handle_) {\n        throw std::runtime_error(\"Library is already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        std::string error_message = dlerror();\n        throw std::runtime_error(\"Failed to load library: \" + error_message);\n    }\n    path_ = path;\n}", "CodeBleu_score": 58.572652557856976}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::lock_guard<std::mutex> lock(mutex_);\n\n    if (handle_ != nullptr) {\n        throw std::runtime_error(\"Library already loaded\");\n    }\n\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        std::string error = dlerror();\n        throw std::runtime_error(\"Failed to load library: \" + error);\n    }\n\n    path_ = path;\n}", "CodeBleu_score": 56.61333270834611}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t    std::unique_lock<std::mutex> lock(mutex_);\n    if (handle_ != nullptr) {\n        throw std::runtime_error(\"Library is already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        std::string error_message = dlerror();\n        throw std::runtime_error(\"Failed to load library: \" + error_message);\n    }\n    path_ = path;\n}", "CodeBleu_score": 56.449747254194136}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    const char* start = str.data();\n    const char* end = start + str.length();\n    start = std::find_if_not(start, end, isSpace);\n    if (start == end) {\n        return false;\n    }\n    if (*start != '{') {\n        return false;\n    }\n    if (*(end - 1) != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = StringView(start + 1, end - 1);\n    }\n    return true;\n}", "CodeBleu_score": 32.896380745175826}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t  if (str.length() < 3) {\n    return false;\n  }\n\n  StringView stripped = strip(str);\n\n  if (stripped[0] != '{' || stripped[stripped.length() - 1] != '}') {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = stripped.substr(1, stripped.length() - 2);\n  }\n\n  return true;\n}", "CodeBleu_score": 25.369600282528904}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t    // Check if the string is at least 3 characters long\n    if (str.length() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces\n    StringView stripped_str = str.strip();\n\n    // Check if the stripped string starts with '{' and ends with '}'\n    if (stripped_str.front() == '{' && stripped_str.back() == '}') {\n        // Assign the inner content to stripped_pointer if provided\n        if (stripped_pointer) {\n            *stripped_pointer = stripped_str.substr(1, stripped_str.length() - 2);\n        }\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 26.44666267808955}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    //Bresenham Ray-Tracing\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for( LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance() )\n    {\n        point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n        if(point_cost < 0)\n            return point_cost;\n\n        if(line_cost < point_cost)\n            line_cost = point_cost;\n    }\n\n    return line_cost;\n\n  }", "CodeBleu_score": 97.44752956296851}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    //Bresenham Ray-Tracing\n    int dx = abs(x1-x0), sx = x0<x1 ? 1 : -1;\n    int dy = abs(y1-y0), sy = y0<y1 ? 1 : -1;\n    int err = (dx>dy ? dx : -dy)/2, e2;\n\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for(;;){\n      point_cost = pointCost(x0, y0);\n      if(point_cost < 0)\n        return point_cost;\n\n      if(x0 == x1 && y0 == y1)\n        return line_cost;\n      e2 = err;\n      if(e2 >-dx) { err -= dy; x0 += sx; }\n      if(e2 < dy) { err += dx; y0 += sy; }\n      line_cost += point_cost;\n    }\n  }", "CodeBleu_score": 52.62588108270037}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t    //Bresenham Ray-Tracing\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for( LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance() )\n    {\n        point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n        if(point_cost < 0)\n            return point_cost;\n\n        if(line_cost < point_cost)\n            line_cost = point_cost;\n    }\n\n    return line_cost;\n\n}", "CodeBleu_score": 97.59555331231357}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t    if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses = path;\n\n    pub.publish(gui_path);\n}", "CodeBleu_score": 55.500665252456706}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses = path;\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 54.82818340954479}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t  if (path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses = path;\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 55.164768362233744}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.z) <= trans_stopped_velocity;\n}", "CodeBleu_score": 88.22393267180335}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.50765311307872}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}", "CodeBleu_score": 98.48708768338908}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::recursive_mutex::scoped_lock l(configuration_mutex_);\n  limits_ = config;\n}", "CodeBleu_score": 79.99472003930074}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t  if (setup_) {\n    if (restore_defaults) {\n      config = default_limits_;\n    }\n    boost::recursive_mutex::scoped_lock l(configuration_mutex_);\n    current_limits_ = config;\n  } else {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  // dynamic reconfigure server\n  boost::recursive_mutex::scoped_lock l(configuration_mutex_);\n  current_limits_ = config;\n}", "CodeBleu_score": 64.54674868709785}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= lethal_cost_ || cell_cost == unknown_cost_) {\n    if (!current_cell->target_dist) {\n      current_cell->target_dist = obstacleCosts();\n    }\n    return false;\n  }\n  double new_target_dist = current_cell->target_dist +\n      distance(current_cell->cx, current_cell->cy, check_cell->cx, check_cell->cy);\n  if (!current_cell->target_dist || new_target_dist < current_cell->target_dist) {\n    current_cell->target_dist = new_target_dist;\n  }\n  return true;\n}", "CodeBleu_score": 61.227955606815684}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t    unsigned int cell_cost = costmap.getCost(check_cell->x, check_cell->y);\n    if (cell_cost == costmap_2d::LETHAL_OBSTACLE ||\n        cell_cost == costmap_2d::NO_INFORMATION) {\n        check_cell->target_dist = obstacleCosts();\n        return false;\n    }\n    double new_target_dist = distance(current_cell->x, current_cell->y, check_cell->x, check_cell->y);\n    if (new_target_dist < check_cell->target_dist) {\n        check_cell->target_dist = new_target_dist;\n    }\n    return true;\n}", "CodeBleu_score": 74.39820829542944}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t    unsigned int cell_cost = costmap.getCost(check_cell->x, check_cell->y);\n    if (cell_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n        check_cell->target_dist = obstacleCosts();\n        return false;\n    }\n\n    double new_target_dist = distance(current_cell->x, current_cell->y,\n                                        check_cell->x, check_cell->y);\n    new_target_dist += current_cell->target_dist;\n    if (new_target_dist < check_cell->target_dist) {\n        check_cell->target_dist = new_target_dist;\n    }\n    return true;\n}", "CodeBleu_score": 70.97703162711696}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint()?\");\n    return -9;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double p_x = traj.getPoint(i).x;\n    double p_y = traj.getPoint(i).y;\n    double p_th = 0;\n\n    if (!traj.getPoint(i).valid()) {\n      ROS_WARN(\"Trajectory point invalid.\");\n      return -8;\n    }\n\n    double footprint_cost = footprintCost(p_x, p_y, p_th, scale, footprint_spec_, costmap_, world_model_);\n\n    if (footprint_cost < 0) {\n      return -6;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 73.59231597445198}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    //nothing we can do... without knowing the robot's footprint...\n    ROS_ERROR(\"Footprint spec is empty...\");\n    return -9;\n  }\n\n  //footprint spec is padded with zeros to match costmap_2d's format\n  unsigned int cell_x, cell_y;\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double f_cost = footprintCost(traj.xv_ * i, traj.yv_ * i, traj.thetav_ * i, scale, footprint_spec_, costmap_, world_model_);\n\n    if (f_cost < 0) {\n      return f_cost;\n    }\n\n    if (sum_scores_) {\n      cost += f_cost;\n    } else {\n      cost = std::max(cost, f_cost);\n    }\n  }\n  return cost;\n}", "CodeBleu_score": 68.28125980919279}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n    double cos_th = cos (th);\n    double sin_th = sin (th);\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point new_pt;\n        new_pt.x = x + (footprint_spec[i].x * cos_th - footprint_spec[i].y * sin_th) * scale;\n        new_pt.y = y + (footprint_spec[i].x * sin_th + footprint_spec[i].y * cos_th) * scale;\n        oriented_footprint.push_back (new_pt);\n    }\n\n    geometry_msgs::Point robot_position;\n    robot_position.x = x;\n    robot_position.y = y;\n    double footprint_cost = world_model->footprintCost (robot_position, oriented_footprint,\n                                                          costmap->getInscribedRadius(), costmap->getCircumscribedRadius());\n\n    //if footprint costs are negative, robot is inside an obstacle\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n\n    //if footprint costs are positive, and not too high, apply potential\n    if (footprint_cost < costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n        return footprint_cost;\n    }\n\n    //if we've reached this point, the footprint cost wasnt below the inscribed radius\n    //we need to return a value that is between the inscribed radius and the costmap's inscribed radius\n    return costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n}", "CodeBleu_score": 62.15277071278054}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if ( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n    if ( odom_topic_ == \"\" ) {\n      sub_.shutdown();\n    } else {\n      ros::NodeHandle gn;\n      sub_ = gn.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n          boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    }\n  }\n}", "CodeBleu_score": 62.72254052198851}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if ( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n\n    if ( odom_topic_ == \"\" ) {\n      sub_.shutdown();\n    } else {\n      ros::NodeHandle gn;\n      sub_ = gn.subscribe<nav_msgs::Odometry>( odom_topic_, 1, &OdometryHelperRos::odomCallback, this );\n    }\n  }\n}", "CodeBleu_score": 63.753190134875595}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t  if ( odom_topic != odom_topic_ ) {\n    odom_topic_ = odom_topic;\n\n    if ( odom_topic_ == \"\" ) {\n      if (odom_sub_) {\n        odom_sub_.shutdown();\n      }\n      return;\n    }\n\n    if (odom_sub_) {\n      odom_sub_.shutdown();\n    }\n\n    ROS_INFO(\"subscribing to %s\", odom_topic_.c_str());\n    odom_sub_ = gnh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n        boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    odom_sub_ = gnh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n        boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n  }\n}", "CodeBleu_score": 56.01710231584246}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n  }\n\n  double angle = acos( (pos.dot(prev)) / (pos.norm() * prev.norm()) );\n  if (last_oscillation_reset_ + oscillation_reset_angle_ < angle) {\n    resetOscillationFlags();\n    last_oscillation_reset_ = angle;\n  }\n}", "CodeBleu_score": 44.30164971833362}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n\n  // if the distance moved is small then we can assume its a\n  // \"skidding\" behavior.\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    resetOscillationFlags();\n    return;\n  }\n\n  double sq_angle = fabs(angles::shortest_angular_distance(yaw(pos), yaw(prev)));\n\n  if (sq_angle < oscillation_reset_angle_) {\n    resetOscillationFlags();\n    return;\n  }\n}", "CodeBleu_score": 42.16337820390113}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t  double sq_dist = (pos - prev).squaredNorm();\n  if (sq_dist < oscillation_reset_dist_sq_) {\n    return;\n  }\n\n  double angle = atan2(pos[1] - prev[1], pos[0] - prev[0]);\n  if (fabs(angle - prev_angle_) > oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 49.89500711106696}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    //get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //check if the point is outside the grid bounds\n    if(gx >= width_ || gy >= height_)\n      return;\n\n    //check if the point is too close to its nearest neighbor\n    double sq_dist = nearestNeighborDistance(pt);\n    if(sq_dist < sq_min_separation_)\n      return;\n\n    //get the index of the cell\n    unsigned int index = gy * width_ + gx;\n\n    //insert the point into the corresponding cell\n    grid_[index].push_back(pt);\n  }", "CodeBleu_score": 66.32529514430131}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t  //get the grid coordinates of the point\n  unsigned int gx, gy;\n\n  gridCoords(pt, gx, gy);\n\n  //check if the point is too close to its nearest neighbor\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n\n  //calculate the grid index\n  unsigned int index = gy * width_ + gx;\n\n  //insert the point into the corresponding cell\n  grid_[index].push_back(pt);\n}", "CodeBleu_score": 73.6781181319748}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t    //get the grid coordinates of the point\n    unsigned int gx, gy;\n    gridCoords(pt, gx, gy);\n\n    //check if the point is outside the grid bounds\n    if(gx >= width_ || gy >= height_)\n        return;\n\n    //check if the point is too close to its nearest neighbor\n    if(nearestNeighborDistance(pt) < sq_min_separation_)\n        return;\n\n    //calculate the grid index\n    unsigned int index = gy * width_ + gx;\n\n    //insert the point into the corresponding cell\n    cells_[index].push_back(pt);\n}", "CodeBleu_score": 73.50543893220312}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel;\n    new_vel << 0, 0, 0;\n\n    for (int i = 0; i < 3; i++) {\n        if (vel[i] < sample_target_vel[i]) {\n            new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n        } else {\n            new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n        }\n    }\n\n    return new_vel;\n}", "CodeBleu_score": 89.45545270244503}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel;\n    new_vel << 0, 0, 0;\n\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n        } else {\n            new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n        }\n    }\n\n    return new_vel;\n}", "CodeBleu_score": 86.70289915045173}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t    Eigen::Vector3f new_vel;\n    new_vel[0] = computeNewVelocity(sample_target_vel[0], vel[0], acclimits[0], dt);\n    new_vel[1] = computeNewVelocity(sample_target_vel[1], vel[1], acclimits[1], dt);\n    new_vel[2] = computeNewVelocity(sample_target_vel[2], vel[2], acclimits[2], dt);\n    return new_vel;\n}", "CodeBleu_score": 37.50977300494293}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t", "CodeBleu_score": 3.717784580155612}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    int x_cell = global_plan_[i].pose.position.x / cell_size_;\n    int y_cell = global_plan_[i].pose.position.y / cell_size_;\n    double goal_x = x_cell * cell_size_ + cell_size_ / 2;\n    double goal_y = y_cell * cell_size_ + cell_size_ / 2;\n    double goal_heading = atan2(goal_y - y, goal_x - x);\n    double diff = fabs(angles::shortest_angular_distance(heading, goal_heading));\n    if (diff <= heading_diff_threshold_) {\n      // Convert goal cell coordinates to world coordinates\n      double goal_x_world = goal_x * cell_size_;\n      double goal_y_world = goal_y * cell_size_;\n      return fabs(angles::shortest_angular_distance(heading, atan2(goal_y_world - y, goal_x_world - x)));\n    }\n  }\n  return DBL_MAX;\n}", "CodeBleu_score": 56.69360923148348}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t  int i = global_plan_.size() - 1;\n  int x_cell, y_cell;\n  double x_world, y_world;\n  double heading_world;\n  while (i >= 0) {\n    mapToWorld(global_plan_[i].x, global_plan_[i].y, x_world, y_world);\n    if (lineCost(cell_x, x_cell, cell_y, y_cell) >= 0) {\n      heading_world = atan2(y_world - y, x_world - x);\n      return fabs(angles::shortest_angular_distance(heading, heading_world));\n    }\n    i--;\n  }\n  return DBL_MAX;\n}", "CodeBleu_score": 55.436671979321304}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n          vtheta_samp, cost);\n      return false;\n    }\n\n    return true;\n  }", "CodeBleu_score": 85.50632450639611}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n          vtheta_samp, cost);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 85.50632450639611}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp,\n          vtheta_samp, cost);\n      return false;\n    }\n\n    return true;\n  }", "CodeBleu_score": 85.50632450639611}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s to unstuck\", (affected_maps_ & GLOBAL) ? \"global\" : \"\",\n           (affected_maps_ & LOCAL) ? \"/local\" : \"\");\n\n  clear(global_costmap_);\n  if (affected_maps_ & LOCAL) {\n    clear(local_costmap_);\n  }\n\n  ROS_INFO(\"Recovery behavior complete.\");\n}", "CodeBleu_score": 31.192997495356252}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s to unstuck\", (affected_maps_ == CostmapClearBehavior::GLOBAL_COSTMAP) ? \"global\" : \"local\",\n           (affected_maps_ == CostmapClearBehavior::BOTH_COSTMAPS) ? \"s\" : \"\");\n\n  if (affected_maps_ == CostmapClearBehavior::GLOBAL_COSTMAP) {\n    clear(global_costmap_);\n  } else if (affected_maps_ == CostmapClearBehavior::LOCAL_COSTMAP) {\n    clear(local_costmap_);\n  } else if (affected_maps_ == CostmapClearBehavior::BOTH_COSTMAPS) {\n    clear(global_costmap_);\n    clear(local_costmap_);\n  }\n\n  if (force_update_) {\n    ROS_WARN(\"Forcing costmap update\");\n    global_costmap_->updateMap();\n    local_costmap_->updateMap();\n  }\n\n  ROS_WARN(\"Recovery behavior complete\");\n}", "CodeBleu_score": 52.20034406697791}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\t  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s to unstuck robot\",\n      (affected_maps_ & costmap_2d::Costmap2DROS::GLOBAL_COSTMAP) ? \"global\" : \"\",\n      (affected_maps_ & costmap_2d::Costmap2DROS::LOCAL_COSTMAP) ? \" and local\" : \"\");\n\n  if (affected_maps_ & costmap_2d::Costmap2DROS::GLOBAL_COSTMAP) {\n    clear(global_costmap_);\n  }\n  if (affected_maps_ & costmap_2d::Costmap2DROS::LOCAL_COSTMAP) {\n    clear(local_costmap_);\n  }\n\n  ROS_INFO(\"Recovery behavior complete.\");\n}", "CodeBleu_score": 36.96532464129712}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n  polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 93.34364503767658}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n\n  polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 93.34364503767658}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t    PolygonOutlineCells cell_gatherer(*this);\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(&cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n    }\n    if (!polygon.empty()) {\n        unsigned int last_index = polygon.size() - 1;\n        // we also need to close the polygon by going from the last point to the first\n        raytraceLine(&cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n    }\n\n    polygon_cells = cell_gatherer.getCells();\n}", "CodeBleu_score": 85.77010741311727}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  ROS_DEBUG(\"Checking for new subscribers\");\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 67.311593696568}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  ROS_DEBUG(\"Someone subscribed to costmap\");\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 67.17876295792209}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t  ROS_DEBUG(\"Checking for new subscribers\");\n  prepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 67.311593696568}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t  // Lock the costmap mutex\n  boost::unique_lock < boost::recursive_mutex > lock(*(costmap_->getMutex()));\n\n  // Get the resolution of the costmap\n  double resolution = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.frame_id = \"map\";\n  grid_.header.stamp = ros::Time::now();\n\n  // Set the grid's resolution, width, and height\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n\n  // Set the origin's position and orientation\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = wx;\n  origin_y_ = wy;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    // Use a translation table to convert the costmap values to OccupancyGrid values\n    grid_.data[i] = TRANSLATION_TABLE[data[i]];\n  }\n}", "CodeBleu_score": 88.88965753478608}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t    boost::unique_lock<boost::recursive_mutex> lock(*(costmap_->getMutex()));\n    double resolution = costmap_->getResolution();\n    grid_.header.stamp = ros::Time::now();\n    grid_.header.frame_id = \"map\";\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n    unsigned char* data = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); i++) {\n        grid_.data[i] = cost_translation_table_[ data[i] ];\n    }\n}", "CodeBleu_score": 72.269522732887}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t  boost::unique_lock < boost::recursive_mutex > lock(*costmap_->getMutex());\n  double resolution = costmap_->getResolution();\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = global_frame_;\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    if (data[i] == 0)\n      grid_.data[i] = -1;\n    else\n      grid_.data[i] = 100 * (data[i] - 1);\n  }\n}", "CodeBleu_score": 85.4265152513845}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  // First, we need to check if the footprint has changed.\n  if (new_config.footprint == old_config.footprint)\n    return;\n\n  // Next, we check if the footprint parameter is empty.\n  if (new_config.footprint == \"\") {\n    // If the footprint parameter is empty, we need to set the footprint based on the robot radius.\n    setUnpaddedRobotFootprintPolygon(new_config.footprint_padding, new_config.footprint_radius);\n  } else {\n    // If the footprint parameter is not empty, we need to parse the string and set the footprint.\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n    } else {\n      ROS_ERROR(\"The footprint parameter does not seem to be set, \"\n                \"will keep the previous one.\");\n    }\n  }\n}", "CodeBleu_score": 61.31594134437244}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  // Validate the footprint string\n  std::vector<geometry_msgs::Point> new_footprint;\n  if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n    setUnpaddedRobotFootprint(new_footprint);\n  } else {\n    ROS_ERROR(\"The footprint parameter is not set or specified in the wrong format. \"\n              \"Footprint must be specified as list of 3D points in the footprint parameter. \"\n              \"In the case of a circular robot, radius alone is specified.\");\n  }\n}", "CodeBleu_score": 59.795607500268474}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n      setUnpaddedRobotFootprint(new_footprint);\n    } else {\n      ROS_ERROR(\"Planner will always fail because footprint parameter is not set and cannot be retrieved from the parameter server by footprint_from_param.\");\n    }\n  } else {\n    // get the footprint from the parameter server\n    geometry_msgs::PointStamped footprint_point;\n    if (getRobotFootprint(footprint_point)) {\n      std::vector<geometry_msgs::Point> footprint_polygon;\n      toPolygon(footprint_point, footprint_polygon);\n      setUnpaddedRobotFootprint(footprint_polygon);\n    }\n  }\n\n  if (new_config.robot_radius != old_config.robot_radius) {\n    setUnpaddedRobotFootprintRadius(new_config.robot_radius);\n  }\n}", "CodeBleu_score": 70.81169743220714}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"[Costmap2DROS] Could not get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  // Update the global current pose\n  current_pose_ = new_pose;\n\n  // We cannot make the footprint polygon smaller than the robot radius, so we'll make it the same size.\n  // 1. Get the current footprint\n  std::vector<geometry_msgs::Point> footprint_spec = costmap_->getRobotFootprint();\n\n  // 2. Get the current robot radius\n  double robot_radius = costmap_->getResolution() * costmap_->getInscribedRadius();\n\n  // 3. Create a new footprint polygon with the same size as the robot radius\n  std::vector<geometry_msgs::Point> new_footprint_spec;\n  for (size_t i = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point point;\n    point.x = footprint_spec[i].x * robot_radius;\n    point.y = footprint_spec[i].y * robot_radius;\n    new_footprint_spec.push_back(point);\n  }\n\n  // 4. Set the new footprint\n  costmap_->setRobotFootprint(new_footprint_spec);\n\n  // 5. Update the costmap\n  costmap_->updateMap(0, 0, 0);\n}", "CodeBleu_score": 61.74113520841329}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    // reactivate threads\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end();\n        ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n    stop_updates_ = false;\n    // wait for the update thread to run\n    boost::unique_lock<boost::recursive_mutex> lock(*access_);\n    while (running_ && !update_thread_) {\n      update_condition_->wait(lock);\n    }\n  }\n}", "CodeBleu_score": 60.54642203279155}, {"code": "void Costmap2DROS::start(){\n\t  // check if the costmap is already stopped\n  if (stopped_) {\n    // loop through the plugins and activate them\n    std::vector<boost::shared_ptr<Layer> >::iterator plugin;\n    for (plugin = plugins_.begin(); plugin != plugins_.end(); ++plugin) {\n      (*plugin)->activate();\n    }\n\n    // set the stopped flag to false\n    stopped_ = false;\n\n    // set the stop_updates_ flag to false\n    stop_updates_ = false;\n\n    // wait until ROS is running\n    ros::Rate r(100);\n    while (!ros::ok()) {\n      r.sleep();\n    }\n\n    // wait until the costmap is initialized\n    while (!initialized_) {\n      r.sleep();\n    }\n\n    // wait until the map update thread is active\n    while (!map_update_thread_active_) {\n      r.sleep();\n    }\n  }\n}", "CodeBleu_score": 63.32921068386448}, {"code": "void Costmap2DROS::start(){\n\t  if (stopped_) {\n    // reactivate plugins\n    std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n    for (std::vector<boost::shared_ptr<Layer> >::iterator pluginp = plugins->begin(); pluginp != plugins->end();\n         ++pluginp) {\n      (*pluginp)->activate();\n    }\n    stopped_ = false;\n    stop_updates_ = false;\n    // start map update thread\n    map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_frequency_));\n  }\n  // block until the costmap is initialized.. it will get initialized by\n  // Costmap2DROS::mapUpdateLoop()\n  ROS_DEBUG(\"Waiting for costmap to initialize\");\n  ros::Rate r(100);\n  while (!initialized_) {\n    r.sleep();\n  }\n  ROS_DEBUG(\"Costmap initialized\");\n  // now we wait...\n  ros::Rate spin_rate(map_update_frequency_);\n  while (ros::ok() && !stop_updates_) {\n    spin_rate.sleep();\n  }\n}", "CodeBleu_score": 62.21441914514803}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 0) {\n      observation_list_.resize(1);\n    }\n    return;\n  }\n\n  ros::Time now = ros::Time::now();\n  std::list<Observation>::iterator obs_it = observation_list_.begin();\n  while (obs_it != observation_list_.end()) {\n    if ((now - obs_it->header.stamp) > observation_keep_time_) {\n      obs_it = observation_list_.erase(obs_it);\n    } else {\n      // We're too far back, we're done.\n      return;\n    }\n  }\n}", "CodeBleu_score": 49.71853806693004}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == 0) {\n    // keep only the most recent observation\n    if (observation_list_.size() > 1) {\n      observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n    }\n  } else {\n    // remove observations that are older than the keep time\n    ros::Time now = ros::Time::now();\n    for (std::list<Observation>::iterator it = observation_list_.begin(); it != observation_list_.end(); ++it) {\n      if (now - it->header.stamp > observation_keep_time_) {\n        observation_list_.erase(it, observation_list_.end());\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 51.5375570342748}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t  if (observation_keep_time_ == ros::Duration(0.0)) {\n    if (observation_list_.size() > 0) {\n      observation_list_.resize(1);\n    }\n    return;\n  }\n\n  ros::Time now = ros::Time::now();\n  std::list<Observation>::iterator iter = observation_list_.begin();\n  while (iter != observation_list_.end()) {\n    if ((now - iter->header.stamp) > observation_keep_time_) {\n      iter = observation_list_.erase(iter);\n    } else {\n      break;\n    }\n  }\n}", "CodeBleu_score": 46.93654213686489}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (start_index < 0 || end_index >= path.size()) {\n    ROS_ERROR(\"Invalid start or end index for interpolation.\");\n    return;\n  }\n\n  // Calculate yaw angles at start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Calculate shortest angular distance between start and end yaw angles\n  double angle_diff = end_yaw - start_yaw;\n  if (angle_diff > M_PI) {\n    angle_diff -= 2 * M_PI;\n  } else if (angle_diff < -M_PI) {\n    angle_diff += 2 * M_PI;\n  }\n\n  // Calculate incremental change in angle for each pose\n  double angle_increment = angle_diff / (end_index - start_index);\n\n  // Update orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double yaw = start_yaw + i * angle_increment;\n    tf2::Quaternion q;\n    q.setRPY(0, 0, yaw);\n    tf2::convert(q, path[i].pose.orientation);\n  }\n}", "CodeBleu_score": 54.94454552765822}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  double start_yaw, end_yaw, d_yaw;\n  geometry_msgs::PoseStamped start_pose, end_pose;\n  double angle;\n\n  start_pose = path[start_index];\n  end_pose = path[end_index];\n  start_yaw = tf2::getYaw(start_pose.pose.orientation);\n  end_yaw = tf2::getYaw(end_pose.pose.orientation);\n  d_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  for (int i = start_index; i <= end_index; i++) {\n    angle = start_yaw + (d_yaw / (end_index - start_index + 1)) * (i - start_index);\n    set_angle(&path[i], angle);\n  }\n}", "CodeBleu_score": 58.35985434206906}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t  if (start_index < 0 || end_index >= path.size() || start_index > end_index) {\n    ROS_ERROR(\"Invalid indices for interpolation\");\n    return;\n  }\n\n  // Calculate yaw angles at start and end indices\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Calculate shortest angular distance between start and end yaw angles\n  double angle_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // Calculate incremental change in angle for each pose\n  double angle_increment = angle_diff / (end_index - start_index);\n\n  // Update orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double new_yaw = start_yaw + (i - start_index) * angle_increment;\n    tf2::Quaternion q;\n    q.setRPY(0, 0, new_yaw);\n    path[i].pose.orientation = tf2::toMsg(q);\n  }\n}", "CodeBleu_score": 61.73958773613484}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  std::vector<geometry_msgs::PoseStamped> path;\n\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  bool success = makePlan(req.start, req.goal, path);\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  return true;\n}", "CodeBleu_score": 91.8845741286968}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  geometry_msgs::PoseStamped start;\n  geometry_msgs::PoseStamped goal;\n\n  start.header.frame_id = \"map\";\n  start.header.stamp = ros::Time::now();\n  start.pose = req.start;\n\n  goal.header.frame_id = \"map\";\n  goal.header.stamp = ros::Time::now();\n  goal.pose = req.goal;\n\n  std::vector<geometry_msgs::PoseStamped> plan;\n  bool success = makePlan(start, goal, plan);\n  resp.plan_found = success;\n\n  if (success) {\n    resp.path = plan;\n  }\n\n  return true;\n}", "CodeBleu_score": 60.56399102215764}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t  std::vector<geometry_msgs::PoseStamped> path;\n\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  bool success = makePlan(req.start, req.goal, path);\n  resp.plan_found = success;\n  if (success) {\n    resp.path = path;\n  }\n\n  return true;\n}", "CodeBleu_score": 91.8845741286968}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 71.63930192844671}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n    initialized_ = false;\n}", "CodeBleu_score": 68.25112300132878}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 71.63930192844671}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < origin_x || wy < origin_y)\n    return false;\n\n  mx = (wx - origin_x) / resolution;\n  my = (wy - origin_y) / resolution;\n\n  if (mx < size_x && my < size_y)\n    return true;\n\n  return false;\n}", "CodeBleu_score": 45.68687328528173}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t  if (wx < origin_x || wy < origin_y)\n    return false;\n\n  mx = (wx - origin_x) / resolution;\n  my = (wy - origin_y) / resolution;\n\n  if (mx < size_x && my < size_y)\n    return true;\n\n  return false;\n}", "CodeBleu_score": 45.68687328528173}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t    if (wx < origin_x_ || wy < origin_y_)\n        return false;\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if (mx < size_x_ && my < size_y_)\n        return true;\n\n    return false;\n}", "CodeBleu_score": 42.381549214563776}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\n            \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = frame_id_;\n        gui_path.header.stamp = ros::Time::now();\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.59449684048896}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = frame_id_;\n        gui_path.header.stamp = ros::Time::now();\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 94.0913292178291}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t    if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = frame_id_;\n        gui_path.header.stamp = ros::Time::now();\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.41307745800299}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 97.07532557418959}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t  ROS_DEBUG_NAMED(\"move_base\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 97.91245108335265}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t    ROS_DEBUG_NAMED(\"MoveBase\", \"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 96.68197632052033}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    double sq_distance = getSqDistance();\n\n    if (sq_distance < sq_distance_limit_) {\n      return;\n    }\n\n    ROS_INFO(\"Moved %f units, removing speed limit\", sq_distance_limit_);\n\n    if (remove_limit_thread_.joinable()) {\n      remove_limit_thread_.join();\n    }\n\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n    distance_check_timer_.stop();\n  }", "CodeBleu_score": 51.401407881814244}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t  if (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"MoveSlowAndClear: Distance limit reached. Removing speed limit.\");\n    if (remove_limit_thread_) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n      remove_limit_thread_ = NULL;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 58.90629921677112}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t    if (getSqDistance() > sq_distance_) {\n      ROS_INFO(\"MoveSlowAndClear: Moved far enough. Removing speed limit.\");\n      if (remove_limit_thread_.joinable()) {\n        remove_limit_thread_.join();\n      }\n      remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n      distance_check_timer_.stop();\n    }\n  }", "CodeBleu_score": 43.74306590569012}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t  ROS_INFO(\"In pose callback\");\n  geometry_msgs::PoseStamped global_pose;\n  getRobotPose(global_pose);\n\n  geometry_msgs::PoseStamped start;\n  start.header.frame_id = global_pose.header.frame_id;\n  start.header.stamp = global_pose.header.stamp;\n  start.pose = global_pose.pose;\n\n  std::vector<geometry_msgs::PoseStamped> plan;\n  makePlan(start, *goal, plan);\n}", "CodeBleu_score": 51.050647654160606}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    ROS_INFO(\"In pose callback.\");\n    // get the current ego-motion state of the ego-vehicle\n    geometry_msgs::PoseStamped current_pose;\n    if (!getRobotPose(current_pose)) {\n        ROS_ERROR(\"Could not transform the global plan to the frame of the controller\");\n        return;\n    }\n    // we'll make sure that we reset our state for the goal that we just received\n    std::vector<geometry_msgs::PoseStamped> global_plan;\n    if (!makePlan(current_pose, goal->pose, global_plan)) {\n        ROS_ERROR(\"Could not find a  path to point (%.2f, %.2f)\", goal->pose.position.x, goal->pose.position.y);\n        return;\n    }\n    // reset the global plan\n    global_plan_.poses.clear();\n    global_plan_.header.frame_id = frame_id_;\n    global_plan_.header.stamp = ros::Time::now();\n    for (int i = 0; i < global_plan.size(); ++i) {\n        global_plan_.poses.push_back(global_plan[i]);\n    }\n}", "CodeBleu_score": 41.80050806430969}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t    ROS_INFO(\"In pose callback\");\n    // get the current robot pose\n    tf::Stamped<tf::Pose> global_pose;\n    if(!costmap_->getRobotPose(global_pose)) {\n        ROS_ERROR(\"[navfn_with_costmap] Unable to get starting pose\");\n        return;\n    }\n\n    geometry_msgs::PoseStamped start;\n    tf::poseStampedTFToMsg(global_pose, start);\n\n    // if the planner fails or returns a zero length plan, planning failed\n    if(!planner_->makePlan(start, goal->pose, plan_)) {\n        ROS_ERROR(\"[navfn_with_costmap] Failed to find a  valid plan\");\n        return;\n    }\n\n    ROS_INFO(\"[navfn_with_costmap] Got a valid plan\");\n    // publish the plan for visualization purposes\n    publishPlan(plan_, 0.0, 1.0, 0.0, 0.0);\n}", "CodeBleu_score": 40.64332627798679}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet gimbal_param_set;\n    gimbal_param_set.request.param_id = param_set.param_id;\n    gimbal_param_set.request.param_value = param_set.param_value;\n    gimbal_param_set_client_.call(gimbal_param_set);\n    if (gimbal_param_set.response.result) {\n        ROS_INFO(\"Gimbal parameter set successfully.\");\n    } else {\n        ROS_WARN(\"Gimbal parameter set failed.\");\n    }\n}", "CodeBleu_score": 49.27967653892434}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t  dji_osdk_ros::GimbalParamSet gimbal_param_set;\n  gimbal_param_set.request.param_id = param_set.param_id;\n  gimbal_param_set.request.param_value = param_set.param_value;\n  gimbal_param_set_client_.call(gimbal_param_set);\n}", "CodeBleu_score": 53.79374281932019}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t    dji_osdk_ros::GimbalParamSet param_set_req;\n    param_set_req.request.param_id = param_set.param_id;\n    param_set_req.request.param_value = param_set.param_value;\n    param_set_client_.call(param_set_req);\n}", "CodeBleu_score": 55.2658905768213}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                   &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *) &address,\n             sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    if ((new_socket = accept(server_fd, (struct sockaddr *) &address,\n                             (socklen_t *) &addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n    while (true) {\n        valread = read(new_socket, buffer, 1024);\n        if (valread > 0) {\n            std::string data(buffer);\n            decode(data);\n        } else if (valread == 0) {\n            ROS_ERROR(\"Error: Received message length is zero or less\");\n            close(new_socket);\n            break;\n        }\n    }\n}", "CodeBleu_score": 54.53062884179031}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  // If not in simulation mode, publish the command to a single UAV\n  if (!simulation_mode_) {\n    uav_basic_.publish(uav_cmd);\n  } else {\n    // Find the corresponding UAV by ID from swarm_control_simulation_\n    for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n      if (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n        // Publish the command to the matching UAV\n        swarm_control_simulation_[i].uav_basic_.publish(uav_cmd);\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 35.274729451831334}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t    // If not in simulation mode, publish the command to the single UAV\n    if (!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    }\n    // If in simulation mode, publish the command to the matching UAV\n    else {\n        // Find the corresponding UAV by ID\n        for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n            if (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n                swarm_control_simulation_[i].uav_command = uav_cmd;\n                swarm_control_simulation_[i].uav_command_publisher.publish(uav_cmd);\n            }\n        }\n    }\n}", "CodeBleu_score": 43.08020077919564}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t  if (simulation_mode_) {\n    // find the corresponding UAV\n    int uav_id = uav_cmd.id;\n    for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n      if (swarm_control_simulation_[i].id == uav_id) {\n        // publish the command to the corresponding UAV\n        swarm_control_simulation_[i].publish(uav_cmd);\n        break;\n      }\n    }\n  } else {\n    // publish the command to a single UAV\n    uav_basic_.publish(uav_cmd);\n  }\n}", "CodeBleu_score": 35.379998093435326}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  if (mode_selection.use_mode == REBOOTNX) {\n    system(\"reboot\");\n  } else if (mode_selection.use_mode == EXITNX) {\n    system(\"exit\");\n  } else if (mode_selection.use_mode == CREATEMODE) {\n    createMode(mode_selection.mode_name);\n  } else if (mode_selection.use_mode == DELETEMODE) {\n    deleteMode(mode_selection.mode_name);\n  }\n}", "CodeBleu_score": 51.24517979601039}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t  if (mode_selection.use_mode == REBOOTNX) {\n    system(\"sudo reboot\");\n  } else if (mode_selection.use_mode == EXITNX) {\n    system(\"exit\");\n  } else {\n    if (mode_selection.use_mode == CREATE) {\n      createMode(mode_selection.mode_name);\n    } else if (mode_selection.use_mode == DELETE) {\n      deleteMode(mode_selection.mode_name);\n    }\n  }\n}", "CodeBleu_score": 52.31723196069251}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t    if (mode_selection.use_mode == REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.use_mode == EXITNX) {\n        system(\"exit\");\n    } else {\n        if (mode_selection.create_mode) {\n            createMode(mode_selection.use_mode);\n        } else {\n            deleteMode(mode_selection.use_mode);\n        }\n    }\n}", "CodeBleu_score": 48.32190978081563}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t  if (heartbeat_count_ == heartbeat_count_prev_) {\n    heartbeat_missed_attempts_++;\n    if (heartbeat_missed_attempts_ == heartbeat_missed_attempts_threshold_) {\n      ROS_ERROR(\"Heartbeat missed %d attempts\", heartbeat_missed_attempts_threshold_);\n      if (vehicle_type_ == \"swarm\") {\n        ROS_ERROR(\"Disconnecting from swarm\");\n        disconnect_flag_ = true;\n      } else if (vehicle_type_ == \"UAV\") {\n        ROS_ERROR(\"Disconnecting from UAV\");\n        disconnect_flag_ = true;\n      } else if (vehicle_type_ == \"UGV\") {\n        ROS_ERROR(\"Disconnecting from UGV\");\n        disconnect_flag_ = true;\n      }\n    }\n  } else {\n    heartbeat_missed_attempts_ = 0;\n  }\n  heartbeat_count_prev_ = heartbeat_count_;\n}", "CodeBleu_score": 35.10619131597392}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t    if (vehicle_type == \"swarm\") {\n        if (heartbeat_count == heartbeat_threshold) {\n            ROS_ERROR_STREAM(\"Communication lost with swarm vehicle.\");\n            disconnect_flag = true;\n        }\n    } else if (vehicle_type == \"UAV\") {\n        if (heartbeat_count == heartbeat_threshold) {\n            ROS_ERROR_STREAM(\"Communication lost with UAV vehicle.\");\n            disconnect_flag = true;\n        }\n    } else if (vehicle_type == \"UGV\") {\n        if (heartbeat_count == heartbeat_threshold) {\n            ROS_ERROR_STREAM(\"Communication lost with UGV vehicle.\");\n            disconnect_flag = true;\n        }\n    }\n}", "CodeBleu_score": 35.75853873425369}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\n  if (vehicle_type == \"UAV\") {\n    if (uav_heartbeat_counter == heartbeat_attempts) {\n      ROS_ERROR(\"UAV heartbeat lost, check connection!\");\n      uav_disconnect_flag = true;\n    }\n    uav_heartbeat_counter++;\n  } else if (vehicle_type == \"UGV\") {\n    if (ugv_heartbeat_counter == heartbeat_attempts) {\n      ROS_ERROR(\"UGV heartbeat lost, check connection!\");\n      ugv_disconnect_flag = true;\n    }\n    ugv_heartbeat_counter++;\n  } else if (vehicle_type == \"Swarm\") {\n    if (swarm_heartbeat_counter == heartbeat_attempts) {\n      ROS_ERROR(\"Swarm heartbeat lost, check connection!\");\n      swarm_disconnect_flag = true;\n    }\n    swarm_heartbeat_counter++;\n  }\n}", "CodeBleu_score": 34.2257717398171}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t  // Extract the drone ID from the message\n  int drone_id = msg->drone_id;\n  // Iterate over the trajectories in the message\n  for (int i = 0; i < msg->traj_num; i++) {\n    // Initialize a Bspline struct\n    Bspline bspline;\n    // Set the Bspline struct's attributes\n    bspline.control_points_num = msg->traj[i].control_points_num;\n    bspline.knots_num = msg->traj[i].knots_num;\n    bspline.order = msg->traj[i].order;\n    bspline.duration = msg->traj[i].duration;\n    // Populate the Bspline struct's knots, position points, and yaw points\n    for (int j = 0; j < bspline.knots_num; j++) {\n      bspline.knots.push_back(msg->traj[i].knots[j]);\n    }\n    for (int j = 0; j < bspline.control_points_num; j++) {\n      bspline.position_pts.push_back(msg->traj[i].position_pts[j]);\n      bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n    }\n    // Encode the MultiBsplines data\n    prometheus_msgs::MultiBsplines multiBsplines;\n    multiBsplines.drone_id = drone_id;\n    multiBsplines.traj_num = 1;\n    multiBsplines.traj.push_back(bspline);\n    // Send the encoded data via TCP using the communication module\n    communication.sendTcp(multiBsplines);\n  }\n}", "CodeBleu_score": 54.62417589352457}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t    // Extract the drone ID from the message\n    int drone_id = msg->drone_id;\n\n    // Get the number of trajectories in the message\n    int num_traj = msg->traj_num;\n\n    // Create a MultiBsplines struct to hold the decoded message data\n    MultiBsplines multi_bsplines;\n\n    // Iterate over each trajectory in the message\n    for (int i = 0; i < num_traj; i++) {\n        // Create a Bspline struct to hold the trajectory data\n        Bspline bspline;\n\n        // Extract the knots, position points, and yaw points from the trajectory message\n        vector<double> knots = msg->knots[i].data;\n        vector<Eigen::Vector3d> pos_pts = msg->pts[i].data;\n        vector<double> yaw_pts = msg->yaw[i].data;\n\n        // Set the attributes of the Bspline struct\n        bspline.knots = knots;\n        bspline.pos_pts = pos_pts;\n        bspline.yaw_pts = yaw_pts;\n\n        // Add the Bspline struct to the MultiBsplines struct\n        multi_bsplines.traj.push_back(bspline);\n    }\n\n    // Encode the MultiBsplines data using the encode_msg function\n    string data = encode_msg(multi_bsplines);\n\n    // Send the encoded data via TCP using the communication module\n    TCP_Send(drone_id, data);\n}", "CodeBleu_score": 32.17696050873789}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(128.0f);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n    octree.getPointIndicesFromNewVoxels(cloud_compressed->points);\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(*cloud_compressed, msg_compressed);\n    delete cloud;\n    delete cloud_compressed;\n    return msg_compressed;\n}", "CodeBleu_score": 36.40103592540381}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(128.0f);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    std::vector<int> pointIdxVec;\n    octree.getPointIndices(pointIdxVec);\n\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n    for (int i = 0; i < pointIdxVec.size(); i++) {\n        cloud_compressed->push_back(cloud->at(pointIdxVec[i]));\n    }\n\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(*cloud_compressed, msg_compressed);\n\n    return msg_compressed;\n}", "CodeBleu_score": 43.01483297387455}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(msg, cloud);\n\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(128.0f);\n    octree.setInputCloud(cloud.makeShared());\n    octree.addPointsFromInputCloud();\n\n    std::vector<int> pointIdxVec;\n    octree.encodePointCloud(msg.header.frame_id, pointIdxVec);\n\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloudOut(new pcl::PointCloud<pcl::PointXYZ>());\n    octree.decodePointCloud(pointIdxVec, cloudOut);\n\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(*cloudOut, msg_compressed);\n    msg_compressed.header = msg.header;\n\n    return msg_compressed;\n}", "CodeBleu_score": 36.29816255726429}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 64.4266456128767}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 51.19884106390078}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n            break;\n        }\n    }\n}", "CodeBleu_score": 51.19884106390078}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    swarm_control::MultiUGVState multi_ugv_state;\n    int ugv_count = 0;\n    for (auto ugv_state : m_multi_ugv_state.ugv_state) {\n        swarm_control::UGVState ugv_state_msg;\n        ugv_state_msg.ugv_id = ugv_state.ugv_id;\n        ugv_state_msg.battery = ugv_state.battery;\n        ugv_state_msg.position.x = ugv_state.position.x;\n        ugv_state_msg.position.y = ugv_state.position.y;\n        ugv_state_msg.position.z = ugv_state.position.z;\n        ugv_state_msg.velocity.x = ugv_state.velocity.x;\n        ugv_state_msg.velocity.y = ugv_state.velocity.y;\n        ugv_state_msg.velocity.z = ugv_state.velocity.z;\n        ugv_state_msg.attitude.x = ugv_state.attitude.x;\n        ugv_state_msg.attitude.y = ugv_state.attitude.y;\n        ugv_state_msg.attitude.z = ugv_state.attitude.z;\n        ugv_state_msg.attitude.w = ugv_state.attitude.w;\n        multi_ugv_state.ugv_state.push_back(ugv_state_msg);\n        ugv_count++;\n    }\n    multi_ugv_state.ugv_count = ugv_count;\n    multi_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 44.43308177838309}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    swarm_control::MultiUGVState multi_ugv_state;\n    int ugv_count = 0;\n    for (auto& ugv_state : m_multi_ugv_state.ugv_states) {\n        swarm_control::UGVState ugv_state_msg;\n        ugv_state_msg.id = ugv_state.id;\n        ugv_state_msg.battery = ugv_state.battery;\n        ugv_state_msg.position.x = ugv_state.position.x;\n        ugv_state_msg.position.y = ugv_state.position.y;\n        ugv_state_msg.position.z = ugv_state.position.z;\n        ugv_state_msg.velocity.x = ugv_state.velocity.x;\n        ugv_state_msg.velocity.y = ugv_state.velocity.y;\n        ugv_state_msg.velocity.z = ugv_state.velocity.z;\n        ugv_state_msg.attitude.x = ugv_state.attitude.x;\n        ugv_state_msg.attitude.y = ugv_state.attitude.y;\n        ugv_state_msg.attitude.z = ugv_state.attitude.z;\n        ugv_state_msg.attitude.w = ugv_state.attitude.w;\n        multi_ugv_state.ugv_states.push_back(ugv_state_msg);\n        ugv_count++;\n    }\n    multi_ugv_state.ugv_count = ugv_count;\n    multi_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.5170332962929}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t    swarm_control::MultiUGVState multi_ugv_state;\n    int ugv_count = 0;\n    for (auto const& x : m_multi_ugv_state.ugv_state) {\n        swarm_control::UGVState ugv_state;\n        ugv_state.id = x.second.id;\n        ugv_state.battery = x.second.battery;\n        ugv_state.position.x = x.second.position.x;\n        ugv_state.position.y = x.second.position.y;\n        ugv_state.position.z = x.second.position.z;\n        ugv_state.velocity.x = x.second.velocity.x;\n        ugv_state.velocity.y = x.second.velocity.y;\n        ugv_state.velocity.z = x.second.velocity.z;\n        ugv_state.attitude.x = x.second.attitude.x;\n        ugv_state.attitude.y = x.second.attitude.y;\n        ugv_state.attitude.z = x.second.attitude.z;\n        ugv_state.attitude.w = x.second.attitude.w;\n        multi_ugv_state.ugv_state.push_back(ugv_state);\n        ugv_count++;\n    }\n    multi_ugv_state.ugv_count = ugv_count;\n    multi_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 45.308299136561594}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  /*\n   * q: control points of the B-spline trajectory\n   * cost: the cost of the trajectory\n   * gradient: the gradient of the cost with respect to the control points\n   */\n  // Set the clearance for collision detection\n  double clearance = 0.5;\n\n  // Initialize the cost and gradient\n  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  // Iterate through control points\n  for (int i = 0; i < q.rows(); i++) {\n    // Get the current control point\n    Eigen::Vector3d p = q.row(i).transpose();\n\n    // Iterate through moving objects\n    for (int j = 0; j < moving_objs_.size(); j++) {\n      // Get the predicted position of the moving object\n      Eigen::Vector3d obj_pos = moving_objs_[j].getPredictedPos(i);\n\n      // Compute the distance between control point and moving object\n      double dist = (p - obj_pos).norm();\n\n      // If the distance is less than the clearance, update the cost and gradient\n      if (dist < clearance) {\n        // Update the cost\n        cost += (dist - clearance) * (dist - clearance);\n\n        // Update the gradient\n        Eigen::Vector3d grad = (p - obj_pos).normalized();\n        gradient.row(i) += grad.transpose();\n      }\n    }\n  }\n}", "CodeBleu_score": 39.63036478596999}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t  cost = 0.0;\n  gradient.setZero();\n\n  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.rows(); i++) {\n    // Compute the predicted positions of moving objects\n    Eigen::Vector2d qi = q.row(i).transpose();\n    std::vector<Eigen::Vector2d> predicted_positions = getPredictedPositions(qi);\n\n    // Evaluate the distance between control points and these objects\n    for (const auto &pos : predicted_positions) {\n      double dist = (qi - pos).norm();\n      if (dist < clearance_) {\n        // Update the cost and gradient based on the distance error\n        double error = clearance_ - dist;\n        cost += weight_moving_obj_ * error * error;\n        gradient.row(i) += -2.0 * weight_moving_obj_ * error * (qi - pos).transpose();\n      }\n    }\n  }\n}", "CodeBleu_score": 39.5868365244948}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n\n    int num_segments = q.rows() - 3;\n    for (int i = 0; i < num_segments; ++i) {\n        Eigen::Vector3d p0 = q.row(i).transpose();\n        Eigen::Vector3d p1 = q.row(i + 1).transpose();\n        Eigen::Vector3d p2 = q.row(i + 2).transpose();\n        Eigen::Vector3d p3 = q.row(i + 3).transpose();\n\n        Eigen::Vector3d v0 = (p1 - p0) / dt_;\n        Eigen::Vector3d v1 = (p2 - p1) / dt_;\n        Eigen::Vector3d v2 = (p3 - p2) / dt_;\n\n        double a2 = v0.squaredNorm() + v1.squaredNorm() + v2.squaredNorm();\n        double b2 = (v1 - v0).squaredNorm() + (v2 - v1).squaredNorm();\n\n        Eigen::Vector3d error = p0 - ref_points_.row(i).transpose();\n        cost += error.squaredNorm() + a2 + b2;\n\n        Eigen::Vector3d gradient_p0 = 2.0 * error + 2.0 * v0;\n        Eigen::Vector3d gradient_p1 = -2.0 * error + 4.0 * v0 - 2.0 * v1;\n        Eigen::Vector3d gradient_p2 = 2.0 * error - 4.0 * v1 + 2.0 * v2;\n        Eigen::Vector3d gradient_p3 = -2.0 * error + 2.0 * v2;\n\n        gradient.row(i) = gradient_p0.transpose();\n        gradient.row(i + 1) = gradient_p1.transpose();\n        gradient.row(i + 2) = gradient_p2.transpose();\n        gradient.row(i + 3) = gradient_p3.transpose();\n    }\n}", "CodeBleu_score": 39.14996458916234}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    cost = 0.0;\n    gradient.setZero();\n    int num_segments = q.cols() - 3;\n    for (int i = 0; i < num_segments; ++i) {\n        double t = (i + 1) * dt_;\n        Eigen::Vector3d pos_err = q.col(i) - (ref_points_.col(i) + t * ref_vels_.col(i));\n        Eigen::Vector3d vel = q.col(i + 1) - q.col(i);\n        double a2 = pos_err.squaredNorm();\n        double b2 = vel.squaredNorm();\n        cost += a2 + b2;\n        Eigen::Vector3d d_cost_d_pos = 2.0 * pos_err;\n        Eigen::Vector3d d_cost_d_vel = 2.0 * vel;\n        gradient.col(i) += d_cost_d_pos;\n        gradient.col(i + 1) += d_cost_d_vel;\n    }\n}", "CodeBleu_score": 38.40075864734156}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t    // initialize the cost to zero\n    cost = 0.0;\n    // initialize the gradient matrix to zero\n    gradient.setZero();\n\n    // iterate through the control points of the trajectory\n    for (int i = 0; i < q.cols(); i++) {\n        // compute the positional error relative to reference points\n        Eigen::Vector3d pos_err = q.col(i) - ref_pts.col(i);\n        // compute the velocity vector\n        Eigen::Vector3d vel = (i < q.cols() - 1) ? (q.col(i + 1) - q.col(i)) / dt : Eigen::Vector3d::Zero();\n        // compute the squared dot product and cross product of pos_err and vel\n        double a = pos_err.dot(pos_err);\n        double b = pos_err.cross(vel).squaredNorm();\n        // update the cost function\n        cost += a / a2 + b / b2;\n        // compute the gradient for the current control point\n        gradient.col(i) += 2.0 * pos_err / a2 + 2.0 * pos_err.cross(vel) / b2;\n    }\n}", "CodeBleu_score": 32.497245491725}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n  double jerk = 0.0;\n  double dt = jerk_traj.getTimeSum();\n  Eigen::VectorXd kts = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n\n  for (int i = 0; i < jerk_traj.getControlPoint().rows() - 1; ++i) {\n    for (int j = 0; j < jerk_traj.getControlPoint().cols(); ++j) {\n      jerk += (kts(i + 1) - kts(i)) * (ctrl_pts.row(i + 1)(j) - ctrl_pts.row(i)(j)) *\n              (ctrl_pts.row(i + 1)(j) - ctrl_pts.row(i)(j));\n    }\n  }\n  jerk = sqrt(jerk / dt / dt / dt);\n  return jerk;\n}", "CodeBleu_score": 71.80642876962384}, {"code": "double UniformBspline::getJerk(){\n\t  UniformBspline jerk_traj = getDerivative().getDerivative();\n  Eigen::VectorXd knot = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  double jerk = 0.0;\n  for (int i = 0; i < ctrl_pts.rows() - 1; ++i) {\n    for (int j = 0; j < ctrl_pts.cols(); ++j) {\n      jerk += (knot(i + 1) - knot(i)) *\n              (ctrl_pts.row(i + 1)(j) * ctrl_pts.row(i + 1)(j) +\n               ctrl_pts.row(i)(j) * ctrl_pts.row(i)(j));\n    }\n  }\n  return jerk;\n}", "CodeBleu_score": 69.74565025022834}, {"code": "double UniformBspline::getJerk(){\n\t  UniformBspline derivative = getDerivative();\n  UniformBspline derivative2 = derivative.getDerivative();\n\n  Eigen::VectorXd knot = derivative2.getKnot();\n  Eigen::MatrixXd cpts = derivative2.getControlPoint();\n\n  double jerk = 0.0;\n  for (int i = 0; i < cpts.rows(); ++i) {\n    for (int j = 0; j < cpts.cols(); ++j) {\n      jerk += pow(cpts(i, j), 2) * (knot(i + 1) - knot(i));\n    }\n  }\n  return jerk;\n}", "CodeBleu_score": 66.77485878015762}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t    Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}", "CodeBleu_score": 63.352792714373265}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  // Create a 4D position vector in the camera frame\n  Eigen::Vector4d pos;\n\n  // Calculate the 3D position of the point in camera coordinates\n  pos[0] = (u - cx_) * depth / fx_;\n  pos[1] = (v - cy_) * depth / fy_;\n  pos[2] = depth;\n  pos[3] = 1;\n\n  // Return the 4D position vector\n  return pos;\n}", "CodeBleu_score": 63.17362118172034}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t  Eigen::Vector4d pos;\n  pos(2) = depth;\n  pos(0) = (u - cx_) * pos(2) / fx_;\n  pos(1) = (v - cy_) * pos(2) / fy_;\n  pos(3) = 1;\n  return pos;\n}", "CodeBleu_score": 59.65841083484683}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        std::string drone_id = odom.child_frame_id;\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (...) {\n        std::cerr << \"Failed to extract drone ID from odometry message\" << std::endl;\n    }\n}", "CodeBleu_score": 43.085718014088094}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        std::string drone_id = odom.child_frame_id;\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 53.44111798097576}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t    try {\n        std::string drone_id = odom.child_frame_id;\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error extracting drone ID from odometry message: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 51.73447023346137}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\n    // Compute the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose_camera = computeTruePose(true_pixel);\n\n    // Check if the drone is present in the camera frame\n    if (isDronePresent(drone_id, true_pose_camera)) {\n\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d pose_error = computePoseError(true_pose_camera);\n\n        // Update the debug result\n        debug_result_.detected = true;\n        debug_result_.error = pose_error;\n\n        // Publish the pose error\n        publishPoseError(pose_error);\n\n    } else {\n\n        // Update the debug result to indicate failure\n        debug_result_.detected = false;\n\n    }\n\n}", "CodeBleu_score": 26.17275158524443}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = camera_model_.pixel_to_camera(true_pixel);\n\n    // Check if the drone is present in the camera frame\n    if (is_drone_present(drone_id, true_pose)) {\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d error = compute_pose_error(true_pose);\n\n        // Update the debug result\n        debug_result_.drone_id = drone_id;\n        debug_result_.true_pixel = true_pixel;\n        debug_result_.true_pose = true_pose;\n        debug_result_.error = error;\n\n        // Publish the pose error\n        publish_pose_error(error);\n    } else {\n        // Update the debug result to indicate failure\n        debug_result_.drone_id = -1;\n        debug_result_.true_pixel = Eigen::Vector2i(-1, -1);\n        debug_result_.true_pose = Eigen::Vector3d::Zero();\n        debug_result_.error = Eigen::Vector3d::Zero();\n    }\n}", "CodeBleu_score": 35.95060794561531}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t  // Calculate the true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose = calculateTruePose(drone_id, true_pixel);\n\n  // Check for the presence of the drone in the camera frame\n  if (checkPresence(true_pose)) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = calculatePoseError(true_pose);\n\n    // Update the debug result\n    updateDebugResult(pose_error);\n\n    // Publish the pose error\n    publishPoseError(pose_error);\n  } else {\n    // Update the debug result to indicate failure\n    updateDebugResult(false);\n  }\n}", "CodeBleu_score": 20.397909847430707}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    // iteratively follow the chain of parents of nodes until the starting node is found\n    while (current != nullptr) {\n        path.push_back(current);\n        current = current->parent;\n    }\n    return path;\n}", "CodeBleu_score": 62.930787763707976}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    // start from end point\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}", "CodeBleu_score": 90.82197591467109}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t    vector<GridNodePtr> path;\n    // iteratively follow the parent node pointers from the current node\n    // until the starting node is found\n    while (current->parent != NULL) {\n        path.push_back(current);\n        current = current->parent;\n    }\n    path.push_back(current); // add the start node to the path\n    std::reverse(path.begin(), path.end()); // reverse the path so it goes from start to goal\n    return path;\n}", "CodeBleu_score": 63.83944392004669}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n        return false;\n\n    if (isObs(start_idx) || isObs(end_idx)) {\n        //ROS_WARN(\"Start or end point is insde obstacle, try to adjust points ...\");\n        Vector3i perturb;\n        while (isObs(start_idx)) {\n            perturb.setRandom();\n            perturb += start_idx;\n            start_idx = perturb;\n        }\n        while (isObs(end_idx)) {\n            perturb.setRandom();\n            perturb += end_idx;\n            end_idx = perturb;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 44.62297694792731}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!Coordinate2Index(start_pt, start_idx) || !Coordinate2Index(end_pt, end_idx))\n        return false;\n\n    if (isObs(start_idx) || isObs(end_idx)) {\n        ROS_WARN(\"Start(end) point is at obstacle, adjusting.\");\n        Vector3d zero(0, 0, 0);\n        Vector3d start_end_offset = end_pt - start_pt;\n        do {\n            start_pt = start_pt - start_end_offset * resolution / 5.0;\n            end_pt = end_pt + start_end_offset * resolution / 5.0;\n            /// \u91cd\u65b0\u8f6c\u6362\n            Coordinate2Index(start_pt, start_idx);\n            Coordinate2Index(end_pt, end_idx);\n\n            for (int x = -1; x <= 1; x++)\n                for (int y = -1; y <= 1; y++)\n                    for (int z = -1; z <= 1; z++) {\n                        if ((x == 0) && (y == 0) && (z == 0))\n                            continue;\n                        Vector3i current_index = start_idx + Vector3i(x, y, z);\n                        if (!isFree(current_index)) {\n                            start_pt = zero;\n                            end_pt = zero;\n                            Coordinate2Index(start_pt, start_idx);\n                            Coordinate2Index(end_pt, end_idx);\n                            return false;\n                        }\n                    }\n        } while (isObs(start_idx) || isObs(end_idx));\n    }\n\n    ROS_INFO(\"Convert to index successed.\");\n    return true;\n}", "CodeBleu_score": 49.72993230875268}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t    if (!pos_checker_ptr_->insideBound(start_pt) || !pos_checker_ptr_->insideBound(end_pt)) return false;\n    if (pos_checker_ptr_->getMinDist(start_pt) > k_w_resolution_ / 2) return false;\n    if (pos_checker_ptr_->getMinDist(end_pt) > k_w_resolution_ / 2) return false;\n\n    start_idx = pos_checker_ptr_->floatToInt(start_pt);\n    end_idx = pos_checker_ptr_->floatToInt(end_pt);\n    Vector3d start_pt_floored;\n\n    int max_iter_num = 10;\n    int iter_num = 0;\n    while (pos_checker_ptr_->isOccupied(start_idx) || pos_checker_ptr_->isOccupied(end_idx)) {\n        start_pt_floored = pos_checker_ptr_->intToFloat(start_idx);\n        if (pos_checker_ptr_->isOccupied(start_idx)) {\n            for (int i = 0; i < 3; i++) start_pt(i) = start_pt_floored(i) + k_w_resolution_ / 2.0;\n        }\n        if (pos_checker_ptr_->isOccupied(end_idx)) {\n            for (int i = 0; i < 3; i++) end_pt(i) = start_pt_floored(i) + k_w_resolution_ / 2.0;\n        }\n        start_idx = pos_checker_ptr_->floatToInt(start_pt);\n        end_idx = pos_checker_ptr_->floatToInt(end_pt);\n\n        iter_num++;\n        if (iter_num >= max_iter_num) return false;\n    }\n    return true;\n}", "CodeBleu_score": 43.37292564399108}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t    Eigen::Vector3i min_id, max_id;\n    posToIndex(min_pos, min_id);\n    posToIndex(max_pos, max_id);\n\n    max_id -= Eigen::Vector3i(1, 1, 1);\n\n    for (int x = min_id(0); x <= max_id(0); ++x)\n        for (int y = min_id(1); y <= max_id(1); ++y)\n            for (int z = min_id(2); z <= max_id(2); ++z)\n                occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) + y * grid_size_(2) + z] = 0;\n}", "CodeBleu_score": 69.34870531250156}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  if (!buffer_initialized_) {\n    initializeBuffer();\n  }\n\n  Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  boundIndex(min_id);\n  boundIndex(max_id);\n\n  /* reset occupancy cached in buffer */\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) + y * grid_size_(2) + z] = 0;\n      }\n}", "CodeBleu_score": 67.48971909002861}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  // max_id(0) = (max_id(0) == min_id(0) ? max_id(0) + 1 : max_id(0));\n  // max_id(1) = (max_id(1) == min_id(1) ? max_id(1) + 1 : max_id(1));\n  // max_id(2) = (max_id(2) == min_id(2) ? max_id(2) + 1 : max_id(2));\n\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) + y * grid_size_(2) + z] = 0;\n      }\n}", "CodeBleu_score": 72.80474942647876}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    double max_x = (boundary_max(0) - camera_pt(0)) / diff(0);\n    double max_y = (boundary_max(1) - camera_pt(1)) / diff(1);\n    double max_z = (boundary_max(2) - camera_pt(2)) / diff(2);\n    double min_x = (boundary_min(0) - camera_pt(0)) / diff(0);\n    double min_y = (boundary_min(1) - camera_pt(1)) / diff(1);\n    double min_z = (boundary_min(2) - camera_pt(2)) / diff(2);\n    double min_positive = std::max(0.0, std::max(std::min(max_x, min_x), std::min(std::min(max_y, min_y), std::min(max_z, min_z))));\n    return camera_pt + diff * min_positive;\n}", "CodeBleu_score": 36.44368968372517}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    // Compute the difference vector between the point and the camera position\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    double max_x = (size_x_ - camera_pt(0)) / diff(0);\n    double min_x = -camera_pt(0) / diff(0);\n    double max_y = (size_y_ - camera_pt(1)) / diff(1);\n    double min_y = -camera_pt(1) / diff(1);\n    double max_z = (size_z_ - camera_pt(2)) / diff(2);\n    double min_z = -camera_pt(2) / diff(2);\n\n    // Find the minimum positive scaling factor that keeps the point within map boundaries\n    double min_scaling = std::max({min_x, min_y, min_z, 0.0});\n\n    // Adjust the point near the boundary\n    return camera_pt + min_scaling * diff;\n}", "CodeBleu_score": 33.65948369736081}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t    Eigen::Vector3d diff = pt - camera_pt;\n    double max_x = (boundary_max(0) - camera_pt(0)) / diff(0);\n    double max_y = (boundary_max(1) - camera_pt(1)) / diff(1);\n    double max_z = (boundary_max(2) - camera_pt(2)) / diff(2);\n\n    double min_x = (boundary_min(0) - camera_pt(0)) / diff(0);\n    double min_y = (boundary_min(1) - camera_pt(1)) / diff(1);\n    double min_z = (boundary_min(2) - camera_pt(2)) / diff(2);\n\n    double min_positive = std::max(0.0, std::max(std::min(min_x, min_y), std::min(min_x, min_z)));\n\n    return camera_pt + diff * min_positive;\n}", "CodeBleu_score": 36.4592721678611}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Check if an update is needed\n  if (!update_occupancy_) {\n    return;\n  }\n\n  // Lock the mutex\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  // Update the last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if the local map has been updated\n  if (local_map_updated_) {\n    // Clear and inflate the local map\n    clearAndInflateMap();\n    local_map_updated_ = false;\n  }\n\n  // Check if the odometry is timeout\n  if ((ros::Time::now() - last_odom_time_).toSec() >\n      odometry_timeout_) {\n    // Reset the odometry flag\n    odometry_initialized_ = false;\n  }\n\n  // Check if the depth image is timeout\n  if ((ros::Time::now() - last_depth_time_).toSec() >\n      depth_image_timeout_) {\n    // Reset the depth image flag\n    depth_image_initialized_ = false;\n  }\n\n  // Check if the odometry and depth image are initialized\n  if (!odometry_initialized_ || !depth_image_initialized_) {\n    // Set the update occupancy flag to false\n    update_occupancy_ = false;\n    // Set the odometry timeout flag to true\n    odometry_timeout_flag_ = true;\n    // Set the depth image timeout flag to true\n    depth_image_timeout_flag_ = true;\n    // Return\n    return;\n  }\n\n  // Reset the odometry timeout flag\n  odometry_timeout_flag_ = false;\n  // Reset the depth image timeout flag\n  depth_image_timeout_flag_ = false;\n\n  // Project the depth image into points\n  std::vector<Eigen::Vector3d> points;\n  projectDepthImage(points);\n\n  // Process the points with raycasting\n  processPoints(points);\n\n  // Set the update occupancy flag to false\n  update_occupancy_ = false;\n}", "CodeBleu_score": 38.0797877996196}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t    // Update the last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Check if an update is needed\n    if (!need_occupancy_update_) {\n        return;\n    }\n\n    // Update the occupancy grid\n    updateOccupancy();\n\n    // Update the local map\n    if (local_map_need_update_) {\n        // Clear the local map\n        local_map_->clear();\n\n        // Inflate the local map\n        local_map_->inflate(local_map_inflate_radius_);\n\n        // Set the local map need update flag to false\n        local_map_need_update_ = false;\n    }\n\n    // Handle timeout errors for odometry or depth data\n    if (ros::Time::now().toSec() - last_odom_time_.toSec() > timeout_odom_sec_) {\n        ROS_WARN(\"Timeout error: odometry data is not received for %f seconds.\", timeout_odom_sec_);\n        odom_timeout_flag_ = true;\n    }\n    if (ros::Time::now().toSec() - last_depth_time_.toSec() > timeout_depth_sec_) {\n        ROS_WARN(\"Timeout error: depth data is not received for %f seconds.\", timeout_depth_sec_);\n        depth_timeout_flag_ = true;\n    }\n\n    // Set the need update flag to false\n    need_occupancy_update_ = false;\n}", "CodeBleu_score": 43.09211828573852}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t  // Update last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if (not occupancy_update_needed_) return;\n  occupancy_update_needed_ = false;\n\n  // Check if the local map has been updated\n  if (local_map_updated_) {\n    local_map_updated_ = false;\n    clearLocalMap();\n    inflateLocalMap();\n  }\n\n  // Project depth image into points\n  std::vector<Eigen::Vector3d> point_cloud;\n  projectDepthImage(point_cloud);\n\n  // Process points with raycasting\n  processPointCloud(point_cloud);\n\n  // Handle timeout errors\n  if ((ros::Time::now() - last_odom_update_time_).toSec() >\n      odometry_timeout_) {\n    ROS_ERROR(\"[OCCUPANCY GRID]: Odometry timeout!\");\n    odometry_timeout_flag_ = true;\n  } else {\n    odometry_timeout_flag_ = false;\n  }\n  if ((ros::Time::now() - last_depth_update_time_).toSec() >\n      depth_timeout_) {\n    ROS_ERROR(\"[OCCUPANCY GRID]: Depth image timeout!\");\n    depth_timeout_flag_ = true;\n  } else {\n    depth_timeout_flag_ = false;\n  }\n}", "CodeBleu_score": 37.95309118392265}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float sum = 0.f;\n    int counter = 0;\n    for (unsigned i = 0; i < image_fns.size(); ++i) {\n        Mat3b img = imread(image_fns[i], IMREAD_COLOR);\n        if (img.empty()) {\n            cout << \"Error: Could not open or find the image\" << endl;\n            return -1;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        sum += fmeasure;\n        counter++;\n    }\n\n    return sum / counter;\n}", "CodeBleu_score": 55.103223000112564}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float fmeasure_total = 0.f;\n    unsigned n_images = image_fns.size();\n    for (unsigned i = 0; i < n_images; ++i) {\n        // Load the image\n        Mat3b img = imread(image_fns[i]);\n\n        // Load the ground truth ellipses\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        // Load the detected ellipses\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        // Evaluate the performance\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fmeasure_total += fmeasure;\n    }\n\n    // Calculate the average F-measure\n    float fmeasure_avg = fmeasure_total / n_images;\n\n    return fmeasure_avg;\n}", "CodeBleu_score": 56.92628553575856}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t    float f_measure_total = 0.f;\n    int image_count = 0;\n\n    for (size_t i = 0; i < image_fns.size(); ++i) {\n        string image_fn = image_fns[i];\n        string gt_fn = gt_fns[i];\n        string dt_fn = dt_fns[i];\n\n        Mat3b img = imread(image_fn, IMREAD_COLOR);\n        if (img.empty()) {\n            cout << \"Error loading image: \" << image_fn << endl;\n            continue;\n        }\n\n        vector<Ellipse> gt_ellipses;\n        _load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\n        vector<Ellipse> dt_ellipses;\n        _load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n        float f_measure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        f_measure_total += f_measure;\n        ++image_count;\n    }\n\n    return f_measure_total / image_count;\n}", "CodeBleu_score": 50.200582229745194}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t", "CodeBleu_score": 2.6118173022443996}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    return angle_diff_signed(angle1, angle2);\n}", "CodeBleu_score": 31.72137705124963}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t    float angle_to_focus1 = atan2(y - foci[1], x - foci[0]);\n    float angle_to_focus2 = atan2(y - foci[3], x - foci[2]);\n    float normal_angle = angle_diff_signed(angle_to_focus1, angle_to_focus2);\n    return normal_angle;\n}", "CodeBleu_score": 37.325631722420525}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t  double minx = std::numeric_limits<double>::max();\n  double miny = std::numeric_limits<double>::max();\n  double maxx = std::numeric_limits<double>::lowest();\n  double maxy = std::numeric_limits<double>::lowest();\n  for (int i = start; i <= end; i++) {\n    minx = std::min(minx, vp1[i].x);\n    miny = std::min(miny, vp1[i].y);\n    maxx = std::max(maxx, vp1[i].x);\n    maxy = std::max(maxy, vp1[i].y);\n  }\n  double integral_above = 0.0;\n  double integral_below = 0.0;\n  for (int i = start; i <= end; i++) {\n    double x1 = vp1[i].x;\n    double y1 = vp1[i].y;\n    double x2 = vp1[(i + 1) % vp1.size()].x;\n    double y2 = vp1[(i + 1) % vp1.size()].y;\n    integral_above += (x2 - x1) * (y2 + y1);\n    integral_below += (x2 - x1) * (y2 - y1);\n  }\n  return integral_above < integral_below;\n}", "CodeBleu_score": 45.145028060931466}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t    double min_x = vp1[start].x, max_x = vp1[start].x, min_y = vp1[start].y, max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        min_x = min(min_x, vp1[i].x);\n        max_x = max(max_x, vp1[i].x);\n        min_y = min(min_y, vp1[i].y);\n        max_y = max(max_y, vp1[i].y);\n    }\n    double above = 0, below = 0;\n    for (int i = start; i <= end; i++) {\n        above += (vp1[i].x - min_x) * (vp1[i].y - max_y);\n        below += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n    }\n    return above < below;\n}", "CodeBleu_score": 42.08037773438943}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t  // Iterate through each detection info\n  for (int i = 0; i < msg->detection_info.size(); i++) {\n    // Update the ellipse_det variable\n    ellipse_det = msg->detection_info[i];\n\n    // Check if an object named \"T\" is detected\n    if (ellipse_det.name == \"T\") {\n      // Increment the num_regain counter and reset num_lost\n      num_regain++;\n      num_lost = 0;\n    } else {\n      // Reset num_regain and increment num_lost\n      num_regain = 0;\n      num_lost++;\n    }\n\n    // Check if num_lost exceeds VISION_THRES\n    if (num_lost > VISION_THRES) {\n      // Set is_detected to false\n      is_detected = false;\n    }\n\n    // Check if num_regain exceeds VISION_THRES\n    if (num_regain > VISION_THRES) {\n      // Set is_detected to true\n      is_detected = true;\n    }\n\n    // Swap the sight_angle values of ellipse_det\n    float temp = ellipse_det.sight_angle.data;\n    ellipse_det.sight_angle.data = ellipse_det.sight_angle.data;\n    ellipse_det.sight_angle.data = temp;\n  }\n}", "CodeBleu_score": 68.34045982820994}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->getOccupancy(cur_pos) >= safe_distance) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 35.649163445393896}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    if (Occupy_map_ptr->getInflateOccupancy(cur_pos) > safe_distance) {\n        return false;\n    } else {\n        return true;\n    }\n}", "CodeBleu_score": 33.76149831528902}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t    bool safe;\n    safe = Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n    return safe;\n}", "CodeBleu_score": 77.21313744523172}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t  NodePtr current_node = end_node;\n  path_nodes_.push_back(current_node);\n\n  while (current_node->parent != nullptr) {\n    current_node = current_node->parent;\n    path_nodes_.push_back(current_node);\n  }\n\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 73.06814700495583}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 74.70027882849524}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t    NodePtr current_node = end_node;\n    while (current_node->parent != NULL) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    path_nodes_.push_back(current_node);\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 67.42544271302356}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t    if (id == nei_ugv_id) {\n        state_nei[0] = odom->pose.pose.position.x;\n        state_nei[1] = odom->pose.pose.position.y;\n        state_nei[2] = odom->pose.pose.position.z;\n\n        if (simulation_mode) {\n            double dist_from_start = sqrt(pow(state_nei[0] - start_pos[0], 2) + pow(state_nei[1] - start_pos[1], 2));\n            if (dist_from_start > 5.0) {\n                get_nei_state = false;\n            } else {\n                get_nei_state = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 38.092300016766835}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t", "CodeBleu_score": 3.1699249080664136}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter % 5 == 0) {\n        update_counter = 0;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*msg, *cloud);\n        for (auto &point : cloud->points) {\n            if (point.z > 0.1) {\n                astar_map->set_point(point.x, point.y, 1);\n            }\n        }\n        astar_map->update_map();\n    }\n}", "CodeBleu_score": 57.96859993887553}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        update_counter = 0;\n        Astar_map.update_map(msg);\n    }\n}", "CodeBleu_score": 58.27869497261092}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (!odom_ready) {\n        ROS_INFO(\"[GLOBAL PLANNER] Waiting for odometry...\");\n        return;\n    }\n    if (!sensor_ready) {\n        sensor_ready = true;\n    }\n    if (update_counter % 5 == 0) {\n        update_counter = 0;\n        ROS_INFO(\"[GLOBAL PLANNER] Updating Astar map...\");\n        updateAstarMap(msg);\n    }\n    update_counter++;\n}", "CodeBleu_score": 48.63695035029154}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud <pcl::PointXYZ>);\n        pcl::fromROSMsg(*global_point, *cloud);\n        cloud_storage.push_back(cloud);\n        inflate_pcl(cloud);\n    }\n}", "CodeBleu_score": 56.14870291793771}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(*global_point, cloud);\n        global_map.setInputCloud(cloud.makeShared());\n        global_map.filter(global_map_inflate);\n    }\n}", "CodeBleu_score": 54.99833122995214}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::fromROSMsg(*global_point, *global_cloud);\n        store_cloud(*global_cloud);\n        inflate_cloud(*global_cloud);\n    }\n}", "CodeBleu_score": 50.290275524925775}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t", "CodeBleu_score": 9.548366120699793}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_map(new pcl::PointCloud<pcl::PointXYZ>());\n    pcl::PointCloud<pcl::PointXYZ>::Ptr inflate_pcl_map(new pcl::PointCloud<pcl::PointXYZ>());\n\n    for (int i = 0; i < global_map_width; i++) {\n        for (int j = 0; j < global_map_height; j++) {\n            if (global_map[i][j] == 1) {\n                pcl::PointXYZ basic_point;\n                basic_point.x = i;\n                basic_point.y = j;\n                basic_point.z = 0;\n                pcl_map->points.push_back(basic_point);\n            }\n        }\n    }\n\n    pcl_map->width = pcl_map->points.size();\n    pcl_map->height = 1;\n    pcl_map->is_dense = true;\n\n    sensor_msgs::PointCloud2 pcl_map_msg;\n    pcl::toROSMsg(*pcl_map, pcl_map_msg);\n    pcl_map_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(pcl_map_msg);\n\n    inflate_pcl_map = inflate_map(pcl_map);\n    sensor_msgs::PointCloud2 inflate_pcl_map_msg;\n    pcl::toROSMsg(*inflate_pcl_map, inflate_pcl_map_msg);\n    inflate_pcl_map_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_map_msg);\n}", "CodeBleu_score": 58.56332256631846}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    // Convert the global point cloud map to a ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_pcl_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the global point cloud message\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert the inflated point cloud to a ROS message\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*inflate_pcl_map, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the inflated point cloud message\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 66.28277905816651}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_pcl, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 65.95496967698551}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    if (odom_ready) {\n        sensor_ready = true;\n    }\n\n    // convert point cloud to pcl point cloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n\n    // update the map\n    map_update(cloud);\n\n    // publish the map\n    publish_map();\n\n    // publish the path\n    publish_path();\n}", "CodeBleu_score": 48.30886083282014}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t    if (odom_ready) {\n        sensor_ready = true;\n        // update the A* algorithm's map using the new point cloud data and current UAV odometry\n        astar_planner.updateMap(msg, current_odom);\n    }\n}", "CodeBleu_score": 49.42894846369713}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\n    if (odom_ready) {\n        sensor_ready = true;\n        sensor_ready_mutex.unlock();\n    }\n\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(*msg, cloud);\n\n    std::vector<std::vector<int>> map(map_size, std::vector<int>(map_size, 0));\n\n    for (auto point : cloud.points) {\n        if (point.z > 0.0) {\n            int x = (int) ((point.x - map_x_min) / map_resolution);\n            int y = (int) ((point.y - map_y_min) / map_resolution);\n            if (x >= 0 && x < map_size && y >= 0 && y < map_size) {\n                map[x][y] = 1;\n            }\n        }\n    }\n\n    astar.update_map(map);\n}", "CodeBleu_score": 45.727593728742185}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t    float target_joints[12];\n    float target_foot_positions[12];\n    bool foot_contacts[4];\n\n    //Calculate target foot positions\n    body_controller_.calculateFootPositions(target_foot_positions);\n\n    //Calculate velocity commands for the legs\n    for (size_t i = 0; i < 4; i++) {\n        base_.legs[i]->setTargetFootPosition(target_foot_positions[i * 3], target_foot_positions[i * 3 + 1], target_foot_positions[i * 3 + 2]);\n    }\n\n    //Perform inverse kinematics to determine target joint positions\n    for (size_t i = 0; i < 4; i++) {\n        base_.legs[i]->calculateJointPositions(target_joints + i * 3);\n    }\n\n    //Publish foot contact information\n    for (size_t i = 0; i < 4; i++) {\n        foot_contacts[i] = base_.legs[i]->isFootInContact();\n    }\n    publishFootContacts_(foot_contacts);\n\n    //Publish joint positions\n    publishJoints_(target_joints);\n}", "CodeBleu_score": 53.35307461185532}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t  ros::Time loop_start_time = ros::Time::now();\n  ros::Duration dt = loop_start_time - last_loop_time_;\n  last_loop_time_ = loop_start_time;\n\n  // Get the current desired pose\n  champ::Pose desired_pose = champ::getDesiredPose(loop_start_time);\n\n  // Update the desired pose in the body controller\n  body_controller_.setDesiredPose(desired_pose);\n\n  // Calculate the target foot positions using the body controller\n  champ::Pose target_foot_positions[4];\n  body_controller_.calculateFootPositions(target_foot_positions, loop_start_time);\n\n  // Calculate the target joint positions for the legs\n  float target_joints[12];\n  for (size_t i = 0; i < 4; i++) {\n    base_.legs[i]->setTargetFootPosition(target_foot_positions[i]);\n    base_.legs[i]->calculateJointPositions(target_joints, i * 3);\n  }\n\n  // Publish foot contact information\n  bool foot_contacts[4];\n  for (size_t i = 0; i < 4; i++) {\n    foot_contacts[i] = base_.legs[i]->gait_phase() > 0.5;\n  }\n  publishFootContacts_(foot_contacts);\n\n  // Publish joint positions\n  publishJoints_(target_joints);\n}", "CodeBleu_score": 51.488241998027696}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contacts_publisher_.getTopic().empty()) {\n    return;\n  }\n  // Create the message\n  quadruped_msgs::msg::FootContactsStamped msg;\n  msg.header.stamp = this->get_clock()->now();\n  msg.header.frame_id = \"base_link\";\n  msg.contacts[0] = foot_contacts[0];\n  msg.contacts[1] = foot_contacts[1];\n  msg.contacts[2] = foot_contacts[2];\n  msg.contacts[3] = foot_contacts[3];\n  // Publish the message\n  foot_contacts_publisher_->publish(msg);\n}", "CodeBleu_score": 40.4381484264723}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t  if (foot_contact_publishing_enabled_) {\n    if (!gazebo_mode_) {\n      // Create a ContactsStamped message\n      std_msgs::Bool foot_contacts_msg;\n\n      // Populate the message with the current gait phase of each leg\n      for (int i = 0; i < 4; i++) {\n        foot_contacts_msg.data = foot_contacts[i];\n      }\n\n      // Publish the message\n      foot_contacts_publisher_.publish(foot_contacts_msg);\n    }\n  }\n}", "CodeBleu_score": 43.45454388322934}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t    if (foot_contacts_publisher_.getTopic() != \"\") {\n        // Create a ContactsStamped message\n        quadruped_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        contacts_msg.contacts.resize(4);\n        // Populate the message with the current gait phase of each leg\n        for (int i = 0; i < 4; i++) {\n            contacts_msg.contacts[i].contact = foot_contacts[i];\n        }\n        // Publish the message\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}", "CodeBleu_score": 60.90473872891688}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.name = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joints_msg.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n\n    # Publish the joints message\n    self.joints_pub.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.joint_names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    point = JointTrajectoryPoint()\n    point.positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n    point.time_from_start = rospy.Duration(0.5)\n    joint_trajectory.points = [point]\n\n    # Publish the joint trajectory message\n    self.joint_trajectory_pub.publish(joint_trajectory)\n}", "CodeBleu_score": 39.031685395189044}, {"code": "def joints_cmd_callback(self, joints){\n\t    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.name = joints.name[:12]\n    joints_msg.position = joints.position[:12]\n    self.joints_pub.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.joint_names = joints.name[:12]\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = Duration(secs=2)\n    trajectory_msg.points.append(point)\n\n    # Publish the trajectory message to the joint trajectory topic\n    self.joint_trajectory_pub.publish(trajectory_msg)\n}", "CodeBleu_score": 46.50485301812776}, {"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\n  for (int i = 0; i < 4; i++) {\n    foot_contact_state_[i] = false;\n  }\n\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    std::string col1 = _msg->contact(i).collision1();\n    std::string col2 = _msg->contact(i).collision2();\n    std::vector<std::string> collisions;\n    collisions.push_back(col1);\n    collisions.push_back(col2);\n\n    for (int j = 0; j < 2; j++) {\n      std::string collision = collisions[j];\n      std::vector<std::string> splitted;\n      boost::split(splitted, collision, boost::is_any_of(\"::\"));\n      std::string foot = splitted[splitted.size() - 2];\n      if (foot == \"LF_FOOT\") {\n        foot_contact_state_[0] = true;\n      } else if (foot == \"RF_FOOT\") {\n        foot_contact_state_[1] = true;\n      } else if (foot == \"LH_FOOT\") {\n        foot_contact_state_[2] = true;\n      } else if (foot == \"RH_FOOT\") {\n        foot_contact_state_[3] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 60.22396446401769}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t    for (int i = 0; i < 4; i++) {\n        foot_contact_[i] = false;\n    }\n    for (int i = 0; i < _msg->contact_size(); ++i) {\n        std::string col1 = _msg->contact(i).collision1();\n        std::string col2 = _msg->contact(i).collision2();\n        std::vector<std::string> strs1;\n        std::vector<std::string> strs2;\n        boost::split(strs1, col1, boost::is_any_of(\"::\"));\n        boost::split(strs2, col2, boost::is_any_of(\"::\"));\n        if (strs1.size() > 0) {\n            if (strs1[0] == \"foot_1\") {\n                foot_contact_[0] = true;\n            }\n            if (strs1[0] == \"foot_2\") {\n                foot_contact_[1] = true;\n            }\n            if (strs1[0] == \"foot_3\") {\n                foot_contact_[2] = true;\n            }\n            if (strs1[0] == \"foot_4\") {\n                foot_contact_[3] = true;\n            }\n        }\n        if (strs2.size() > 0) {\n            if (strs2[0] == \"foot_1\") {\n                foot_contact_[0] = true;\n            }\n            if (strs2[0] == \"foot_2\") {\n                foot_contact_[1] = true;\n            }\n            if (strs2[0] == \"foot_3\") {\n                foot_contact_[2] = true;\n            }\n            if (strs2[0] == \"foot_4\") {\n                foot_contact_[3] = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 56.033111172647544}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t  // Initialize foot contact states to false\n  for (int i = 0; i < NUM_LEGS; i++) {\n    contact_states_[i] = false;\n  }\n\n  // Process each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string to identify the contact link\n    std::string collision_str = _msg->contact(i).collision1();\n    std::string collision_link = collision_str.substr(0, collision_str.find(\"::\"));\n\n    // Check if the contact link matches a foot link\n    for (int j = 0; j < NUM_LEGS; j++) {\n      if (collision_link == foot_links_[j]) {\n        contact_states_[j] = true;\n        break;\n      }\n    }\n  }\n}", "CodeBleu_score": 64.81432651281742}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == rotor_count_);\n\n  rotor_velocities->resize(rotor_count_);\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_count_));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 87.3521291533696}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(rotor_velocities->size() == rotor_count_);\n\n  rotor_velocities->resize(rotor_count_);\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 92.04405810933775}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_cmd_);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 85.0277801195965}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t", "CodeBleu_score": 5.185615338987256}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  CHECK_NOTNULL(acceleration);\n\n  // Get the current vehicle position and orientation.\n  Eigen::Vector3d position, velocity, orientation_vector;\n  vehicle_state_.getPose(&position, &orientation_vector);\n  vehicle_state_.getVelocity(&velocity);\n\n  // Transform the velocity to the world frame.\n  const Eigen::Quaterniond orientation =\n      Eigen::AngleAxisd(orientation_vector.x(), Eigen::Vector3d::UnitX()) *\n      Eigen::AngleAxisd(orientation_vector.y(), Eigen::Vector3d::UnitY()) *\n      Eigen::AngleAxisd(orientation_vector.z(), Eigen::Vector3d::UnitZ());\n  velocity = orientation.inverse() * velocity;\n\n  // Compute the position and velocity errors.\n  *acceleration = trajectory_msg_.position_W - position;\n  *acceleration += trajectory_msg_.velocity_W - velocity;\n\n  // Add the feedforward acceleration.\n  *acceleration += trajectory_msg_.acceleration_W;\n\n  // Scale the acceleration by the gains.\n  *acceleration *= config_.position_gain;\n\n  // Scale the acceleration by the vehicle mass.\n  *acceleration /= vehicle_parameters_.mass;\n\n  // Add the gravity vector.\n  *acceleration += Eigen::Vector3d(0, 0, -9.81);\n\n  // Scale the acceleration by the vehicle mass.\n  *acceleration *= vehicle_parameters_.mass;\n\n  // Scale the acceleration by the acceleration gain.\n  *acceleration *= config_.acceleration_gain;\n\n  // Limit the acceleration.\n  *acceleration = acceleration->cwiseMax(-max_acceleration_).cwiseMin(max_acceleration_);\n}", "CodeBleu_score": 47.80834823510812}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t  // Position error.\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position.transpose();\n  // Velocity error.\n  // Transform to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity.transpose();\n\n  Eigen::Vector3d total_error = position_error.cwiseProduct(gain_.k_position.cwiseProduct(position_error))\n      + velocity_error.cwiseProduct(gain_.k_velocity.cwiseProduct(velocity_error));\n\n  *acceleration = -total_error.cwiseProduct(odometry_.orientation.toRotationMatrix() * Eigen::Vector3d::UnitZ())\n      - odometry_.orientation.toRotationMatrix() * Eigen::Vector3d::UnitZ() * kGravity\n      + command_trajectory_.acceleration.transpose();\n}", "CodeBleu_score": 69.06200501704919}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_);\n\n  rotor_velocities->resize(rotors_.size());\n  if (rotors_.size() == 0) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotors_.size());\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd angular_acceleration_thrust(6);\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust.block<3, 1>(3, 0) = control_attitude_thrust_reference_.block<3, 1>(3, 0);\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->array().max(1.0);\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 72.78976416637623}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_thrust_mix_);\n\n  rotor_velocities->resize(rotors_.size());\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd control_attitude_thrust_reference(4);\n  control_attitude_thrust_reference << angular_acceleration,\n                                       control_attitude_thrust_reference_(3);\n\n  Eigen::VectorXd control_attitude_thrust_reference_rotor_frame = attitude_.inverse() * control_attitude_thrust_reference;\n\n  Eigen::VectorXd rotor_velocities_sq = control_attitude_thrust_reference_rotor_frame.transpose() * thrust_mix_;\n  (*rotor_velocities)(0) = sqrt(std::max(rotor_velocities_sq(0), 1.0));\n  (*rotor_velocities)(1) = sqrt(std::max(rotor_velocities_sq(1), 1.0));\n  (*rotor_velocities)(2) = sqrt(std::max(rotor_velocities_sq(2), 1.0));\n  (*rotor_velocities)(3) = sqrt(std::max(rotor_velocities_sq(3), 1.0));\n}", "CodeBleu_score": 50.65522714319422}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_);\n\n  rotor_velocities->resize(rotor_count_);\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::Vector3d angular_acceleration_thrust(Eigen::Vector3d::Zero());\n  angular_acceleration_thrust[2] = control_attitude_thrust_reference_[2];\n\n  // R^3_hat * (ang_accel_des + g^b) + omega^b\n  Eigen::Vector3d angular_thrust = R_3_hat_ * (angular_acceleration + angular_acceleration_thrust) + angular_rate_;\n\n  //M*thrust + omega^2\n  Eigen::Vector3d angular_thrust_squared = inertia_matrix_ * angular_thrust + angular_rate_.cwiseProduct(angular_rate_);\n\n  *rotor_velocities = sqrt(angular_thrust_squared.cwiseQuotient(rotor_configuration_mat_ * rotor_configuration_mat_.transpose()).array());\n\n  //rotor_velocities->resize(rotor_count_);\n  //*rotor_velocities = Eigen::VectorXd::Ones(rotor_count_) * sqrt(10);\n}", "CodeBleu_score": 48.62805121712013}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    # Find the corresponding indices for the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # Make a deep copy of the object\n    sliced_obj = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    sliced_obj.time = self.time[start_index:end_index]\n    sliced_obj.data = self.data[start_index:end_index]\n    sliced_obj.name = self.name\n\n    return sliced_obj\n\n", "CodeBleu_score": 33.34449290102203}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = sliced_object.time[start_index:end_index]\n    sliced_object.x = sliced_object.x[start_index:end_index]\n    sliced_object.y = sliced_object.y[start_index:end_index]\n    sliced_object.z = sliced_object.z[start_index:end_index]\n    sliced_object.yaw = sliced_object.yaw[start_index:end_index]\n    sliced_object.pitch = sliced_object.pitch[start_index:end_index]\n    sliced_object.roll = sliced_object.roll[start_index:end_index]\n    return sliced_object", "CodeBleu_score": 24.172232417778268}, {"code": "def slice(self, start_time, end_time)\n\t\n    # Find the indices for the start and end times\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n\n    # Make a deep copy of the object\n    new_obj = copy.deepcopy(self)\n\n    # Update the attributes of the copied object to contain only the sliced data\n    new_obj.time = self.time[start_index:end_index]\n    new_obj.value = self.value[start_index:end_index]\n    new_obj.label = self.label[start_index:end_index]\n\n    return new_obj\n\n", "CodeBleu_score": 32.09599486576378}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    roll, pitch, yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object with the position and yaw\n    point = Point(position.x, position.y, position.z, yaw)\n\n    # Check if the current waypoint is different from the last one\n    if not self.waypoints or point != self.waypoints[-1]:\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.time.append(msg_time)\n        self.bag_time.append(bag_time)\n\n\n", "CodeBleu_score": 24.07255275639151}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    (_, _, yaw) = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    point = Point(position.x, position.y, position.z)\n    if not self.last_point or not self.last_point.is_same(point, yaw):\n        self.append_point(point)\n        self.append_yaw(yaw)\n        self.append_times(msg_time, bag_time)\n        self.last_point = Waypoint(point, yaw)\n\n", "CodeBleu_score": 24.44096351570045}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert the rotation to Euler angles\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if not self.waypoints or point != self.waypoints[-1].point or yaw != self.waypoints[-1].yaw:\n        # Create a Waypoint object\n        waypoint = Waypoint(point, yaw)\n\n        # Append the waypoint to the list\n        self.waypoints.append(waypoint)\n\n        # Append the x, y, and z components of the point to their respective arrays\n        self.append_point(point)\n\n        # Append the yaw to the array\n        self.yaw = numpy.append(self.yaw, yaw)\n\n        # Append the msg_time and bag_time to their respective arrays\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 36.50658704565345}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.accel_x = numpy.append(self.accel_x, msg.linear_acceleration.x)\n        self.accel_y = numpy.append(self.accel_y, msg.linear_acceleration.y)\n        self.accel_z = numpy.append(self.accel_z, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 33.2238673613564}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        msg_time = msg.header.stamp.to_sec()\n        self.append_times(msg_time, bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        msg_time = msg.header.stamp.to_sec()\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 32.01041363444115}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n        self.ax = numpy.append(self.ax, msg.linear_acceleration.x)\n        self.ay = numpy.append(self.ay, msg.linear_acceleration.y)\n        self.az = numpy.append(self.az, msg.linear_acceleration.z)\n\n", "CodeBleu_score": 32.16874332621615}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        else:\n            plot_suffix = \"_\" + plot_suffix\n        filename = self.prefix + \"_accelerations\" + plot_suffix + \".png\"\n        plt.savefig(filename)\n        plt.close()\n\n\n\n", "CodeBleu_score": 19.98362289722796}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    fig = plt.figure()\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(111)\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel[\"t\"], accel[\"x\"], color=\"r\", label=\"x\" if i == 0 else None)\n        ax.plot(accel[\"t\"], accel[\"y\"], color=\"g\", label=\"y\" if i == 0 else None)\n        ax.plot(accel[\"t\"], accel[\"z\"], color=\"b\", label=\"z\" if i == 0 else None)\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.legend()\n    if self.save_plots:\n        filename = f\"{self.plot_prefix}_accelerations{plot_suffix if plot_suffix else ''}.png\"\n        plt.savefig(filename)\n\n\n\n", "CodeBleu_score": 36.86870885745864}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    plt.figure()\n    plt.suptitle(self.name + \" Accelerations\")\n    plt.subplot(1, 1, 1)\n    for i in range(len(self.accelerations)):\n        plt.plot(self.accelerations[i].time, self.accelerations[i].x, color='r', label='x')\n        plt.plot(self.accelerations[i].time, self.accelerations[i].y, color='g', label='y')\n        plt.plot(self.accelerations[i].time, self.accelerations[i].z, color='b', label='z')\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Acceleration (m/s^2)\")\n    plt.legend()\n    if self.save_plots:\n        filename = \"accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        plt.savefig(self.plot_path + filename + \".png\")\n\n\n\n", "CodeBleu_score": 35.51583419786586}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"At least two pose indeces are required to perform comparisons.\")\n        return\n\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 39.31098507121715}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required for comparison.\")\n        return\n\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 36.84751499447101}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required to perform comparisons.\")\n        return\n\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(pose_indeces[i], pose_indeces[j])", "CodeBleu_score": 37.264648021042056}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n\n", "CodeBleu_score": 37.93512643360498}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 32.146680046322444}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n  float multiplier =\n      this->k1 * this->k2 * this->k3 * this->baseline_fx / this->fx;\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n  float rms_noise = this->noise_param1;\n  float noise_val = this->noise_param2;\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(data_vec[i])) {\n      data_vec[i] += multiplier * rms_noise * noise_val;\n    } else {\n      data_vec[i] = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 50.118301060845894}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) {\n    return;\n  }\n\n  const float multiplier = this->alpha * this->alpha * this->beta;\n\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  const float rms_noise = this->ComputeRMSNoise(data_vec);\n  const float noise_stddev = rms_noise * multiplier;\n\n  for (uint32_t i = 0; i < width * height; ++i) {\n    const float depth = data_vec(i);\n    if (this->InRange(depth)) {\n      data_vec(i) += this->rng.Gaussian(0.0, noise_stddev);\n    } else {\n      data_vec(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 50.79750820207687}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t  if (data == nullptr) return;\n\n  // Compute the multiplier based on camera parameters\n  float multiplier =\n      this->focal_length * this->baseline /\n      (this->measurement_noise * this->measurement_noise);\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Compute the RMS noise\n  float rms_noise = this->measurement_noise * multiplier;\n\n  // Compute the noise values\n  std::random_device rd;\n  std::mt19937 gen(rd());\n  std::normal_distribution<float> d(0, rms_noise);\n\n  // Add noise to each pixel\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(data_vec(i))) {\n      data_vec(i) += d(gen);\n    } else {\n      data_vec(i) = this->bad_point;\n    }\n  }\n}", "CodeBleu_score": 49.11122150983359}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  common::Time current_time = world_->GetSimTime();\n\n  // Convert the current simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n  // Write the trajectory message to a bag file\n  bag_.write(namespace_ + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 53.93989564383996}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t    ros::Time ros_time = ros::Time::now();\n    gazebo::common::Time gazebo_time = this->world_->SimTime();\n    ros::Time ros_time_from_gazebo = ros::Time(gazebo_time.sec, gazebo_time.nsec);\n\n    this->WriteMessageToBag(this->bag_name_, this->namespace_ + \"/\" + this->waypoint_topic_,\n                            trajectory_msg, ros_time_from_gazebo);\n}", "CodeBleu_score": 51.96044651497138}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t  // Get the current simulation time\n  gazebo::common::Time current_time = this->model_->GetWorld()->SimTime();\n\n  // Convert the current simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 55.767022611957884}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t  // Convert the simulation time to ROS time\n  ros::Time ros_now = ros::Time::now();\n\n  // Prepare a message for actuator velocities\n  gazebo_msgs::ActuatorVelocities actuator_velocities;\n\n  // Iterate through the motor joints\n  for (int i = 0; i < num_motors_; i++) {\n    // Calculate the slowed-down rotational velocity\n    double slowed_down_rotational_velocity =\n        joints_[i]->GetVelocity(0) * motor_velocity_slowdown_;\n\n    // Assign the slowed-down rotational velocity to the message\n    actuator_velocities.velocities.push_back(slowed_down_rotational_velocity);\n  }\n\n  // Set the message timestamp\n  actuator_velocities.header.stamp.sec = ros_now.sec;\n  actuator_velocities.header.stamp.nsec = ros_now.nsec;\n\n  // Write the data to a bag file\n  bag_.write(motor_topic_, ros_now, actuator_velocities);\n}", "CodeBleu_score": 44.678235837632805}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t    ros::Time time = ros::Time::now();\n    gazebo_msgs::ActuatorVelocities msg;\n    for (unsigned int i = 0; i < this->motorJoints.size(); i++) {\n        gazebo::physics::JointPtr joint = this->motorJoints[i];\n        double slowedDownVel = joint->GetVelocity(0) * this->slowdown;\n        msg.velocity.push_back(slowedDownVel);\n    }\n    msg.header.stamp = ros::Time::now();\n    this->bag.write(this->namespace_ + \"/\" + this->motorTopic, time, msg);\n}", "CodeBleu_score": 39.5769159017605}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t    // Convert simulation time to ROS time\n    ros::Time now_ros = ros::Time::now();\n    now_ros.sec = now.sec;\n    now_ros.nsec = now.nsec;\n\n    // Prepare message for actuator velocities\n    sensor_msgs::JointState msg;\n    msg.header.stamp = now_ros;\n\n    // Iterate through the motor joints\n    for (int i = 0; i < num_motors_; i++) {\n        // Calculate the slowed-down rotational velocities\n        double slowed_down_velocity = joints_[i]->GetVelocity(0) * velocity_slowdown_factor_;\n        msg.name.push_back(motor_names_[i]);\n        msg.velocity.push_back(slowed_down_velocity);\n    }\n\n    // Set the message timestamp\n    msg.header.stamp = now_ros;\n\n    // Write the data to the bag file\n    bag_.write(motor_topic_, now_ros, msg);\n}", "CodeBleu_score": 42.01621611934791}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called.\n\";\n  }\n\n  // Convert normalized input values to control surface angles.\n  aileron_left_cmd_ = NormalizedInputToAngle(aileron_left_,\n      roll_pitch_yawrate_thrust_msg->roll());\n  aileron_right_cmd_ = NormalizedInputToAngle(aileron_right_,\n      roll_pitch_yawrate_thrust_msg->roll());\n  elevator_cmd_ = NormalizedInputToAngle(elevator_,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_cmd_ = NormalizedInputToAngle(rudder_,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  throttle_cmd_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 49.60992181880557}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control\n  // surface angles for ailerons, elevator, and rudder respectively.\n  aileron_left_rad_ = NormalizedInputToAngle(\n      control_surfaces_.at(kAileronLeft), roll_pitch_yawrate_thrust_msg->roll());\n  aileron_right_rad_ = NormalizedInputToAngle(\n      control_surfaces_.at(kAileronRight), roll_pitch_yawrate_thrust_msg->roll());\n  elevator_left_rad_ = NormalizedInputToAngle(\n      control_surfaces_.at(kElevatorLeft), roll_pitch_yawrate_thrust_msg->pitch());\n  elevator_right_rad_ = NormalizedInputToAngle(\n      control_surfaces_.at(kElevatorRight), roll_pitch_yawrate_thrust_msg->pitch());\n  rudder_left_rad_ = NormalizedInputToAngle(\n      control_surfaces_.at(kRudderLeft), roll_pitch_yawrate_thrust_msg->yaw_rate());\n  rudder_right_rad_ = NormalizedInputToAngle(\n      control_surfaces_.at(kRudderRight), roll_pitch_yawrate_thrust_msg->yaw_rate());\n\n  // Set the throttle value from the thrust message.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust();\n}", "CodeBleu_score": 62.97862855312025}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t", "CodeBleu_score": 2.6366947450589233}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  if (select(_fd + 1, &readfds, nullptr, nullptr, &timeout) > 0) {\n    if (FD_ISSET(_fd, &readfds)) {\n      uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n      ssize_t packetlen = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n      mavlink_message_t message;\n      mavlink_status_t status;\n\n      for (ssize_t i = 0; i < packetlen; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &message, &status)) {\n          if (message.sysid == getSystemId() &&\n              message.compid == getComponentId()) {\n            if (serial_enabled_) {\n              send_mavlink_message(&message);\n            }\n            handle_message(&message);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 55.878744427192615}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  int status = select(_fd + 1, &readfds, NULL, NULL, &timeout);\n\n  if (status == -1) {\n    gzerr << \"Error on Mavlink Serial select\n\";\n  } else if (status > 0) {\n    if (FD_ISSET(_fd, &readfds)) {\n      uint8_t cp;\n      int result = -1;\n      result = recv(_fd, &cp, 1, 0);\n      if (result != 1) {\n        gzerr << \"Error reading from Mavlink Serial\n\";\n      }\n      if (mavlink_parse_char(MAVLINK_COMM_1, cp, &_msg, &_status)) {\n        if (serial_enabled_) {\n          send_mavlink_message(&_msg, 0);\n        }\n        handle_message(&_msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 50.77512865579551}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n\n  timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  if (select(_fd + 1, &readfds, nullptr, nullptr, &timeout) > 0) {\n    if (FD_ISSET(_fd, &readfds)) {\n      ssize_t recsize = recvfrom(_fd, _buf, sizeof(_buf), 0,\n                                 (struct sockaddr*)&srcaddr_, &addrlen_);\n\n      if (recsize > 0) {\n        mavlink_message_t message;\n        mavlink_status_t status;\n\n        for (ssize_t i = 0; i < recsize; i++) {\n          if (mavlink_parse_char(MAVLINK_COMM_1, _buf[i], &message, &status)) {\n            if (serial_enabled_) {\n              if (message.sysid == 255) {\n                // forward message from QGC to serial\n                send_mavlink_message(&message);\n              }\n            }\n            handle_message(&message);\n          }\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 59.745678663465675}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t  lock_guard lock(mutex);\n  if (serial_dev) {\n    io_service.stop();\n    serial_dev->close();\n  }\n  if (io_thread.joinable()) {\n    io_thread.join();\n  }\n}", "CodeBleu_score": 63.729554556148}, {"code": "void GazeboMavlinkInterface::close() {\n\t", "CodeBleu_score": 2.410600273879713}, {"code": "void GazeboMavlinkInterface::close() {\n\t  lock_guard lock(mutex);\n  if (is_open()) {\n    io_service.stop();\n    serial_dev->close();\n    if (io_thread.joinable()) {\n      io_thread.join();\n    }\n  }\n}", "CodeBleu_score": 65.16672065360709}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    ignition::math::Vector3d p1, p2, p3;\n    ignition::math::Vector3d v1, v2;\n    double t;\n\n    p1 = this->data.GetWindVelocity(0);\n    p2 = this->data.GetWindVelocity(this->data.GetNumberOfWindVelocity() - 1);\n    p3 = ignition::math::Vector3d(\n        _wind.velocity().x(),\n        _wind.velocity().y(),\n        _wind.velocity().z()\n    );\n\n    v1 = p2 - p1;\n    v2 = p3 - p1;\n    t = v2.Dot(v1) / v1.Dot(v1);\n\n    return p1 + v1 * t;\n}", "CodeBleu_score": 32.95466273108507}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t    double x = position.X();\n    double y = position.Y();\n\n    double x1 = std::floor(x);\n    double x2 = std::ceil(x);\n    double y1 = std::floor(y);\n    double y2 = std::ceil(y);\n\n    double x1y1 = map_data[x1][y1];\n    double x1y2 = map_data[x1][y2];\n    double x2y1 = map_data[x2][y1];\n    double x2y2 = map_data[x2][y2];\n\n    double x1y = (x2 - x) * x1y1 + (x - x1) * x2y1;\n    double x2y = (x2 - x) * x1y2 + (x - x1) * x2y2;\n\n    double xy = (y2 - y) * x1y + (y - y1) * x2y;\n\n    return ignition::math::Vector3d(xy, 0, 0);\n}", "CodeBleu_score": 30.761160266558775}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\n    // Initialize variables for interpolation\n    ignition::math::Vector3d interpolated_value;\n    ignition::math::Vector3d point1 = this->data.at(0);\n    ignition::math::Vector3d point2 = this->data.at(1);\n    double value1 = point1.Z();\n    double value2 = point2.Z();\n\n    // Check if the given position is within the range of the two points\n    if (position < point1.X() || position > point2.X()) {\n        // If the position is outside the range, return the value of the nearest point\n        if (position < point1.X()) {\n            interpolated_value.X(point1.X());\n            interpolated_value.Y(point1.Y());\n            interpolated_value.Z(value1);\n        } else {\n            interpolated_value.X(point2.X());\n            interpolated_value.Y(point2.Y());\n            interpolated_value.Z(value2);\n        }\n    } else {\n        // If the position is within the range, perform linear interpolation\n        double slope = (value2 - value1) / (point2.X() - point1.X());\n        double intercept = value1 - slope * point1.X();\n        interpolated_value.X(position);\n        interpolated_value.Y(0.0);\n        interpolated_value.Z(slope * position + intercept);\n    }\n\n    return interpolated_value;\n}", "CodeBleu_score": 35.26373372166795}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t    if (time != _time) {\n        time = _time;\n        if (looping) {\n            time = fmod(time, length);\n            if (time < 0.0) {\n                time += length;\n            }\n        }\n        else {\n            if (time < 0.0) {\n                time = 0.0;\n            }\n            if (time > length) {\n                time = length;\n            }\n        }\n    }\n}", "CodeBleu_score": 43.28163043749767}, {"code": "void Animation::SetTime(double _time){\n\t    if (time == _time) return;\n    time = _time;\n    if (looping) {\n        while (time >= length) time -= length;\n        while (time < 0) time += length;\n    } else {\n        time = std::max(time, 0.0);\n        time = std::min(time, length);\n    }\n}", "CodeBleu_score": 37.29933602115593}, {"code": "void Animation::SetTime(double _time){\n\t    if (time == _time) {\n        return;\n    }\n\n    time = _time;\n\n    if (looping) {\n        time = fmod(time, length);\n\n        if (time < 0.0) {\n            time += length;\n        }\n    } else {\n        if (time < 0.0) {\n            time = 0.0;\n        }\n\n        if (time > length) {\n            time = length;\n        }\n    }\n}", "CodeBleu_score": 43.01303218139409}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_motion = self.construct_target(self.local_position[0], self.local_position[1], self.local_position[2], 0, 0, 0, 0, 0, 0, self.yaw)\n    self.set_target_motion(target_motion)\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n", "CodeBleu_score": 51.14800105983029}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n\n    target_motion = self.construct_target(self.current_pose.position.x, self.current_pose.position.y, self.current_pose.position.z, 0, 0, 0, 0, 0, 0, self.current_pose.orientation.z, 0)\n\n    print(self.vehicle_type, self.vehicle_id, self.flight_mode)\n\n    return target_motion\n", "CodeBleu_score": 55.2012334589475}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_motion = self.construct_target(self.local_position.pose.position.x, self.local_position.pose.position.y, self.local_position.pose.position.z, 0, 0, 0, 0, 0, 0, self.yaw)\n    self.pub_target_motion.publish(target_motion)\n    print(\"Vehicle Type: \", self.vehicle_type, \"Vehicle ID: \", self.vehicle_id, \"Flight Mode: \", self.flight_mode)\n\n", "CodeBleu_score": 52.486938450291255}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        print(self.vehicle_type+'_'+self.vehicle_id+\": HOVER\")\n        return True\n    else:\n        try:\n            self.flightModeService(vehicle_id=self.vehicle_id, flightMode=self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" failed\")\n            return False\n\n", "CodeBleu_score": 59.687124090775825}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        print('Successfully switched to HOVER mode')\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print('Successfully switched to '+self.flight_mode+' mode')\n            return True\n        except:\n            print('Failed to switch to '+self.flight_mode+' mode')\n            return False\n\n", "CodeBleu_score": 37.16838191982995}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode)\n        return True\n    else:\n        mode_switch_result = self.flightModeService(vehicle_id=self.vehicle_id, flightMode=self.flight_mode)\n        if mode_switch_result.mode_sent:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode switch success\")\n            return True\n        else:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\" mode switch failed\")\n            return False\n\n", "CodeBleu_score": 60.00805468695181}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)\n\n", "CodeBleu_score": 69.87302832283582}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005) and self.flight_mode != 'HOVER':\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    elif self.flight_mode != 'HOVER':\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n\n", "CodeBleu_score": 74.67909155473319}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != \"HOVER\":\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n    else:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n\n", "CodeBleu_score": 43.35885490722895}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode != 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()\n\n", "CodeBleu_score": 86.80699819509282}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        yaw = Quaternion(q).yaw\n    return yaw\n\n", "CodeBleu_score": 25.283454472451417}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        yaw_rad = q.yaw_pitch_roll[0]\n    else:\n        q = Quaternion(q)\n        yaw_rad = q.yaw_pitch_roll[0]\n    return yaw_rad\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 44.94036300357372}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q).yaw_pitch_roll[0]\n\n\n\n", "CodeBleu_score": 24.58575872254351}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_BODY_NED\n    self.motion_type = 2\n    target_motion = self.construct_target(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n    print(\"Vehicle Type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight Mode:\", self.vehicle_type, \"in hover mode\")\n    return target_motion\n", "CodeBleu_score": 24.226737821798633}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_LOCAL_NED\n    self.motion_type = 2\n\n    target_motion = self.construct_target(x=self.local_position.pose.position.x, y=self.local_position.pose.position.y,\n                                          z=self.local_position.pose.position.z,\n                                          yaw=self.attitude.yaw)\n\n    print(\"Vehicle Type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight Mode:\", self.flight_mode)\n\n    return target_motion\n\n", "CodeBleu_score": 43.215196064562775}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = MAV_FRAME_LOCAL_NED\n    self.motion_type = 2\n    target_motion = self.construct_target(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.set_position_target_local_ned(target_motion)\n    print(\"Vehicle type: \" + str(self.vehicle_type) + \" Vehicle ID: \" + str(self.vehicle_id) + \" Flight Mode: \" + str(\n        self.flight_mode))\n\n", "CodeBleu_score": 26.075266615575565}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            flight_mode_request = self.flight_mode_service(custom_mode=self.flight_mode)\n            if flight_mode_request.mode_sent:\n                print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n                return True\n        except rospy.ServiceException as e:\n            print(\"Failed to switch flight mode: %s\" % e)\n            return False\n\n", "CodeBleu_score": 46.97537455257823}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Switch to %s failed: %s\" % (self.flight_mode, e))\n            return False\n\n", "CodeBleu_score": 58.09904618133949}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            flight_mode_service = self.vehicle.services.flight_mode\n            flight_mode_service(mavutil.mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED, self.flight_mode_dict[self.flight_mode])\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Failed to switch to \" + self.flight_mode + \" mode\")\n            return False", "CodeBleu_score": 51.1372074590574}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n\n    if self.takeoff_target_pose is not None:\n        self.takeoff_target_pose.pose.position.x += self.local_pose.pose.position.x\n        self.takeoff_target_pose.pose.position.y += self.local_pose.pose.position.y\n        self.takeoff_target_pose.pose.position.z += self.local_pose.pose.position.z\n\n    if self.hover_target_pose is not None:\n        self.hover_target_pose.pose.position.x += self.local_pose.pose.position.x\n        self.hover_target_pose.pose.position.y += self.local_pose.pose.position.y\n        self.hover_target_pose.pose.position.z += self.local_pose.pose.position.z\n\n    self.global_pose.pose.position.x += self.local_pose.pose.position.x\n    self.global_pose.pose.position.y += self.local_pose.pose.position.y\n    self.global_pose.pose.position.z += self.local_pose.pose.position.z\n\n", "CodeBleu_score": 20.243847842874647}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.uav_id:\n        self.local_pose = msg\n\n    if self.uav_id == 0:\n        if self.takeoff_flag:\n            self.takeoff_target_pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.position.z = self.local_pose.pose.position.z + self.takeoff_height\n            self.takeoff_target_pose.orientation.x = self.local_pose.pose.orientation.x\n            self.takeoff_target_pose.orientation.y = self.local_pose.pose.orientation.y\n            self.takeoff_target_pose.orientation.z = self.local_pose.pose.orientation.z\n            self.takeoff_target_pose.orientation.w = self.local_pose.pose.orientation.w\n\n        if self.hover_flag:\n            self.hover_target_pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.position.z = self.local_pose.pose.position.z\n            self.hover_target_pose.orientation.x = self.local_pose.pose.orientation.x\n            self.hover_target_pose.orientation.y = self.local_pose.pose.orientation.y\n            self.hover_target_pose.orientation.z = self.local_pose.pose.orientation.z\n            self.hover_target_pose.orientation.w = self.local_pose.pose.orientation.w\n\n    if self.uav_id == 1:\n        if self.takeoff_flag:\n            self.takeoff_target_pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.position.y = self.local_pose.pose.position.y\n            self", "CodeBleu_score": 16.107784948851318}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if i == self.id:\n        self.local_pose = msg\n        self.local_pose.header.frame_id = \"uav\" + str(self.id) + \"_home\"\n    if self.takeoff_target_pose is None:\n        self.takeoff_target_pose = self.local_pose\n    if self.hover_target_pose is None:\n        self.hover_target_pose = self.local_pose\n    self.global_pose = self.local_pose\n    self.global_pose.pose.position.x += self.pose_bias[0]\n    self.global_pose.pose.position.y += self.pose_bias[1]\n    self.global_pose.pose.position.z += self.pose_bias[2]\n\n\n\n", "CodeBleu_score": 30.263981094040265}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == \"GUIDED\" and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 58.997434928278494}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.mode == \"GUIDED\" and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n\n\n\n\n", "CodeBleu_score": 58.997434928278494}, {"code": "def takeoff_detection(self)\n\t\n    if self.state.armed and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 57.03249491742921}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distances = np.zeros((len(orig_formation), len(orig_formation)))\n    for i, uav1 in enumerate(orig_formation):\n        for j, uav2 in enumerate(orig_formation):\n            distances[i][j] = int(50 - np.linalg.norm(uav1 - uav2))\n    return distances\n", "CodeBleu_score": 22.82778793895379}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    distance_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            distance_matrix[i][j] = int(50 - np.linalg.norm(orig_formation[i] - orig_formation[j]))\n    return distance_matrix\n\n", "CodeBleu_score": 25.490931479095753}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    n = len(orig_formation)\n    distance_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                distance_matrix[i, j] = int(\n                    50 - np.linalg.norm(orig_formation[i] - orig_formation[j])\n                )\n    return distance_matrix\n\n", "CodeBleu_score": 24.882525188448458}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    for i in range(self.num_left):\n        self.slack_right = [\n            float('inf') for _ in range(self.num_right)\n        ]\n        while True:\n            self.visit_left = [False for _ in range(self.num_left)]\n            self.visit_right = [False for _ in range(self.num_right)]\n            if self.find_path(i):\n                break\n            d = float('inf')\n            for j in range(self.num_right):\n                if not self.visit_right[j]:\n                    d = min(d, self.slack_right[j])\n            for j in range(self.num_left):\n                if self.visit_left[j]:\n                    self.label_left[j] -= d\n            for j in range(self.num_right):\n                if self.visit_right[j]:\n                    self.label_right[j] += d\n                else:\n                    self.slack_right[j] -= d\n    return self.match_right", "CodeBleu_score": 43.85323911688184}, {"code": "def KM(self)\n\t\n    for i in range(self.n):\n        self.slack_right = [float(\"inf\") for _ in range(self.m)]\n        while True:\n            self.visit_left = [False for _ in range(self.n)]\n            self.visit_right = [False for _ in range(self.m)]\n            if self.find_path(i):\n                break\n            d = float(\"inf\")\n            for j in range(self.m):\n                if not self.visit_right[j]:\n                    d = min(d, self.slack_right[j])\n            for j in range(self.n):\n                if self.visit_left[j]:\n                    self.label_left[j] -= d\n            for j in range(self.m):\n                if self.visit_right[j]:\n                    self.label_right[j] += d\n                else:\n                    self.slack_right[j] -= d\n    return self.match_right", "CodeBleu_score": 44.76798540434401}, {"code": "def KM(self)\n\t\n    for i in range(self.num_UAVs):\n        self.slack_right = [float(\"inf\") for _ in range(self.num_targets)]\n        while True:\n            self.visit_left = [False for _ in range(self.num_UAVs)]\n            self.visit_right = [False for _ in range(self.num_targets)]\n            if self.find_path(i):\n                break\n            d = float(\"inf\")\n            for j in range(self.num_targets):\n                if not self.visit_right[j]:\n                    d = min(d, self.slack_right[j])\n            for j in range(self.num_UAVs):\n                if self.visit_left[j]:\n                    self.label_left[j] -= d\n            for j in range(self.num_targets):\n                if self.visit_right[j]:\n                    self.label_right[j] += d\n                else:\n                    self.slack_right[j] -= d\n    return self.match_right\n\n", "CodeBleu_score": 43.528923185135206}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV color space\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color using the lower and upper bounds\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV color space\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color using the defined bounds\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n\n", "CodeBleu_score": 30.535780286037383}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t    auto it = standalone_tag_descriptions_.find(id);\n    if (it != standalone_tag_descriptions_.end()) {\n        descriptionContainer = it->second;\n        return true;\n    }\n    if (printWarning) {\n        ROS_WARN_STREAM(\"Could not find standalone tag description with id \" << id);\n    }\n    return false;\n}", "CodeBleu_score": 37.34767168459728}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t  // Check if the standalone_tag_descriptions_ map contains the given ID\n  if (standalone_tag_descriptions_.count(id) == 0) {\n    // If the ID is not found, log a warning message if printWarning is true\n    if (printWarning) {\n      ROS_WARN_STREAM(\"Could not find standalone tag description with id \" << id << \". This tag will be ignored.\");\n    }\n    return false;\n  }\n  // If the ID is found, set the descriptionContainer to the tag's description and return true\n  descriptionContainer = standalone_tag_descriptions_[id];\n  return true;\n}", "CodeBleu_score": 28.42013875530699}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t    auto it = standalone_tag_descriptions_.find(id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (print_warning) {\n            ROS_WARN_STREAM(\"Could not find standalone tag description with id \" << id);\n        }\n        return false;\n    }\n\n    description_container = it->second;\n    return true;\n}", "CodeBleu_score": 38.57205745266374}]}
