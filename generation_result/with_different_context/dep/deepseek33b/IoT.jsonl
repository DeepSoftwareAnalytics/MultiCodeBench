{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_desc_t UDC_DESC_STORAGE *next_desc;\n\tuint8_t *desc_end;\n\n\tnext_desc = (usb_desc_t UDC_DESC_STORAGE *) desc;\n\tdesc_end = (uint8_t *) desc + desc->bLength;\n\n\twhile (next_desc < desc_end) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tnext_desc = (usb_desc_t UDC_DESC_STORAGE *) ((uint8_t *) next_desc + next_desc->bLength);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 48.77117605685519}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *)\n\t\t\t\tdesc + desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.06002970671796}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\twhile (desc->bLength) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 33.92509164172057}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  usb_config_desc_t *config_desc = udc_get_config_desc();\n  if (config_desc == NULL) {\n    return false;\n  }\n  if (iface_num >= config_desc->bNumInterfaces) {\n    return false;\n  }\n  uint8_t *desc_ptr = (uint8_t *)config_desc;\n  desc_ptr += config_desc->bLength;\n  while (desc_ptr < (uint8_t *)config_desc + config_desc->wTotalLength) {\n    usb_desc_header_t *desc_header = (usb_desc_header_t *)desc_ptr;\n    if (desc_header->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n      usb_interface_desc_t *iface_desc = (usb_interface_desc_t *)desc_ptr;\n      if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n        return true;\n      }\n    }\n    desc_ptr += desc_header->bLength;\n  }\n  return false;\n}", "CodeBleu_score": 47.44201207518106}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t  usb_desc_t *desc = udc_config_desc;\n  usb_desc_t *desc_end = udc_config_desc + udc_config_desc_size;\n  usb_iface_desc_t *iface_desc;\n  while (desc < desc_end) {\n    if (desc->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n      iface_desc = (usb_iface_desc_t *)desc;\n      if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n        return true;\n      }\n    }\n    desc = (usb_desc_t *)((uint8_t *)desc + desc->bLength);\n  }\n  return false;\n}", "CodeBleu_score": 35.46322961101638}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t    // Check if there is a valid configuration\n    if (!udc_is_configured()) {\n        return false;\n    }\n\n    // Check if the interface number is within bounds\n    if (iface_num >= udc_get_num_ifaces()) {\n        return false;\n    }\n\n    // Iterate through the descriptors, starting from the beginning of the configuration descriptor\n    const usb_desc_t *desc = udc_get_config_desc();\n    while (desc) {\n        // Check if the descriptor is an interface descriptor\n        if (desc->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n            // Check if the interface descriptor matches the specified interface number and setting number\n            const usb_iface_desc_t *iface_desc = (const usb_iface_desc_t *)desc;\n            if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n                return true;\n            }\n        }\n\n        // Move to the next descriptor\n        desc = usb_desc_next(desc);\n    }\n\n    // If no matching interface descriptor was found, return false\n    return false;\n}", "CodeBleu_score": 37.82243531789703}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udc_req_len != sizeof(udc_ep_status)) {\n        return false;\n    }\n\n    if (udc_ep_is_halted(udc_req_windex)) {\n        udc_ep_status = UDC_EP_STATUS_HALTED;\n    } else {\n        udc_ep_status = 0;\n    }\n\n    udc_setup_payload_in(udc_ep_status);\n    return true;\n}", "CodeBleu_score": 41.79594796635423}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    if (udc_req_len != sizeof(udc_ep_status)) {\n        return false;\n    }\n    udc_ep_status = (udc_ep_status_t)udc_ep_status_halt;\n    if (udc_ep_is_halted(udc_ep_num)) {\n        udc_ep_status |= UDC_EP_STATUS_HALTED;\n    }\n    udc_req_resp_payload[0] = udc_ep_status;\n    return true;\n}", "CodeBleu_score": 50.17014602020311}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t    uint8_t ep_status = 0;\n    if (udc_req_len != sizeof(ep_status)) {\n        return false;\n    }\n    if (udc_ep_is_halted(udc_req_wIndex)) {\n        ep_status = UDC_EP_STATUS_HALTED;\n    }\n    udc_resp_payload[0] = ep_status;\n    udc_resp_len = 1;\n    return true;\n}", "CodeBleu_score": 38.727396289035354}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num = udc_setup.wIndex & 0xFF;\n\tuint8_t setting_num = (udc_setup.wIndex >> 8) & 0xFF;\n\n\t// Check if the device is in a configured state\n\tif (udc_state != UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\tswitch (udc_setup.bRequest) {\n\tcase USB_REQ_SET_INTERFACE:\n\t\treturn udc_ptr_iface->udi_iface->setup(udc_setup.bRequest,\n\t\t\t\tudc_setup.wValue, udc_setup.wIndex,\n\t\t\t\tudc_setup.wLength);\n\tdefault:\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 62.95731389303907}, {"code": "static bool udc_req_iface(void){\n\t", "CodeBleu_score": 1.917982802830473}, {"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tusb_setup_req_t *setup;\n\tuint8_t *ptr;\n\tbool result;\n\n\t// Check if device is in a configured state\n\tif (USB_STATE_CONFIGURED != udc_state) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tiface_num = udc_setup_request.wIndex & 0xFF;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tsetting_num = 0;\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tsetting_num = udc_ptr_iface->bAlternateSetting;\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\tsetup = &udc_setup_request;\n\tptr = udc_setup_buffer;\n\tresult = udc_ptr_conf->udi_handler->setup(setup, ptr);\n\n\treturn result;\n}", "CodeBleu_score": 60.544072084762234}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t  // Initialize flags\n  udi_msc_cbw_received_flag = false;\n  udi_msc_data_in_received_flag = false;\n  udi_msc_data_out_received_flag = false;\n\n  // Get number of LUNs\n  udi_msc_num_luns = udi_msc_get_nb_luns();\n\n  // Check if there are any LUNs available\n  if (udi_msc_num_luns == 0) {\n    return false;\n  }\n\n  // Unload medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_num_luns; i++) {\n    udi_msc_lun_unload(i);\n  }\n\n  // Check if external enable function fails\n  if (!udi_msc_enable_external()) {\n    return false;\n  }\n\n  // Start MSC process by waiting for CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 47.54343792225098}, {"code": "bool udi_msc_enable(void){\n\t  // Check if the interface is already enabled\n  if (udi_msc.enabled) {\n    return true;\n  }\n\n  // Check if the external enable function is available and returns true\n  if (!udi_msc_external_enable()) {\n    return false;\n  }\n\n  // Set the number of LUNs\n  udi_msc.nb_lun = udi_msc_get_nb_lun();\n\n  // Check if there are any LUNs available\n  if (udi_msc.nb_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t i = 0; i < udi_msc.nb_lun; i++) {\n    udi_msc_unload_lun(i);\n  }\n\n  // Set the enabled flag to true\n  udi_msc.enabled = true;\n\n  // Wait for a Command Block Wrapper (CBW) reception\n  udi_msc_cbw_wait();\n\n  // Return true if the MSC interface is enabled\n  return true;\n}", "CodeBleu_score": 47.13308629622786}, {"code": "bool udi_msc_enable(void){\n\t  // Initialize the MSC state\n  udi_msc_state = UDI_MSC_ENABLED;\n\n  // Initialize the number of LUNs\n  udi_msc_lun_nb = udi_msc_get_nb_lun();\n\n  // Check if there are LUNs available\n  if (udi_msc_lun_nb == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  for (uint8_t i = 0; i < udi_msc_lun_nb; i++) {\n    udi_msc_lun_unload(i);\n  }\n\n  // Check if the external enable function fails\n  if (!udi_msc_enable_external()) {\n    return false;\n  }\n\n  // Start the MSC process by waiting for a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 48.179979716149745}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_TRANSFER_OK) {\n    // Wait for MSC setup reset to restart CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_update(0, 0, 0);\n  // Decrease data residue in CSW by amount of data sent\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 69.06737130342857}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_TRANSFER_OK) {\n    // Error during transfer\n    // Wait for MSC setup reset to restart CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_update(udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN,\n      udi_msc_cbw.bmCBWFlags & USB_CBW_DATA_TRANSFER_LENGTH,\n      udi_msc_cbw.bmCBWFlags & USB_CBW_LAST_BLOCK_OF_XFER,\n      udi_msc_cbw.bmCBWFlags & USB_CBW_DISCONNECT, nb_sent);\n  // Decrease data residue in CSW by amount of data sent\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 62.50738869492436}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t  if (status != UDD_EP_TRANSFER_OK) {\n    // Wait for MSC setup reset to restart CBW reception\n    udi_msc_sense_error(USB_MSC_SENSE_NOT_READY);\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_data.dRemainingLength -= nb_sent;\n  if (udi_msc_sense_data.dRemainingLength == 0) {\n    // End of transfer\n    udi_msc_sense_pass();\n  }\n  // Decrease data residue in CSW by amount of data sent\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 60.53638413201552}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue, stall the next request\n  if (udi_msc_csw.bCSWDataResidue != 0) {\n    if (udi_msc_csw.bCSWStatus == UDI_MSC_CSW_STATUS_SUCCESSFUL) {\n      // Stall next IN request\n      udd_ep_stall(UDI_MSC_EP_IN);\n    } else {\n      // Stall next OUT request\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    }\n  }\n  // Prepare CSW\n  udi_msc_csw.dwCSWTag = udi_msc_csw.dwCSWTag;\n  udi_msc_csw.bCSWDataResidue = udi_msc_csw.bCSWDataResidue;\n  udi_msc_csw.bCSWStatus = udi_msc_csw.bCSWStatus;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 53.22680700321505}, {"code": "static void udi_msc_csw_process(void){\n\t  // If there is a non-zero data residue\n  if (udi_msc_csw.b.dResidue) {\n    // Stall the next request from the USB host on the appropriate endpoint\n    udi_msc_csw.b.bStatus = UDI_MSC_CSW_STATUS_FAILED;\n    if (udi_msc_cbw.b.bDirection) {\n      // If the direction is IN\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      // If the direction is OUT\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  } else {\n    // Prepare the CSW by setting its tag\n    udi_msc_csw.b.bStatus = UDI_MSC_CSW_STATUS_OK;\n  }\n\n  // Convert the data residue to little-endian format\n  udi_msc_csw.b.dResidue = udi_msc_csw.b.dResidue;\n\n  // Send the CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 55.09303157172059}, {"code": "static void udi_msc_csw_process(void){\n\t  if (udi_msc_cbw.dDataResidue != 0) {\n    // Stall next request\n    udd_ep_stall(udi_msc_cbw.bmFlags & UDI_MSC_CBW_DIR_IN ? UDI_MSC_EP_IN : UDI_MSC_EP_OUT);\n  }\n\n  // Prepare CSW\n  udi_msc_csw.dTag = udi_msc_cbw.dTag;\n  udi_msc_csw.bStatus = UDI_MSC_CSW_OK;\n  udi_msc_csw.dDataResidue = udi_msc_cbw.dDataResidue;\n  udi_msc_csw.bStatus = udi_msc_cbw.bmFlags & UDI_MSC_CBW_DIR_IN ? UDI_MSC_CSW_OK : UDI_MSC_CSW_FAIL;\n  udi_msc_csw.bmFlags = udi_msc_cbw.bmFlags;\n\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 45.17563067102228}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (b_enable) {\n        usb_cdc_dtr_enable(port);\n        cancelReset();\n    } else {\n        usb_cdc_dtr_disable(port);\n        if (usb_cdc_get_line_coding(port).dwDTERate == 1200) {\n            resetController.reset_scheduled = true;\n            resetController.reset_scheduled_time = time_ms();\n            initiateReset();\n        }\n    }\n}", "CodeBleu_score": 43.195633734287355}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (port >= USB_NUM_PORTS) {\n        return;\n    }\n\n    usb_cdc_dtr_t dtr = usb_cdc_dtr[port];\n    dtr.b_dtr_enabled = b_enable;\n    usb_cdc_dtr[port] = dtr;\n\n    if (usb_cdc_dtr[port].b_dtr_enabled && usb_cdc_dtr[port].dtr_rate == 1200) {\n        // 1200 baud DTR means we are active\n        // Cancel any reset scheduled because of DTR\n        cancelReset();\n    } else {\n        // 1200 baud DTR means we are active\n        // Schedule a reset in 100 ms\n        writeResetController(1);\n        schedule_function_call(initiateReset, NULL, 100 * 1000);\n    }\n}", "CodeBleu_score": 42.241561909415026}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t    if (b_enable) {\n        if (usb_task_cdc_dtr_rate[port] == 1200) {\n            usb_task_cdc_dtr_asserted[port] = true;\n            cancelReset();\n        }\n    } else {\n        usb_task_cdc_dtr_asserted[port] = false;\n        if (usb_task_cdc_dtr_rate[port] == 1200) {\n            // schedule reset in 100ms\n            reset_scheduled = true;\n            reset_delayed_time = (uint32_t) (100 * 1000);\n            reset_delayed_port = port;\n            reset_delayed_task = TASK_CDC;\n            reset_delayed_function = &initiateReset;\n            reset_delayed_arg = NULL;\n        }\n    }\n}", "CodeBleu_score": 38.49129379867778}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t    if (usb_task_get_setup_request_type() == USB_SETUP_REQUEST_TYPE_VENDOR) {\n        switch (usb_task_get_setup_request()) {\n        case 0x04:\n            usb_task_set_control_request_payload(&ms_os_desc_table[0]);\n            usb_task_set_control_request_payload_size(sizeof(ms_os_desc_table));\n            return true;\n        case 0x05:\n            usb_task_set_control_request_payload(&ms_ext_prop_desc_table[0]);\n            usb_task_set_control_request_payload_size(sizeof(ms_ext_prop_desc_table));\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 16.353842151278936}, {"code": "bool usb_task_other_requests(void){\n\t", "CodeBleu_score": 0.8606018832997959}, {"code": "bool usb_task_other_requests(void){\n\t    if (usb_task_get_setup_request_type() == USB_SETUP_REQUEST_TYPE_VENDOR) {\n        if (usb_task_get_setup_request_index() == 0x04) {\n            usb_task_set_payload(usb_descriptors_ms_os_descriptors, sizeof(usb_descriptors_ms_os_descriptors));\n            return true;\n        }\n\n        if (usb_task_get_setup_request_index() == 0x05) {\n            usb_task_set_payload(usb_descriptors_ms_extended_properties_descriptors, sizeof(usb_descriptors_ms_extended_properties_descriptors));\n            return true;\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 17.640304229243796}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t  if (nbyte == 0) {\n    return;\n  }\n\n  nbyte--;\n  spiSend(0xFF);\n  while (nbyte--) {\n    *buf++ = spiRec();\n    spiSend(0xFF);\n  }\n  *buf = spiRec();\n}", "CodeBleu_score": 39.15129974334559}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0) {\n        return;\n    }\n    nbyte--;\n    spiSend(0xFF);\n    while (nbyte--) {\n        // wait for byte received\n        while (!(SPSR & (1 << SPIF))) {\n        }\n        *buf = SPDR;\n        buf++;\n        spiSend(0xFF);\n    }\n    // wait for byte received\n    while (!(SPSR & (1 << SPIF))) {\n    }\n    *buf = SPDR;\n}", "CodeBleu_score": 35.43456310851625}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t    if (nbyte == 0) return;\n    for (uint16_t i = 0; i < nbyte - 1; i++) {\n        spiTransmitByte(0xFF);\n        while (spiDataReady() == 0);\n        buf[i] = spiRec();\n    }\n    spiTransmitByte(0xFF);\n    buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 53.74993517312754}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pNVIC_VectTable;\n\n    /* Get the address of the relocated interrupt vector table */\n    pNVIC_VectTable = (uint32_t *) SCB_VTOR;\n\n    /* Disable global interrupts to ensure atomic operation */\n    __disable_irq();\n\n    /* Retrieve the current handler for the specified IRQ */\n    oldHandler = (pfnISR_Handler) pNVIC_VectTable[irq + 16];\n\n    /* Replace the current handler with the new handler */\n    pNVIC_VectTable[irq + 16] = (uint32_t) newHandler;\n\n    /* Re-enable global interrupts */\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 56.390397986038735}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler;\n    uint32_t *pIntVec;\n\n    pIntVec = (uint32_t *)SCB_VTOR;\n    oldHandler = (pfnISR_Handler)pIntVec[irq + 16];\n    __disable_irq();\n    pIntVec[irq + 16] = (uint32_t)newHandler;\n    __enable_irq();\n    return oldHandler;\n}", "CodeBleu_score": 57.19912931420791}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pNVIC_VECT_TBL = (uint32_t *)NVIC_VECT_TBL_BASE;\n    uint32_t offset = irq + NVIC_VECT_TBL_OFFSET;\n\n    __disable_irq();\n    oldHandler = (pfnISR_Handler)pNVIC_VECT_TBL[offset];\n    pNVIC_VECT_TBL[offset] = (uint32_t)newHandler;\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 46.21441110346676}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_cdc_enabled) {\n    int c = usb_cdc_peek_byte();\n    if (c >= 0) {\n      if (c == DLE) {\n        if (usb_cdc_peek_byte() == EMERGENCY_BYTE) {\n          emergency_parser.update(EMERGENCY_BYTE);\n          c = usb_cdc_get_byte();\n        }\n      }\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 46.87287511000995}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (!is_active()) return -1;\n  if (rx_buffer_head == rx_buffer_tail) return -1;\n  return rx_buffer[rx_buffer_tail];\n}", "CodeBleu_score": 24.085082630491232}, {"code": "int MarlinSerialUSB::peek(){\n\t  if (usb_cdc_enabled) {\n    int c = usb_cdc_peek();\n    if (c >= 0) {\n      if (c == DLE) {\n        c = usb_cdc_getchar();\n        if (c >= 0) {\n          if (c == ETX) {\n            if (emergency_parser.enabled)\n              emergency_parser.parse(c);\n          }\n          else {\n            if (emergency_parser.enabled)\n              emergency_parser.parse(c);\n            c = usb_cdc_getchar();\n          }\n        }\n      }\n      else {\n        if (emergency_parser.enabled)\n          emergency_parser.parse(c);\n      }\n    }\n    return c;\n  }\n  else\n    return -1;\n}", "CodeBleu_score": 42.893212786391295}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t  int c = -1;\n\n  if (usb_serial_available()) {\n    c = _usb_serial_getchar();\n    if (c < 0) return 0;\n    if (c == DLE) {\n      ucp = c;\n      return -1;\n    }\n    else if (ucp == DLE) {\n      c = c ^ 0x20;\n      ucp = 0;\n    }\n  }\n  else {\n    if (usb_cdc_enabled) {\n      c = _usb_readchar();\n      if (c > 0) {\n        if (ucp == DLE) {\n          c = c ^ 0x20;\n          ucp = 0;\n        }\n        else if (c == DLE) {\n          ucp = c;\n          return -1;\n        }\n      }\n      else\n        return 0;\n    }\n    else\n      return -1;\n  }\n\n  if (ucp == DLE) {\n    ucp = 0;\n    return -1;\n  }\n\n  if (emergency_parser)\n    emergency_parser.update(c);\n\n  return c;\n}", "CodeBleu_score": 44.15206489544242}, {"code": "int MarlinSerialUSB::read(){\n\t  // Check if there is a pending character\n  if (pending) {\n    pending = false;\n    return buffer;\n  }\n\n  // Check if USB CDC is enabled and configured\n  if (!is_usb_cdc_enabled())\n    return -1;\n\n  // Check if there are any bytes available to read\n  if (!tud_cdc_available())\n    return -1;\n\n  // Read a byte from the PC\n  char c = tud_cdc_read_char();\n\n  // Update the emergency parser if enabled\n  if (emergency_state != Emergency_parser_state::NOT_STARTED) {\n    emergency_parser(c);\n    return -1;\n  }\n\n  // Return the read character\n  return c;\n}", "CodeBleu_score": 40.57328487872562}, {"code": "int MarlinSerialUSB::read(){\n\t    int c = -1;\n    if (usb_serial_class::_rx_buffer_head != usb_serial_class::_rx_buffer_tail) {\n        c = usb_serial_class::_rx_buffer[usb_serial_class::_rx_buffer_tail];\n        usb_serial_class::_rx_buffer_tail = (usb_serial_class::_rx_buffer_tail + 1) % USB_RX_BUFFER_SIZE;\n        return c;\n    }\n    if (!usb_serial_class::_usb_cdc_enabled) return -1;\n    if (!usb_serial_class::_usb_cdc_configured) return -1;\n    if (usb_serial_class::_usb_cdc_rx_buffer_head == usb_serial_class::_usb_cdc_rx_buffer_tail) return -1;\n    c = usb_serial_class::_usb_cdc_rx_buffer[usb_serial_class::_usb_cdc_rx_buffer_tail];\n    usb_serial_class::_usb_cdc_rx_buffer_tail = (usb_serial_class::_usb_cdc_rx_buffer_tail + 1) % USB_CDC_RX_BUFFER_SIZE;\n    if (c == '\n' && usb_serial_class::_emergency_parser) {\n        usb_serial_class::_emergency_parser = false;\n    }\n    return c;\n}", "CodeBleu_score": 36.42230362860075}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t    if (usb_cdc_is_rx_ready()) {\n        return usb_cdc_available();\n    }\n    return 0;\n}", "CodeBleu_score": 20.215069974423717}, {"code": "int MarlinSerialUSB::available(){\n\t  if (usb_serial_available()) {\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}", "CodeBleu_score": 16.261928876184587}, {"code": "int MarlinSerialUSB::available(){\n\t    if (usb_cdc_line_rtsdtr_available()) {\n        return usb_cdc_line_rtsdtr_get();\n    }\n    return 0;\n}", "CodeBleu_score": 19.03219375135929}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = read_byte(pos++);\n    if (writing) {\n      crc16(crc, &c, 1);\n      *value++ = c;\n    }\n  }\n  return false;\n}", "CodeBleu_score": 56.69919525502055}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) *value++ = c;\n    crc16(crc, &c, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 65.80663681108155}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t  while (size--) {\n    uint8_t c = ee_Read(pos);\n    if (writing) {\n      *value = c;\n      crc16(crc, value, 1);\n      value++;\n    }\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 64.90892648210291}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin == PIN_NONE) return;\n  if (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return;\n\n  // Try to use hardware PWM channels\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // Try to use software PWM\n  for (int i = 0; i < MAX_SOFTWARE_PWM; i++) {\n    if (swpwm[i].pin == pin) {\n      swpwm[i].value = value;\n      return;\n    }\n  }\n\n  // Allocate new software PWM slot\n  if (used_swpwm < MAX_SOFTWARE_PWM) {\n    swpwm[used_swpwm].pin = pin;\n    swpwm[used_swpwm].value = value;\n    used_swpwm++;\n    if (used_swpwm == 1) {\n      // Start the timer\n      timer_pwm.priority(1);\n      timer_pwm.begin(PWM_TIMER_INTERVAL, timer_pwm_callback, NULL, true);\n    }\n  }\n}", "CodeBleu_score": 62.38432708321856}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n  }\n  else {\n    // no hardware PWM channel available\n    // find existing software PWM state\n    for (int i = 0; i < MAX_PWM_SOFTWARE_PINS; i++) {\n      if (pwmSoftwarePins[i].pin == pin) {\n        // found existing software PWM state\n        pwmSoftwarePins[i].value = value;\n        return;\n      }\n    }\n    // allocate new software PWM state\n    if (pwmSoftwarePinsCount < MAX_PWM_SOFTWARE_PINS) {\n      pwmSoftwarePins[pwmSoftwarePinsCount].pin = pin;\n      pwmSoftwarePins[pwmSoftwarePinsCount].value = value;\n      pwmSoftwarePinsCount++;\n      if (pwmSoftwarePinsCount == 1) {\n        // start timer if this is the first PWM pin used\n        pwmSoftwareTimer.begin(pwmSoftwareTimerCallback, 1000000 / PWM_FREQUENCY);\n      }\n    }\n  }\n}", "CodeBleu_score": 61.84856580131473}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\t  if (pin >= MAX_PWM_IOPIN) return; // Not a PWM pin\n\n  // Check for hardware PWM\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n\n  // Allocate a new slot if needed\n  int8_t sid = -1;\n  for (int i = 0; i < MAX_SOFTWARE_PWM; i++) {\n    if (swpwm_pin[i] == 0) {\n      sid = i;\n      swpwm_pin[i] = pin;\n      swpwm_freq[i] = freq;\n      swpwm_res[i] = res;\n      if (swpwm_used == 0) {\n        swpwm_timer = timerBegin(SWPWM_TIMER_NUM, swpwm_res[i], true);\n        timerAttachInterrupt(swpwm_timer, swpwm_isr, true);\n        timerAlarmWrite(swpwm_timer, 1000000 / swpwm_freq[i], true);\n        timerAlarmEnable(swpwm_timer);\n      }\n      swpwm_used++;\n      break;\n    }\n  }\n  if (sid < 0) return; // No free slots\n\n  // Set the PWM value\n  swpwm_value[sid] = value;\n  swpwm_value_max[sid] = (1 << swpwm_res[sid]) - 1;\n  swpwm_value_cur[sid] = 0;\n  swpwm_count[sid] = 0;\n  swpwm_ready[sid] = false;\n}", "CodeBleu_score": 58.63339245458029}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 40.689774758976164}, {"code": "void Servo::move(const int value){\n\t  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVOS, \"SERVO_DELAY must be an array NUM_SERVOS long.\");\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 76.16059977709784}, {"code": "void Servo::move(const int value){\n\t  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 34.173929819247675}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t    // Read the current state of the PWM tick count\n    uint32_t pwm_ticks = i2s_pwm_ticks;\n\n    // Update the PWM states for each pin\n    for (int i = 0; i < I2S_NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (i2s_pwm_duty[i] > 0) {\n            // If the PWM tick count reaches zero, toggle the pin state\n            if (pwm_ticks == 0) {\n                i2s_pwm_state[i] = !i2s_pwm_state[i];\n                // Set the tick count for the next transition\n                pwm_ticks = i2s_pwm_duty[i];\n            }\n            // Decrement the PWM tick count\n            pwm_ticks--;\n        }\n    }\n\n    // Store the updated port data into the current position of the DMA buffer\n    i2s_dma_buffer[i2s_dma_pos++] = i2s_pwm_state[0] | (i2s_pwm_state[1] << 1) | (i2s_pwm_state[2] << 2) | (i2s_pwm_state[3] << 3) | (i2s_pwm_state[4] << 4) | (i2s_pwm_state[5] << 5) | (i2s_pwm_state[6] << 6) | (i2s_pwm_state[7] << 7);\n\n    // Update the PWM tick count\n    i2s_pwm_ticks = pwm_ticks;\n}", "CodeBleu_score": 29.730275633830907}, {"code": "void i2s_push_sample(){\n\t    // Update the PWM states for each pin\n    for (int i = 0; i < NUM_PINS; i++) {\n        if (pin_duty_cycle[i] > 0) {\n            if (pin_tick_count[i] == 0) {\n                // Toggle the pin state between high and low based on its current state\n                if (pin_state[i] == HIGH) {\n                    pin_state[i] = LOW;\n                } else {\n                    pin_state[i] = HIGH;\n                }\n\n                // Set the tick count for the next transition\n                pin_tick_count[i] = (pin_duty_cycle[i] * PWM_RESOLUTION) / 100;\n            }\n\n            // Decrement the tick count\n            pin_tick_count[i]--;\n        }\n    }\n\n    // Write the resulting data to the DMA buffer\n    uint32_t port_data = 0;\n    for (int i = 0; i < NUM_PINS; i++) {\n        port_data |= (pin_state[i] << i);\n    }\n    dma_buffer[dma_buffer_pos] = port_data;\n    dma_buffer_pos++;\n}", "CodeBleu_score": 39.08333567524199}, {"code": "void i2s_push_sample(){\n\t    uint32_t mask = 0;\n    for (uint i = 0; i < NUM_PINS; ++i) {\n        if (pwm_get_counter(i) == 0) {\n            if (pwm_get_level(i) == PWM_LEVEL_LOW) {\n                // set pin high\n                mask |= (1u << pins[i]);\n                pwm_set_level(i, PWM_LEVEL_HIGH);\n            } else {\n                // set pin low\n                mask &= ~(1u << pins[i]);\n                pwm_set_level(i, PWM_LEVEL_LOW);\n            }\n            pwm_set_counter(i, pwm_get_period(i));\n        }\n        pwm_dec_counter(i);\n    }\n    dma_hw->al3_write_addr = mask;\n    dma_channel_hw_addr(dma_channel)->write_addr_trig = (uint32_t) &dma_hw->al3_write_addr;\n}", "CodeBleu_score": 37.576275153071336}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    hal_timer_t count;\n\n    switch (timer_num) {\n        case 0:\n            count = TIMER0_COUNT;\n            break;\n        case 1:\n            count = TIMER1_COUNT;\n            break;\n        case 2:\n            count = TIMER2_COUNT;\n            break;\n        case 3:\n            count = TIMER3_COUNT;\n            break;\n        default:\n            count = 0;\n            break;\n    }\n\n    return count;\n}", "CodeBleu_score": 27.395010818947966}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    // Check if the timer number is valid\n    if (timer_num >= NUM_HW_TIMERS) {\n        return 0;\n    }\n\n    // Access the timer configuration for the given timer number\n    TIM_TypeDef *timer = timers[timer_num];\n\n    // Fetch the current counter value from the timer\n    return timer->CNT;\n}", "CodeBleu_score": 31.8414056192077}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t    // Check if the timer number is valid\n    if (timer_num >= NUM_TIMERS) {\n        return 0;\n    }\n\n    // Get the timer configuration\n    timer_config_t *config = &timer_configs[timer_num];\n\n    // Return the current counter value\n    return config->counter;\n}", "CodeBleu_score": 34.41006724031657}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  while (size_t bytes_read = min(size, EEPROM.length() - pos)) {\n    uint8_t c = EEPROM.read(pos);\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    if (--bytes_read == 0) break;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 49.14808315264524}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  while (size_t bytes_read = min(size - (pos & (EE24_PAGE_SIZE - 1)), EE24_PAGE_SIZE)) {\n    uint8_t data[EE24_PAGE_SIZE];\n    uint8_t *ptr = data;\n    uint16_t page = pos >> 5;\n    uint8_t offset = pos & (EE24_PAGE_SIZE - 1);\n    eeprom.read(page, offset, bytes_read, ptr);\n    crc16(crc, ptr, bytes_read);\n    if (writing)\n      while (bytes_read--)\n        *value++ = *ptr++;\n    pos += bytes_read;\n  }\n  return false;\n}", "CodeBleu_score": 43.50625881423428}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\t  while (size_t bytes = min(size, E2END - pos + 1)) {\n    uint8_t c = eeprom_read_byte((uint8_t*)(pos));\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    if (--bytes == 0) break;\n    value++;\n  }\n  return false;\n}", "CodeBleu_score": 52.43557370840075}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t  assert(sdioh);\n  assert(src);\n\n  int tries = 5;\n  while (tries--) {\n    if (SDIO_OK == SDIO_WriteBlock_DMA(sdioh, block, src)) {\n      return true;\n    }\n  }\n\n  printf(\"SDIO_WriteBlock failed\n\");\n  return false;\n}", "CodeBleu_score": 28.871464476200202}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert_param(sdio_handle != NULL);\n    assert_param(src != NULL);\n\n    uint32_t retries = SDIO_WRITE_RETRIES;\n    uint32_t status;\n\n    do {\n        status = SDIO_WriteBlock_DMA(sdio_handle, block, src);\n        if (status != SD_OK) {\n            printf(\"SDIO_WriteBlock failed with status %d\n\", status);\n            HAL_Delay(10);\n        }\n    } while (status != SD_OK && retries--);\n\n    if (status != SD_OK) {\n        printf(\"SDIO_WriteBlock failed after %d retries\n\", SDIO_WRITE_RETRIES);\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 43.83018852929806}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t    assert(sdio_handle != NULL);\n    assert(src != NULL);\n\n    int retries = 5;\n    while (retries-- > 0) {\n        if (SDIO_WriteBlock_DMA(block, src) == true) {\n            return true;\n        }\n    }\n    printf(\"SDIO_WriteBlock: failed\n\");\n    return false;\n}", "CodeBleu_score": 30.032260886461337}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    switch (timer_num) {\n        case TEMP_TIMER:\n            // Set the timer frequency based on the provided frequency\n            // and the temperature timer prescale\n            timer_set_frequency(TEMP_TIMER, frequency, TIMER_PRESCALE_1);\n            // Set the callback priority for temperature\n            timer_set_callback(TEMP_TIMER, temperature_callback, PRIORITY_TEMP);\n            break;\n        case STEP_TIMER:\n            // Set the timer frequency based on the provided frequency\n            // and the stepper timer prescale\n            timer_set_frequency(STEP_TIMER, frequency, TIMER_PRESCALE_1);\n            // Set the callback priority for stepper\n            timer_set_callback(STEP_TIMER, stepper_callback, PRIORITY_STEP);\n            break;\n        default:\n            // If the timer channel is invalid, trigger an assertion failure\n            ASSERT(0);\n            break;\n    }\n}", "CodeBleu_score": 28.691690945132454}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    if (timer_num == TEMP_TIMER) {\n        // Initialize the timer with the given frequency and temperature timer prescale\n        timer_init(TEMP_TIMER, frequency, TEMP_PRESCALE);\n\n        // Set the callback priority for temperature\n        timer_set_callback_priority(TEMP_TIMER, TEMP_CALLBACK_PRIORITY);\n    } else if (timer_num == STEP_TIMER) {\n        // Initialize the timer with the given frequency and stepper timer prescale\n        timer_init(STEP_TIMER, frequency, STEP_PRESCALE);\n\n        // Set the callback priority for stepper\n        timer_set_callback_priority(STEP_TIMER, STEP_CALLBACK_PRIORITY);\n    } else {\n        // Trigger an assertion failure if the timer channel is invalid\n        assert(0);\n    }\n}", "CodeBleu_score": 38.85378329566023}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t    if (timer_num == TIMER_CHANNEL_TEMP) {\n        // Start the temperature timer with the given frequency and temperature timer prescale\n        timer_start(TIMER_GROUP_0, TIMER_0, TIMER_DIVIDER_16, frequency, temperature_timer_callback, NULL, 0);\n\n        // Set the callback priority for temperature\n        timer_set_callback_data(TIMER_GROUP_0, TIMER_0, (void *)TIMER_CHANNEL_TEMP);\n    } else if (timer_num == TIMER_CHANNEL_STEP) {\n        // Start the step timer with the given frequency and stepper timer prescale\n        timer_start(TIMER_GROUP_1, TIMER_1, TIMER_DIVIDER_16, frequency, stepper_timer_callback, NULL, 0);\n\n        // Set the callback priority for stepper\n        timer_set_callback_data(TIMER_GROUP_1, TIMER_1, (void *)TIMER_CHANNEL_STEP);\n    } else {\n        // Invalid timer channel, trigger an assertion failure\n        assert(false);\n    }\n}", "CodeBleu_score": 37.74192641489176}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t  if (!_file) {\n    _file = fileOpen(EEPROM_FILE, (const char *)(\"r+\"));\n\n    if (!_file) {\n      return false;\n    }\n  }\n\n  size_t actualLen = fileSeek(_file, 0, SEEK_END);\n\n  if (actualLen < EEPROM_SIZE) {\n    _dirty = true;\n    memset(_buffer, EEPROM_ERASED_BYTE, actualLen);\n    memset(&_buffer[actualLen], EEPROM_ERASED_BYTE, EEPROM_SIZE - actualLen);\n  } else {\n    fileSeek(_file, 0, SEEK_SET);\n    fileRead(_file, _buffer, EEPROM_SIZE);\n  }\n\n  return true;\n}", "CodeBleu_score": 44.86472668207182}, {"code": "bool PersistentStore::access_start(){\n\t    if (!_eeprom_file.open(eeprom_file_name, OpenMode::readWrite)) {\n        return false;\n    }\n\n    _eeprom_file.seek(0);\n    const uint32_t stat_size = _eeprom_file.size();\n\n    if (stat_size < eeprom_size) {\n        // file is too small.  Make it the right size.\n        for (uint32_t i=stat_size; i<eeprom_size; i++) {\n            _eeprom_file.putc(eeprom_erase_value);\n        }\n    }\n\n    _eeprom_file.seek(0);\n    _eeprom_file.read(_eeprom_buffer, eeprom_size);\n    return true;\n}", "CodeBleu_score": 32.382484295379825}, {"code": "bool PersistentStore::access_start(){\n\t    if (!_eeprom_file.open(eeprom_filename, O_RDWR | O_CREAT)) {\n        return false;\n    }\n\n    if (_eeprom_file.size() < EEPROM_SIZE) {\n        // Fill remainder of buffer with default erase value\n        for (size_t i = _eeprom_file.size(); i < EEPROM_SIZE; i++) {\n            _eeprom_buffer[i] = 0xFF;\n        }\n    } else {\n        // Read file contents into buffer\n        _eeprom_file.read(_eeprom_buffer, EEPROM_SIZE);\n    }\n\n    _eeprom_file.close();\n    return true;\n}", "CodeBleu_score": 27.878463576866707}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t i;\n    uint8_t r = 0;\n\n    for (i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_SET);\n        r <<= 1;\n        if (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin)) {\n            r |= 0x01;\n        }\n        b <<= 1;\n    }\n\n    HAL_Delay(1);\n    return r;\n}", "CodeBleu_score": 42.39984227987734}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t r = 0;\n    for (uint8_t i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_SCK_PORT, SPI_SCK_PIN, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, b & 0x80 ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_SCK_PORT, SPI_SCK_PIN, GPIO_PIN_SET);\n        r = (r << 1) | (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET);\n        b <<= 1;\n    }\n    HAL_Delay(1);\n    return r;\n}", "CodeBleu_score": 43.4035919363875}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t    uint8_t i;\n    uint8_t rxData = 0;\n\n    for (i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_SCK_GPIO_Port, SPI_SCK_Pin, GPIO_PIN_SET);\n        rxData <<= 1;\n        if (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n            rxData |= 0x01;\n        }\n        b <<= 1;\n    }\n\n    HAL_Delay(1);\n    return rxData;\n}", "CodeBleu_score": 41.828224434474635}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.79020628658785}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    uint32_t tmpreg = 0;\n\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (RCC_AHBPeriph == RCC_AHBPeriph_CRC) {\n        /* Enable the CRC clock */\n        tmpreg = RCC->AHBENR;\n        tmpreg |= RCC_AHBPeriph_CRC;\n        RCC->AHBENR = tmpreg;\n    } else {\n        /* Enable or disable the AHB peripheral clock */\n        if (NewState != DISABLE) {\n            RCC->AHBENR |= RCC_AHBPeriph;\n        } else {\n            RCC->AHBENR &= ~RCC_AHBPeriph;\n        }\n    }\n}", "CodeBleu_score": 68.92057270201744}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t    uint32_t tmpreg = 0;\n    uint32_t bitpos = 0;\n    uint32_t bitmask = 0x01;\n\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    bitpos = RCC_AHBPeriph & 0x0F;\n    bitpos = (bitpos >> 1) + (0x0F & (uint32_t)((uint32_t)0x03 * (bitpos & 0x01)));\n    bitmask = ((uint32_t)0x01 << bitpos);\n\n    tmpreg = RCC->AHBENR;\n\n    if (NewState != DISABLE) {\n        tmpreg |= bitmask;\n    } else {\n        tmpreg &= ~bitmask;\n    }\n\n    RCC->AHBENR = tmpreg;\n}", "CodeBleu_score": 56.38697995037503}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t data = obj->uart->RDR;\n  if (obj->parity_error) {\n    obj->uart->CR1 |= USART_CR1_RXNEIE;\n    obj->parity_error = 0;\n    return;\n  }\n  obj->_push(data);\n  obj->uart->CR1 |= USART_CR1_RXNEIE;\n  if (obj->emergency_parser) obj->emergency_parser(data);\n}", "CodeBleu_score": 34.77157176269343}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  uint8_t data = obj->uart->DR;\n  if (!(obj->uart->ISR & USART_ISR_PE)) {\n    obj->_push(data);\n  }\n}", "CodeBleu_score": 17.615932458234727}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t  // If we have a parity error, we need to read the data\n  // to clear it before we can continue.\n  if (obj->is_parity_error()) {\n    // Read the data to clear the error\n    obj->getc();\n    return;\n  }\n\n  // Get the byte\n  char c = obj->getc();\n\n  // Store the byte if there is space.\n  if (rx_buffer_head < RX_BUFFER_SIZE) {\n    rx_buffer[rx_buffer_head] = c;\n    rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n  }\n\n  // Update the emergency parser\n  if (emergency_state != EmergencyParserState::IDLE) {\n    emergency_parser.update(c);\n  }\n}", "CodeBleu_score": 37.969868645817414}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t  if (timer_num == MF_TIMER_STEP) {\n    if (Step_timer_initialized) {\n      if (!Step_timer_interrupt_attached) {\n        attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, RISING);\n        Step_timer_interrupt_attached = true;\n      }\n    }\n  } else if (timer_num == MF_TIMER_TEMP) {\n    if (Temp_timer_initialized) {\n      if (!Temp_timer_interrupt_attached) {\n        attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\n        Temp_timer_interrupt_attached = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 32.39834771046395}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (timer_step_init_flag) {\n            if (!timer_step_interrupt_flag) {\n                attachInterrupt(digitalPinToInterrupt(PIN_TIMER_STEP), Step_Handler, CHANGE);\n                timer_step_interrupt_flag = true;\n            }\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (timer_temp_init_flag) {\n            if (!timer_temp_interrupt_flag) {\n                attachInterrupt(digitalPinToInterrupt(PIN_TIMER_TEMP), Temp_Handler, CHANGE);\n                timer_temp_interrupt_flag = true;\n            }\n        }\n    }\n}", "CodeBleu_score": 30.91807056445412}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t    if (timer_num == MF_TIMER_STEP) {\n        if (!Step_Timer_Initialized) {\n            return;\n        }\n        if (Step_Timer_Interrupt_Attached) {\n            return;\n        }\n        attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, RISING);\n        Step_Timer_Interrupt_Attached = true;\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (!Temp_Timer_Initialized) {\n            return;\n        }\n        if (Temp_Timer_Interrupt_Attached) {\n            return;\n        }\n        attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\n        Temp_Timer_Interrupt_Attached = true;\n    }\n}", "CodeBleu_score": 29.19749475430573}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(sep)\n\tswitch {\n\tcase n == 0:\n\t\treturn len(s)\n\tcase n == len(s):\n\t\tif sep == s {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n > len(s):\n\t\treturn -1\n\t}\n\t// Hash sep and first window of s\n\thashsep, pow := HashStrRev(sep)\n\th := uint32(0)\n\tfor i := 0; i < n; i++ {\n\t\th = h*PrimeRK + uint32(s[len(s)-n+i])\n\t}\n\tlast := len(s) - n\n\tfor i := len(s) - n; i >= 0; i-- {\n\t\tif h == hashsep && s[i:i+n] == sep {\n\t\t\treturn i\n\t\t}\n\t\th *= PrimeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+n])\n\t\tif h == hashsep && s[last:len(s)] == sep {\n\t\t\treturn last\n\t\t}\n\t\tlast--\n\t}\n\treturn -1\n}", "CodeBleu_score": 56.7318133355825}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\thashss, pow := HashStrRev(sep)\n\tlast := len(sep) - 1\n\tn := len(s)\n\tif n < len(sep) {\n\t\treturn -1\n\t}\n\tvar h uint32\n\tfor i := n - 1; i >= 0; i-- {\n\t\th = h*PrimeRK + uint32(s[i])\n\t\tif i+len(sep) >= n {\n\t\t\tif h == hashss && Equal(s[i:i+len(sep)], sep) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\th -= pow * uint32(s[last])\n\t\tlast--\n\t}\n\treturn -1\n}", "CodeBleu_score": 51.98021086237253}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\t\tn := len(sep)\n\tswitch {\n\tcase n == 0:\n\t\treturn len(s)\n\tcase n == len(s):\n\t\tif sep == s {\n\t\t\treturn 0\n\t\t}\n\t\treturn -1\n\tcase n > len(s):\n\t\treturn -1\n\t}\n\t// Hash sep and first window of s\n\thashsep, pow := HashStrRev(sep)\n\thashs, _ := HashStrRev(s[len(s)-n:])\n\tif hashsep == hashs && sep == s[len(s)-n:] {\n\t\treturn len(s) - n\n\t}\n\tfor i := len(s) - n - 1; i >= 0; i-- {\n\t\thashs *= PrimeRK\n\t\thashs += uint32(s[i])\n\t\thashs -= pow * uint32(s[i+n])\n\t\tif hashsep == hashs && sep == s[i:i+n] {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 50.039714673990346}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t", "CodeBleu_score": 2.9310803108831127}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t    usbcdc.waitTxc = false\n    usbcdc.waitRxd = false\n    usbcdc.waitTxc = false\n    usbcdc.waitRxd = false\n}", "CodeBleu_score": 19.68558313968018}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\tusbcdc.waitTxc = false\n}", "CodeBleu_score": 15.616912205308239}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.SetBits(i2c_control_I2C_CONTROL_I2C_CONTROL_CLEAR_INTERRUPT_FLAG)\n\ti2c.control.SetBits(i2c_control_I2C_CONTROL_I2C_CONTROL_START_I2C_TRANSFER)\n\ti2c.control.SetBits(i2c_control_I2C_CONTROL_I2C_CONTROL_ENABLE_I2C_MODULE)\n\n\tfor !i2c.status.HasBits(i2c_status_I2C_STATUS_I2C_STATUS_START_TRANSFER_COMPLETE) {\n\t}\n\n\ti2c.data.Set(address << 1)\n\n\tif !write {\n\t\ti2c.data.SetBits(i2c_data_I2C_DATA_I2C_DATA_READ_TRANSFER)\n\t}\n\n\ti2c.control.SetBits(i2c_control_I2C_CONTROL_I2C_CONTROL_START_I2C_TRANSFER)\n\n\tfor !i2c.status.HasBits(i2c_status_I2C_STATUS_I2C_STATUS_TRANSFER_COMPLETE) {\n\t}\n}", "CodeBleu_score": 28.376069224846972}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.control.SetBits(1 << i2c_control_start)\n\ti2c.control.SetBits(1 << i2c_control_enable)\n\n\tfor !i2c.control.HasBits(1 << i2c_control_started) {\n\t}\n\n\ti2c.data.SetBits(uint32(address) << 1)\n\n\tif !write {\n\t\ti2c.data.SetBits(1 << i2c_data_read)\n\t}\n\n\ti2c.control.SetBits(1 << i2c_control_enable)\n\n\tfor !i2c.control.HasBits(1 << i2c_control_started) {\n\t}\n}", "CodeBleu_score": 35.5183009325399}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.Bus.CTR.SetBits(i2c_ctr_txr | i2c_ctr_start)\n\tfor !i2c.Bus.SR1.HasBits(i2c_sr1_sb) {\n\t}\n\ti2c.writeByte(address<<1 | i2c_write<<7 | i2c_generate_start_read_write)\n}", "CodeBleu_score": 25.708457086090412}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\taddr := uint32(start) * f.blockSize\n\tend := addr + uint32(len)*f.blockSize\n\n\t// Wait for any flash operations to complete.\n\tf.waitForReady()\n\n\t// Erase the flash blocks.\n\tf.setErase()\n\tfor addr < end {\n\t\tf.writeWord(addr, f.eraseValue)\n\n\t\t// Wait until the flash is no longer busy.\n\t\tfor f.readStatus()&StatusBusy != 0 {\n\t\t}\n\n\t\taddr += f.blockSize\n\t}\n\n\t// Set the flash back to read mode.\n\tf.setRead()\n\n\treturn nil\n}", "CodeBleu_score": 29.261603046690297}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := uint32(start) * f.blockSize\n\tendAddress := startAddress + uint32(len)*f.blockSize\n\n\t// Wait for any flash operations to complete.\n\terr := f.waitForAnyBusy()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set flash to erase mode.\n\terr = f.setErase()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Erase sectors.\n\tfor address := startAddress; address < endAddress; address += f.sectorSize {\n\t\terr := f.eraseSector(address)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait until the sector is no longer busy.\n\t\terr = f.waitForBusy()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Set flash back to read mode.\n\terr = f.setRead()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 39.23721670155915}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddr := f.blockSize * start\n\tendAddr := f.blockSize * (start + len)\n\t_, err := f.wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\tf.configureErase()\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\tf.writeWord(addr, f.eraseValue)\n\t\t_, err := f.wait()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tf.configureRead()\n\treturn nil\n}", "CodeBleu_score": 34.44098953397443}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\taddr := uint32(off)\n\tend := addr + uint32(len(p))\n\tif end > f.size {\n\t\treturn 0, errors.New(\"write exceeds device boundary\")\n\t}\n\tstart := addr % f.blockSize\n\tif start > 0 {\n\t\taddr -= start\n\t\tp = p[start:]\n\t}\n\tif uint32(len(p))%f.blockSize != 0 {\n\t\tpad := make([]byte, f.blockSize-uint32(len(p))%f.blockSize)\n\t\tp = append(p, pad...)\n\t}\n\tf.enableWrite()\n\tfor len(p) > 0 {\n\t\tf.waitForReady()\n\t\tf.writeBlock(addr, p[:f.blockSize])\n\t\taddr += f.blockSize\n\t\tp = p[f.blockSize:]\n\t}\n\treturn int(end - uint32(off)), nil\n}", "CodeBleu_score": 30.9653897785909}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\taddr := uint32(off)\n\tend := addr + uint32(len(p))\n\tif end > f.size {\n\t\treturn 0, errFlashRange\n\t}\n\n\tstart := addr - addr%f.blockSize\n\tbuf := p[addr%f.blockSize:]\n\n\tf.wait()\n\tf.setWriteMode()\n\n\tfor len(buf) > 0 {\n\t\tblock := buf[:f.blockSize]\n\t\tbuf = buf[f.blockSize:]\n\t\twriteBlock(f.data, start, block)\n\t\tstart += f.blockSize\n\t\tf.wait()\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 27.357313349962425}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tstart := off\n\tend := off + int64(len(p))\n\tif start < 0 || end > f.size {\n\t\treturn 0, errFlashRange\n\t}\n\n\taddr := f.start + start\n\tlen := end - start\n\n\tbuf := make([]byte, f.writeSize)\n\n\tfor i := int64(0); i < len; i += int64(f.writeSize) {\n\t\tblock := buf[:]\n\t\tif i+int64(len(block)) > len {\n\t\t\tblock = block[:len-i]\n\t\t}\n\n\t\tcopy(block, p[i:])\n\n\t\tf.waitForReady()\n\n\t\tf.setWriteEnable(true)\n\n\t\tf.spi.Tx(addr, block, nil)\n\n\t\tf.setWriteEnable(false)\n\n\t\tn += len(block)\n\t\taddr += int64(len(block))\n\t}\n\n\treturn n, nil\n}", "CodeBleu_score": 30.442398142608944}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupfd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupfd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 59.339342521378924}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tvar dir *syscall.Fdopendir\n\tvar errno syscall.Errno\n\tfor {\n\t\tdir, errno = syscall.Fdopendir(fd2)\n\t\tif errno != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif errno != 0 {\n\t\tsyscall.Close(fd2)\n\t\treturn 0, \"\", errno\n\t}\n\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n}", "CodeBleu_score": 65.43654275711019}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\tdupfd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupfd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dir), \"\", nil\n\t\t}\n\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupfd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 59.339342521378924}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    const esp_partition_t *partition = esp_ota_get_running_partition();\n    if (partition == NULL) {\n        return 0;\n    }\n    const esp_partition_pos_t partition_pos = {\n        .offset = response == SKETCH_SIZE_FREE ? partition->address : 0,\n        .size = partition->size,\n    };\n    return esp_ota_get_partition_size(partition, &partition_pos);\n}", "CodeBleu_score": 45.62581766003444}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t  const esp_partition_t *partition = esp_ota_get_boot_partition();\n  const esp_app_desc_t *app_desc = esp_ota_get_app_description();\n  if (app_desc == NULL) {\n    log_e(\"Could not get sketch size\");\n    return 0;\n  }\n\n  uint32_t sketch_size = app_desc->image_size;\n  if (response == SKETCH_FREE_SPACE) {\n    uint32_t free_space = (partition->size - partition->address) - sketch_size;\n    return free_space;\n  }\n  return sketch_size;\n}", "CodeBleu_score": 41.50609111000288}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t    const esp_partition_t *partition = esp_ota_get_running_partition();\n    if (partition == NULL) {\n        return 0;\n    }\n    if (response == free) {\n        return partition->size - partition->ota_region->offset;\n    } else {\n        return partition->size;\n    }\n}", "CodeBleu_score": 36.67022675531093}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk = calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk) {\n    log_e(\"Failed to allocate %u bytes for RAM disk\", total_sectors * DISK_SECTOR_SIZE);\n    return false;\n  }\n  fat_set_boot_sector(msc_disk, total_sectors, msc_table_sectors, mcs_is_fat16);\n  fat_set_fs_info_sector(msc_disk, total_sectors, msc_table_sectors, mcs_is_fat16);\n  fat_set_fat(msc_disk, msc_table_sectors, mcs_is_fat16);\n  fat_set_volume_label(msc_disk, volume_label);\n  fat_set_serial_number(msc_disk, serial_number);\n  if (msc_run_partition) {\n    fat_add_dir_entry(msc_disk, msc_table_sectors, \"/FIRMWARE.BIN\", fw_size, 0, 0, mcs_is_fat16);\n  }\n  return true;\n}", "CodeBleu_score": 46.85964556657809}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk_sector_size = DISK_SECTOR_SIZE;\n  msc_disk_sector_count = total_sectors;\n  msc_disk_buffer = (uint8_t *)heap_caps_malloc(msc_disk_sector_size * msc_disk_sector_count, MALLOC_CAP_8BIT);\n  if (!msc_disk_buffer) {\n    log_e(\"Failed to allocate %u bytes for disk buffer\", msc_disk_sector_size * msc_disk_disk_sector_count);\n    return false;\n  }\n  fat_set_disk_parameters(msc_disk_sector_size, msc_disk_sector_count, msc_disk_buffer);\n  fat_set_boot_sector(volume_label, serial_number);\n  fat_set_fat_type(mcs_is_fat16);\n  fat_set_fat_table(msc_table_sectors, 0);\n  fat_set_root_directory();\n  if (msc_run_partition) {\n    fat_add_file(\"firmware.bin\", fw_size, 0);\n  }\n  return true;\n}", "CodeBleu_score": 46.214535702698264}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t  size_t total_sectors = msc_update_get_required_disk_sectors();\n  msc_disk = (uint8_t *)calloc(total_sectors, DISK_SECTOR_SIZE);\n  if (!msc_disk) {\n    log_e(\"Failed to allocate RAM disk\");\n    return false;\n  }\n  log_d(\"RAM disk allocated at %p\", msc_disk);\n  msc_update_setup_boot_sector(volume_label, serial_number);\n  msc_update_setup_fat(total_sectors);\n  if (msc_run_partition) {\n    msc_update_add_root_entry(\"firmware.bin\", fw_size, 0);\n  }\n  return true;\n}", "CodeBleu_score": 31.818593001839762}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    if (offset % SPI_FLASH_SEC_SIZE) {\n        err = spi_flash_erase_sector(partition->address + offset);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"spi_flash_erase_sector failed (0x%x)\", err);\n            return err;\n        }\n    }\n    err = spi_flash_write(partition->address + offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"spi_flash_write failed (0x%x)\", err);\n    }\n    return err;\n}", "CodeBleu_score": 55.85773921709964}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err;\n    if (offset % SPI_FLASH_SEC_SIZE) {\n        err = ESP_ERR_INVALID_ARG;\n    } else {\n        err = esp_partition_erase_range(partition, offset, size);\n    }\n    if (err == ESP_OK) {\n        err = esp_partition_write(partition, offset, data, size);\n    }\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"write error %d\", err);\n    }\n    return err;\n}", "CodeBleu_score": 58.21503393089479}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t    esp_err_t err = ESP_OK;\n    if (offset % partition->sector_size) {\n        err = ESP_ERR_INVALID_ARG;\n    } else {\n        err = esp_partition_erase_range(partition, offset, partition->sector_size);\n    }\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"esp_partition_erase_range failed: 0x%x\", err);\n        return err;\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"esp_partition_write failed: 0x%x\", err);\n    }\n    return err;\n}", "CodeBleu_score": 58.11849899976769}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  while (i < maxlen && in[i * 2] && in[i * 2 + 1]) {\n    out[i] = (hex_char_to_byte(in[i * 2]) << 4) | hex_char_to_byte(in[i * 2 + 1]);\n    i++;\n  }\n  return i;\n}", "CodeBleu_score": 37.61581353141522}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  size_t j = 0;\n  while (i < maxlen && in[j]) {\n    uint8_t b = hex_char_to_byte(in[j++]);\n    if (b == 0x10) {\n      continue;\n    }\n    out[i++] = b;\n    b = hex_char_to_byte(in[j++]);\n    if (b == 0x10) {\n      continue;\n    }\n    out[i++] = b;\n  }\n  return i;\n}", "CodeBleu_score": 44.36306135045499}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\t  size_t i = 0;\n  size_t j = 0;\n  while (in[i] != '\\0' && j < maxlen) {\n    uint8_t b;\n    if (in[i] == ' ') {\n      i++;\n      continue;\n    }\n    b = hex_char_to_byte(in[i]) << 4;\n    i++;\n    if (in[i] == '\\0') {\n      break;\n    }\n    if (in[i] == ' ') {\n      i++;\n      continue;\n    }\n    b |= hex_char_to_byte(in[i]);\n    i++;\n    out[j] = b;\n    j++;\n  }\n  return j;\n}", "CodeBleu_score": 43.92806551268652}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t    if (!m_transmitRingBuffer || !m_transmitLock) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(m_transmitLock, portMAX_DELAY)) {\n        int freeSize = m_transmitRingBuffer->availableForWrite();\n        xSemaphoreGive(m_transmitLock);\n        return freeSize;\n    }\n    return 0;\n}", "CodeBleu_score": 49.35107740366431}, {"code": "int HWCDC::availableForWrite(void){\n\t    int ret = 0;\n    if (mRingBuffer && mRingBufferLock) {\n        if (sem_timedwait(mRingBufferLock, &mRingBufferLockTimeout) == 0) {\n            ret = mRingBuffer->getAvailableToWrite();\n            sem_post(mRingBufferLock);\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 39.65706996717774}, {"code": "int HWCDC::availableForWrite(void){\n\t    if (!_tx_ring_buffer || !_tx_lock) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(_tx_lock, 10 / portTICK_PERIDE_MS) == pdTRUE) {\n        int free_size = _tx_ring_buffer->availableForWrite();\n        xSemaphoreGive(_tx_lock);\n        return free_size;\n    }\n\n    return 0;\n}", "CodeBleu_score": 53.10161018941576}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  lock();\n  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    uart_set_rx_full_threshold(_uart_nr, _rx_buffer_size - 1);\n    if (_eventTask == NULL) {\n      _createEventTask(this);\n    }\n  }\n  unlock();\n}", "CodeBleu_score": 42.56870181803174}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  _lock.lock();\n  _onReceiveCB = function;\n  if (onlyOnTimeout) {\n    _rxTimeout = true;\n  } else {\n    _rxTimeout = false;\n  }\n  if (_onReceiveCB != NULL) {\n    uart_set_rx_full_thresh(_uart_nr, UART_FIFO_LEN - 1);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n  _lock.unlock();\n}", "CodeBleu_score": 53.07144263977437}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t  _onReceiveCB = function;\n  _onlyOnTimeout = onlyOnTimeout;\n  if (_onReceiveCB != NULL) {\n    uart_set_fifo_full_threshold(_uart, ARDUINO_SERIAL_FIFO_FULL_THRESHOLD);\n    if (_eventTask == NULL) {\n      _createEventTask(this);\n    }\n  }\n}", "CodeBleu_score": 38.41032354983614}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1)\n    return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator)\n      break;\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, excluding null terminator\n}", "CodeBleu_score": 86.74667315859874}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 99.80465478981657}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}", "CodeBleu_score": 99.80465478981657}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_v(\"Tone on pin %d at %d Hz for %d ms\", pin, frequency, duration);\n  if (pin != _tone_pin) {\n    if (_tone_pin != PIN_UNAVAILABLE) {\n      log_e(\"Tone pin %d is already in use\", _tone_pin);\n      return;\n    }\n    _tone_pin = pin;\n    ledcSetup(_tone_channel, frequency, 8);\n    ledcAttachPin(_tone_pin, _tone_channel);\n  }\n  tone_msg_t msg = {pin, frequency, duration};\n  xQueueSend(_tone_queue, &msg, 1000 / portTICK_PERIOD_MS);\n}", "CodeBleu_score": 48.9862408103083}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_d(\"tone(%d, %d, %d)\", pin, frequency, duration);\n  if (!_tone_pin_available(pin)) {\n    log_e(\"Pin %d is already in use\", pin);\n    log_e(\"Stop the current tone on pin %d first\", pin);\n    return;\n  }\n  _tone_init(pin);\n  tone_msg_t msg = {\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration,\n    .start = true\n  };\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 54.21815703926178}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t  log_v(\"Tone on pin %d at %d Hz for %d ms\", pin, frequency, duration);\n  if (pin >= NUM_DIGITAL_PINS) {\n    log_e(\"Invalid pin number %d\", pin);\n    return;\n  }\n  if (digitalPinIsAttached(pin)) {\n    log_e(\"Pin %d is already in use\", pin);\n    return;\n  }\n  if (!tone_init()) {\n    log_e(\"Tone initialization failed\");\n    return;\n  }\n\n  tone_msg_t msg = {\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration,\n    .command = TONE_START\n  };\n  xQueueSend(_tone_queue, &msg, 0);\n}", "CodeBleu_score": 61.6078403124244}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (enabled) {\n        if (usb_version < 0x0210) {\n            usb_version = 0x0210;\n            usb_has_started = false;\n        }\n        webusb_enabled = true;\n    } else {\n        webusb_enabled = false;\n    }\n    return !usb_has_started;\n}", "CodeBleu_score": 55.51007486034866}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (usb_started) {\n        if (enabled) {\n            usb_descriptor_webusb.bLength = sizeof(USBDescriptorWebUSB);\n            usb_descriptor_webusb.bDescriptorType = USB_DESCRIPTOR_WEBUSB_URL;\n            usb_descriptor_webusb.bScheme = 0x03;\n            usb_descriptor_webusb.bUrlLength = strlen(webusb_url);\n            usb_descriptor_webusb.bUrlScheme = 0x00;\n            usb_descriptor_webusb.bUrl = 0x00;\n            usb_descriptor_webusb.bUrl.qwUrl = (uint64_t)webusb_url;\n        } else {\n            usb_descriptor_webusb.bLength = 0;\n            usb_descriptor_webusb.bDescriptorType = 0x00;\n            usb_descriptor_webusb.bScheme = 0x00;\n            usb_descriptor_webusb.bUrlLength = 0;\n            usb_descriptor_webusb.bUrlScheme = 0x00;\n            usb_descriptor_webusb.bUrl = 0x00;\n        }\n        usb_descriptor_webusb_enabled = enabled;\n        return false;\n    } else {\n        usb_descriptor_webusb_enabled = enabled;\n        return true;\n    }\n}", "CodeBleu_score": 35.67842293569301}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t    if (usb_state == USB_STATE_NOT_STARTED) {\n        webUSB_enabled = enabled;\n        if (enabled) {\n            usb_version = std::max(usb_version, 0x0210);\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 40.69250272422224}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t    uint8_t buf[64];\n    int len = _dev->read(buf, sizeof(buf));\n    if (len > 0) {\n        int sent = _rx_queue.send_all(buf, len);\n        if (sent != len) {\n            _overflow_count += (len - sent);\n            _dev->onError(USBError(errOverflow));\n        }\n        _dev->postEvent(Callback<void()>(this, &USBCDC::_onEvent));\n    }\n}", "CodeBleu_score": 19.413401457170732}, {"code": "void USBCDC::_onRX(){\n\t    // Read data into buffer\n    int len = _rxBuff.read(_rxBuff.getCapacity());\n\n    // Attempt to send each byte to receive queue\n    int dropped = 0;\n    for (int i = 0; i < len; i++) {\n        if (!_rxQueue.try_put(_rxBuff[i])) {\n            dropped++;\n        }\n    }\n\n    // Post overflow event if queue is full\n    if (dropped > 0) {\n        _eventQueue.call(mbed::callback(&USBCDC::_postOverflow), dropped);\n        MBED_WARNING1(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_USB_CDC_RX_OVERFLOW), dropped, \"USBCDC: receive overflow\");\n    }\n\n    // Post receive event with length of received data\n    _eventQueue.call(mbed::callback(&USBCDC::_postReceive), len);\n}", "CodeBleu_score": 27.92810841016343}, {"code": "void USBCDC::_onRX(){\n\t    uint32_t rxlen = 0;\n    uint8_t *rxbuf = (uint8_t *)_rxbuf;\n\n    while (_rxbuf_head != _rxbuf_tail) {\n        if (_rx_queue.full()) {\n            // overflow\n            _rx_overflow.count++;\n            _rx_overflow.timestamp = Kernel::Clock::now();\n            _rx_overflow_event.post();\n            return;\n        }\n\n        _rx_queue.push(*rxbuf);\n        rxbuf++;\n        rxlen++;\n        _rxbuf_head++;\n        if (_rxbuf_head == _rxbuf_end) {\n            _rxbuf_head = _rxbuf;\n        }\n    }\n\n    if (rxlen > 0) {\n        _rx_event.post(rxlen);\n    }\n}", "CodeBleu_score": 27.763587017690377}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\ta.jsonResponse(res, http.StatusInternalServerError, \"Error retrieving robot\")\n\t\treturn\n\t}\n\tif robot == nil {\n\t\ta.jsonResponse(res, http.StatusNotFound, fmt.Sprintf(\"Robot '%s' not found\", robotName))\n\t\treturn\n\t}\n\n\tdevices, err := a.db.GetRobotDevices(robot.ID)\n\tif err != nil {\n\t\ta.jsonResponse(res, http.StatusInternalServerError, \"Error retrieving devices\")\n\t\treturn\n\t}\n\n\tdeviceResponses := []*DeviceResponse{}\n\tfor _, device := range devices {\n\t\tdeviceResponses = append(deviceResponses, &DeviceResponse{\n\t\t\tID:   device.ID,\n\t\t\tName: device.Name,\n\t\t})\n\t}\n\n\ta.jsonResponse(res, http.StatusOK, deviceResponses)\n}", "CodeBleu_score": 40.75926259259751}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\trespondWithError(res, http.StatusNotFound, \"Robot not found\")\n\t\treturn\n\t}\n\n\tdevices, err := a.db.GetDevicesByRobotID(robot.ID)\n\tif err != nil {\n\t\trespondWithError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\trespondWithJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 32.304725263677156}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tdevices, err := a.db.GetDevicesByRobotID(robot.ID)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tjsonData, err := json.Marshal(devices)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonData)\n}", "CodeBleu_score": 37.54166120586186}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := mux.Vars(req)[\"robotName\"]\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\thandleError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\tconnections := make([]Connection, len(robot.Connections))\n\tfor i, connection := range robot.Connections {\n\t\tconnections[i] = Connection{\n\t\t\tID: connection.ID,\n\t\t\tRobotA: Robot{\n\t\t\t\tID:   connection.RobotA.ID,\n\t\t\t\tName: connection.RobotA.Name,\n\t\t\t},\n\t\t\tRobotB: Robot{\n\t\t\t\tID:   connection.RobotB.ID,\n\t\t\t\tName: connection.RobotB.Name,\n\t\t\t},\n\t\t}\n\t}\n\n\tjsonData, err := json.Marshal(connections)\n\tif err != nil {\n\t\thandleError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(jsonData)\n}", "CodeBleu_score": 42.69054649599689}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := mux.Vars(req)[\"robot_name\"]\n\n\trobot, ok := a.db.Robot(robotName)\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"no robot with name %q found\", robotName)))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(\"[\"))\n\n\tfirst := true\n\tfor _, connection := range robot.Connections {\n\t\tif !first {\n\t\t\tres.Write([]byte(\",\"))\n\t\t}\n\t\tfirst = false\n\n\t\tjsonBytes, err := json.Marshal(connection)\n\t\tif err != nil {\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(err.Error()))\n\t\t\treturn\n\t\t}\n\t\tres.Write(jsonBytes)\n\t}\n\n\tres.Write([]byte(\"]\"))\n}", "CodeBleu_score": 31.87344806663377}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections := make([]*Connection, 0)\n\tfor _, connection := range robot.Connections {\n\t\tconnections = append(connections, connection)\n\t}\n\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 43.817658374673066}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robotname\")\n\tdeviceName := req.URL.Query().Get(\"devicename\")\n\tcommand := req.URL.Query().Get(\"command\")\n\tdevice := a.Master.FindRobotDevice(robotName, deviceName)\n\tif device != nil {\n\t\tresult, err := device.ExecuteCommand(command)\n\t\tif err != nil {\n\t\t\ta.writeJSON(res, err)\n\t\t\treturn\n\t\t}\n\t\ta.writeJSON(res, result)\n\t\treturn\n\t}\n\ta.writeJSON(res, fmt.Errorf(\"device %s not found\", deviceName))\n}", "CodeBleu_score": 52.627793990984465}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robotname\")\n\tdeviceName := req.URL.Query().Get(\"devicename\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tdevice, err := a.robot.Device(deviceName, robotName)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tswitch command {\n\tcase \"on\":\n\t\tdevice.On()\n\tcase \"off\":\n\t\tdevice.Off()\n\t}\n\n\ta.writeJSON(res, http.StatusOK, \"ok\")\n}", "CodeBleu_score": 51.438061283699355}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\trobotName := req.URL.Query().Get(\"robotname\")\n\tdeviceName := req.URL.Query().Get(\"devicename\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tdevice, err := a.getRobotDevice(robotName, deviceName)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\terr = device.ExecuteCommand(command)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\ta.writeJSON(res, http.StatusOK, \"OK\")\n}", "CodeBleu_score": 54.07231634896215}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgivenUser, givenPass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(givenUser, username) || !secureCompare(givenPass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.58178812059605}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgivenUser, givenPass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, givenUser) || !secureCompare(password, givenPass) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.62441325011417}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgivenUser, givenPass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(givenUser, username) || !secureCompare(givenPass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tfmt.Fprintf(w, \"Unauthorized\")\n\t\t\treturn\n\t\t}\n\n\t\th.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.327152862353714}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tok := a.Connection().AnalogReadSupported()\n\tif !ok {\n\t\terr := fmt.Errorf(\"AnalogRead not supported by %v\", a.Name())\n\t\tgobot.Publish(a.Event(Error), err)\n\t\treturn 0, 0.0, err\n\t}\n\n\tval, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\tgobot.Publish(a.Event(Error), err)\n\t\treturn 0, 0.0, err\n\t}\n\n\traw := int(val)\n\tscaled := a.convertReadValue(val)\n\n\ta.lastValue = raw\n\ta.lastScaledValue = scaled\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 48.85610946616576}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif !a.Connection().AnalogModeSupported() {\n\t\treturn 0, 0.0, fmt.Errorf(\"Analog reading not supported by this connection\")\n\t}\n\n\traw, err := a.Connection().AnalogRead(a.Pin())\n\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaled := a.scaleReading(float64(raw))\n\n\ta.value = raw\n\ta.scaledValue = scaled\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 42.5706384587573}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tok := a.connection.AnalogReadSupported()\n\tif !ok {\n\t\terr := fmt.Errorf(\"AnalogRead not supported by %v\", a.Name())\n\t\treturn 0, 0.0, err\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\tscaled := a.scaleToVoltage(float64(raw))\n\n\ta.value = scaled\n\ta.rawValue = raw\n\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 49.335625820166705}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 10, 10*time.Millisecond, 10),\n\t\tname:               gobot.DefaultName(\"GroveSoundSensor\"),\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase func(string):\n\t\t\ts.name = option.(func(string))(s.name)\n\t\t}\n\t}\n\n\ts.AddEvent(Data)\n\ts.AddEvent(SoundDetected)\n\n\treturn s\n}", "CodeBleu_score": 39.04213858345305}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 1*time.Second, 10, \"GroveSoundSensor\"),\n\t}\n\n\tfor _, option := range opts {\n\t\toption(d)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 36.513192973700484}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t\ts := NewAnalogSensorDriver(a, pin, 10*time.Millisecond)\n\n\tn := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: s,\n\t\tDefaultName:        GroveSoundSensorName,\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tn.setName(option)\n\t\t}\n\t}\n\n\treturn n\n}", "CodeBleu_score": 33.37267243467964}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftReset)\n\n\ttime.Sleep(50 * time.Millisecond)\n\n\tvalue, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif value&(1<<4) != 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 50.61588616154019}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\tif err := d.writeReg(CommandReg, SoftReset); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Millisecond * 10)\n\n\tval, err := d.readReg(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val&(1<<4) != 0 {\n\t\treturn errors.New(\"device is not ready\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.35788884159301}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\td.writeRegister(CommandReg, SoftReset)\n\t// Timeout initialization\n\ttimeout := time.NewTimer(initializationTimeout)\n\tdefer timeout.Stop()\n\tselect {\n\tcase <-timeout.C:\n\t\treturn errors.New(\"MFRC522Common.softReset: timeout\")\n\tcase <-time.After(initializationDelay):\n\t}\n\n\t// Check if the power-down bit is still set\n\tval, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&(1<<4) != 0 {\n\t\treturn errors.New(\"MFRC522Common.softReset: power-down bit still set\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 51.10824201254592}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.ReadByteReg(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: n = %d, len = %d\", n, len(backData))\n\t}\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.ReadByteReg(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tval, err := d.ReadByteReg(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn val & 0x07, nil\n}", "CodeBleu_score": 56.79639141115983}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn := d.readFIFOLen()\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"bad length in readFifo()\")\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i] = d.readFIFO()\n\t}\n\n\treturn d.readFIFO()\n}", "CodeBleu_score": 20.625675863913994}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tn, err := d.dev.ReadRegister(FIFOLevelReg, 1)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(backData) != int(n[0]) {\n\t\treturn 0, fmt.Errorf(\"bad length in fifo read (%d != %d)\", len(backData), n[0])\n\t}\n\t_, err = d.dev.ReadRegister(FIFODataReg, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn, err = d.dev.ReadRegister(ControlReg, 1)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn n[0] & 0x07, nil\n}", "CodeBleu_score": 42.75861897904459}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\n\thaltCommand := []byte{0x50, 0x00, 0x00, 0x00, 0x00}\n\tcrc := d.calcCRC(haltCommand)\n\thaltCommand = append(haltCommand, crc[0], crc[1])\n\n\t_, err := d.PCDRequest(haltCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.80166599927857}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\td.Log.Debug(\"Halting...\")\n\n\tcmd := []byte{byte(PCD_Halt), 0}\n\td.calculateCRC(cmd, 2)\n\n\tresult, err := d.toCard(PCD_Transceive, cmd, 4, nil, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif result != 0x00 {\n\t\treturn fmt.Errorf(\"Failed to halt\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 29.897175246728292}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tif d.debug {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\tbuff := []byte{mfrc522.PiccHalt, 0}\n\tcrc := d.calculateCRC(buff, 1)\n\tbuff[1] = byte(crc)\n\tif _, err := d.dev.Write(buff); err != nil {\n\t\treturn err\n\t}\n\t// 4 bytes PICC_Halt return\n\t_, err := d.dev.ReadByte()\n\treturn err\n}", "CodeBleu_score": 26.571823528454996}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{mfrc522.PiccCmdRead, block}\n\td.calculateCRC(cmd)\n\n\trx, err := d.transceive(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(rx) < 18 {\n\t\treturn nil, errRead\n\t}\n\n\treturn rx[:16], nil\n}", "CodeBleu_score": 29.86387713223772}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{piccRead, block}\n\tcrc := d.calculateCRC(cmd)\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t_, err := d.dev.Write(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make([]byte, 18)\n\t_, err = d.dev.Read(data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data[:16], nil\n}", "CodeBleu_score": 44.408001655763975}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tcmd := []byte{\n\t\tpiccReadCmd,\n\t\tblock,\n\t\tpiccReadCmdCrc,\n\t}\n\n\tdata, err := d.piccTransceive(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn data, nil\n}", "CodeBleu_score": 28.92753090739111}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\n\tswitch reqMode {\n\tcase MFRC522_PICC_REQIDL:\n\t\td.clearRegisterBitMask(COLL_REG, 0x80)\n\t\tbreak\n\tcase MFRC522_PICC_REQALL:\n\t\td.clearRegisterBitMask(COLL_REG, 0x80)\n\t\td.clearRegisterBitMask(COLL_REG, 0x40)\n\t\tbreak\n\tdefault:\n\t\td.clearRegisterBitMask(COLL_REG, 0x80)\n\t\td.clearRegisterBitMask(COLL_REG, 0x40)\n\t\tbreak\n\t}\n\n\td.writeRegister(FIFO_LEVEL_REG, 0x80)\n\tresult, err := d.transceiveData(reqMode, nil, answer, 1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif result != 0 {\n\t\treturn errors.New(\"piccRequest failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.92656149534083}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"invalid answer buffer\")\n\t}\n\n\td.clearBits(collReg)\n\n\tswitch reqMode {\n\tcase piccRequestMode0:\n\t\td.setBit(collReg, 7)\n\tcase piccRequestMode1:\n\t\td.clearBit(collReg, 7)\n\tcase piccRequestMode2:\n\t\td.setBit(collReg, 6)\n\tcase piccRequestMode3:\n\t\td.clearBit(collReg, 6)\n\t}\n\n\t_, err := d.transceiveData(reqMode, 0, answer)\n\treturn err\n}", "CodeBleu_score": 50.23559645792712}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer must have at least 2 bytes\")\n\t}\n\n\td.clearBits(CollReg, 0x80) // ValuesAfterColl=1 => Bits received after collision are cleared.\n\n\tswitch reqMode {\n\tcase PiccRequest:\n\t\td.setBits(TxAsk, 0x40) // TxLastBists = Bit7 => send 0 after collision\n\tcase PiccWakeup:\n\t\td.setBits(TxAsk, 0x30) // TxLastBists = Bit7 => send 0 after collision\n\t}\n\n\t_, err := d.transceiveData(reqMode, 0, answer, 0)\n\treturn err\n}", "CodeBleu_score": 46.171239861865566}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step by setting the step pin low\n\tif err := d.StepPin.Out(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for a delay\n\ttime.Sleep(d.StepDelay)\n\n\t// Set the step pin high\n\tif err := d.StepPin.Out(gpio.High); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number based on the direction\n\tif d.Direction {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.43773779228133}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.StepPin.Out(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Millisecond * 1)\n\n\tif err := d.StepPin.Out(gpio.High); err != nil {\n\t\treturn err\n\t}\n\n\tif d.Direction {\n\t\td.StepNumber++\n\t} else {\n\t\td.StepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.2499145793939}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger one step by holding enable pin low for 200ns as per datasheet\n\tif err := d.stepPin.Low(); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Nanosecond * 200)\n\tif err := d.stepPin.High(); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number,\n\t// depending on whether motor is moving positively or negatively\n\tif d.direction {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 64.74443091837709}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stopChan != nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChan = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tcase <-time.After(d.interval):\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distanceChan <- distance\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 48.019554013165845}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stopChannel != nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChannel = make(chan bool)\n\td.waitGroup = &sync.WaitGroup{}\n\td.waitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.waitGroup.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChannel:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"Distance: %.2f cm\", distance)\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 44.07484826472828}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stopChan != nil {\n\t\treturn fmt.Errorf(\"Distance monitor is already running\")\n\t}\n\n\td.stopChan = make(chan bool)\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"Distance: %.2f cm\", distance)\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 43.1386158803013}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstart := time.Now()\n\treturn func(event int, duration time.Duration, src string, timestamp uint32, seqno uint32) {\n\t\tif event == 1 {\n\t\t\tstart = time.Now()\n\t\t} else {\n\t\t\td.duration <- time.Since(start)\n\t\t\tstart = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 33.990878682144285}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tstart := time.Now()\n\treturn func(pin int, duration time.Duration, event string, timestamp uint32, seqno uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\tduration := time.Since(start)\n\t\t\td.distance <- duration\n\t\t\tstart = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 40.2045917348929}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\n\treturn func(id int, dur time.Duration, event string, channel uint32, sequence uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.durationChannel <- time.Since(start)\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.47691705555801}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\tselect {\n\tcase <-d.echoPin.WaitForEdge(time.Second):\n\t\td.measurement = d.echoPin.ReadDuration()\n\tcase <-time.After(time.Second):\n\t\treturn errors.New(\"timeout\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.40301436418319}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.trigger.Low()\n\ttime.Sleep(2 * time.Microsecond)\n\td.trigger.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigger.Low()\n\n\tselect {\n\tcase <-d.echo.WaitForEdge(time.Second):\n\t\td.measurement = d.echo.Time()\n\tcase <-time.After(time.Second):\n\t\treturn errors.New(\"timeout\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.85574462468155}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\tselect {\n\tcase <-d.echoPin.WaitForEdge(time.Second):\n\t\td.measuredTime = d.echoPin.HighTime()\n\t\treturn nil\n\tcase <-time.After(time.Second):\n\t\treturn errors.New(\"timeout\")\n\t}\n}", "CodeBleu_score": 42.950905130813375}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    if self.auth_token:\n        return self.auth_token\n\n    # Check if the token is available in the environment variables\n    if self.auth_token_env_var:\n        auth_token = os.getenv(self.auth_token_env_var)\n        if auth_token:\n            return auth_token\n\n    # Check if the token is available in the local state\n    if self.local_state:\n        auth_token = self.local_state.get(\"auth_token\")\n        expiration_time = self.local_state.get(\"auth_token_expiration_time\")\n        if auth_token and expiration_time and datetime.utcnow() < datetime.fromisoformat(expiration_time):\n            return auth_token\n\n    # Check if the refresh token is available in the local state\n    refresh_token = self.local_state.get(\"refresh_token\")\n    if refresh_token:\n        # Attempt to fetch a new access token using the refresh token\n        try:\n            response = requests.post(\n                self.auth_url,\n                data={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": refresh_token,\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                },\n            )\n            response.raise_for_status()\n            auth_data = response.json()\n            self.local_state[\"auth_token\"] = auth_data[\"access_token\"]\n            self.local_state[\"auth_token_expiration_time\"] = (\n                datetime.utcnow() + timedelta(seconds=auth_data[\"expires_in\"])\n            ).isoformat()\n            return auth_data[\"access_token\"]\n        except requests.exceptions.RequestException as exc:\n            raise AccountNotAuthorized(\"Failed to fetch authentication token using refresh token\") from exc\n\n    raise AccountNotAuthorized(\"No valid authentication token found\")\n\n", "CodeBleu_score": 36.54602978583023}, {"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.environ.get(\"ACCESS_TOKEN\")\n    if access_token:\n        return access_token\n\n    local_state = self.get_local_state()\n    access_token = local_state.get(\"access_token\")\n    access_token_expires = local_state.get(\"access_token_expires\")\n    refresh_token = local_state.get(\"refresh_token\")\n\n    if access_token and access_token_expires:\n        now = datetime.now()\n        expires = datetime.fromisoformat(access_token_expires)\n        if now < expires:\n            return access_token\n\n    if refresh_token:\n        try:\n            new_auth_data = self.fetch_new_access_token(refresh_token)\n        except HTTPClientError as exc:\n            raise AccountNotAuthorized() from exc\n\n        self.update_local_state(new_auth_data)\n        return new_auth_data[\"access_token\"]\n\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 42.238562062791246}, {"code": "def fetch_authentication_token(self)\n\t\n    access_token = os.getenv('ACCESS_TOKEN')\n    if access_token:\n        return access_token\n\n    local_state = self.get_local_state()\n    access_token = local_state.get('access_token')\n    expiry = local_state.get('expiry')\n\n    if access_token and expiry and datetime.now() < datetime.fromisoformat(expiry):\n        return access_token\n\n    refresh_token = local_state.get('refresh_token')\n    if refresh_token:\n        try:\n            new_auth_data = self.fetch_new_authentication_data(refresh_token)\n            self.update_local_state(new_auth_data)\n            return new_auth_data['access_token']\n        except AccountError:\n            pass\n\n    raise AccountNotAuthorized\n\n", "CodeBleu_score": 36.291718535010844}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.session.get(\"refresh_token\")\n    self.session.delete()\n    try:\n        self.post(\"/v1/logout\", json={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 49.49696901155398}, {"code": "def logout(self)\n\t\n    refresh_token = self.session.get(\"refresh_token\")\n    self.session.delete()\n    try:\n        self.post(\"/v1/logout\", json={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n\n", "CodeBleu_score": 49.49696901155398}, {"code": "def logout(self)\n\t\n    refresh_token = self.session.get(\"refresh_token\")\n    if refresh_token:\n        del self.session[\"refresh_token\"]\n        try:\n            self.fetch_json_data(\n                \"POST\",\n                \"https://account.codingame.com/api/v1/logout\",\n                data={\"refresh_token\": refresh_token},\n            )\n        except AccountError:\n            pass\n    return True\n\n", "CodeBleu_score": 57.97590510562449}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    res = []\n    for p in self.pm.get_packages():\n        if p.optional:\n            continue\n        meta = p.meta\n        res.append((p.name, p.version, meta.get(\"url\", \"\")))\n    return res", "CodeBleu_score": 21.275435139636087}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for p in self.pm.get_packages():\n        if p.optional:\n            continue\n        if p.external:\n            packages.append(\n                {\n                    \"name\": p.name,\n                    \"version\": p.version,\n                    \"source\": p.source,\n                }\n            )\n        else:\n            packages.append(\n                {\n                    \"name\": p.name,\n                    \"version\": p.version,\n                }\n            )\n    return packages\n\n", "CodeBleu_score": 26.465503980763504}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.pm.iter_packages():\n        if package.optional:\n            continue\n        metadata = package.metadata\n        packages.append({\n            \"name\": metadata[\"name\"],\n            \"version\": metadata[\"version\"],\n            \"source\": metadata.get(\"source\", \"\"),\n        })\n    return packages\n\n", "CodeBleu_score": 27.70487349536883}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform_spec = cls.get_platform_spec(env)\n    except exception.UndefinedEnvPlatformError as exc:\n        if not autoinstall:\n            raise\n        platform_spec = cls.get_default_platform_spec()\n\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 40.10298823657821}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    spec = cls.get_env_spec(env)\n    if not spec:\n        raise exception.UndefinedEnvPlatformError(env)\n    instance = cls(spec, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure_project(env, targets)\n    return instance\n\n", "CodeBleu_score": 28.421359578973714}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    try:\n        platform = cls.get_platform(env)\n    except UndefinedEnvPlatformError:\n        if not autoinstall:\n            raise\n        platform = cls.install_platform(env)\n\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 38.8364856655513}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire.beginTransmission(0x34);\n    Wire.write(Addr);\n    Wire.endTransmission();\n\n    Wire.requestFrom(0x34, (int)Size);\n\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire.read();\n    }\n}", "CodeBleu_score": 90.06132220795931}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t    Wire.beginTransmission(0x34);\n    Wire.write(Addr);\n    Wire.endTransmission();\n\n    Wire.requestFrom(0x34, (int)Size);\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire.read();\n    }\n}", "CodeBleu_score": 90.06132220795931}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire.read();\n  }\n}", "CodeBleu_score": 87.87942830325366}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 69.78665494933675}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t    SetSleep();\n    if (time_in_us > 0) {\n        // Use timer wakeup\n        SetTimerWakeup(time_in_us);\n    } else {\n        // Disable timer wakeup\n        Write1Byte(0x30, Read8bit(0x30) & 0xFC);\n    }\n    // Generate an interrupt to wake up the device\n    Write1Byte(0x31, Read8bit(0x31) | (1 << 2));\n    // Enter deep sleep\n    Write1Byte(0x90, 0x01);  // Deep Sleep\n    // Wait for interrupt\n    esp_sleep_enable_ext1_wakeup(1ULL << 15, ESP_EXT1_WAKEUP_ANY_HIGH);\n    esp_deep_sleep_start();\n}", "CodeBleu_score": 55.15505178164407}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tteBar ? y_top_fixed_area_alt : y_top_fixed_area;\n  int h = tteBar ? h_top_fixed_area_alt : h_top_fixed_area;\n  int y_old = y;\n  tft.fillRect(0, y, tft.width(), h, color);\n  y += h;\n  if (y >= tft.height() - h_bottom_fixed_area) y = 0;\n  if (tteBar) y_top_fixed_area_alt = y; else y_top_fixed_area = y;\n  scrollAddress(y);\n  return y_old;\n}", "CodeBleu_score": 22.451854183550818}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tteBar ? 10 : 14;\n  int y_prev = tft.getCursorY();\n  if (y_prev + tft.fontHeight() > tft.height() - 10) {\n    tft.fillRect(0, 0, tft.width(), tft.fontHeight(), color);\n    scrollAddress(0);\n  } else {\n    tft.fillRect(0, y_prev, tft.width(), tft.fontHeight(), color);\n    scrollAddress(y_prev + tft.fontHeight());\n  }\n  return y_prev;\n}", "CodeBleu_score": 19.280217192625287}, {"code": "int Display::scroll_line(uint32_t color){\n\t  int y = tteBar ? tteBar : tte;\n  tft.fillRect(0, y, 320, 16, color);\n  y += 16;\n  if (y >= (240 - 16)) y = 0;\n  scrollAddress(y);\n  return y;\n}", "CodeBleu_score": 8.78072224970238}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  if (!this->setupAP(ssids)) {\n    return false;\n  }\n\n  if (!this->setupHTML(access_points)) {\n    return false;\n  }\n\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 63.13611033365181}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  this->ssids = ssids;\n  this->access_points = access_points;\n\n  if (!this->setupAPs()) {\n    Serial.println(\"[!] Failed to setup APs\");\n    return false;\n  }\n\n  if (!this->setupHTML()) {\n    Serial.println(\"[!] Failed to setup HTML\");\n    return false;\n  }\n\n  this->startPortal();\n  return true;\n}", "CodeBleu_score": 55.39612887363224}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t  // set up access points\n  if (!this->setupAPs(ssids)) {\n    return false;\n  }\n\n  // set up html content\n  if (!this->setupHTML()) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 51.79238104607708}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t    if (queue_enabled_flag) {\n        // If the queue is already enabled, ensure that the queue, text, and text_in are initialized\n        queue = \"\";\n        text = \"\";\n        text_in = \"\";\n    } else {\n        // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}", "CodeBleu_score": 13.50873908677379}, {"code": "void GpsInterface::enable_queue(){\n\t  if (queue_enabled_flag) {\n    // If the queue is already enabled, ensure that the queue, text, and text_in are initialized\n    if (!queue) {\n      queue = xQueueCreate(10, sizeof(GpsData));\n    }\n    if (!text) {\n      text = xQueueCreate(10, sizeof(char*));\n    }\n    if (!text_in) {\n      text_in = xQueueCreate(10, sizeof(char*));\n    }\n  } else {\n    // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n    flush_queue();\n    queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 16.642956624735973}, {"code": "void GpsInterface::enable_queue(){\n\t  if (queue_enabled_flag) {\n    // queue is already enabled, ensure that queue, text, and text_in are initialized\n    queue = \"\";\n    text = \"\";\n    text_in = \"\";\n  } else {\n    // queue is not enabled, flush existing queue and set queue_enabled_flag to true\n    flush_queue();\n    queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 11.604792378973276}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (nmea_queue != NULL) {\n        if (nmea_queue->size() > 0) {\n            delete nmea_queue;\n            nmea_queue = new std::queue<std::string>;\n        }\n    } else {\n        nmea_queue = new std::queue<std::string>;\n    }\n}", "CodeBleu_score": 43.57352589992915}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (this->queue_nmea != NULL) {\n\t\tdelete this->queue_nmea;\n\t}\n\tthis->queue_nmea = new Queue<char*>();\n}", "CodeBleu_score": 14.16871097705384}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t    if (this->queue_nmea != NULL) {\n        if (this->queue_nmea->size() > 0) {\n            delete this->queue_nmea;\n            this->queue_nmea = new std::queue<std::string>();\n        }\n    } else {\n        this->queue_nmea = new std::queue<std::string>();\n    }\n}", "CodeBleu_score": 23.548412596892586}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Start a write transaction\n    ili9341_write_cmd(ILI9341_CMD_WRITE_MEMORY);\n\n    // Set the address window to the specified area\n    ili9341_set_address_window(area->x1, area->y1, area->x2, area->y2);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        // Write the corresponding color from the provided color buffer\n        ili9341_write_data(*color_p++);\n      }\n    }\n\n    // End the write transaction\n    ili9341_write_cmd(ILI9341_CMD_NOP);\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 54.07025135624943}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t  /*\n   * The function \"my_disp_flush\" updates a specified area of the display with new color data.\nIt starts a write transaction, sets the address window to the specified area, and iterates through each pixel in the area.\nFor each pixel, it writes the corresponding color from the provided color buffer.\nAfter updating the area, it ends the write transaction and notifies that the display flush is complete.\n   */\n  uint32_t w = (area->x2 - area->x1 + 1);\n  uint32_t h = (area->y2 - area->y1 + 1);\n\n  disp_start_write(area);\n\n  tft_write_color_buf((uint16_t *)color_p, w * h);\n\n  disp_end_write();\n\n  lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 33.129841457967444}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t    // Get the display buffer and its size\n    uint8_t *buf = (uint8_t *)disp->buffer;\n    uint32_t w = disp->hor_res;\n    uint32_t h = disp->ver_res;\n\n    // Start a write transaction\n    lcd_write_cmd(0x2c);\n\n    // Set the address window to the specified area\n    lcd_write_cmd(0x2a);\n    lcd_write_data(area->x1 >> 8);\n    lcd_write_data(area->x1 & 0xff);\n    lcd_write_data((area->x2 - 1) >> 8);\n    lcd_write_data((area->x2 - 1) & 0xff);\n    lcd_write_cmd(0x2b);\n    lcd_write_data(area->y1 >> 8);\n    lcd_write_data(area->y1 & 0xff);\n    lcd_write_data((area->y2 - 1) >> 8);\n    lcd_write_data((area->y2 - 1) & 0xff);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2 - 1; y++) {\n      for (int x = area->x1; x <= area->x2 - 1; x++) {\n        // Get the color from the provided color buffer\n        lv_color_t color = color_p[y * w + x];\n\n        // Write the color to the display buffer\n        buf[(y * w + x) * 2] = color.ch.red;\n        buf[(y * w + x) * 2 + 1] = color.ch.green;\n      }\n    }\n\n    // End the write transaction\n    lcd_write_cmd(0x2e);\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 52.6910965295552}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (MenuNode * node : menu->getNodes()) {\n\t\tstd::string indent = \"\";\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tindent += \"    \";\n\t\t}\n\t\tstd::cout << indent << node->getName() << std::endl;\n\t\tif (node->getType() == MenuNodeType::MENU) {\n\t\t\tshowMenuList(node->getMenu(), layer + 1);\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}", "CodeBleu_score": 42.909942586878714}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tfor (MenuNode * node : menu->getNodes()) {\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tstd::cout << \"  \";\n\t\t}\n\t\tstd::cout << node->getName() << std::endl;\n\t}\n\tstd::cout << std::endl;\n}", "CodeBleu_score": 41.57259519253857}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t    for (MenuNode * node : menu->getMenuNodes()) {\n        for (int i = 0; i < layer; i++) {\n            std::cout << \"  \";\n        }\n        std::cout << node->getName() << std::endl;\n    }\n    std::cout << std::endl;\n}", "CodeBleu_score": 44.74918792716831}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t    int generated = 0;\n\n    for (int i = 0; i < count; i++) {\n        String ssid = generateRandomSSID();\n        int channel = random(1, 12);\n        String mac = generateRandomMAC();\n\n        WiFi.begin(ssid.c_str(), \"\", channel, false, mac.c_str());\n        generated++;\n\n        Serial.print(\"SSID: \");\n        Serial.print(ssid);\n        Serial.print(\" Channel: \");\n        Serial.print(channel);\n        Serial.print(\" MAC: \");\n        Serial.println(mac);\n    }\n\n    return generated;\n}", "CodeBleu_score": 38.617436149026474}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int n = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int i = 0; i < 6; i++) {\n      ssid += (char)random(65, 91);\n    }\n    int ch = random(1, 15);\n    String mac = WiFi.macAddress();\n    ssids += \"SSID: \" + ssid + \" CH: \" + String(ch) + \" (\" + mac + \")\n\";\n    n++;\n  }\n  return n;\n}", "CodeBleu_score": 40.44005674193277}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t  int generatedSSIDs = 0;\n\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += random(0, 255);\n    }\n    int channel = random(1, 12);\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(random(0, 255), HEX);\n      if (j < 5) {\n        mac += \":\";\n      }\n    }\n    ssidList.push_back(ssid);\n    channelList.push_back(channel);\n    macList.push_back(mac);\n    Serial.println(\"SSID: \" + ssid + \", Channel: \" + String(channel) + \", MAC: \" + mac);\n    generatedSSIDs++;\n  }\n\n  return generatedSSIDs;\n}", "CodeBleu_score": 43.01345510220623}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    import jwt\n    import time\n\n    token = {\n        'iat': int(time.time()),\n        'exp': int(time.time()) + 3600,\n        'aud': project_id\n    }\n\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n\n", "CodeBleu_score": 55.36573622215498}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        # The time that the token was issued at\n        'iat': datetime.datetime.utcnow(),\n        # The time the token expires.\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        'aud': project_id\n    }\n\n    # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Return the JWT.\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n\n\n\n", "CodeBleu_score": 59.173179330736936}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(seconds=3600),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 56.83928995663258}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload, message.topic, str(message.qos)))\n    if message.payload == 'on':\n        print('Turning on the camera')\n        preview_capture('/home/pi/image.jpg')\n        print('Uploading image')\n        url = upload_file('/home/pi/image.jpg', bucket_name)\n        print('Publishing message')\n        client.publish(mqtt_event_topic, url, qos=1)\n    elif message.payload == 'off':\n        print('Turning off the camera')\n\n", "CodeBleu_score": 38.755940470618555}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload, message.topic, str(message.qos)))\n    if message.payload == 'on':\n        preview_capture('/tmp/preview.jpg')\n        url = upload_file('/tmp/preview.jpg', 'iot-device-bucket-2023')\n        print('Uploaded file to {}'.format(url))\n        client.publish(\n                'events/{}/{}'.format(args.device_id, args.registry_id),\n                json.dumps({'image': url}),\n                qos=1)\n    else:\n        print('Off')\n\n", "CodeBleu_score": 40.150289874354094}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('Turning on the camera')\n        preview_capture('image.jpg')\n        print('Uploading file to bucket')\n        url = upload_file('image.jpg', args.bucket_name)\n        print('Publishing message to MQTT topic')\n        client.publish(mqtt_event_topic, url)\n    else:\n        print('Turning off the camera')\n\n", "CodeBleu_score": 37.71218325469348}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument('--project_id', default=os.environ.get('GOOGLE_CLOUD_PROJECT'), help='GCP project ID')\n    parser.add_argument('--subscription_name', required=True, help='Cloud Pub/Sub subscription name')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT registry ID')\n    parser.add_argument('--device_id', required=True, help='Cloud IoT device ID')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), required=True, help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    return parser.parse_args()\n\n\n\n", "CodeBleu_score": 43.80281072084592}, {"code": "def parse_command_line_args()\n\t\n    import argparse\n    import os\n\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--subscription_name\", required=True, help=\"Cloud Pub/Sub subscription name\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 67.93356531935233}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT Core registry id\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT Core device id\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), required=True, help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\"--ca_certs\", default=\"roots.pem\", help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\")\n    parser.add_argument(\"--message_type\", choices=(\"event\", \"state\"), default=\"event\", help=\"Indicates whether the message to be published is a telemetry event or a device state message.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", choices=(8883, 443), default=8883, type=int, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--jwt_expires_minutes\", default=20, type=int, help=\"Expiration time, in minutes, for JWT tokens.\")\n    return parser.parse_args()\n\n", "CodeBleu_score": 44.54954372649071}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(api_version)\n    service_account_credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = service_account_credentials.with_scopes(api_scopes)\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(api_version)\n    return discovery.build('cloudiot', api_version, discoveryServiceUrl=discovery_api_url, credentials=scoped_credentials)\n\n\n\n\n", "CodeBleu_score": 48.29991423263619}, {"code": "def get_client(service_account_json)\n\t\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(api_version)\n\n    service_account_credentials = ServiceAccountCredentials.from_json_keyfile_name(\n        service_account_json, scopes=api_scopes)\n\n    service_name = 'cloudiotcore'\n\n    # Create a Cloud IoT Core client object\n    client = googleapiclient.discovery.build(\n        service_name,\n        api_version,\n        discoveryServiceUrl=discovery_api_url,\n        credentials=service_account_credentials)\n\n    return client\n\n\n\n", "CodeBleu_score": 52.78562162223363}, {"code": "def get_client(service_account_json)\n\t\n    import google.auth\n    import google.auth.transport.grpc\n    import google.auth.transport.requests\n    import google.oauth2.credentials\n    import google.oauth2.service_account\n    import grpc\n    from google.api_core import client_options\n    from google.cloud import iot_v1\n\n    # Define the necessary API scopes\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Define the version of the API\n    api_version = 'v1'\n\n    # Define the discovery URL for the Cloud IoT Core service\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(api_version)\n\n    # Load the service account credentials\n    credentials = google.oauth2.service_account.Credentials.from_service_account_file(\n        service_account_json)\n\n    # Scope the credentials appropriately\n    scoped_credentials = credentials.with_scopes(scopes)\n\n    # Use the scoped credentials to build the client for the Cloud IoT Core service\n    client = google.api_core.client_options.ClientOptions(\n        scopes=scopes,\n        credentials=scoped_credentials,\n        discovery_api_host=discovery_url)\n\n    return client\n\n\n", "CodeBleu_score": 52.769164858672966}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    if hash_method == 'md5':\n        asn1_code = b'\\x30\\x20\\x30\\x0c\\x06\\x08\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x02\\x05\\x05\\x00\\x04\\x10'\n    elif hash_method == 'sha1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'sha256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'sha384':\n        asn1_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'sha512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    padded_hash = _pad_for_signing(asn1_code + hash_value, 1", "CodeBleu_score": 13.72251455677601}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_asn1 = _get_hash_algorithm_asn1(hash_method)\n    hash_value = hash_asn1 + hash_value\n    padded_hash = _pad_for_signing(hash_value, priv_key.size_in_bytes())\n    return priv_key.sign(padded_hash, padding.PKCS1v15(), hashes.SHA256())\n\n\n", "CodeBleu_score": 11.398008465843851}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t\n    hash_method = _get_hash_algorithm(hash_method)\n\n    if hash_method is None:\n        raise ValueError('unsupported hash type ' + hash_method)\n\n    asn1 = _get_signature_asn1(hash_method)\n\n    hash_value = _truncate_digest(hash_value, hash_method)\n\n    padded_msg = _pad_for_signing(asn1 + hash_value, priv_key.size_in_bytes())\n\n    return _encrypt(padded_msg, priv_key)\n\n", "CodeBleu_score": 30.19296083001303}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t\n    # Convert the signature to an integer and decrypt it to obtain the clear signature\n    clearsig = pow(int.from_bytes(signature, byteorder='big'), pub_key.e, pub_key.n)\n\n    # Determine the hash method used\n    hash_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hashed = compute_hash(message, hash_name)\n\n    # Reconstruct the expected padded hash\n    padded_hash = _pad_for_signing(hashed, len(signature))\n\n    # Compare the expected padded hash with the clear signature\n    if clearsig != int.from_bytes(padded_hash, byteorder='big'):\n        raise VerificationError('Verification failed')\n\n    return hash_name\n", "CodeBleu_score": 22.303561194043468}, {"code": "def verify(message, signature, pub_key)\n\t\n\n    # Convert the signature to an integer and decrypt it to obtain the clear signature\n    clearsig = _cryptography.rsa.decrypt(signature, pub_key)\n\n    # Determine the hash method used\n    hash_name = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hasher = HASH_METHODS[hash_name]()\n    hasher.update(message)\n    message_hash = hasher.digest()\n\n    # Reconstruct the expected padded hash\n    padded_hash = _pad_for_signing(message_hash, pub_key.size_in_bytes())\n\n    # Compare the expected padded hash with the clear signature\n    if clearsig != padded_hash:\n        raise VerificationError('Verification failed')\n\n    return hash_name\n", "CodeBleu_score": 19.378406647044976}, {"code": "def verify(message, signature, pub_key)\n\t\n    signature = bytes_to_long(signature)\n    clearsig = pub_key.encrypt(signature, K)[0]\n\n    method_name = _find_method_hash(clearsig)\n    hashed = compute_hash(message, method_name)\n    hashed = _pad_for_signing(hashed, pub_key.n.bit_length() + 7 >> 3)\n\n    if clearsig != hashed:\n        raise VerificationError('Verification failed')\n\n    return method_name\n\n", "CodeBleu_score": 22.495876744179853}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t   time_t t;\n   time(&t);\n   debug_printInfo(\"MQTT: Current time: %s\", ctime(&t));\n\n   if(t > 0) {\n      updateJWT(t);\n      MQTT_connect();\n      sendSubscribe = 1;\n   }\n   debug_printInfo(\"MQTT: Connecting...\");\n}", "CodeBleu_score": 51.76573200759091}, {"code": "static void connectMQTT(){\n\t   uint32_t epoch = getTime();\n   if (epoch != 0) {\n      updateJWT(epoch);\n      mqttConnected = CRYPTO_CLIENT_mqttConnect(cid, mqttTopic, mqttPassword, &mqttSubscribe);\n      debug_printInfo(\"MQTT: Attempting to connect to %s:%d...\", MQTT_BROKER, MQTT_PORT);\n   }\n}", "CodeBleu_score": 44.365662997642644}, {"code": "static void connectMQTT(){\n\t   time_t epoch = getTime();\n   if (epoch != 0) {\n      updateJWT(epoch);\n   }\n   MQTT_CLIENT_connect(cid, mqttUsername, mqttPassword, mqttTopic, &mqttConnected);\n   debug_printInfo(\"MQTT: connect\");\n}", "CodeBleu_score": 47.45549261929372}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t result = 0;\n    uint8_t ch;\n    for (int i = 0; i < width; i++) {\n        ch = str[i];\n        if (!isdigit(ch)) {\n            return str;\n        }\n        result = result * 10 + (ch - '0');\n    }\n    *num = result;\n    return str + width;\n}", "CodeBleu_score": 26.76256693898135}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    const uint8_t* end = str + width;\n    while (str < end) {\n        uint8_t digit = *str++ - '0';\n        if (digit > 9) {\n            return str - 1;\n        }\n        value = value * 10 + digit;\n    }\n    *num = value;\n    return end;\n}", "CodeBleu_score": 23.680605010827794}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t    uint32_t value = 0;\n    for (int i = 0; i < width; i++) {\n        uint8_t c = str[i];\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        value = value * 10 + (c - '0');\n    }\n    *num = value;\n    return str + width;\n}", "CodeBleu_score": 24.650870942437603}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret;\n    uint8_t sn_buf[32];\n    size_t sn_size;\n\n    if (build_state == NULL || build_state->cert_def == NULL || build_state->cert == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the certificate serial number\n    ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Get the certificate serial number\n    ret = atcacert_get_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_CERT_SN], build_state->cert, build_state->cert_size, sn_buf, &sn_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Check for duplicate serial number\n    ret = atcacert_cert_sn_check_duplicate(build_state->cert_def, build_state->cert, build_state->cert_size, sn_buf, sn_size);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 60.542379057148985}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t    int ret = 0;\n    uint8_t* cert = build_state->cert_def->cert_template;\n    size_t cert_size = build_state->cert_def->cert_template_size;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->sn_source == SNSRC_STORED || build_state->cert_def->sn_source == SNSRC_STORED_DYNAMIC)\n    {\n        ret = atcacert_gen_cert_sn(build_state->cert_def, cert, cert_size, build_state->device_sn);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (build_state->cert_def->sn_source == SNSRC_STORED_DYNAMIC)\n    {\n        ret = atcacert_set_cert_element(build_state->cert_def, &build_state->cert_def->std_cert_elements[STDCERT_CERT_SN], cert, cert_size, build_state->cert_sn, build_state->cert_sn_size);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 63.54049943325247}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret = ATCACERT_E_BAD_PARAMS;\n\n    if (cert_def == NULL) {\n        return (ret);\n    }\n\n    if (cert == NULL) {\n        return (ret);\n    }\n\n    if (ca_public_key == NULL) {\n        return (ret);\n    }\n\n    if (cert_size < cert_def->cert_size) {\n        return (ret);\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_def->tbs_start_offset, cert_def->tbs_size,\n                                   cert + cert_def->signature_offset);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return (ret);\n    }\n\n    ret = atcacert_verify_signature(cert + cert_def->signature_offset, cert_def->signature_size,\n                                     cert + cert_def->tbs_cert_start_offset, cert_def->tbs_size,\n                                     ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return (ret);\n    }\n\n    return (ATCACERT_E_SUCCESS);\n}", "CodeBleu_score": 46.698958822325075}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    int ret;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_verify_signature(tbs_digest, signature, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 79.95078515810155}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    uint8_t tbs_digest[32];\n    int     ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    const uint8_t* cert_signature = cert + cert_def->cert_signature_index;\n\n    return atcacert_verify_signature(tbs_digest, cert_signature, ca_public_key);\n}", "CodeBleu_score": 46.937041962988964}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *prev = list;\n    while (*prev != NULL)\n    {\n        if (*prev == timer)\n        {\n            *prev = (*prev)->next;\n            return true;\n        }\n        prev = &((*prev)->next);\n    }\n    return false;\n}", "CodeBleu_score": 19.463418014610824}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    timerStruct_t * volatile *listPtr = list;\n    while (*listPtr != NULL)\n    {\n        if (*listPtr == timer)\n        {\n            *listPtr = timer->next;\n            return true;\n        }\n        listPtr = &((*listPtr)->next);\n    }\n    return false;\n}", "CodeBleu_score": 22.019029199698796}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t    if (list == NULL)\n    {\n        return false;\n    }\n\n    if (*list == NULL)\n    {\n        return false;\n    }\n\n    if (*list == timer)\n    {\n        *list = timer->next;\n        return true;\n    }\n\n    timerStruct_t *current = *list;\n    while (current->next != NULL)\n    {\n        if (current->next == timer)\n        {\n            current->next = timer->next;\n            return true;\n        }\n        current = current->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 38.458020386977445}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\t", "CodeBleu_score": 1.4458552095808714}, {"code": "int BSD_close(int socket){\n\t    int retVal = BSD_SUCCESS;\n    tstrSocketInfo* socketInfo = BSD_getSocketInfo(socket);\n    if (socketInfo == NULL) {\n        bsd_setErrNo(EBADF);\n        retVal = BSD_ERROR;\n    } else {\n        int closeStatus = close(socket);\n        if (closeStatus != BSD_SUCCESS) {\n            if (closeStatus == SOCK_ERR_INVALID_ARG) {\n                bsd_setErrNo(EINVAL);\n            } else {\n                bsd_setErrNo(EIO);\n            }\n            retVal = BSD_ERROR;\n        } else {\n            socketInfo->socketState = NOT_A_SOCKET;\n        }\n    }\n    return retVal;\n}", "CodeBleu_score": 47.77273548035562}, {"code": "int BSD_close(int socket){\n\t\tSOCKET sock;\n\tuint8 u8Ret;\n\n\tsock = BSD_getSocket(socket);\n\tif (sock != SOCKET_INVALID) {\n\t\tu8Ret = close(sock);\n\t\tif (u8Ret != SOCK_ERR_NO_ERROR) {\n\t\t\tbsd_setErrNo(BSD_EINVAL);\n\t\t\treturn BSD_ERROR;\n\t\t}\n\t\tBSD_setSocket(socket, SOCKET_INVALID);\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 26.11003415604669}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\t    int ret = listen(socket, backlog);\n    if (ret < 0) {\n        bsd_setErrNo(SOCK_ERR_INVALID);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 21.25848570471805}, {"code": "int BSD_listen(int socket, int backlog){\n\t    int ret = listen(socket, backlog);\n    if (ret < 0) {\n        bsd_setErrNo(errno);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 20.62131898576583}, {"code": "int BSD_listen(int socket, int backlog){\n\t\tint ret = listen(socket, backlog);\n\tif (ret < 0) {\n\t\tbsd_setErrNo(errno);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 19.46709741950741}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint s8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 12.17579186402033}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t    int ret;\n    struct bsd_sockaddr_in * addr_in;\n\n    if (socket < 0 || socket >= BSD_MAX_SOCKETS) {\n        errno = EBADF;\n        return -1;\n    }\n\n    if (addr == NULL || addrlen == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (sockets[socket].type != SOCK_STREAM) {\n        errno = EOPNOTSUPP;\n        return -1;\n    }\n\n    addr_in = (struct bsd_sockaddr_in *) addr;\n    if (addr_in->sin_family != AF_INET) {\n        errno = EAFNOSUPPORT;\n        return -1;\n    }\n\n    ret = accept(socket, (struct bsd_sockaddr *) addr, addrlen);\n    if (ret < 0) {\n        if (ret == -1) {\n            errno = EBADF;\n        } else {\n            errno = EINVAL;\n        }\n        return -1;\n    }\n\n    return ret;\n}", "CodeBleu_score": 43.58600385405401}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t   time_t t = time(NULL);\n   if (t > 0) {\n      updateJWT(t);\n      debug_printInfo(\"MQTT: Connecting to %s\", mqttHost);\n      MQTT_connect(mqttHost, mqttPort, mqttUser, mqttPassword, mqttTopic, 1, 0, 0);\n      mqttSubscribe = 1;\n   }\n}", "CodeBleu_score": 48.94958908425963}, {"code": "static void connectMQTT(){\n\t   time_t epoch = getTime();\n   if (epoch > 0) {\n      updateJWT(epoch);\n      MQTT_connect(cid, mqttUsername, mqttPassword, mqttTopic, 1);\n      debug_printInfo(\"MQTT: Connecting\");\n      sendSubscribe = 1;\n   }\n}", "CodeBleu_score": 50.64058828512377}, {"code": "static void connectMQTT(){\n\t   time_t t = time(NULL);\n   if (t > 0) {\n      updateJWT(t);\n      MQTT_initConnection(cid, mqttUserName, mqttPassword, mqttTopic, mqttBroker, mqttPort);\n      debug_printInfo(\"MQTT: Connecting...\");\n      mqtt_send_subscribe = 1;\n   }\n}", "CodeBleu_score": 51.539213134318395}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t   MQTT_Client_t *client;\n   MQTT_Client_t *client = MQTT_getClient();\n\n   if (client->state == MQTT_CONNECTED) {\n      MQTT_disconnect(client);\n   }\n}", "CodeBleu_score": 46.127879282242695}, {"code": "void CLOUD_disconnect(void){\n\t   if (MQTT_GetConnectionState() == CONNECTED) {\n      mqttClientInfo* connectionInfo = MQTT_GetClientConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n\n   DEBUG_LOG(\"Disconnected from cloud service\");\n}", "CodeBleu_score": 65.56276400074985}, {"code": "void CLOUD_disconnect(void){\n\t   if (mqttState == CONNECTED) {\n      mqttContext* connectionInfo = MQTT_GetConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n\n   DEBUG_LOG(\"Disconnected from Cloud\n\");\n}", "CodeBleu_score": 56.074427882347024}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    // If new credentials are provided, attempt to connect using them\n    if (passed_wifi_creds) {\n        // Connect using the specified SSID, authentication type, and password\n        if (m2m_wifi_connect(ssid, strlen(ssid), M2M_WIFI_SEC_WPA_PSK, pass, 0) != 0) {\n            // If the connection fails, log an error message, update the networking error status, and return false\n            log_error(\"Failed to connect to WiFi\");\n            networking_error_status = 1;\n            return false;\n        }\n    } else {\n        // Attempt to connect using the default Wi-Fi settings\n        if (m2m_wifi_default_connect() != 0) {\n            // If the connection fails, log an error message, update the networking error status, and return false\n            log_error(\"Failed to connect to WiFi\");\n            networking_error_status = 1;\n            return false;\n        }\n    }\n\n    // If the connection succeeds, return true\n    return true;\n}", "CodeBleu_score": 45.8560087974975}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    bool connected = false;\n    if (passed_wifi_creds) {\n        // Connect to the Wi-Fi network using the provided credentials\n        if (m2m_wifi_connect_sc(wifi_ssid, strlen(wifi_ssid), M2M_WIFI_SEC_WPA_PSK, wifi_pass, 0, 0) == M2M_SUCCESS) {\n            connected = true;\n        } else {\n            // If the connection fails, log an error message and update the networking error status\n            log_error(\"Failed to connect to Wi-Fi network\");\n            networking_error_status = true;\n        }\n    } else {\n        // Attempt to connect to the Wi-Fi network using the default credentials\n        if (m2m_wifi_default_connect() == M2M_SUCCESS) {\n            connected = true;\n        } else {\n            // If the connection fails, log an error message and update the networking error status\n            log_error(\"Failed to connect to Wi-Fi network using default credentials\");\n            networking_error_status = true;\n        }\n    }\n    return connected;\n}", "CodeBleu_score": 38.009120071955735}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t    if (passed_wifi_creds) {\n        // Connect using new credentials\n        if (m2m_wifi_connect(wifi_ssid, strlen((const char *)wifi_ssid), M2M_WIFI_SEC_WPA, wifi_pass, 0) != M2M_SUCCESS) {\n            // Connection failed\n            printf(\"Connection failed\\r\n\");\n            networking_error_status = NETWORKING_ERROR_WIFI_CONNECT;\n            return false;\n        }\n    } else {\n        // Connect using default credentials\n        if (m2m_wifi_default_connect() != M2M_SUCCESS) {\n            // Connection failed\n            printf(\"Connection failed\\r\n\");\n            networking_error_status = NETWORKING_ERROR_WIFI_CONNECT;\n            return false;\n        }\n    }\n\n    // Connection succeeded\n    return true;\n}", "CodeBleu_score": 44.455345193081286}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t    const client = new ApolloClient({\n        uri: 'http://localhost:4000/graphql',\n        cache: new InMemoryCache(),\n    });\n\n    const { data } = await client.query({\n        query: gql`\n            query GetSensors {\n                sensors {\n                    id\n                    name\n                    latitude\n                    longitude\n                }\n            }\n        `,\n    });\n\n    console.log('API response:', data);\n\n    if (data.sensors) {\n        console.log('Retrieved sensors:', data.sensors);\n\n        data.sensors.forEach((sensor) => {\n            const marker = L.marker([sensor.latitude, sensor.longitude]).addTo(map);\n        });\n    }\n}", "CodeBleu_score": 41.47222980916927}, {"code": "async function DisplaySensors(map){\n\t  const client = new GraphQLClient(\n    \"https://api.tfl.gov.uk/graphql\",\n    {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-api-key\": \"c96f719475f34220872233077c78911\",\n      },\n    }\n  );\n  const query = `\n  query {\n    naptan {\n      sensors {\n        id\n        commonName\n        lat\n        lon\n      }\n    }\n  }\n  `;\n  const data = await client.request(query);\n  console.log(data);\n  if (data) {\n    console.log(\"Retrieved sensors\");\n    data.naptan.sensors.forEach((sensor) => {\n      const marker = new google.maps.Marker({\n        position: { lat: sensor.lat, lng: sensor.lon },\n        map: map,\n        title: sensor.commonName,\n      });\n    });\n  }\n}", "CodeBleu_score": 39.557715342670214}, {"code": "async function DisplaySensors(map){\n\t    // Create a new GraphQL client\n    const client = new GraphQLClient(API_URL, {\n        headers: {\n            Authorization: `Bearer ${API_KEY}`,\n        },\n    });\n\n    // Define the GraphQL query\n    const query = `\n        query {\n            sensors {\n                id\n                name\n                latitude\n                longitude\n            }\n        }\n    `;\n\n    // Send the GraphQL query to the API\n    const response = await client.request(query);\n\n    // Log the API response\n    console.log(response);\n\n    // If the response contains data\n    if (response.data) {\n        // Log the retrieval of sensors\n        console.log(\"Retrieved sensors:\");\n\n        // Iterate through each sensor\n        response.data.sensors.forEach((sensor) => {\n            // Create a new marker at the sensor's geographical coordinates\n            const marker = new google.maps.Marker({\n                position: {\n                    lat: sensor.latitude,\n                    lng: sensor.longitude,\n                },\n                map: map,\n                title: sensor.name,\n            });\n\n            // Place the marker on the map\n            marker.setMap(map);\n        });\n    }\n}", "CodeBleu_score": 42.17837298211176}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t    let marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = '#000000';\n    marker.style.border = '2px solid #000000';\n    return marker;\n}", "CodeBleu_score": 44.17296110100457}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t  let marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"marker\";\n  marker.style.backgroundColor = \"rgba(255, 0, 0, 0.5)\";\n  marker.style.border = \"1px solid rgba(255, 0, 0, 1)\";\n  return marker;\n}", "CodeBleu_score": 44.562030952190256}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.classList.add('sensor-marker');\n    marker.style.backgroundColor = '#000000';\n    marker.style.border = '2px solid #000000';\n    return marker;\n}", "CodeBleu_score": 45.87000021499378}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{MODULE_PATH}.{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Module %s not found\", module_path)\n        raise MfaModuleNotFound from err\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await async_process_requirements(\n            hass, module_name, module.REQUIREMENTS\n        )\n\n    if module_name not in hass.data[DATA_MFA_PROVIDERS]:\n        hass.data[DATA_MFA_PROVIDERS].add(module_name)\n        await hass.config_entries.async_forward_entry_setup(\n            ConfigEntry(\n                1,\n                DOMAIN,\n                data={CONF_USER_ID: module_name},\n                title=module_name,\n            ),\n            module_name,\n        )\n\n    return module\n\n", "CodeBleu_score": 44.10501678689598}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{__package__}.mfa.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Unable to find module %s\", module_path, exc_info=err)\n        raise HomeAssistantError(f\"Module not found: {module_path}\") from err\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await async_process_requirements(\n            hass, module_path, module.REQUIREMENTS  # type: ignore[attr-defined]\n        )\n\n    if module_name not in hass.data.setdefault(DATA_MFA_PROVIDERS, set()):\n        hass.data[DATA_MFA_PROVIDERS].add(module_name)\n\n    return module\n\n", "CodeBleu_score": 41.216920534708294}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"{MODULE_PATH}.{module_name}\"\n    try:\n        module = import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load MFA module %s: %s\", module_name, err)\n        raise HomeAssistantError(\n            f\"Unable to load MFA module {module_name}: {err}\"\n        ) from err\n\n    if hasattr(module, \"REQUIREMENTS\") and not skip_pip_installation():\n        await async_process_requirements(\n            hass, f\"MFA {module_name}\", module.REQUIREMENTS\n        )\n\n    if module_name not in processed_mfa_modules:\n        await process_integration_platforms(\n            hass, module_name, MULTI_FACTOR_AUTH_MODULE_PLATFORMS\n        )\n        processed_mfa_modules.add(module_name)\n\n    return module\n\n", "CodeBleu_score": 52.38694659050667}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for data in self._data:\n        if data[0] == user_id:\n            data[1] = pin\n            return\n    self._data.append([user_id, pin])\n\n", "CodeBleu_score": 51.88920184418089}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    if self._data.current_user:\n        self._data.data[self._data.current_user][\"pin\"] = pin\n    else:\n        self._data.data.append({\"user_id\": user_id, \"pin\": pin})\n    return True\n\n", "CodeBleu_score": 40.78054310847191}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data[\"pin\"]\n    for index, entry in enumerate(self.data[\"users\"]):\n        if entry[\"user_id\"] == user_id:\n            self.data[\"users\"][index][\"pin\"] = pin\n            self._async_persist()\n            return\n    self.data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n    self._async_persist()\n\n", "CodeBleu_score": 48.06646753380169}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings:\n            return\n\n        self._user_settings = {}\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        for user_id in data:\n            self._user_settings[user_id] = NotifySetting(\n                user_id,\n                data[user_id].get(\"notify_service\"),\n                data[user_id].get(\"notify_service_data\"),\n            )\n\n", "CodeBleu_score": 35.660791949048395}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        self._user_settings = {\n            user: NotifySetting(user, data.get(user, {})) for user in self._users\n        }\n\n", "CodeBleu_score": 46.680734326437154}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._user_settings:\n            return\n\n        self._user_settings = {}\n\n        if data := await self._store.async_load():\n            for user_id, user_data in data.items():\n                self._user_settings[user_id] = NotifySetting(\n                    user_id, user_data[\"notify\"], user_data[\"mobile_app\"]\n                )\n        else:\n            self._user_settings = {}\n\n", "CodeBleu_score": 34.12291536864766}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    user_settings = await self.async_load_user_settings(user_id)\n\n    if user_settings is None:\n        return False\n\n    notification_settings = user_settings.get(NOTIFICATION_SETTINGS_KEY)\n\n    if notification_settings is None:\n        return False\n\n    otp_code = user_input.get(CONF_OTP_CODE)\n    otp_secret = notification_settings.get(CONF_OTP_SECRET)\n\n    if otp_code is None or otp_secret is None:\n        return False\n\n    otp_code = otp_code.replace(\" \", \"\")\n\n    try:\n        otp_code = int(otp_code)\n    except ValueError:\n        return False\n\n    result = await self.hass.async_add_executor_job(\n        pyotp.TOTP(otp_secret).verify, otp_code\n    )\n\n    return result\n\n", "CodeBleu_score": 45.92160556769931}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    notification_settings = self._user_settings.get(user_id)\n    if notification_settings is None:\n        return False\n\n    async def validate_otp(otp: str) -> bool:\n        return notification_settings.validate_otp(otp)\n\n    return await self.hass.async_add_executor_job(validate_otp, user_input[CONF_OTP])\n\n", "CodeBleu_score": 49.739197403066285}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    user_settings = self.user_settings.get(user_id)\n    if user_settings is None:\n        return False\n    otp = user_settings.get(\"otp\")\n    if otp is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        validate_totp, otp, user_input.get(\"otp\")\n    )\n\n", "CodeBleu_score": 54.13313552475092}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_id = entity_entry.device_id\n\n    if device_id is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 71.85350694065305}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None or entity_entry.device_id is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n\n\n", "CodeBleu_score": 84.80969214731853}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_policies = [\n                policy_.get(category) for policy_ in policies if category in policy_\n            ]\n\n            policy[category] = _merge_policies(category_policies)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 62.884922788477795}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [src.get(category) for src in policies if category in src]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 63.6061226598494}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n\n    for category in ALL_CATEGORIES:\n        if category in seen:\n            continue\n        seen.add(category)\n\n        category_sources = [p.get(category) for p in policies if isinstance(p, dict)]\n\n        policy[category] = _merge_policies(category_sources)\n\n    return policy\n", "CodeBleu_score": 56.129143257221}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    module = await async_import_module(hass, f\"hass_nabucasa.auth_providers.{provider}\")\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed = hass.data.get(DATA_PROCESSED, set())\n    if processed is None:\n        hass.data[DATA_PROCESSED] = processed = hass.data.get(DATA_PROCESSED, set())\n\n    if processed.add(provider) and module.REQUIREMENTS:\n        await async_process_requirements(\n            hass, provider, module.REQUIREMENTS, hass.config.path(\"deps\")\n        )\n\n    return module\n\n", "CodeBleu_score": 40.251010329667466}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"hass_nabucasa.auth_providers.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Failed to find auth provider %s\", provider)\n        raise HomeAssistantError(\"Failed to find auth provider\") from None\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed = hass.data.setdefault(DATA_PROCESSED, set())\n    if module.REQUIREMENTS not in processed:\n        await async_process_requirements(\n            hass, f\"auth_provider {provider}\", module.REQUIREMENTS\n        )\n        processed.add(module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 44.43069288490587}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to load authentication provider %s\", provider)\n        raise HomeAssistantError(f\"Unable to load authentication provider {provider}\")\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not module.REQUIREMENTS:\n        return module\n\n    processed = hass.data.get(DATA_SETUP_PROCESSED, set())\n    if processed is None:\n        processed = hass.data[DATA_SETUP_PROCESSED] = set()\n\n    processed.add(provider)\n\n    await async_process_requirements(\n        hass, provider, module.REQUIREMENTS, processed=processed\n    )\n\n    return module\n\n", "CodeBleu_score": 50.546139892082955}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n\n", "CodeBleu_score": 0.7575757575757576}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.strip().lower()\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = base64.b64decode(user.password_hash)\n            if not bcrypt.checkpw(password.encode(), password_hash):\n                raise InvalidAuth(\"Invalid username or password\")\n            return\n    bcrypt.checkpw(password.encode(), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 41.56824378043381}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = user.password_hash.encode('utf-8')\n            if not bcrypt.checkpw(password.encode('utf-8'), password_hash):\n                raise InvalidAuth(\"Invalid username or password\")\n            return\n    bcrypt.checkpw(password.encode('utf-8'), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 38.500862003552506}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = user.password_hash.encode(\"utf-8\")\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth(\"Invalid username\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 38.152061289784164}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    user_id = self.async_normalize_username(username)\n    found = None\n    for index, user in enumerate(self._users):\n        if user.get(\"id\") == user_id:\n            found = user\n            break\n    if not found:\n        raise InvalidUser(\"user_not_found\")\n    self._users.remove(found)\n\n\n\n", "CodeBleu_score": 39.356727475760096}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 29.89753697862173}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = self.normalize_username(username)\n    user = None\n    for u in self.users:\n        if u.username == username:\n            user = u\n            break\n    if user is None:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(user)\n\n\n\n\n", "CodeBleu_score": 40.63866459403677}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n\n    try:\n        self._data[\"auth_providers\"][0][\"data\"][\"users\"].pop(credentials.id)\n    except KeyError:\n        pass\n    else:\n        await self._store.async_save(self._data)", "CodeBleu_score": 49.33875677828996}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self.initialized:\n        await self.async_initialize()\n\n    try:\n        self._data[credentials.data[\"username\"]]\n    except KeyError:\n        return\n\n    del self._data[credentials.data[\"username\"]]\n    await self.async_save()\n\n", "CodeBleu_score": 54.16042374367584}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._data:\n        await self.async_initialize()\n\n    try:\n        self._data.pop(credentials.id)\n    except KeyError:\n        pass\n    else:\n        await self.async_save()\n\n", "CodeBleu_score": 45.49919121929782}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    now = time.monotonic()\n    timeout_per_thread = timeout / len(threads)\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        if thread.ident is None:\n            # Thread is not running or has not started.\n            joined.add(thread)\n            continue\n\n        # Thread is still running.\n        thread_timeout = now + timeout_per_thread - time.monotonic()\n        thread.join(timeout=max(thread_timeout, 0))\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n\n    # Try to raise SystemExit in the threads that have not exited.\n    for thread in threads:\n        if thread in joined:\n            continue\n        if thread.ident is None:\n            continue\n        if not thread.is_alive():\n            continue\n        _asyncio.run_coroutine_threadsafe(_raise_system_exit_async(), loop=_asyncio.get_running_loop())\n        thread.join(timeout=0)\n        if thread.is_alive():\n            joined.add(thread)\n    return joined\n\n", "CodeBleu_score": 55.78908551911246}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    now = time.monotonic()\n    timeout_per_thread = timeout / len(threads)\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n\n        if thread.ident is None:\n            # Threads that are not started have an indent of None.\n            joined.add(thread)\n            continue\n\n        delta = now + timeout_per_thread - time.monotonic()\n        if delta <= 0:\n            if log:\n                _log_thread_running_at_shutdown(thread.name, thread.ident)\n            joined.add(thread)\n            continue\n\n        thread.join(timeout=delta)\n        if not thread.is_alive():\n            joined.add(thread)\n\n    for thread in threads - joined:\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        thread.raise_system_exit()\n\n    return joined\n\n", "CodeBleu_score": 57.3028219453973}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    _LOGGER.debug(\"Joining threads: %s\", threads)\n\n    joined: set[Thread] = set()\n\n    for thread in threads:\n        thread_timeout = timeout - (time.monotonic() - thread.start_time)\n        thread.join(max(0, thread_timeout))\n\n        if not thread.is_alive() or thread.ident is None:\n            joined.add(thread)\n            continue\n\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n\n        with suppress(SystemExit):\n            c_thread = _find_thread(thread.ident)\n            if c_thread:\n                _asyncio.run_coroutine_threadsafe(\n                    _asyncio.sleep(0), c_thread._loop\n                ).result()\n\n    return joined\n\n", "CodeBleu_score": 59.51497970950758}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    shutdown_timeout = config.SHUTDOWN_TIMEOUT\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon]\n    timeout = shutdown_timeout / len(threads)\n    for t in threads:\n        t.join(timeout=timeout)\n        if t.is_alive():\n            logger.warning(f\"Thread {t.name} failed to join within {timeout} seconds\")", "CodeBleu_score": 25.561045131951023}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    import threading\n    import logging\n    import time\n\n    # Get the current time\n    start_time = time.time()\n\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon]\n\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = (deadlock_safe_shutdown.shutdown_timeout - (time.time() - start_time)) / len(threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        thread.join(timeout)\n\n        # If joining the thread failed, log a warning\n        if thread.is_alive():\n            logging.warning(f\"Failed to join thread {thread.name} within {timeout} seconds\")\n", "CodeBleu_score": 37.072984436152936}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    import threading\n    import logging\n    import time\n\n    logger = logging.getLogger(__name__)\n\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon and t.is_alive()]\n\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    total_timeout = 10\n    timeout = total_timeout / len(threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for t in threads:\n        start_time = time.time()\n        t.join(timeout)\n        if t.is_alive():\n            logger.warning(f\"Thread {t.name} did not shut down within {timeout} seconds\")\n        else:\n            logger.info(f\"Thread {t.name} shut down in {time.time() - start_time:.2f} seconds\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 42.26335383988633}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_remaining:\n        self.hass.helpers.dispatcher.async_dispatcher_send(\n            self.hass, _SIGNAL_INTERNAL_DISPATCHER\n        )\n    self._previous_remaining = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 47.74993816724316}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_remaining:\n        self._hass.helpers.dispatcher.async_dispatcher_send(\n            _DISPATCHER_SIGNAL_SETUP_REMAINING, remaining_with_setup_started\n        )\n    self._previous_remaining = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 51.40202719749548}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._previous_state:\n        self._hass.helpers.dispatcher.async_dispatcher_send(\n            self._signal_name, remaining_with_setup_started\n        )\n    self._previous_state = remaining_with_setup_started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 46.827739195914106}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if config.specific_integrations:\n        return\n\n    with bluetooth_path.open(\"r\") as fp:\n        current = fp.read().strip()\n        if current != content:\n            config.add_error(\n                \"bluetooth\",\n                \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n                fixable=True,\n            )\n        return\n\n", "CodeBleu_score": 88.43099504559059}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = (\n        config.root / \"homeassistant/generated/bluetooth.py\"\n    )\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if config.specific_integrations:\n        return\n\n    with open(str(bluetooth_path)) as fp:\n        current = fp.read()\n\n    if current != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n", "CodeBleu_score": 78.09843797448643}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    bluetooth_path = (\n        config.root / \"homeassistant/generated/bluetooth.py\"\n    )\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n\n    if config.specific_integrations:\n        return\n\n    with open(str(bluetooth_path)) as fp:\n        current = fp.read()\n\n    if current != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )", "CodeBleu_score": 77.44365422609772}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Prepare the request body with the refresh token, app key, and app secret\n\tbody := url.Values{\n\t\t\"grant_type\":    {\"refresh_token\"},\n\t\t\"refresh_token\": {d.refreshToken},\n\t\t\"client_id\":     {d.appKey},\n\t\t\"client_secret\": {d.appSecret},\n\t}\n\n\t// Send a POST request to the Dropbox OAuth2 token endpoint with the request body\n\tresp, err := http.PostForm(\"https://api.dropboxapi.com/oauth2/token\", body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\trespBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the request was successful, update the access token\n\tif resp.StatusCode == http.StatusOK {\n\t\tvar tokenResp struct {\n\t\t\tAccessToken string `json:\"access_token\"`\n\t\t}\n\t\tif err := json.Unmarshal(respBody, &tokenResp); err != nil {\n\t\t\treturn err\n\t\t}\n\t\td.accessToken = tokenResp.AccessToken\n\t} else {\n\t\t// If the request was not successful, log the response and return an error\n\t\tlog.Printf(\"Dropbox token refresh failed: %s\", respBody)\n\t\treturn fmt.Errorf(\"Dropbox token refresh failed: %s\", respBody)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.52099371421744}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Prepare the request body with the refresh token and other parameters.\n\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\tdata.Set(\"refresh_token\", d.refreshToken)\n\tdata.Set(\"client_id\", d.appKey)\n\tdata.Set(\"client_secret\", d.appSecret)\n\n\t// Send the POST request to the Dropbox OAuth2 token endpoint.\n\tresp, err := http.PostForm(\"https://api.dropboxapi.com/oauth2/token\", data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check if the request was successful (status code 200 OK).\n\tif resp.StatusCode != http.StatusOK {\n\t\t// Read the response body.\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Log the response body for debugging purposes.\n\t\tlog.Println(\"Error refreshing token:\", string(body))\n\t\treturn errors.New(\"error refreshing token\")\n\t}\n\n\t// Parse the response body into a TokenResponse struct.\n\tvar tokenResponse TokenResponse\n\terr = json.NewDecoder(resp.Body).Decode(&tokenResponse)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Update the access token with the new value.\n\td.accessToken = tokenResponse.AccessToken\n\n\treturn nil\n}", "CodeBleu_score": 50.6354728954837}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\tdata.Set(\"refresh_token\", d.refreshToken)\n\tdata.Set(\"client_id\", d.appKey)\n\tdata.Set(\"client_secret\", d.appSecret)\n\n\tresp, err := http.PostForm(\"https://api.dropboxapi.com/oauth2/token\", data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\trespBody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"failed to refresh token: %s\", respBody)\n\t}\n\n\tvar refreshResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tif err := json.NewDecoder(resp.Body).Decode(&refreshResponse); err != nil {\n\t\treturn err\n\t}\n\n\td.accessToken = refreshResponse.AccessToken\n\treturn nil\n}", "CodeBleu_score": 50.443368704308234}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tparams := req.URL.Query()\n\tparams.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = params.Encode()\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tres, err := d.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode == http.StatusUnauthorized {\n\t\tif err := d.RefreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d: %s\", res.StatusCode, string(body))\n\t}\n\n\tif resp != nil {\n\t\tif err := json.Unmarshal(body, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 60.03213232042515}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\tif callback != nil {\n\t\terr = callback(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode == http.StatusUnauthorized {\n\t\td.RefreshToken()\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d: %s\", res.StatusCode, string(body))\n\t}\n\n\tif resp != nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 58.43579426524479}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\tparams := req.URL.Query()\n\tparams.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = params.Encode()\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tres, err := d.Client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode == http.StatusUnauthorized {\n\t\td.RefreshToken()\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tif res.StatusCode < 200 || res.StatusCode >= 300 {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d\", res.StatusCode)\n\t}\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp != nil {\n\t\tif err := json.Unmarshal(body, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 59.745696818929986}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := d.conf.ChunkSize\n\tif chunkSize <= 0 {\n\t\tchunkSize = chunkSizeEnv\n\t}\n\tchunkNum := stream.GetSize()/chunkSize + 1\n\tlog.Debugf(\"total chunk num: %d\", chunkSize)\n\n\tfor chunk := int64(0); chunk < chunkNum; chunk++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\toffset := chunk * chunkSize\n\t\t\tlimit := chunkSize\n\t\t\tif chunk+1 == chunkNum {\n\t\t\t\tlimit = -1\n\t\t\t}\n\t\t\tlog.Debugf(\"uploading chunk %d, offset: %d, limit: %d\", chunk, offset, limit)\n\t\t\tuploader := stream.GetUploader()\n\t\t\treq, err := http.NewRequestWithContext(ctx, \"POST\", url, uploader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treq.ContentLength = limit\n\t\t\trangeHeader := fmt.Sprintf(\"bytes %d-%d/*\", offset, offset+limit-1)\n\t\t\tif chunk+1 == chunkNum {\n\t\t\t\trangeHeader = fmt.Sprintf(\"bytes %d-%d/*\", offset, offset+limit)\n\t\t\t}\n\t\t\treq.Header.Set(\"Content-Range\", rangeHeader)\n\t\t\treq.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", limit))\n\t\t\tresp, err := d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\t_ = resp.Body.Close()\n\t\t\t}()\n\t\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {\n\t\t\t\tbs, err := io.ReadAll(resp.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"bad code: %d, message: %s\", resp.StatusCode, string(bs))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 39.01338805531145}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\tchunkSize := int64(googleapi.DefaultUploadChunkSize)\n\tchunk := make([]byte, chunkSize)\n\tchunkCount := int64(0)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tn, err := stream.Read(chunk)\n\t\t\tif err != nil && err != io.EOF {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tchunkCount++\n\t\t\tlog.Printf(\"Uploading chunk %d\", chunkCount)\n\n\t\t\treq, err := http.NewRequest(\"PUT\", url, bytes.NewReader(chunk[:n]))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(n))\n\t\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", (chunkCount-1)*chunkSize, (chunkCount-1)*chunkSize+int64(n)-1, stream.GetSize()))\n\n\t\t\tres, err := d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tdefer res.Body.Close()\n\n\t\t\tif res.StatusCode != http.StatusOK {\n\t\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", res.StatusCode)\n\t\t\t}\n\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.728034979896286}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar data map[string]string\n\tif err := ctx.Bind(&data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Invalid request payload\"})\n\t}\n\n\tmountPoint := data[\"mount_point\"]\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Mount point is required\"})\n\t}\n\n\tcmd := exec.Command(\"umount\", mountPoint)\n\tif err := cmd.Run(); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to unmount storage\"})\n\t}\n\n\t// Delete the corresponding configuration\n\tconfigPath := filepath.Join(\"/etc/fstab.d\", mountPoint+\".conf\")\n\tif err := os.Remove(configPath); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to delete configuration\"})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Storage unmounted successfully\"})\n}", "CodeBleu_score": 33.29508392126305}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar data map[string]string\n\terr := ctx.Bind(&data)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Invalid request body\"})\n\t}\n\tmountPoint := data[\"mount_point\"]\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Mount point is required\"})\n\t}\n\tcmd := exec.Command(\"umount\", mountPoint)\n\terr = cmd.Run()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to unmount storage\"})\n\t}\n\tconfigFile := fmt.Sprintf(\"/etc/fstab.d/%s.conf\", mountPoint)\n\terr = os.Remove(configFile)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to delete configuration\"})\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Storage unmounted successfully\"})\n}", "CodeBleu_score": 37.85749901137115}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\treq := ctx.Request().Context()\n\tbody := ctx.Request().Body\n\n\tdata := struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}{}\n\n\tif err := json.NewDecoder(body).Decode(&data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"invalid request body\"})\n\t}\n\n\tif data.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"mount point is required\"})\n\t}\n\n\tif err := storage.UnmountStorage(req, data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\tif err := storage.DeleteStorageConfig(req, data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"successfully unmounted storage\"})\n}", "CodeBleu_score": 36.63553582194432}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"filePath\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\tdefer file.Close()\n\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to get file info\"})\n\t}\n\n\tctx.Response().Header().Set(\"Content-Disposition\", \"attachment; filename=\"+fileInfo.Name())\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 36.37289234165672}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\tdefer file.Close()\n\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to get file info\"})\n\t}\n\n\tctx.Response().Header().Set(echo.HeaderContentDisposition, fmt.Sprintf(\"attachment; filename=%s\", fileInfo.Name()))\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 36.125612205412324}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File path not provided\"})\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\tdefer file.Close()\n\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to get file information\"})\n\t}\n\n\tctx.Response().Header().Set(\"Content-Disposition\", fmt.Sprintf(\"attachment; filename=%s\", fileInfo.Name()))\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 37.002306645971814}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\tnotify.Send(name, message)\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"message\": \"Notification sent successfully\",\n\t})\n}", "CodeBleu_score": 50.935095653453565}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\tnotifier.SendNotification(name, message)\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"Notification sent successfully\",\n\t})\n}", "CodeBleu_score": 47.64209262717342}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tnotify.SendNotification(name, message)\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent\"})\n}", "CodeBleu_score": 49.2142526757924}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\tconnections = append(connections, ws)\n\n\tif !sending {\n\t\tsending = true\n\t\tgo sendMessages()\n\t}\n\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received message: %s\", message)\n\t}\n\treturn nil\n}", "CodeBleu_score": 49.97258360659745}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP GET request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to a list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tif !sending {\n\t\tgo sendMessage()\n\t}\n\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// If there was an error reading the message, print it and break out of the loop\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message\n\t\tlog.Printf(\"recv: %s\", msg)\n\t}\n\n\t// Close the WebSocket connection\n\tws.Close()\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, conn := range connections {\n\t\tif conn == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.77858325890916}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tif !messageSendingServiceRunning {\n\t\tmessageSendingServiceRunning = true\n\t\tgo sendMessages()\n\t}\n\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// Remove the WebSocket connection from the list of connections\n\t\t\tfor i, conn := range connections {\n\t\t\t\tif conn == ws {\n\t\t\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Print the message type and message\n\t\tfmt.Println(\"Message Type:\", messageType)\n\t\tfmt.Println(\"Message:\", string(message))\n\n\t\t// Print any errors that occurred\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t}\n\t}\n}", "CodeBleu_score": 46.6069145514595}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveInfo, err := getDriveInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, &models.Response{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\n\tcpuInfo, err := getCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, &models.Response{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, &models.Response{\n\t\tStatus: \"success\",\n\t\tData: &models.SystemHardwareInfo{\n\t\t\tDriveModel:  driveInfo.Model,\n\t\t\tDriveArch:   driveInfo.Architecture,\n\t\t\tCPUModel:    cpuInfo.Model,\n\t\t\tCPUArch:     cpuInfo.Architecture,\n\t\t\tCPUCores:    cpuInfo.Cores,\n\t\t\tCPUMhz:      cpuInfo.Mhz,\n\t\t\tCPUCache:    cpuInfo.Cache,\n\t\t\tCPUCpus:     cpuInfo.Cpus,\n\t\t\tCPUCoresNum: cpuInfo.CoresNum,\n\t\t},\n\t})\n}", "CodeBleu_score": 27.221301841895517}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tdriveModel, driveArchitecture, err := GetDriveInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\tcpuModel, cpuArchitecture, err := GetCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"driveModel\":       driveModel,\n\t\t\"driveArchitecture\": driveArchitecture,\n\t\t\"cpuModel\":         cpuModel,\n\t\t\"cpuArchitecture\":  cpuArchitecture,\n\t})\n}", "CodeBleu_score": 20.665963495827594}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get the drive model and architecture\n\tdriveModel, driveArchitecture := GetDriveModelAndArchitecture()\n\n\t// Get the CPU information\n\tcpuInfo := GetCPUInfo()\n\n\t// Create a JSON response with the drive model and architecture and CPU information\n\tresponse := map[string]interface{}{\n\t\t\"drive_model\":        driveModel,\n\t\t\"drive_architecture\": driveArchitecture,\n\t\t\"cpu_info\":           cpuInfo,\n\t}\n\n\treturn ctx.JSON(http.StatusOK, response)\n}", "CodeBleu_score": 17.493578632843555}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 76.09609143114078}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service.Name, \"casaos-\") {\n\t\t\tif service.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 69.61781582262023}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.Running {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 79.59633022603168}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tresp, err := i.messageBus.Publish(name, string(msg))\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tif resp.Status != \"OK\" {\n\t\tlog.Printf(\"failed to send notification: %s\", resp.Details)\n\t}\n}", "CodeBleu_score": 26.89438256279314}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tmessageJson, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"error marshalling message to json\", zap.Error(err))\n\t\treturn\n\t}\n\n\tevent := &notify.NotifyRequest{\n\t\tName:    name,\n\t\tMessage: string(messageJson),\n\t}\n\n\tresponse, err := i.messageBus.Publish(context.Background(), event)\n\tif err != nil {\n\t\ti.logger.Error(\"error publishing event\", zap.Error(err))\n\t\treturn\n\t}\n\n\tif response.Status != http.StatusOK {\n\t\ti.logger.Error(\"failed to publish event\", zap.String(\"status\", response.Status), zap.String(\"message\", response.Message))\n\t}\n}", "CodeBleu_score": 41.903213655996154}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\tjsonString, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"Error marshalling message to JSON string: \", err)\n\t\treturn\n\t}\n\n\tevent := &events.Event{\n\t\tName:    name,\n\t\tMessage: string(jsonString),\n\t}\n\n\tresponse, err := i.messageBus.Publish(event)\n\tif err != nil {\n\t\ti.logger.Error(\"Error publishing event: \", err)\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"Failed to publish event: \", response.Details)\n\t}\n}", "CodeBleu_score": 36.97429740002682}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.runtime.HttpClient())\n\n\taddress, err := c.runtime.GetAddress(messageBusAddress)\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = address\n\t}\n\n\treturn client\n}", "CodeBleu_score": 36.60016722558725}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(c.runtime.HttpClient())\n\taddress, err := c.runtime.GetAddress(c.runtime.Environment().RelativeDataPath, \"message-bus.sock\")\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = \"http://\" + address\n\t}\n\treturn client\n}", "CodeBleu_score": 39.930400136641275}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClientWithResponses(\"\")\n\taddr, err := c.runtime.Get(c.runtimePath)\n\tif err != nil {\n\t\tclient.Server = \"error\"\n\t} else {\n\t\tclient.Server = addr\n\t}\n\treturn client\n}", "CodeBleu_score": 33.80419407271138}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\t// Get the \"x-forwarded-for\" header value\n\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\n\t// If the header is not empty, split the value by comma and return the first IP\n\tif forwarded != \"\" {\n\t\tip := strings.Split(forwarded, \",\")[0]\n\t\treturn ip\n\t}\n\n\t// If the header is empty, get the remote address\n\tip, _, err := net.SplitHostPort(request.RemoteAddr)\n\tif err != nil {\n\t\tlog.Fatalf(\"userip: %q is not IP:port\", request.RemoteAddr)\n\t}\n\n\t// Convert the loopback addresses to \"127.0.0.1\"\n\tuserIP := net.ParseIP(ip)\n\tif userIP == nil {\n\t\treturn \"\"\n\t}\n\tif userIP.IsLoopback() {\n\t\treturn \"127.0.0.1\"\n\t}\n\n\t// Return the IP address\n\treturn userIP.String()\n}", "CodeBleu_score": 34.44498680151853}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\t// Convert loopback addresses to \"127.0.0.1\"\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip != \"\" {\n\t\tipParts := strings.Split(ip, \",\")\n\t\tif len(ipParts) > 0 {\n\t\t\tip = ipParts[0]\n\t\t}\n\t} else {\n\t\tip, _, _ = net.SplitHostPort(request.RemoteAddr)\n\t}\n\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 61.756271458764054}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.getNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 65.89258600506749}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.systemService.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 66.0360004734164}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.GetNetNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 66.14623549657843}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t", "CodeBleu_score": 3.308789824934465}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t ret = TSDB_CODE_SUCCESS;\n\n    if (pTscObj->pTscAppInfo) {\n        pTscObj->pTscAppInfo->request.total++;\n        pTscObj->pTscAppInfo->request.current++;\n    }\n\n    pTscObj->requestCount++;\n    taosAddRefObj(pRequest);\n\n    if (pTscObj->pTscAppInfo) {\n        pTscObj->pTscAppInfo->request.total++;\n        pTscObj->pTscAppInfo->request.current++;\n    }\n\n    pTscObj->requestCount++;\n    taosAddRefObj(pRequest);\n\n    return ret;\n}", "CodeBleu_score": 33.36283665446266}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t    int32_t ret = TSDB_CODE_SUCCESS;\n\n    if (pRequest == NULL || pTscObj == NULL) {\n        ret = TSDB_CODE_INVALID_ARGUMENT;\n        goto EXIT;\n    }\n\n    pRequest->ref = 1;\n    pTscObj->requests++;\n\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requests++;\n        pTscObj->pAppInfo->currentRequests++;\n    }\n\n    taosLogDebug(\"register request:%p, tsc:%p, tsc->requests:%d, app->requests:%d, app->currentRequests:%d\",\n                  pRequest, pTscObj, pTscObj->requests, pTscObj->pAppInfo->requests, pTscObj->pAppInfo->currentRequests);\n\nEXIT:\n    return ret;\n}", "CodeBleu_score": 36.95507478350938}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    char *db = pRequest->db;\n    if (db && strcmp(db, exceptDb) != 0) {\n        return true;\n    }\n\n    SStrList *pDbList = pRequest->dbList;\n    if (pDbList) {\n        int32_t dbNum = pDbList->size;\n        for (int32_t i = 0; i < dbNum; i++) {\n            char *db = pDbList->str[i];\n            char *p = strchr(db, '.');\n            if (p) {\n                db = p + 1;\n            }\n            if (strcmp(db, exceptDb) != 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 54.14252348413437}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (pRequest->db == exceptDb) {\n        return false;\n    }\n\n    int32_t dbNum = taosGetDbNum(pRequest);\n    for (int32_t i = 0; i < dbNum; i++) {\n        char *db = taosGetDb(pRequest, i);\n        if (db == NULL) {\n            continue;\n        }\n        char *dbName = strchr(db, '.');\n        if (dbName != NULL) {\n            dbName++;\n        } else {\n            dbName = db;\n        }\n        if (strcmp(dbName, exceptDb) == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 58.036141658782235}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t    if (strcmp(pRequest->db, exceptDb) != 0) {\n        int32_t i = 0;\n        for (i = 0; i < pRequest->dbListNum; ++i) {\n            if (strcmp(pRequest->dbList[i], exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 46.729063488093146}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t    if (code == RPC_ERROR_REDIRECT) {\n        switch (msgType) {\n            case TMSG_RPC_REQ:\n            case TMSG_RPC_RESP:\n            case TMSG_RPC_NOTIFY:\n                return true;\n            default:\n                return false;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 39.449245942850666}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t", "CodeBleu_score": 7.876935227418826}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t  int32_t   numOfRequests = taosHashGetSize(pRequests);\n  int64_t * pRids = (int64_t *)taosMemoryCalloc(1, numOfRequests * sizeof(int64_t));\n  taosHashIter iter;\n  int64_t      rid;\n  int32_t      i = 0;\n\n  taosHashIterInit(&iter, pRequests);\n  while ((rid = taosHashIterNext(&iter)) != -1) {\n    pRids[i++] = rid;\n  }\n\n  for (i = 0; i < numOfRequests; ++i) {\n    int64_t rid = pRids[i];\n    SRequest *pRequest = (SRequest *)taosHashGet(pRequests, rid);\n    if (pRequest == NULL) {\n      continue;\n    }\n\n    if (pRequest->pSql != NULL) {\n      taosStopQuery(pRequest->pSql);\n    }\n    releaseRequest(rid);\n  }\n\n  taosMemoryFree(pRids);\n}", "CodeBleu_score": 44.54145757596797}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  SHashIterator *pIter = NULL;\n  pIter = taosHashIterateAll(pRequests);\n  if (pIter == NULL) return;\n\n  while (taosHashIterHasNext(pIter)) {\n    SHashRow *pRow = taosHashIterNext(pIter);\n    int64_t rid = *(int64_t *)pRow->pKey;\n    int32_t code = releaseRequest(rid);\n    if (code != 0) {\n      taosWarn(\"failed to release request %\" PRId64 \": code:%d\", rid, code);\n    }\n  }\n\n  taosHashIterDestroy(pIter);\n}", "CodeBleu_score": 39.85213165179022}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t  int32_t  numOfReq = taosHashGetSize(pRequests);\n  int64_t *pRids = (int64_t *)taosMemoryCalloc(1, numOfReq * sizeof(int64_t));\n  int32_t  numOfStoppedReq = 0;\n\n  int32_t ret = taosHashGetAll(pRequests, (void **)pRids, &numOfStoppedReq);\n  if (ret != 0) {\n    taosMemoryFree(pRids);\n    return;\n  }\n\n  for (int32_t i = 0; i < numOfStoppedReq; ++i) {\n    int64_t rid = pRids[i];\n    SRequest *pReq = (SRequest *)taosAcquireRef(clientReqRefPool, rid);\n    if (pReq != NULL) {\n      if (pReq->pTsc != NULL) {\n        taosStopQuery(pReq->pTsc);\n      }\n      releaseRequest(rid);\n    }\n  }\n\n  taosMemoryFree(pRids);\n}", "CodeBleu_score": 41.323447492731844}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t    if (crashReportingEnabled == 0) {\n        return;\n    }\n\n    int clientStop = 1;\n    if (atomic_compare_exchange_strong(&crashReportingEnabled, &clientStop, 0) == 0) {\n        return;\n    }\n\n    while (crashReportingEnabled != 0) {\n        sleep(1);\n    }\n}", "CodeBleu_score": 43.047112180896065}, {"code": "void tscStopCrashReport(){\n\t    if (!tscIsCrashReportingEnabled()) {\n        return;\n    }\n\n    int clientStop = 1;\n    if (!__atomic_compare_exchange_n(&tscCrashReportClientStop, &clientStop, 0, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) {\n        tscLogMessage(\"Crash report thread is already stopped\");\n        return;\n    }\n\n    while (tscCrashReportClientStop) {\n        tscSleep(1);\n    }\n}", "CodeBleu_score": 57.39208248217152}, {"code": "void tscStopCrashReport(){\n\t  if (!crashReportEnabled) {\n    return;\n  }\n\n  int expected = 0;\n  if (atomic_compare_exchange_strong(&clientStop, &expected, 1)) {\n    while (clientStop) {\n      usleep(1000);\n    }\n  } else {\n    log_info(\"Crash report thread already stopped\");\n  }\n}", "CodeBleu_score": 54.497112165738805}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t ret = 0;\n    SHeartbeatResp *pResp = (SHeartbeatResp *)value;\n    SViewMeta *pViewMeta = NULL;\n    int32_t viewId;\n    int32_t columnNum;\n    int32_t i;\n\n    if (valueLen != sizeof(SHeartbeatResp)) {\n        ret = TSDB_CODE_CLI_INVALID_RESP_PKG_LEN;\n        goto cleanup;\n    }\n\n    if (pResp->code != 0) {\n        ret = TSDB_CODE_CLI_INVALID_RESP_PKG;\n        goto cleanup;\n    }\n\n    for (i = 0; i < pResp->viewNum; ++i) {\n        viewId = pResp->viewMeta[i].viewId;\n        columnNum = pResp->viewMeta[i].columnNum;\n\n        pViewMeta = taosGetViewMeta(pCatalog, viewId);\n        if (pViewMeta == NULL) {\n            if (columnNum > 0) {\n                ret = taosAddViewMeta(pCatalog, &pResp->viewMeta[i]);\n                if (ret != 0) {\n                    goto cleanup;\n                }\n            }\n        } else {\n            if (columnNum == 0) {\n                taosRemoveViewMeta(pCatalog, viewId);\n            } else {\n                pViewMeta->columnNum = columnNum;\n            }\n        }\n    }\n\ncleanup:\n    return ret;\n}", "CodeBleu_score": 37.90503654317063}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t code;\n    SViewInfoResp *pViewInfoResp;\n    int32_t numOfViews;\n    int32_t i;\n\n    pViewInfoResp = (SViewInfoResp *)value;\n    if (pViewInfoResp->numOfViews > 0) {\n        numOfViews = pViewInfoResp->numOfViews;\n        for (i = 0; i < numOfViews; ++i) {\n            SViewMeta *pViewMeta = &pViewInfoResp->viewMeta[i];\n            if (pViewMeta->numOfColumns > 0) {\n                code = updateViewMeta(pCatalog, pViewMeta);\n                if (code != 0) {\n                    return code;\n                }\n            } else {\n                code = removeViewMeta(pCatalog, pViewMeta->name);\n                if (code != 0) {\n                    return code;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 34.8589786950258}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t    int32_t ret = 0;\n    SHeartbeatResp *pResp = (SHeartbeatResp *)value;\n    int32_t         numOfViews = 0;\n    SViewMeta      *pViewMeta = NULL;\n    int32_t         i;\n\n    ret = deserializeHeartbeatResp(pResp, valueLen, &numOfViews, &pViewMeta);\n    if (ret != 0) {\n        taosLog(\"Failed to deserialize heartbeat response, ret:%d\", ret);\n        goto cleanup;\n    }\n\n    for (i = 0; i < numOfViews; i++) {\n        SViewMeta *pView = &pViewMeta[i];\n        if (pView->numOfColumns > 0) {\n            ret = updateViewInfo(pCatalog, pView);\n        } else {\n            ret = removeViewInfo(pCatalog, pView->vgId, pView->dbId, pView->viewId);\n        }\n        if (ret != 0) {\n            taosLog(\"Failed to update view info, ret:%d\", ret);\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    if (pViewMeta != NULL) {\n        free(pViewMeta);\n    }\n\n    return ret;\n}", "CodeBleu_score": 42.73793071190042}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    S3_CHECK_OR_RAISE(properties, S3StatusInvalidArgument, \"The input argument properties is invalid\");\n    S3_CHECK_OR_RAISE(callbackData, S3StatusInvalidArgument, \"The input argument callbackData is invalid\");\n\n    S3GetObjectResponse *response = (S3GetObjectResponse *)callbackData;\n    if (properties->getContentLength() > 0) {\n        response->contentLength = properties->getContentLength();\n    } else {\n        response->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 53.72128947444372}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    S3Status status = S3StatusOK;\n    ResponseData *responseData = (ResponseData *)callbackData;\n    if (properties->getContentLength() > 0) {\n        responseData->contentLength = properties->getContentLength();\n    } else {\n        responseData->contentLength = 0;\n    }\n    return status;\n}", "CodeBleu_score": 58.91819717968588}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t    GET_CONTENT_LENGTH_CALLBACK_DATA *callbackDataCast = (GET_CONTENT_LENGTH_CALLBACK_DATA *)callbackData;\n    if (properties->getContentLengthResult.contentLength > 0) {\n        callbackDataCast->contentLength = properties->getContentLengthResult.contentLength;\n    } else {\n        callbackDataCast->contentLength = 0;\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 60.54911248610635}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\t  int32_t ret = taosCreateDir(tsCheckpointBackupDir);\n  if (ret < 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  ret = generateConfigFile(tsCheckpointBackupDir);\n  if (ret < 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n#ifdef WINDOWS\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --config=%srsyncd.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n#else\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --config=%srsyncd.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort);\n#endif\n  uDebug(\"[rsync] cmd:%s\", cmd);\n\n  ret = system(cmd);\n  if (ret == 0) {\n    uInfo(\"[rsync] rsync server start success\");\n  } else {\n    uError(\"[rsync] rsync server start error, ret:%d\", ret);\n  }\n}", "CodeBleu_score": 56.886218340923776}, {"code": "void startRsync(){\n\t  if (taosMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] mkdir %s error,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n#ifdef WINDOWS\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port %d --config=%s\", tsRsyncPort, confDir);\n#else\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port %d --config=%s\", tsRsyncPort, confDir);\n#endif\n\n  int32_t pid = taosStartProcess(cmd);\n  if (pid != 0) {\n    uInfo(\"[rsync] start rsync success, pid:%d\", pid);\n  } else {\n    uError(\"[rsync] start rsync error\");\n  }\n}", "CodeBleu_score": 68.7625648105018}, {"code": "void startRsync(){\n\t  if (taosCreateDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir,\n           ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n  if (generateConfigFile(confDir) != 0) {\n    uError(\"[rsync] generate conf file error\");\n    return;\n  }\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --port=%d --config=%s\", tsRsyncPort, confDir);\n  uDebug(\"[rsync] start rsync server, cmd:%s\", cmd);\n  int32_t ret = system(cmd);\n  if (ret != 0) {\n    uError(\"[rsync] start rsync server error, ret:%d\", ret);\n  } else {\n    uInfo(\"[rsync] start rsync server success\");\n  }\n}", "CodeBleu_score": 64.21081752259904}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.shutdown();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 63.43598746766709}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t  Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n  if (dispatcher != null) {\n    dispatcher.shutdown();\n  } else {\n    throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n  }\n}", "CodeBleu_score": 70.434103689478}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdown();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n}", "CodeBleu_score": 68.3845324874622}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t    List<TbActorId> children = parentToChildren.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            TbActorRef childRef = actorContext.getActorRef(child);\n            if (childRef != null) {\n                childRef.tell(msg, highPriority);\n            } else {\n                log.warn(\"[{}]: Failed to find actor for id {}\", parent, child);\n            }\n        });\n    }\n}", "CodeBleu_score": 56.07845615067233}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        List<TbActorId> children = getContext().getChildren(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                try {\n                    tell(child, msg, highPriority);\n                } catch (TbActorError e) {\n                    log.warn(\"Failed to send message to child actor: {}\", child, e);\n                }\n            });\n        }\n    }", "CodeBleu_score": 62.01773712094073}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t        List<TbActorId> children = actorSystemContext.getChildren(parent);\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    try {\n                        tellInternal(child, msg, highPriority);\n                    } catch (TbActorException e) {\n                        log.warn(\"Failed to send message to child actor [{}]: {}\", child, e.getMessage());\n                    }\n                }\n            }\n        }\n    }", "CodeBleu_score": 58.26050539712774}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (!destructionInProgress.get()) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else if (msg.getMsgType().equals(RULE_NODE_UPDATED_MSG)) {\n            if (msg.getData() instanceof RuleNodeUpdatedMsgData) {\n                RuleNodeUpdatedMsgData data = (RuleNodeUpdatedMsgData) msg.getData();\n                if (data.getErrorMsg() != null && data.getErrorMsg().getErrorCode() == RULE_NODE_INIT_FAILURE) {\n                    tryInit(1);\n                }\n            }\n        } else {\n            msg.getCallback().onMsgProcessed(null);\n        }\n    }", "CodeBleu_score": 60.62111439885507}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (!destructionInProgress.get()) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else if (msg.getMsgType().equals(RULE_NODE_UPDATED_MSG)) {\n            if (failedToInit.get()) {\n                tryInit(1);\n            }\n        } else {\n            msg.getCallback().onFailure(new ActorIsStoppedException(\"Actor is stopped: \" + selfId));\n        }\n    }", "CodeBleu_score": 48.16443927349814}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t        if (msg instanceof RuleNodeUpdatedMsg && !destructionInProgress.get()) {\n            //We can reinitialize actor if it failed during initialization\n            if (initializationInProgress.get() && !initializationCompleted.get()) {\n                log.debug(\"[{}] Reinitializing actor\", selfId);\n                tryInit(0);\n            }\n        } else if (destructionInProgress.get()) {\n            msg.notifyActorStopped(selfId);\n        }\n        if (!destructionInProgress.get()) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 56.335307114884635}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t    try {\n        long start = System.currentTimeMillis();\n        int processed = 0;\n        while (true) {\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n            }\n            if (msg == null) {\n                break;\n            }\n            try {\n                actor.process(msg);\n            } catch (TbActorInitializationException e) {\n                stopReason = TbActorStopReason.INIT_FAILED;\n                destroy(e);\n                return;\n            } catch (Throwable e) {\n                log.warn(\"[{}] Failed to process message: {}\", selfId, e);\n                actor.onProcessFailure(msg, e);\n                if (actor.isStopped()) {\n                    destroy(e);\n                    return;\n                }\n            }\n            processed++;\n            if (System.currentTimeMillis() - start >= throughputLimit) {\n                break;\n            }\n        }\n        if (processed > 0) {\n            log.trace(\"[{}] Processed {} messages in {}ms\", selfId, processed, System.currentTimeMillis() - start);\n        }\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            ready.set(FREE);\n        } else {\n            dispatcher.scheduleMailboxProcessing(selfId);\n        }\n    } finally {\n        busy.set(FREE);\n    }\n}", "CodeBleu_score": 50.881689096999416}, {"code": "private void processMailbox(){\n\t    try {\n        long start = System.currentTimeMillis();\n        while (System.currentTimeMillis() - start < throughputLimit) {\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n            }\n            if (msg == null) {\n                break;\n            }\n            try {\n                actor.process(msg);\n            } catch (TbActorInitializationException e) {\n                log.warn(\"[{}] Actor initialization failure during processing of msg: {}\", selfId, e);\n                stopReason = TbActorStopReason.INIT_FAILURE;\n                destroy(e);\n                return;\n            } catch (Throwable t) {\n                log.warn(\"[{}] Actor failure during processing of msg: {}\", selfId, t);\n                actor.onProcessFailure(t);\n                if (actor.stopIfFailed()) {\n                    stopReason = TbActorStopReason.STOPPED;\n                    destroy(t);\n                    return;\n                }\n            }\n        }\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            ready.set(FREE);\n        } else {\n            scheduleQueueProcessing();\n        }\n    } finally {\n        busy.set(FREE);\n    }\n}", "CodeBleu_score": 49.71525384627656}, {"code": "private void processMailbox(){\n\t    try {\n        long start = System.currentTimeMillis();\n        int processed = 0;\n        while (true) {\n            if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                break;\n            }\n            if (processed >= throughputLimit) {\n                break;\n            }\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n            }\n            if (msg != null) {\n                try {\n                    actor.process(msg);\n                    processed++;\n                } catch (TbActorInitializationException e) {\n                    stopReason = TbActorStopReason.INIT_FAILED;\n                    destroy(e);\n                    break;\n                } catch (Throwable t) {\n                    log.warn(\"[{}] Failed to process message: {}\", selfId, t);\n                    actor.onProcessFailure(t);\n                    if (actor.stopIfFailed()) {\n                        stopReason = TbActorStopReason.STOPPED;\n                        destroy(t);\n                        break;\n                    }\n                }\n            }\n        }\n        long duration = System.currentTimeMillis() - start;\n        if (processed > 0) {\n            log.trace(\"[{}] Processed {} messages in {} ms\", selfId, processed, duration);\n        }\n    } finally {\n        if (busy.compareAndSet(BUSY, FREE)) {\n            if (ready.get() == READY) {\n                dispatcher.scheduleMailboxProcessing(selfId);\n            }\n        }\n    }\n}", "CodeBleu_score": 47.01369957960466}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.85357591640158}, {"code": "public void destroy(Throwable cause){\n\t        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.36402548545796}, {"code": "public void destroy(Throwable cause){\n\t    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.85357591640158}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t    if (tenantId.isSysTenantId()) {\n        return true;\n    }\n    TenantProfile profile = tenantProfileService.findTenantProfile(tenantId);\n    if (profile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        }\n        throw new TenantProfileNotFoundException(tenantId);\n    }\n    RateLimitConfig config = profile.getRateLimitConfig();\n    boolean result = checkRateLimit(api, tenantId, level, config);\n    if (!result) {\n        processRateLimitNotification(api, tenantId, level, config);\n    }\n    return result;\n}", "CodeBleu_score": 48.54435913944995}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t        TenantProfile profile = getTenantProfile(tenantId, ignoreTenantNotFound);\n        if (profile == null) {\n            return true;\n        }\n        RateLimitConfiguration limitConfiguration = profile.getRateLimitConfiguration();\n        if (limitConfiguration == null) {\n            return true;\n        }\n        RateLimitKey key = new RateLimitKey(api, level);\n        boolean success = rateLimitService.checkRateLimit(key, limitConfiguration);\n        if (!success) {\n            rateLimitNotificationService.processRateLimitNotification(key, limitConfiguration);\n        }\n        return success;\n    }", "CodeBleu_score": 40.64496318236724}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t        if (tenantId.isSysTenantId()) {\n            return true;\n        }\n        TenantProfile profile = tenantProfileService.findTenantProfile(tenantId);\n        if (profile == null) {\n            if (ignoreTenantNotFound) {\n                return true;\n            }\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n        RateLimitConfig rateLimitConfig = profile.getRateLimitConfig();\n        if (rateLimitConfig == null) {\n            return true;\n        }\n        boolean result = checkRateLimit(api, tenantId, level, rateLimitConfig);\n        if (!result) {\n            processRateLimitNotification(api, tenantId, level, rateLimitConfig);\n        }\n        return result;\n    }", "CodeBleu_score": 54.07801918882954}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n        DTLSSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.info(\"Removed DTLS session with ID: \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 46.27702441059163}, {"code": "public void evictTimeoutSessions(){\n\t  long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n  for (Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n    if (entry.getValue().getLastActivityTime() < expirationTime) {\n      dtlsSessions.remove(entry.getKey());\n      logger.info(\"DTLS session with ID {} has been removed due to inactivity timeout\", entry.getKey());\n    }\n  }\n}", "CodeBleu_score": 52.16189719813518}, {"code": "public void evictTimeoutSessions(){\n\t  long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n  for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n    if (entry.getValue().getLastActivityTime() < expirationTime) {\n      dtlsSessions.remove(entry.getKey());\n      logger.info(\"Removed DTLS session for {}\", entry.getKey());\n    }\n  }\n}", "CodeBleu_score": 51.51482449450637}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return timeseries.entrySet().stream().flatMap(entry -> {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            return values.stream().map(value -> {\n                KvEntry kvEntry = parseValue(key, value);\n                return new BaseTsKvEntry(System.currentTimeMillis(), kvEntry);\n            });\n        }).collect(Collectors.toList());\n    }", "CodeBleu_score": 43.08643873584076}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries == null || timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> tsKvEntries = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                tsKvEntries.add(new TsKvEntry(System.currentTimeMillis(), key, parseValue(key, value)));\n            }\n        }\n        return tsKvEntries;\n    }", "CodeBleu_score": 43.78659052134907}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t        if (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            for (JsonNode value : entry.getValue()) {\n                result.add(parseValue(key, value));\n            }\n        }\n        return result;\n    }", "CodeBleu_score": 42.292040414285786}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        JsonNode response = this.sendRequest(request, \"POST\", \"/api/v1/auth/refreshToken\");\n        this.setTokenInfo(System.currentTimeMillis(), response);\n    }", "CodeBleu_score": 40.520127595868935}, {"code": "public void refreshToken(){\n\t        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(\n                authEndpoint,\n                request,\n                JsonNode.class);\n        this.setTokenInfo(System.currentTimeMillis(), response.getBody());\n    }", "CodeBleu_score": 45.86990104788327}, {"code": "public void refreshToken(){\n\t        Map<String, String> request = new HashMap<>();\n        request.put(\"refreshToken\", this.refreshToken);\n        JsonNode response = this.sendRequest(this.authEndpoint, request, HttpMethod.POST, null);\n        this.setTokenInfo(System.currentTimeMillis(), response);\n    }", "CodeBleu_score": 44.49344982342718}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(serverUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 89.95593210043789}, {"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(baseUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        setTokenInfo(ts, response.getBody());\n    }", "CodeBleu_score": 89.49406239263915}, {"code": " private void doLogin(){\n\t        long ts = System.currentTimeMillis();\n        Map<String, Object> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", this.username);\n        loginRequest.put(\"password\", this.password);\n        ResponseEntity<JsonNode> response = restTemplate.postForEntity(this.apiUrl + \"/api/auth/login\", loginRequest, JsonNode.class);\n        JsonNode tokenInfo = response.getBody();\n        setTokenInfo(ts, tokenInfo);\n    }", "CodeBleu_score": 68.18295654745852}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n            \"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (RestClientException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 52.01086015193381}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n            \"/api/device/{deviceId}\",\n            Device.class,\n            deviceId.getId()\n        );\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 51.4066211294528}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (HttpClientErrorException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 52.20332467121489}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        Request request = new Request();\n        request.setDevice(device);\n        request.setCredentials(credentials);\n        return Optional.of(restTemplate.postForObject(baseUrl + \"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (Exception e) {\n        throw e;\n    }\n}", "CodeBleu_score": 39.16408318582272}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        Request request = new Request.Builder().url(BASE_URL + \"/api/device-with-credentials\").post(RequestBody.create(JSON, gson.toJson(new DeviceWithCredentials(device, credentials)))).build();\n        Response response = client.newCall(request).execute();\n        if (response.code() == 200) {\n            return Optional.of(gson.fromJson(response.body().string(), Device.class));\n        } else if (response.code() == 404) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(\"Failed to save device with credentials: \" + response.code());\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 51.78365748030682}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t    try {\n        HttpRequest request = HttpRequest.newBuilder().uri(new URI(\"http://localhost:8080/api/device-with-credentials\")).POST(HttpRequest.BodyPublishers.ofString(new ObjectMapper().writeValueAsString(new DeviceWithCredentials(device, credentials)))).build();\n        HttpResponse<String> response = HttpClient.newHttpClient().send(request, HttpResponse.BodyHandlers.ofString());\n        return Optional.of(new ObjectMapper().readValue(response.body(), Device.class));\n    } catch (URISyntaxException | IOException | InterruptedException e) {\n        throw new RuntimeException(e);\n    } catch (HttpClientException e) {\n        if (e.getMessage().contains(\"404\")) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 52.763304172624984}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 97.94874339045735}, {"code": "brightness(addr, val){\n\t  if (arguments.length === 1) {\n    val = addr;\n    this.each(function(device) {\n      this.brightness(device, val);\n    });\n  } else {\n    this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n  }\n  return this;\n}", "CodeBleu_score": 99.78108665049078}, {"code": "brightness(addr, val){\n\t  if (arguments.length === 1) {\n    val = addr;\n    this.each(function(device) {\n      this.brightness(device, val);\n    });\n  } else {\n    this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n  }\n  return this;\n}", "CodeBleu_score": 99.78108665049078}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.09390594052935}, {"code": "device(addr){\n\t  const bound = {};\n\n  /* keys from prototype */\n  Object.keys(LedControl.prototype).forEach(key => {\n    bound[key] = this[key].bind(this, addr);\n  });\n\n  /* functions from interface */\n  Object.getOwnPropertyNames(this).forEach(key => {\n    if (this[key] && typeof this[key] === \"function\") {\n      bound[key] = this[key].bind(this, addr);\n    }\n  });\n  return bound;\n}", "CodeBleu_score": 99.81793301349097}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  for (const method of methods) {\n    target[method] = (duration, callback) => {\n      if (!callback || typeof callback !== 'function') {\n        throw new Error('Callback must be a function');\n      }\n\n      duration = duration || 1000;\n\n      const promises = [];\n\n      for (const element of this) {\n        const promise = element[method](duration);\n        promises.push(promise);\n      }\n\n      Promise.all(promises).then(callback);\n    };\n  }\n}", "CodeBleu_score": 33.96725905902886}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t    methods.forEach(method => {\n        target[method] = function (...args) {\n            let duration = args.shift();\n            let callback = args.shift();\n            if (typeof duration === 'function') {\n                callback = duration;\n                duration = 1000;\n            }\n            if (typeof callback !== 'function') {\n                callback = () => { };\n            }\n            const promises = this.map(item => item[method](...args));\n            Promise.all(promises).then(callback);\n            return this;\n        };\n    });\n}", "CodeBleu_score": 51.447165793605585}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t  methods.forEach(method => {\n    target[method] = (duration = 1000) => {\n      let callback = arguments[arguments.length - 1];\n      if (typeof callback !== 'function') {\n        callback = () => {};\n      }\n      const promises = this.map(element => {\n        return new Promise((resolve, reject) => {\n          setTimeout(() => {\n            try {\n              element[method]();\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n          }, duration);\n        });\n      });\n      Promise.all(promises).then(callback);\n    };\n  });\n}", "CodeBleu_score": 41.552173747546995}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t  let input = \"\";\n\n  // Start the read loop\n  this.io.serialRead(this.portId, data => {\n    input += new Buffer(data).toString(\"ascii\");\n    const sentences = input.split(\"\\r\n\");\n\n    if (sentences.length > 1) {\n      for (let i = 0; i < sentences.length - 1; i++) {\n        this.parseNmeaSentence(sentences[i]);\n      }\n      input = sentences[sentences.length - 1];\n    }\n  });\n}", "CodeBleu_score": 71.0384210165341}, {"code": "listen(){\n\t\n    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.00812640651824}, {"code": "listen(){\n\t    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n        input += new Buffer(data).toString(\"ascii\");\n        const sentences = input.split(\"\\r\n\");\n\n        if (sentences.length > 1) {\n            for (let i = 0; i < sentences.length - 1; i++) {\n                this.parseNmeaSentence(sentences[i]);\n            }\n            input = sentences[sentences.length - 1];\n        }\n    });\n}", "CodeBleu_score": 89.65664796092429}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t needed_buffer_size;\n\tuint32_t active_channels;\n\n\tactive_channels = sequence->options->channels;\n\tneeded_buffer_size = sequence->options->extra_samplings + 1;\n\n\tif (active_channels & BIT(config->channels - 1)) {\n\t\tneeded_buffer_size *= config->resolution;\n\t} else {\n\t\tneeded_buffer_size *= config->resolution / 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 50.484910087043055}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tint num_channels = 0;\n\tsize_t needed_buffer_size = 0;\n\tint ret;\n\n\tfor (uint8_t i = 0; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels[i].channel_id ==\n\t\t    sequence->trigger.channel_id) {\n\t\t\tcontinue;\n\t\t}\n\t\tnum_channels++;\n\t}\n\n\tret = adc_ad559x_get_buffer_size(dev, num_channels,\n\t\t\t\t\t  sequence->resolution,\n\t\t\t\t\t  &needed_buffer_size);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Buffer size insufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.07479952070342}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t needed_buffer_size;\n\tuint8_t active_channels = 0;\n\n\tfor (uint8_t i = 0; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels_config[i].channel_id >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel %d\", sequence->channels_config[i].channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_config[i].acquisition_time != AD559X_ACQ_TIME_4_MS) {\n\t\t\tLOG_ERR(\"Invalid acquisition time %d\", sequence->channels_config[i].acquisition_time);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels_config[i].input_mode != AD559X_INPUT_MODE_SINGLE_ENDED) {\n\t\t\tLOG_ERR(\"Invalid input mode %d\", sequence->channels_config[i].input_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tactive_channels++;\n\t}\n\n\tneeded_buffer_size = active_channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Buffer size %d is not sufficient for %d channels\", sequence->buffer_size, active_channels);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 44.55356186921811}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Resolution %d is not supported\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > config->channels) {\n\t\tLOG_ERR(\"Invalid channels: %d\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tadc_ad559x_set_buffer(dev, sequence->buffer, sequence->buffer_size);\n\n\tadc_ad559x_start_read_context(dev);\n\n\tk_sem_take(&config->sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 58.93161193600934}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channels;\n\tsize_t needed;\n\tint ret;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Requested resolution %d does not match configured resolution %d\",\n\t\t\tsequence->resolution, config->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!adc_ad559x_is_valid_channel(dev, sequence->channels)) {\n\t\tLOG_ERR(\"Invalid channel(s) specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadc_context.buffer = sequence->buffer;\n\tadc_context.buffer_size = sequence->buffer_size;\n\tadc_context.channels = sequence->channels;\n\tadc_context.num_channels = channels;\n\tadc_context.resolution = sequence->resolution;\n\tadc_context.config = config;\n\n\tret = adc_ad559x_read(dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_sem_take(&adc_context.sem, K_FOREVER);\n\n\treturn adc_context.result;\n}", "CodeBleu_score": 58.04530403784517}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > config->num_channels) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tadc_context_start_read(dev, sequence);\n\tadc_context_wait_for_completion(dev);\n\n\treturn 0;\n}", "CodeBleu_score": 68.09231704818937}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n    struct adc_dev *dev = data->dev;\n    uint32_t channels = data->channels;\n\n    adc_set_channels(dev, channels);\n    adc_set_repeat_buf(dev, data->buf, data->buf_len);\n    adc_set_repeat_samples(dev, data->samples);\n    adc_start_conversion(dev);\n\n    os_sem_release(&data->sem);\n}", "CodeBleu_score": 49.90842927428778}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n    uint32_t channel_mask = 0;\n\n    for (int i = 0; i < data->num_channels; i++) {\n        channel_mask |= (1 << data->channels[i]);\n    }\n\n    adc_set_channels(data->adc, channel_mask);\n\n    adc_set_repeat_buffer(data->adc, data->buffer, data->buffer_size);\n\n    adc_start(data->adc);\n\n    sem_release(&ctx->sem);\n}", "CodeBleu_score": 31.907548408199858}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t    struct adc_data *data = ctx->data;\n    struct adc_descriptor *descriptor = data->descriptor;\n    struct _adc_async_descriptor *adc_desc = &descriptor->adc_descriptor;\n    uint8_t channel_count = descriptor->channel_count;\n    uint8_t *channels = descriptor->channels;\n    uint16_t *buffer = descriptor->buffer;\n    uint16_t buffer_size = descriptor->buffer_size;\n    uint8_t *repeat_buffer = descriptor->repeat_buffer;\n\n    adc_async_descriptor_set_channel_seq(adc_desc, channel_count, channels);\n    adc_async_descriptor_set_callback(adc_desc, adc_callback);\n    adc_async_descriptor_set_param(adc_desc, ctx);\n    adc_async_descriptor_set_repeat_buffer(adc_desc, repeat_buffer, buffer_size);\n\n    adc_async_init(ADC, adc_desc);\n    adc_async_start_conversion(ADC);\n\n    sem_release_blocking(&ctx->sem);\n}", "CodeBleu_score": 44.28020149338081}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data *data = adc_context_get_data(ctx);\n    if (repeat_sampling) {\n        data->buffer = data->repeat_buffer;\n    } else {\n        data->buffer = data->buffer_1;\n    }\n}", "CodeBleu_score": 60.74925792579644}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *data_container = ctx->data_container;\n    if (repeat_sampling) {\n        ctx->buffer = data_container->repeat_buffer;\n    } else {\n        ctx->buffer = data_container->buffer;\n    }\n}", "CodeBleu_score": 38.64477188374534}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t    struct adc_data_container *adc_data_container = adc_context_get_adc_data_container(ctx);\n    if (repeat_sampling) {\n        adc_data_container->buffer = adc_data_container->repeat_buffer;\n    } else {\n        adc_data_container->buffer = adc_data_container->buffer_1;\n    }\n}", "CodeBleu_score": 46.422936264124445}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t  // Initialize the ADC context.\n  adc_ad559x_context_init(&data->adc_ctx);\n\n  // Continuously acquire data from ADC channels.\n  while (true) {\n    // Wait for a semaphore to be released.\n    k_sem_take(&data->sem, K_FOREVER);\n\n    // Iterate through the active channels.\n    for (int i = 0; i < data->num_channels; i++) {\n      // Read the ADC value.\n      int ret = adc_ad559x_read_channel(data->dev, data->channels[i], &data->adc_ctx.buffer[i]);\n      if (ret < 0) {\n        // Log an error and mark the ADC context as complete.\n        LOG_ERR(\"Failed to read ADC channel %d: %d\", data->channels[i], ret);\n        adc_ad559x_context_complete(&data->adc_ctx);\n        break;\n      }\n    }\n\n    // Signal that the sampling is done.\n    k_sem_give(&data->sem);\n  }\n}", "CodeBleu_score": 40.82020599359593}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t  while (true) {\n    k_sem_take(&data->sem, K_FOREVER);\n    if (data->complete) {\n      break;\n    }\n    for (int i = 0; i < data->num_channels; i++) {\n      if (!data->active_channels[i]) {\n        continue;\n      }\n      uint16_t val;\n      int ret = adc_ad559x_read_channel(data->dev, i, &val);\n      if (ret < 0) {\n        LOG_ERR(\"Failed to read ADC channel %d: %d\", i, ret);\n        data->complete = true;\n        break;\n      }\n      data->buffer[i] = val;\n    }\n    k_sem_give(&data->sem);\n    k_sem_give(&data->done);\n  }\n}", "CodeBleu_score": 48.529784895093655}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\t\tint ret;\n\n\twhile (true) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tif (data->stop_sampling) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (size_t i = 0; i < data->num_channels; i++) {\n\t\t\tret = adc_ad559x_read_channel(data->dev, data->channels[i], &data->buffer[i]);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", data->channels[i], ret);\n\t\t\t\tdata->error = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\t\tk_sem_give(&data->done);\n\t}\n}", "CodeBleu_score": 44.52116256222228}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val = 0;\n\tint rc = 0;\n\n\tk_sleep(K_MSEC(config->ready_time));\n\n\tdo {\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t\tif (rc != 0) {\n\t\t\tLOG_ERR(\"Failed to read configuration register: %d\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\tk_sleep(K_USEC(100));\n\t} while ((reg_val & ADS1112_CONFIG_DRDY) == 0);\n\n\treturn 0;\n}", "CodeBleu_score": 46.80902512358939}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\n\tk_sleep(K_MSEC(config->ready_time_ms));\n\n\tuint8_t reg_val = 0;\n\tint rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\n\twhile ((reg_val & ADS1112_CONFIG_DRDY) == 0) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 49.748198036262615}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\n\tk_sleep(K_MSEC(config->ready_time_ms));\n\n\tuint8_t reg_val = 0;\n\tint rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\twhile ((reg_val & ADS1112_CONFIG_DRDY) == 0) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &reg_val);\n\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 66.93574801498569}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t num_samplings = sequence->options->extra_samplings;\n    size_t num_channels = sequence->channels->count;\n    size_t buffer_size = sequence->buffer_size;\n    size_t required_size = num_samplings * num_channels;\n\n    if (buffer_size < required_size) {\n        LOG_ERR(\"Buffer size is insufficient. Required size: %d, Buffer size: %d\", required_size, buffer_size);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 38.35237835526567}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t buffer_size = sequence->options ? sequence->options->extra_samplings : 0;\n    int i;\n\n    for (i = 0; i < sequence->channels->count; i++) {\n        const struct ads1112_config *config = sequence->channels->configs[i];\n        buffer_size += config->resolution;\n    }\n\n    if (sequence->buffer_size < buffer_size) {\n        LOG_ERR(\"buffer size %zu is smaller than needed for %zu bits\",\n                sequence->buffer_size, buffer_size);\n        return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 44.4267661827884}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t    size_t buffer_size = sequence->options->extra_samplings + 1;\n    if (sequence->buffer_size < buffer_size) {\n        LOG_ERR(\"buffer size %zu is smaller than the expected buffer size %zu\",\n                sequence->buffer_size, buffer_size);\n        return -EINVAL;\n    }\n    return 0;\n}", "CodeBleu_score": 40.056778261769864}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tstruct ads1112_adc_read_context *ctx;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tctx = &data->ctx;\n\n\tctx->dev = dev;\n\tctx->buffer = sequence->buffer;\n\tctx->buffer_size = sequence->buffer_size;\n\tctx->wait = wait;\n\tctx->complete = false;\n\n\tret = ads1112_start_read(dev);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tk_sem_take(&ctx->sem, K_FOREVER);\n\t\tret = ctx->result;\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 60.74770433316975}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\n\tif (wait) {\n\t\tif (ads1112_validate_sequence(dev, sequence) != 0) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->buffer = sequence->buffer;\n\t\tdata->buffer_size = sequence->buffer_size;\n\t\tdata->resolution = sequence->resolution;\n\n\t\tdata->wait_for_completion = true;\n\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOTSUP;\n}", "CodeBleu_score": 53.096108549281574}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\t\tconst struct ads1112_data *data = dev->data;\n\tuint8_t buf[2];\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tdata->sequence.buffer = sequence->buffer;\n\tdata->sequence.buffer_end = sequence->buffer_end;\n\tdata->sequence.resolution = sequence->resolution;\n\tdata->sequence.oversampling = sequence->oversampling;\n\n\tret = ads1112_read(dev, buf, 2);\n\tif (ret != 0) {\n\t\tLOG_ERR(\"Failed to read register\");\n\t\treturn ret;\n\t}\n\n\tdata->sequence.calibration_data = sys_be16_to_cpu(buf[0]);\n\n\tif (wait) {\n\t\tret = ads1112_wait_for_completion(dev);\n\t\tif (ret != 0) {\n\t\t\tLOG_ERR(\"Failed to wait for completion\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 54.40776958849036}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t  int ret;\n  struct device *dev;\n  struct audio_codec_config config;\n  struct audio_codec_data data;\n\n  dev = device_get_binding(argv[1]);\n  if (!dev) {\n    shell_error(sh, \"Cannot find device %s\", argv[1]);\n    return -ENODEV;\n  }\n\n  config.sample_rate = atoi(argv[2]);\n  config.bit_width = atoi(argv[3]);\n  config.mic_gain = atoi(argv[4]);\n  config.speaker_gain = atoi(argv[5]);\n  config.speaker_en = atoi(argv[6]);\n\n  ret = audio_codec_apply_config(dev, &config);\n  if (ret) {\n    shell_error(sh, \"Failed to apply config: %d\", ret);\n    return ret;\n  }\n\n  ret = audio_codec_get_data(dev, &data);\n  if (ret) {\n    shell_error(sh, \"Failed to get data: %d\", ret);\n    return ret;\n  }\n\n  shell_print(sh, \"Sample rate: %d\", data.sample_rate);\n  shell_print(sh, \"Bit width: %d\", data.bit_width);\n  shell_print(sh, \"Mic gain: %d\", data.mic_gain);\n  shell_print(sh, \"Speaker gain: %d\", data.speaker_gain);\n  shell_print(sh, \"Speaker enabled: %d\", data.speaker_en);\n\n  return 0;\n}", "CodeBleu_score": 48.49081564833272}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t    int ret;\n    struct device *codec_dev;\n\n    codec_dev = device_get_binding(argv[1]);\n    if (!codec_dev) {\n        LOG_ERR(\"device %s not found\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(codec_dev);\n    if (ret) {\n        LOG_ERR(\"apply properties failed: %d\", ret);\n        return ret;\n    }\n\n    return 0;\n}", "CodeBleu_score": 52.17890246741541}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t  int res;\n  struct audio_codec_dev *codec_dev;\n\n  codec_dev = get_codec_device(argv[1]);\n  if (codec_dev == NULL) {\n    shell_error(sh, \"codec device %s not found\", argv[1]);\n    return -ENODEV;\n  }\n\n  res = audio_codec_apply_properties(codec_dev);\n  if (res) {\n    shell_error(sh, \"apply properties failed %d\", res);\n    return res;\n  }\n\n  return 0;\n}", "CodeBleu_score": 51.30520462196695}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_i2s_dev_cfg *dev_cfg = dev->config;\n    const struct mpxxdtyy_i2s_cfg *cfg = dev_cfg->cfg;\n    struct mpxxdtyy_i2s_data *data = dev->data;\n    int err;\n\n    if (cmd == DMIC_TRIGGER_START) {\n        if (data->state != MPXXXXXX_I2S_STATE_CONFIGURED) {\n            LOG_ERR(\"DMIC device not in configured state\");\n            return -ENOTSUP;\n        }\n\n        err = mpxxdtyy_i2s_send_cmd(dev, MPXXXXXX_I2S_CMD_START);\n        if (err) {\n            LOG_ERR(\"Failed to send start command\");\n            return err;\n        }\n\n        data->state = MPXXXXXX_I2S_STATE_ACTIVE;\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        if (data->state != MPXXXXXX_I2S_STATE_ACTIVE) {\n            LOG_ERR(\"DMIC device not in active state\");\n            return -ENOTSUP;\n        }\n\n        err = mpxxdtyy_i2s_send_cmd(dev, MPXXXXXX_I2S_CMD_STOP);\n        if (err) {\n            LOG_ERR(\"Failed to send stop command\");\n            return err;\n        }\n\n        data->state = MPXXXXXX_I2S_STATE_CONFIGURED;\n    } else {\n        LOG_ERR(\"Unsupported DMIC trigger command\");\n        return -ENOTSUP;\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.25652023415754}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    const struct mpxxdtyy_config *config = dev->config;\n    struct mpxxdtyy_data *data = dev->data;\n    int err = 0;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != DMIC_STATE_CONFIGURED) {\n                LOG_ERR(\"DMIC device not configured\");\n                return -ENOTSUP;\n            }\n            err = mpxxdtyy_i2s_cmd_set(dev, config->i2s_cmd_start);\n            if (err) {\n                LOG_ERR(\"Failed to set I2S command\");\n                return err;\n            }\n            data->state = DMIC_STATE_ACTIVE;\n            break;\n        case DMIC_TRIGGER_STOP:\n            if (data->state != DMIC_STATE_ACTIVE) {\n                LOG_ERR(\"DMIC device not active\");\n                return -ENOTSUP;\n            }\n            err = mpxxdtyy_i2s_cmd_set(dev, config->i2s_cmd_stop);\n            if (err) {\n                LOG_ERR(\"Failed to set I2S command\");\n                return err;\n            }\n            data->state = DMIC_STATE_CONFIGURED;\n            break;\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command\");\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 55.25282696390268}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t    struct mpxxdtyy_dmic_data *data = dev->data;\n    int ret;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != DMIC_STATE_CONFIGURED) {\n                LOG_ERR(\"DMIC device not in configured state\");\n                return -EINVAL;\n            }\n\n            ret = mpxxdtyy_i2s_send_cmd(dev, MPXxDtYY_I2S_CMD_START);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send start command\");\n                return ret;\n            }\n\n            data->state = DMIC_STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state != DMIC_STATE_ACTIVE) {\n                LOG_ERR(\"DMIC device not in active state\");\n                return -EINVAL;\n            }\n\n            ret = mpxxdtyy_i2s_send_cmd(dev, MPXxDtYY_I2S_CMD_STOP);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send stop command\");\n                return ret;\n            }\n\n            data->state = DMIC_STATE_CONFIGURED;\n            break;\n\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command\");\n            return -EINVAL;\n    }\n\n    return 0;\n}", "CodeBleu_score": 54.95838472904337}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t}\n\n\tif (config->cursor_position) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_POSITION;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 70.18791849500813}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_ON;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 72.66726784712534}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\t\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_DISPLAY_MODE_COMMAND;\n\n\tif (config->cursor) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR;\n\t}\n\n\tif (config->blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_BLINK;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_ENABLED;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 70.07822622024591}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_port) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get(config->busy_port, config->busy_pin);\n}", "CodeBleu_score": 42.30828837867442}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n    if (!config->busy_port) {\n        return -ENOTSUP;\n    }\n    return gpio_pin_get_dt(&config->busy_port);\n}", "CodeBleu_score": 44.936919717537585}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (config->busy_gpio.port == NULL) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get(config->busy_gpio.port, config->busy_gpio.pin);\n}", "CodeBleu_score": 76.06081306180677}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c, buf, sizeof(buf), config->i2c_address);\n}", "CodeBleu_score": 60.616940723114574}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c_master, &config->i2c_slave_addr, buf, sizeof(buf),\n\t\t\t  config->i2c_flags);\n}", "CodeBleu_score": 62.15675888756831}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[AUXDISPLAY_SERLCD_SPECIAL_COMMAND_LENGTH];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c_master, buf, sizeof(buf), config->i2c_slave_address);\n}", "CodeBleu_score": 62.38231115575672}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tconst struct bbram_emul_data *data = dev->data;\n\n\tif (size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset > data->size - size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &data->mem[offset], size);\n\treturn 0;\n}", "CodeBleu_score": 53.66502051973768}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\tsize_t len = data->size;\n\n\tif (offset + size > len) {\n\t\tLOG_ERR(\"Invalid read size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid read\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data->mem + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 63.20476520151131}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\tsize_t end = offset + size;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (end > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, data->mem + offset, size);\n\treturn 0;\n}", "CodeBleu_score": 65.15128785357223}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\tsize_t available_size = data->size - offset;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > available_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data->buffer + offset, data, size);\n\treturn 0;\n}", "CodeBleu_score": 64.75267497853206}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size != 1 && size != 2 && size != 4) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&data->mem[offset], data, size);\n\treturn 0;\n}", "CodeBleu_score": 55.80514181384826}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *data = dev->data;\n\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\tif (offset + size > data->size) {\n\t\treturn -EMSGSIZE;\n\t}\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&data->data[offset], data, size);\n\treturn 0;\n}", "CodeBleu_score": 57.43257412880314}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!(*bbram_dev)) {\n\t\tshell_error(sh, \"Device \\\"%s\\\" not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.50352689983417}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tARG_UNUSED(sh);\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 85.99816256766685}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tARG_UNUSED(sh);\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing BBRAM device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"BBRAM device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 86.19504900721726}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t    uint32_t bytes_read;\n    uint32_t remaining_bytes;\n\n    bytes_read = h4_hdr_bytes_read;\n    remaining_bytes = h4_hdr_bytes_remaining;\n\n    if (uart_poll_in(dev, h4_hdr_buf + bytes_read) != 0) {\n        LOG_ERR(\"H4 header read error\");\n        return;\n    }\n\n    remaining_bytes -= H4_HDR_SIZE - bytes_read;\n    h4_hdr_bytes_read += H4_HDR_SIZE - bytes_read;\n\n    if (remaining_bytes == 0) {\n        h4_hdr_bytes_read = 0;\n        h4_hdr_bytes_remaining = H4_HDR_SIZE;\n    } else {\n        h4_hdr_bytes_remaining = remaining_bytes;\n    }\n}", "CodeBleu_score": 36.40767157648055}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t  const uint8_t *rx_buf = (const uint8_t *)dev->config->rx_buf;\n  const uint8_t *hdr_buf = (const uint8_t *)dev->config->hdr_buf;\n  size_t hdr_size = dev->config->hdr_size;\n  size_t rx_size = dev->config->rx_size;\n  size_t rx_count = dev->config->rx_count;\n  size_t rx_remaining = rx_size - rx_count;\n  size_t hdr_remaining = hdr_size - rx_count;\n  size_t read_count;\n\n  if (hdr_remaining > rx_remaining) {\n    hdr_remaining = rx_remaining;\n  }\n\n  if (hdr_remaining > 0) {\n    read_count = uart_rx_buf_rsize(dev);\n    if (read_count > hdr_remaining) {\n      read_count = hdr_remaining;\n    }\n    if (read_count > 0) {\n      memcpy(&hdr_buf[rx_count], &rx_buf[rx_count], read_count);\n      dev->config->rx_count += read_count;\n      hdr_remaining -= read_count;\n    }\n  }\n\n  if (hdr_remaining > 0) {\n    LOG_ERR(\"Failed to read header data from UART device\");\n  }\n}", "CodeBleu_score": 44.65586181403736}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t  uint8_t rx_data[H4_HDR_LEN];\n  uint8_t hdr_bytes_read = h4_hdr_buf.len - h4_hdr_buf.rem;\n  int ret;\n\n  ret = uart_rx_enable(dev, rx_data, H4_HDR_LEN - hdr_bytes_read, SYS_FOREVER_MS);\n  if (ret < 0) {\n    LOG_ERR(\"Error reading header from UART: %d\", ret);\n    return;\n  }\n\n  h4_hdr_buf.rem -= ret;\n  if (h4_hdr_buf.rem == 0) {\n    h4_hdr_buf.rem = H4_HDR_LEN;\n    h4_hdr_buf.len = H4_HDR_LEN;\n    h4_hdr_buf.pos = 0;\n  }\n}", "CodeBleu_score": 45.24727565923127}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t ret = 0;\n\n    while (len) {\n        size_t read_len = MIN(len, sizeof(buf));\n        int err = uart_fifo_read(uart, buf, read_len);\n\n        if (err) {\n            LOG_ERR(\"uart_fifo_read error: %d\", err);\n            break;\n        }\n\n        ret += read_len;\n        len -= read_len;\n    }\n\n    return ret;\n}", "CodeBleu_score": 44.80856208162035}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t i;\n    int err;\n\n    for (i = 0; i < len; i += 32) {\n        err = uart_fifo_read(uart, buf, MIN(len - i, sizeof(buf)));\n        if (err) {\n            LOG_ERR(\"Failed to read uart fifo (err %d)\", err);\n            return 0;\n        }\n    }\n\n    return i;\n}", "CodeBleu_score": 49.586448572819684}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t    uint8_t buf[33];\n    size_t ret;\n\n    ret = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n    if (ret == 0) {\n        LOG_ERR(\"uart_fifo_read failed\");\n    }\n    return ret;\n}", "CodeBleu_score": 53.60874364909171}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    int hop = INT_MAX;\n    struct zbus_observer *observer;\n\n    spin_lock(&chan->lock);\n    list_for_each_entry(observer, &chan->observers, list) {\n        if (observer->priority < hop && observer->enabled)\n            hop = observer->priority;\n    }\n    chan->highest_observer_priority = hop;\n    spin_unlock(&chan->lock);\n}", "CodeBleu_score": 16.34064194898785}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    int hop = -1;\n    struct zbus_observer *obs;\n\n    spin_lock(&chan->lock);\n    list_for_each_entry(obs, &chan->observers, list) {\n        if (obs->priority < hop && obs->enabled) {\n            hop = obs->priority;\n        }\n    }\n    spin_unlock(&chan->lock);\n\n    chan->highest_observer_priority = hop;\n}", "CodeBleu_score": 15.314841176882682}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t    uint32_t highest_priority = 0;\n\n    zbus_lock(&chan->lock);\n    struct zbus_observer *observer = chan->observers;\n    while (observer) {\n        if (observer->priority < highest_priority && observer->enabled) {\n            highest_priority = observer->priority;\n        }\n        observer = observer->next;\n    }\n    chan->highest_observer_priority = highest_priority;\n    zbus_unlock(&chan->lock);\n}", "CodeBleu_score": 22.31392805479997}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = _zbus_chan_observations_end_idx;\n\n\t\tfor (int16_t i = _zbus_chan_observations_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs && !observation_mask->enabled) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 20.637568117850535}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tfor (int16_t i = 0; i < _zbus_chan_observation_count; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.95194846873477}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\t\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = zbus_chan_observation_size();\n\n\t\tfor (int16_t i = 0; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs || !observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.858619653024387}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t__ASSERT_NO_MSG(!k_is_in_isr());\n\t__ASSERT_NO_MSG(obs != NULL);\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_observer_lock);\n\n\tobs->priority = K_LOWEST_APPLICATION_THREAD_PRIO;\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_observer_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 51.366594545696174}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t__ASSERT(!in_isr(), \"zbus_obs_attach_from_thread() cannot be called from an ISR\");\n\t__ASSERT(obs != NULL, \"zbus_obs_attach_from_thread() cannot be called with NULL observer\");\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\n\tupdate_all_channels_hop(obs);\n\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 57.12922280570617}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\t\t__ASSERT(!in_isr(), \"Cannot attach observer in ISR\");\n\t__ASSERT(obs != NULL, \"Cannot attach NULL observer\");\n\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tobs->priority = K_MIN_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&zbus_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 58.78407334323021}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\n\tint prio;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 50.562569815136584}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tk_timepoint_t end_time = sys_timepoint_calc(timeout);\n\tint prio = 0;\n\tint err;\n\n\tZBUS_ASSERT(chan != NULL, \"chan must not be NULL\");\n\n\tif (k_is_in_isr()) {\n\t\tend_time = sys_timepoint_timeout(end_time);\n\t}\n\n\tLOG_DBG(\"Notifying %s\", _ZBUS_CHAN_NAME(chan));\n\n\terr = chan_lock(chan, sys_timepoint_timeout(end_time), &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 63.37092849144999}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t\tint err = 0;\n\tint prio = 0;\n\tk_timepoint_t end_time;\n\n\t_ZBUS_ASSERT(chan != NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tend_time = sys_timepoint_calc(timeout);\n\n\terr = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 59.64166102719835}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t    uint32_t temp;\n    uint32_t mask;\n\n    /* Check the parameters */\n    assert_param(IS_ETH_GET_IT(Int));\n\n    if (enable) {\n        if (Int & 0x00000001) {\n            /* Enable the normal interrupts */\n            ETH->DMASR |= Int;\n        } else {\n            /* Enable the abnormal interrupts */\n            ETH->DMASR |= Int << 16;\n        }\n    } else {\n        if (Int & 0x00000001) {\n            /* Disable the selected normal interrupts */\n            mask = Int & ETH->DMASR;\n            ETH->DMASR &= ~mask;\n        } else {\n            /* Disable the selected abnormal interrupts */\n            mask = Int & ETH->DMASR;\n            ETH->DMASR &= ~mask;\n        }\n    }\n}", "CodeBleu_score": 42.9589981325078}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *tx_desc = ETH_GetTxDesc();\n    ETH_TX_DESC *start_tx_desc = tx_desc;\n\n    do {\n        if (!ETH_IsTxDescOwnedByDma(tx_desc)) {\n            return tx_desc;\n        }\n\n        tx_desc = ETH_GetNextTxDesc(tx_desc);\n    } while (tx_desc != start_tx_desc);\n\n    return 0;\n}", "CodeBleu_score": 43.796410402496804}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t txDescAddr;\n\n    txDescAddr = ETH->DMADSCADDR;\n\n    while (1) {\n        txDesc = (ETH_TX_DESC *)txDescAddr;\n\n        if (txDesc->OWN == 0) {\n            return txDesc;\n        }\n\n        txDescAddr = txDesc->NXTDESC;\n\n        if (txDescAddr == ETH->DMADSCADDR) {\n            return 0;\n        }\n    }\n}", "CodeBleu_score": 50.67719813704177}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t    ETH_TX_DESC *txDesc;\n    uint32_t i;\n\n    txDesc = ETH_GetTxDesc();\n\n    for (i = 0; i < ETH_TX_DESC_NUM; i++) {\n        if (txDesc->status & ETH_TX_DESC_OWN) {\n            txDesc++;\n            if (txDesc == (ETH_TX_DESC *) ETH_TX_DESC_END_ADDR) {\n                txDesc = (ETH_TX_DESC *) ETH_TX_DESC_START_ADDR;\n            }\n        } else {\n            return txDesc;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 49.32093382751647}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (device == RT_NULL) {\n        rt_kprintf(\"dac device is null\n\");\n        return -RT_ERROR;\n    }\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS) {\n        rt_kprintf(\"Cy_CSDIDAC_OutputEnable failed\n\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 55.74911617768827}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_err_t result;\n    rt_uint32_t cyp_dac_channel;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    result = Cy_CSDIDAC_OutputEnable(device->hw_obj, cyp_dac_channel, *value);\n    if (result != RT_EOK) {\n        rt_kprintf(\"Failed to enable DAC output for channel %d\n\", channel);\n        return result;\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 67.44654008786466}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t    rt_uint32_t cyp_dac_channel = 0;\n    rt_err_t result = RT_EOK;\n\n    RT_ASSERT(device != RT_NULL);\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (Cy_CSDIDAC_OutputEnable(device->user_data, cyp_dac_channel, *value) != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Failed to enable DAC output\n\");\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 58.34223798529283}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i;\n    rt_uint32_t end_addr;\n\n    if (addr + size > FLASH_END_ADDRESS) {\n        rt_kprintf(\"read outrange flash size\n\");\n        return -RT_EINVAL;\n    }\n\n    end_addr = addr + size;\n    for (i = 0; i < size; i += 4) {\n        *(rt_uint32_t *) (buf + i) = *(rt_uint32_t *) addr;\n        addr += 4;\n    }\n\n    return size;\n}", "CodeBleu_score": 52.69439329676266}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i = 0;\n    rt_uint32_t *p = (rt_uint32_t *)buf;\n\n    if (addr + size > FLASH_END_ADDRESS) {\n        rt_kprintf(\"ERROR: read flash out of range!!!\n\");\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size / 4; i++) {\n        *(p + i) = *(__IO rt_uint32_t *)(addr + i * 4);\n    }\n\n    return i * 4;\n}", "CodeBleu_score": 50.47751399174992}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t    int i;\n    rt_uint32_t end_addr;\n    rt_uint32_t *p = (rt_uint32_t *)buf;\n\n    if (addr + size > FLASH_SIZE) {\n        rt_kprintf(\"read addr 0x%x, size 0x%x is out of flash range\n\", addr, size);\n        return -RT_EINVAL;\n    }\n\n    end_addr = addr + size;\n    for (i = 0; i < size; i += 4, p++) {\n        *p = *(rt_uint32_t *)(FLASH_START_ADRESS + addr);\n        addr += 4;\n    }\n\n    return size;\n}", "CodeBleu_score": 52.647003563358155}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 31.751041619710936}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 31.751041619710936}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->priv;\n    return cyhal_timer_read(obj);\n}", "CodeBleu_score": 26.99729535138733}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t    int ret = pthread_mutex_lock(&dfs_lock_mutex);\n    assert(ret == 0);\n}", "CodeBleu_score": 6.178391546684704}, {"code": "void dfs_lock(void){\n\t    int err = pthread_mutex_lock(&dfs_mutex);\n    if (err != 0) {\n        if (err == EBUSY) {\n            /*\n             * The mutex is busy.\n             * This indicates a deadlock, so trigger an assertion failure.\n             */\n            panic(\"dfs_lock: deadlock detected\");\n        } else {\n            /*\n             * The mutex locking failed for some other reason.\n             * Trigger an assertion failure.\n             */\n            panic(\"dfs_lock: pthread_mutex_lock failed (%s)\", strerror(err));\n        }\n    }\n}", "CodeBleu_score": 21.927197911335348}, {"code": "void dfs_lock(void){\n\t    int ret = pthread_mutex_lock(&dfs_mutex);\n    if (ret != 0) {\n        if (ret == EBUSY) {\n            /*\n             * The mutex is already locked.\n             */\n            panic(\"dfs_lock: mutex is already locked\");\n        } else {\n            /*\n             * An unexpected error occurred.\n             */\n            panic(\"dfs_lock: unexpected error\");\n        }\n    }\n}", "CodeBleu_score": 23.408567469991098}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int fd;\n    int index;\n    struct dfs_file **fds;\n\n    /* search for an empty slot starting from the specified index */\n    fds = fdt->fds;\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* if no empty slot is found, try to expand the fd table */\n    fd = fd_slot_expand(fdt, fdt->maxfd);\n    if (fd < 0) {\n        return -1;\n    }\n\n    return fd;\n}", "CodeBleu_score": 45.8334415532611}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n\n    /* Search for an empty slot starting from the specified index */\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            return index;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table */\n    if (fd_slot_expand(fdt, fdt->maxfd) < 0) {\n        return -1;\n    }\n\n    /* Recursively call fd_slot_alloc to find an empty slot in the expanded table */\n    return fd_slot_alloc(fdt, fdt->maxfd);\n}", "CodeBleu_score": 44.65859038053869}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t    int index;\n    int fd;\n\n    if (fdt->maxfd == 0) {\n        return -1;\n    }\n\n    for (index = startfd; index < fdt->maxfd; index++) {\n        if (fdt->fds[index] == NULL) {\n            break;\n        }\n    }\n\n    if (index >= fdt->maxfd) {\n        fd = fd_slot_expand(fdt, index);\n        if (fd < 0) {\n            return -1;\n        }\n    } else {\n        fd = index;\n    }\n\n    return fd;\n}", "CodeBleu_score": 47.051883090917606}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t    int i;\n    int error_code = error;\n\n    if (error_code < 0) {\n        error_code = -error_code;\n    }\n\n    for (i = 0; i < sizeof(rt_errors) / sizeof(rt_errors[0]); i++) {\n        if (rt_errors[i].code == error_code) {\n            return rt_errors[i].message;\n        }\n    }\n\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 61.62056252406715}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(rt_errlist) / sizeof(rt_errlist[0]); i++) {\n        if (rt_errlist[i].err_code == error) {\n            return rt_errlist[i].err_str;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.17138816501067}, {"code": "const char *rt_strerror(rt_err_t error){\n\t    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(rt_errors) / sizeof(rt_errors[0]); i++) {\n        if (rt_errors[i].code == error) {\n            return rt_errors[i].message;\n        }\n    }\n    return \"EUNKNOW\";\n}", "CodeBleu_score": 65.2051863561066}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_uint32_t level;\n    rt_uint32_t i;\n\n    level = rt_hw_interrupt_disable();\n\n    /* find a empty slot */\n    for (i = 0; i < RT_THREAD_HOOK_MAX; i++) {\n        if (idle_hook[i] == RT_NULL) {\n            idle_hook[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* no empty slot */\n    if (i == RT_THREAD_HOOK_MAX) {\n        result = -RT_EFULL;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 67.36654724794361}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_base_t level;\n    rt_uint8_t i;\n\n    result = -RT_EFULL;\n    level = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_THREAD_HOOK_MAX; i++) {\n        if (rt_thread_idle_hook[i] == RT_NULL) {\n            rt_thread_idle_hook[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n    return result;\n}", "CodeBleu_score": 64.27909683085251}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t    rt_err_t result;\n    rt_uint8_t i;\n    rt_spinlock_t *lock;\n    void (*old_hook)(void);\n\n    lock = &rt_thread_idle_sethook_lock;\n    result = RT_EOK;\n    if (hook == ((void*)0)) {\n        return -RT_EINVAL;\n    }\n    rt_spin_lock(lock);\n    for (i = 0; i < RT_THREAD_HOOK_MAX; i++) {\n        if (rt_thread_idle_sethook_list[i] == ((void*)0)) {\n            old_hook = rt_thread_idle_sethook_list[i];\n            rt_thread_idle_sethook_list[i] = hook;\n            break;\n        }\n    }\n    if (i == RT_THREAD_HOOK_MAX) {\n        result = -RT_EFULL;\n    }\n    rt_spin_unlock(lock);\n    return result;\n}", "CodeBleu_score": 53.89366981463319}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t level;\n    struct rt_thread_idle_hook *node;\n\n    level = rt_hw_interrupt_disable();\n    node = rt_thread_idle_hook_list;\n    while (node) {\n        if (node->hook == hook) {\n            node->hook = RT_NULL;\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n        node = node->next;\n    }\n    rt_hw_interrupt_enable(level);\n    return -RT_ERROR;\n}", "CodeBleu_score": 43.39359475500238}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_base_t level;\n    rt_list_t *node;\n\n    /* parameter check */\n    if (hook == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    level = rt_hw_interrupt_disable();\n\n    /* find the hook in the idle hook list */\n    node = rt_list_find(&idle_hook_list, (void *) hook);\n    if (node != RT_NULL) {\n        rt_list_remove(&idle_hook_list, node);\n        rt_hw_interrupt_enable(level);\n        return RT_EOK;\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 34.05150876398089}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t    rt_err_t result = RT_ERROR;\n    rt_uint32_t i;\n    rt_thread_idle_hook_t *idle_hook;\n\n    /* lock the spinlock to ensure thread safety */\n    rt_spin_lock(&rt_thread_idle_hook_lock);\n\n    /* iterate through the idle hook list */\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n        idle_hook = &rt_thread_idle_hook[i];\n\n        /* check if the hook is found */\n        if (idle_hook->hook == hook) {\n            /* set the corresponding entry to null */\n            idle_hook->hook = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* unlock the spinlock */\n    rt_spin_unlock(&rt_thread_idle_hook_lock);\n\n    /* return the result */\n    return result;\n}", "CodeBleu_score": 55.11979280212119}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_thread_t thread;\n    RT_ASSERT(susp_list != RT_NULL);\n    rt_enter_critical();\n    while (rt_list_isempty(susp_list) != RT_TRUE) {\n        thread = rt_list_entry(rt_list_first(susp_list), struct rt_thread, tlist);\n        rt_list_remove(&(thread->tlist));\n        thread->error = thread_error;\n        rt_thread_resume(thread);\n    }\n    rt_exit_critical();\n    return RT_EOK;\n}", "CodeBleu_score": 32.945154202246464}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t result = RT_EOK;\n    rt_thread_t thread;\n\n    /* Ensure the scheduler is unlocked */\n    rt_enter_critical();\n\n    /* Dequeue and wake up each suspended thread from the list */\n    while (rt_list_isempty(susp_list) != RT_TRUE) {\n        thread = rt_list_entry(rt_list_get_first(susp_list), struct rt_thread, tlist);\n        result = rt_thread_resume_from_list(thread, thread_error);\n        if (result != RT_EOK) {\n            break;\n        }\n    }\n\n    /* Release the scheduler lock */\n    rt_exit_critical();\n\n    return result;\n}", "CodeBleu_score": 41.568045234492914}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t    rt_err_t result = RT_EOK;\n\n    /* Ensure the scheduler is unlocked */\n    rt_sched_lock();\n\n    /* Dequeue and resume each suspended thread from the list */\n    while (!rt_list_isempty(susp_list)) {\n        rt_thread_t *thread = rt_list_entry(rt_list_get_first(susp_list), struct rt_thread, tlist);\n        rt_list_remove(&thread->tlist);\n        result = rt_thread_resume_from_suspend(thread, thread_error);\n        if (result != RT_EOK) {\n            break;\n        }\n    }\n\n    /* Restore the scheduler lock */\n    rt_sched_unlock();\n\n    return result;\n}", "CodeBleu_score": 39.916690112794086}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = rt_console_get_device();\n\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n    }\n\n    rt_device_t new_console = rt_device_find(name);\n    if (new_console != RT_NULL) {\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        rt_console_set_device(new_console);\n    }\n\n    return old_console;\n}", "CodeBleu_score": 44.33585102146219}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_device;\n    rt_device_t new_device;\n    rt_device_t console_device;\n    old_device = rt_console_get_device();\n    new_device = rt_device_find(name);\n    if (new_device != RT_NULL && new_device != old_device) {\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n        console_device = rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        if (console_device != RT_NULL) {\n            rt_console_set_device(console_device);\n        }\n    }\n    return old_device;\n}", "CodeBleu_score": 59.21796764299756}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t    rt_device_t old_console = rt_console_get_device();\n    rt_device_t new_console = rt_device_find(name);\n\n    if (new_console != old_console) {\n        if (old_console != RT_NULL) {\n            rt_device_close(old_console);\n        }\n\n        if (new_console != RT_NULL) {\n            rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n            rt_console_set_device(new_console);\n        }\n    }\n\n    return old_console;\n}", "CodeBleu_score": 52.90696937606205}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object_information *info;\n\n    /* Get information about the object class type */\n    info = rt_object_get_information(type);\n    if (!info) {\n        return -1;\n    }\n\n    /* Lock the spinlock to ensure thread safety */\n    rt_spinlock_lock(&info->lock);\n\n    /* Iterate through the object list, counting the number of objects */\n    struct rt_object *object = info->object_list;\n    while (object) {\n        count++;\n        object = object->list.next;\n    }\n\n    /* Release the spinlock */\n    rt_spinlock_unlock(&info->lock);\n\n    return count;\n}", "CodeBleu_score": 39.87363838066819}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t    int count = 0;\n    struct rt_object *obj = NULL;\n    struct rt_object_information *obj_info = NULL;\n    rt_spinlock_t *lock = NULL;\n\n    obj_info = rt_object_get_information(type);\n    if (obj_info == NULL) {\n        return 0;\n    }\n\n    lock = &(obj_info->object_lock);\n\n    /* enter critical */\n    rt_spin_lock(lock);\n\n    /* iterate all object */\n    rt_list_for_each_entry(obj, &(obj_info->object_list), list)\n    {\n        count++;\n    }\n\n    /* leave critical */\n    rt_spin_unlock(lock);\n\n    return count;\n}", "CodeBleu_score": 48.90145753155613}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t", "CodeBleu_score": 2.4407600714820052}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t    rt_object_information_t info;\n    rt_err_t result;\n\n    /* parameter check */\n    if (object == RT_NULL) {\n        return;\n    }\n\n    /* get object information */\n    info = object->information;\n\n    /* lock object */\n    rt_spinlock_lock(&info->lock);\n\n    /* remove object from list */\n    rt_list_remove(&info->object_list, &object->list);\n\n    /* unlock object */\n    rt_spinlock_unlock(&info->lock);\n\n    /* set object type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 33.507316774045734}, {"code": "void rt_object_detach(rt_object_t object){\n\t\n    if (object == RT_NULL) {\n        return;\n    }\n\n    rt_object_detach_hook(object);\n\n    struct rt_object_information *information = object->information;\n    rt_spinlock_t *lock = &information->lock;\n\n    rt_spinlock_lock(lock);\n\n    rt_list_remove(&information->object_list, &object->list);\n\n    rt_spinlock_unlock(lock);\n\n    object->type = 0;\n}", "CodeBleu_score": 33.5610093610744}, {"code": "void rt_object_detach(rt_object_t object){\n\t    RT_ASSERT(object != RT_NULL);\n    object->hooks->detach(object);\n    rt_object_information_t info = object->information;\n    rt_spinlock_t *lock = &(info->lock);\n    rt_base_t level;\n    rt_err_t result;\n    level = rt_hw_interrupt_disable();\n    result = rt_spinlock_take(lock);\n    if (result == RT_EOK) {\n        rt_list_remove(&(info->object_list));\n        rt_spinlock_release(lock);\n        object->type = 0;\n    }\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 49.50856111581244}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n    /* get the object information */\n    struct rt_object_information *information = rt_object_get_information(RT_Object_Class_Custom);\n    RT_ASSERT(information != RT_NULL);\n\n    /* lock the object list */\n    rt_base_t level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* check if the object is in the list */\n    if (rt_list_find(&(information->object_list), &(obj->list)) == RT_NULL) {\n        result = -RT_ERROR;\n    } else {\n        /* call the destroy method if it exists */\n        if (obj->destroy != RT_NULL) {\n            result = obj->destroy(obj);\n        } else {\n            result = RT_EOK;\n        }\n\n        /* delete the object */\n        rt_object_delete(obj);\n    }\n\n    /* unlock the object list */\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    return result;\n}", "CodeBleu_score": 46.40882473931312}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result;\n    rt_custom_object_t custom_obj;\n\n    /* parameter check */\n    RT_ASSERT(obj != RT_NULL);\n\n    /* object type check */\n    RT_ASSERT(obj->type & RT_Object_Class_Custom);\n\n    /* get the custom object */\n    custom_obj = (rt_custom_object_t)obj;\n\n    /* call the destroy function if it exists */\n    if (custom_obj->destroy != RT_NULL) {\n        result = custom_obj->destroy(custom_obj);\n    } else {\n        result = RT_EOK;\n    }\n\n    /* delete the object */\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 49.290040602399884}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\t    rt_err_t result = RT_EOK;\n    struct rt_custom_object *object;\n\n    /* parameter check */\n    RT_ASSERT(obj != RT_NULL);\n\n    /* get the object */\n    object = (struct rt_custom_object *)obj;\n\n    /* object check */\n    RT_ASSERT(object->parent.type & RT_Object_Class_Custom);\n\n    /* call object destroy */\n    if (object->destroy != RT_NULL) {\n        result = object->destroy(object);\n    }\n\n    /* delete object */\n    rt_object_delete(&(object->parent));\n\n    return result;\n}", "CodeBleu_score": 55.418149708890226}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_sched_lock_level_t slvl;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_sched_lock(&slvl);\n\n    /* close current thread */\n    rt_sched_thread_close(thread);\n\n    /* add thread to defunct list */\n    rt_sched_thread_add_defunct(thread);\n\n    /* exit critical section */\n    rt_sched_unlock(slvl);\n\n    /* trigger context switch */\n    rt_sched_yield();\n}", "CodeBleu_score": 61.736461477621795}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread;\n    rt_sched_lock_level_t slvl;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* enter critical section */\n    rt_sched_lock(&slvl);\n\n    /* close current thread */\n    rt_sched_thread_close(thread);\n\n    /* add current thread to defunct thread list */\n    rt_list_insert_after(&(rt_thread_defunct_list), &(thread->tlist));\n\n    /* exit critical section */\n    rt_sched_unlock(slvl);\n\n    /* trigger context switch */\n    rt_sched_yield();\n}", "CodeBleu_score": 37.19101123253142}, {"code": "static void _thread_exit(void){\n\t    rt_thread_t thread = rt_thread_self();\n    rt_sched_lock_level_t slvl;\n\n    /* enter critical section */\n    rt_sched_lock(&slvl);\n\n    /* close thread */\n    rt_sched_thread_close(thread);\n\n    /* add thread to defunct thread list */\n    rt_sched_add_defunct(thread);\n\n    /* leave critical section */\n    rt_sched_unlock(slvl);\n\n    /* trigger context switch */\n    rt_sched_yield();\n}", "CodeBleu_score": 56.9176641708983}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t    thread_t *thread = (thread_t *)parameter;\n\n    if (thread == NULL) {\n        return;\n    }\n\n    _scheduler_lock();\n\n    if (thread->status != SUSPENDED) {\n        _scheduler_unlock();\n        return;\n    }\n\n    thread->error = ETIMEOUT;\n\n    _list_remove(&_suspended_threads, thread);\n    _list_insert(&_ready_threads, thread);\n\n    _scheduler_unlock();\n}", "CodeBleu_score": 33.183223739855585}, {"code": "static void _thread_timeout(void *parameter){\n\t    thread_t *thread;\n\n    /* Check parameter validity */\n    if (parameter == NULL) {\n        return;\n    }\n\n    thread = (thread_t *)parameter;\n\n    /* Lock the scheduler */\n    scheduler_lock();\n\n    /* Verify the thread is suspended */\n    if (thread->state != THREAD_SUSPENDED) {\n        scheduler_unlock();\n        return;\n    }\n\n    /* Set the thread's error number to a timeout value */\n    thread->error_number = ETIMEOUT;\n\n    /* Remove the thread from the suspend list */\n    list_remove(&thread->list);\n\n    /* Insert the thread into the ready list */\n    list_insert_after(&thread->list, &ready_list);\n\n    /* Unlock the scheduler to reschedule */\n    scheduler_unlock();\n}", "CodeBleu_score": 32.51478786080653}, {"code": "static void _thread_timeout(void *parameter){\n\t  thread_t *thread = (thread_t *)parameter;\n\n  if (thread == NULL) {\n    return;\n  }\n\n  if (thread->state != THREAD_SUSPENDED) {\n    return;\n  }\n\n  thread->error_code = ERROR_THREAD_TIMEOUT;\n\n  _thread_suspend_remove(thread);\n  _thread_ready_insert(thread);\n}", "CodeBleu_score": 32.530253148105885}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_err_t result = RT_EOK;\n    rt_mutex_t mutex;\n    rt_list_t *node;\n\n    /* lock thread spinlock */\n    rt_hw_spin_lock(&thread->spinlock);\n\n    /* check if the thread is waiting on a mutex */\n    if (thread->wait_obj != RT_NULL) {\n        /* get the mutex object */\n        mutex = (rt_mutex_t)thread->wait_obj;\n\n        /* remove the thread from the mutex's waiting list */\n        node = rt_list_find(&mutex->wait_list, &thread->tlist);\n        if (node != RT_NULL) {\n            rt_list_remove(node);\n        }\n\n        /* clear the pending object */\n        thread->wait_obj = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    result = rt_mutex_release_all(thread);\n\n    /* restore the spinlock state */\n    rt_hw_spin_unlock(&thread->spinlock);\n}", "CodeBleu_score": 34.126211443156315}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    /* Lock the thread's spinlock */\n    rt_base_t level;\n    rt_hw_spin_lock(&thread->spinlock);\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->wait_obj != RT_NULL) {\n        /* Remove the thread from the mutex's waiting list */\n        rt_mutex_t mutex = (rt_mutex_t)thread->wait_obj;\n        rt_list_remove(&mutex->owner_list, &thread->tlist);\n\n        /* Clear the pending object */\n        thread->wait_obj = RT_NULL;\n    }\n\n    /* Release all mutexes the thread has taken */\n    rt_list_t *list = &thread->mutex_list;\n    rt_list_t *node = list->next;\n    while (node != list) {\n        rt_mutex_t mutex = rt_list_entry(node, struct rt_mutex, owner_list);\n        node = node->next;\n        rt_mutex_release(mutex);\n    }\n\n    /* Restore the spinlock state */\n    level = rt_hw_spin_unlock(&thread->spinlock);\n}", "CodeBleu_score": 47.554094341062935}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t    rt_mutex_t mutex;\n    rt_uint8_t level;\n    rt_base_t lock;\n\n    level = rt_hw_interrupt_disable();\n\n    lock = rt_thread_spin_lock(thread);\n    mutex = thread->wait_mutex;\n    if (mutex != RT_NULL) {\n        rt_mutex_remove_thread(mutex, thread);\n        thread->wait_mutex = RT_NULL;\n    }\n    rt_thread_spin_unlock(thread, lock);\n\n    rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 29.220116857660944}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* check thread state */\n    RT_ASSERT(thread->parent.stat == RT_THREAD_INIT);\n\n    rt_sched_lock(&slvl);\n\n    /* calculate thread priority attributes */\n    thread->priority_attr = thread->parent.priority;\n    thread->priority_attr.priority = thread->parent.priority.priority;\n    thread->priority_attr.preempt_threshold = thread->parent.priority.preempt_threshold;\n    thread->priority_attr.inherit_priority = thread->parent.priority.inherit_priority;\n\n    /* reset thread state */\n    thread->parent.stat = RT_THREAD_SUSPENDED;\n\n    error = rt_sched_thread_ready(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 49.66373452757955}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t", "CodeBleu_score": 1.899294977411007}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\t    rt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_ready(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_startup_hook, (thread));\n\n    return error;\n}", "CodeBleu_score": 51.31186223905877}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t timer;\n    rt_list_t *list;\n    rt_list_t *list_end;\n    rt_tick_t timeout;\n    rt_tick_t now;\n    rt_tick_t timeout_min;\n\n    /* get the highest level of the timer skip list */\n    list = &timer_list[TIMER_SKIP_LIST_LEVEL_MAX - 1];\n    list_end = list;\n\n    /* check if the list is empty */\n    if (list->next == list_end) {\n        return -RT_ETIMEOUT;\n    }\n\n    /* get the first timer entry */\n    timer = rt_list_entry(list->next, struct rt_timer, list);\n\n    /* set the timeout tick to the timer's timeout value */\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 56.80658317996041}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_list_t list;\n    struct rt_timer *timer;\n\n    list = timer_list[0];\n    if (list != RT_NULL) {\n        timer = rt_list_entry(list, struct rt_timer, list);\n        *timeout_tick = timer->timeout;\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 54.0071561607508}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t    rt_timer_t timer;\n    rt_list_t *list;\n\n    /* get the highest level list */\n    list = &timer_list[0];\n    if (list->next != list) {\n        /* get the first timer entry */\n        timer = rt_list_entry(list->next, struct rt_timer, list);\n        *timeout_tick = timer->timeout;\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 51.38248173889072}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for the timer */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL)\n    {\n        /* initialize timer */\n        _timer_init(timer, timeout, parameter, time, flag);\n\n        /* set the timer name */\n        rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);\n    }\n\n    return timer;\n}", "CodeBleu_score": 60.37909333079119}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for the timer */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n\n    if (timer != RT_NULL)\n    {\n        /* initialize timer */\n        _timer_init(timer, timeout, parameter, time, flag);\n\n        /* set the timer name */\n        rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);\n    }\n\n    return timer;\n}", "CodeBleu_score": 60.37909333079119}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for timer */\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL)\n    {\n        /* initialize timer */\n        _timer_init(timer, timeout, parameter, time, flag);\n\n        /* set timer name */\n        rt_object_init((rt_object_t)timer, name, RT_Object_Class_Timer);\n    }\n\n    return timer;\n}", "CodeBleu_score": 60.20923723303662}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trecorder := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 69.0311937767435}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\ta.sendNotAuthorized(res)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 46.25673769568831}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tfor key, values := range rec.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 66.34037646200859}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\t// Get the file path from the URL\n\tfilePath := req.URL.Path\n\n\t// Check if the file path is empty\n\tif filePath == \"\" {\n\t\tfilePath = \"index.html\"\n\t}\n\n\t// Read the file from the assets folder\n\tfile, err := assets.ReadFile(filePath)\n\tif err != nil {\n\t\t// If the file is not found, return a 404 error\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"404 - Not Found\"))\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension\n\tcontentType := mime.TypeByExtension(filepath.Ext(filePath))\n\tif contentType != \"\" {\n\t\tres.Header().Set(\"Content-Type\", contentType)\n\t}\n\n\t// Write the file content to the response\n\tres.Write(file)\n}", "CodeBleu_score": 40.08794957228477}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\n\tasset, err := a.assets.Get(path)\n\tif err != nil {\n\t\thttp.Error(res, \"not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch filepath.Ext(path) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t_, err = res.Write(asset)\n\tif err != nil {\n\t\thttp.Error(res, \"not found\", http.StatusNotFound)\n\t\treturn\n\t}\n}", "CodeBleu_score": 59.909714259101435}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tpath := req.URL.Path\n\tasset, err := a.Asset(path)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch filepath.Ext(path) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(asset)\n}", "CodeBleu_score": 46.91978333467883}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := mux.Vars(req)[\"robotName\"]\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(struct {\n\t\t\tError string `json:\"error\"`\n\t\t}{\"no robot found with name \" + robotName})\n\t\treturn\n\t}\n\tjson.NewEncoder(res).Encode(struct {\n\t\tConnections []string `json:\"connections\"`\n\t}{robot.Connections()})\n}", "CodeBleu_score": 28.23381879927457}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot := a.master.GetRobotByName(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"no robot was found with the specified name\"})\n\t\treturn\n\t}\n\n\tconnections := robot.GetConnections()\n\tconnectionsJSON := make([]*ConnectionJSON, 0, len(connections))\n\tfor _, connection := range connections {\n\t\tconnectionJSON := &ConnectionJSON{\n\t\t\tID:        connection.ID,\n\t\t\tType:      connection.Type,\n\t\t\tRobotName: connection.Robot.Name,\n\t\t}\n\t\tconnectionsJSON = append(connectionsJSON, connectionJSON)\n\t}\n\n\tjson.NewEncoder(res).Encode(connectionsJSON)\n}", "CodeBleu_score": 45.391578919779974}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\trobotName := mux.Vars(req)[\"robotName\"]\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, &jsonError{\n\t\t\tSuccess: false,\n\t\t\tMessage: \"No robot found with that name\",\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\n\tconnectionsJSON := make([]*jsonConnection, len(connections))\n\tfor i, c := range connections {\n\t\tconnectionsJSON[i] = &jsonConnection{\n\t\t\tName:    c.Name(),\n\t\t\tAddress: c.Address(),\n\t\t}\n\t}\n\n\ta.writeJSON(res, http.StatusOK, &jsonConnections{\n\t\tSuccess:     true,\n\t\tConnections: connectionsJSON,\n\t})\n}", "CodeBleu_score": 46.68210316469413}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgivenUser, givenPass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, givenUser) || !secureCompare(password, givenPass) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t}\n}", "CodeBleu_score": 55.8221683010101}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 48.1957216225316}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tgivenUser, givenPass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(username, givenUser) || !secureCompare(password, givenPass) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Please enter your username and password for this site\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", 401)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 50.276009985981176}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\n\t// Calculate the slope and intercept of the linear scaling transformation\n\tslope := float64(toMax-toMin) / (fromMax-fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\t// Return a function that performs the scaling and clamps the output value\n\treturn func(input float64) (value int) {\n\t\t// Calculate the scaled value\n\t\tscaled := slope*input + intercept\n\n\t\t// Clamp the scaled value within the target range\n\t\tif scaled < float64(toMin) {\n\t\t\tscaled = float64(toMin)\n\t\t} else if scaled > float64(toMax) {\n\t\t\tscaled = float64(toMax)\n\t\t}\n\n\t\t// Convert the scaled value to an integer\n\t\tvalue = int(scaled)\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.551034058710876}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 52.48219814729991}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.63205197792933}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor has been removed\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = float64(raw) / float64(a.rawMax) * a.scalingFactor\n\treturn raw, a.lastValue, nil\n}", "CodeBleu_score": 54.2946877375674}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogModeSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"analog read mode not supported by connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = float64(raw)\n\n\treturn raw, a.lastValue, nil\n}", "CodeBleu_score": 50.00499059431765}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0.0, errors.New(\"AnalogSensor has not been initialized yet\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = float64(raw) * a.scale\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 46.49002127025267}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t    m := (toMax - toMin) / float64(fromMax - fromMin)\n    n := toMin - m*float64(fromMin)\n    return func(v int) float64 {\n        return m*float64(v) + n\n    }\n}", "CodeBleu_score": 53.59453104308849}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(value int) float64 {\n\t\tscaled := m*float64(value) + n\n\t\tif scaled < toMin {\n\t\t\tscaled = toMin\n\t\t} else if scaled > toMax {\n\t\t\tscaled = toMax\n\t\t}\n\t\treturn scaled\n\t}\n}", "CodeBleu_score": 65.24774542131745}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\toutput := m*float64(input) + n\n\t\tif output < toMin {\n\t\t\toutput = toMin\n\t\t} else if output > toMax {\n\t\t\toutput = toMax\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 69.04864294591027}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, 10*time.Millisecond, 100, opts...)\n\td.name = GrovePiezoVibrationSensor\n\n\td.AddEvent(Vibration)\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t\tDefaultDriver:      gobot.NewDefaultDriver(GrovePiezoVibrationSensor, GrovePiezoVibrationSensor, a.(gobot.Connection)),\n\t}\n}", "CodeBleu_score": 56.261588058855374}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\td := NewAnalogSensorDriver(a, pin, 1000, 0, opts...)\n\td.name = \"GrovePiezoVibrationSensor\"\n\td.AddEvent(Vibration)\n\n\tif _, err := d.AddEvent(Data); err != nil {\n\t\tpanic(err)\n\t}\n\n\td.On(Data, func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), nil)\n\t\t}\n\t})\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t\tDefaultDriver:      gobot.NewDefaultDriver(\"GrovePiezoVibrationSensor\", \"GrovePiezoVibrationSensor\", a.(gobot.AdaptorInterface)),\n\t}\n}", "CodeBleu_score": 48.29643729726359}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t\tv := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 1000, 1000),\n\t\tEventer:           gobot.NewEventer(),\n\t\tpin:               pin,\n\t}\n\n\tv.AddEvent(Vibration)\n\n\tif err := v.Eventer.AddEvent(Data, v.handleVibration); err != nil {\n\t\tpanic(err)\n\t}\n\n\tv.SetName(GrovePiezoVibrationSensor)\n\n\treturn v\n}", "CodeBleu_score": 40.64162056156076}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\td.toneLock.Lock()\n\tdefer d.toneLock.Unlock()\n\n\ttonePeriod := uint64(1000000 / hz)\n\ttempo := uint64(60 / d.bpm * 1000)\n\n\td.pwm.SetEnabled(true)\n\td.pwm.SetDutyCycle(0)\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tstart := time.Now()\n\tfor time.Since(start) < time.Duration(duration*1000)*time.Millisecond {\n\t\td.pwm.SetDutyCycle(0xffff)\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\t\td.pwm.SetDutyCycle(0)\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Microsecond)\n\t}\n\n\td.pwm.SetEnabled(false)\n\n\treturn nil\n}", "CodeBleu_score": 29.44836531854499}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := uint64(1000000 / hz)\n\ttempo := uint64(60 / d.bpm * 1000000)\n\n\td.toneLock.Lock()\n\tdefer d.toneLock.Unlock()\n\n\td.toneStop = make(chan bool)\n\td.toneStopped = make(chan bool)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(time.Duration(tempo) * time.Microsecond):\n\t\t\t\td.Toggle()\n\t\t\tcase <-d.toneStop:\n\t\t\t\td.Halt()\n\t\t\t\td.toneStopped <- true\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-time.After(time.Duration(period) * time.Microsecond):\n\tcase <-d.toneStop:\n\t\td.Halt()\n\t}\n\n\td.toneStop <- true\n\t<-d.toneStopped\n\n\treturn nil\n}", "CodeBleu_score": 33.787677642971424}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tperiod := uint64(1000000.0 / hz)\n\ttempo := uint64(60.0 / d.bpm * 1000000.0)\n\tlog.Printf(\"hz: %v, period: %v, tempo: %v\n\", hz, period, tempo)\n\n\td.On()\n\t<-time.After(rpi.Delay(period / 2))\n\td.Off()\n\t<-time.After(rpi.Delay(tempo - period/2))\n\n\tfor i := 0; i < int(duration*1000.0/float64(tempo)); i++ {\n\t\td.On()\n\t\t<-time.After(rpi.Delay(period / 2))\n\t\td.Off()\n\t\t<-time.After(rpi.Delay(tempo - period/2))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.569952362167292}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 29.943367263086824}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.04561564971337}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin not set\")\n\t}\n\n\td.stop()\n\n\td.sleepPin.Low()\n\n\td.sleeping = true\n\n\treturn nil\n}", "CodeBleu_score": 29.791986733112097}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, id, err := translateAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = NewAnalogPin(a.sys, path, id)\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 51.63695574538525}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath, id, err := translateAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = NewAnalogPin(a.sys, path, id)\n\treturn a.pins[id], nil\n}", "CodeBleu_score": 51.63695574538525}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Must initialize analog pins before use\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpin := a.translateAnalogPin(id)\n\tif pin == nil {\n\t\treturn nil, errors.New(\"Unknown analog pin: \" + id)\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.24839828582517}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 74.83386803168175}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 76.385731078308}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}", "CodeBleu_score": 76.385731078308}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins are registered\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := parseID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = NewDigitalPin(a, chip, line)\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, option := range opts {\n\t\toption(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 43.51356841717311}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif a.connector == nil {\n\t\treturn nil, errors.New(\"Adaptor has no connected Connector\")\n\t}\n\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := parseDigitalPin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = sysfs.NewDigitalPin(chip, line)\n\t\tif pin == nil {\n\t\t\treturn nil, errors.New(\"Could not create new DigitalPin\")\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, option := range opts {\n\t\toption(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 52.89712164042697}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"No pins available\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := parseID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = newDigitalPin(a, chip, line, id, opts...)\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, option := range opts {\n\t\toption(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 46.80152467065021}]}
