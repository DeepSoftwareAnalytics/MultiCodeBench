{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_ptr;\n\n\tdesc_ptr = desc;\n\twhile (desc_ptr->bLength!= 0) {\n\t\tif (desc_ptr->bDescriptorType == desc_id) {\n\t\t\treturn desc_ptr;\n\t\t}\n\t\tdesc_ptr = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc_ptr\n\t\t\t\t+ desc_ptr->bLength);\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 41.320629726948525}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_conf_desc_t UDC_DESC_STORAGE *desc_ptr = desc;\n\n\twhile (desc_ptr->bLength) {\n\t\tif (desc_ptr->bDescriptorType == desc_id) {\n\t\t\treturn desc_ptr;\n\t\t}\n\n\t\tdesc_ptr = (usb_conf_desc_t UDC_DESC_STORAGE *) (((uint8_t *)\n\t\t\t\tdesc_ptr) + desc_ptr->bLength);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 37.46983875254614}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\t\tusb_iface_desc_t UDC_DESC_STORAGE * iface_desc;\n\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc;\n\n\tiface_desc = (usb_iface_desc_t UDC_DESC_STORAGE *) desc;\n\n\tif (desc->bDescriptorType!= USB_DESC_INTERFACE) {\n\t\treturn NULL;\n\t}\n\n\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc + desc->bLength);\n\n\twhile (next_desc->bLength!= 0) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) next_desc + next_desc->bLength);\n\t}\n\n\treturn NULL;\n}", "CodeBleu_score": 48.092737288477004}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tstruct udc_config_desc_t *config_desc = (struct udc_config_desc_t *)udc_get_config_desc();\n\tstruct udc_iface_desc_t *iface_desc = (struct udc_iface_desc_t *)config_desc->iface_desc;\n\tuint8_t *desc_ptr = (uint8_t *)iface_desc;\n\n\tif (config_desc == NULL)\n\t\treturn false;\n\n\tif (iface_num >= config_desc->bNumInterfaces)\n\t\treturn false;\n\n\twhile (desc_ptr < (uint8_t *)config_desc + config_desc->wTotalLength) {\n\t\tif (desc_ptr[0] == UDC_DESC_INTERFACE && desc_ptr[2] == iface_num && desc_ptr[3] == setting_num) {\n\t\t\tiface_desc = (struct udc_iface_desc_t *)desc_ptr;\n\t\t\treturn true;\n\t\t}\n\t\tdesc_ptr += desc_ptr[1];\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 36.833469385175036}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t\tif (g_curr_cfg_num == 0) {\n\t\treturn false;\n\t}\n\tif (iface_num >= g_curr_cfg_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\tstruct usb_interface_descriptor *iface_desc = (struct usb_interface_descriptor *)g_curr_cfg_desc;\n\tfor (uint8_t i = 0; i < g_curr_cfg_desc->bNumInterfaces; i++) {\n\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\tg_curr_iface_desc = iface_desc;\n\t\t\treturn true;\n\t\t}\n\t\tiface_desc = (struct usb_interface_descriptor *)((uint8_t *)iface_desc + iface_desc->bLength);\n\t}\n\treturn false;\n}", "CodeBleu_score": 39.614511879551856}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\t", "CodeBleu_score": 3.3949924833137373}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (setup.wLength!= 2) {\n\t\treturn false;\n\t}\n\n\tuint8_t ep = setup.wIndex & 0x0F;\n\tuint8_t status = 0;\n\n\tif (ep > 0) {\n\t\tif (udc_get_endpoint_halt_status(ep) == true) {\n\t\t\tstatus = 1;\n\t\t}\n\t}\n\n\tudc_write_payload(status);\n\tudc_write_payload(0);\n\n\treturn true;\n}", "CodeBleu_score": 26.813992374439934}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tif (setup_pkt->wLength!= 2)\n\t\treturn false;\n\n\tuint8_t ep_idx = udc_ep_idx(setup_pkt->wIndex);\n\tuint8_t ep_status = udc_ep_is_halted(ep_idx)? 1 : 0;\n\n\tudc_setup_payload_set(0, &ep_status, 2);\n\treturn true;\n}", "CodeBleu_score": 17.908416473002642}, {"code": "static bool udc_req_std_ep_get_status(void){\n\t\tuint8_t ep_status;\n\tif (usb_setup.wLength!= 2) {\n\t\treturn false;\n\t}\n\tif (usb_setup.wIndex & 0x80) {\n\t\tep_status = udc_ep_is_halted(usb_setup.wIndex & 0x0F);\n\t} else {\n\t\tep_status = 0;\n\t}\n\tudc_setup_payload(0, &ep_status, 2);\n\treturn true;\n}", "CodeBleu_score": 27.511519923517813}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\t\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool ret;\n\n\t// Check if the device is in a configured state\n\tif (UDC_STATE_CONFIGURED!= udc_get_state()) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tiface_num = udi_req->wIndex;\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tsetting_num = udi_req->wValue;\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the UDI handler\n\tret = udi_req_handler[iface_num].setup(udi_req);\n\n\t// Return the result of the UDI handler's setup function\n\treturn ret;\n}", "CodeBleu_score": 62.113002642993706}, {"code": "static bool udc_req_iface(void){\n\t\tbool b_iface_found;\n\tuint8_t iface_num = udi_g_ctrlreq.req.wIndex;\n\tuint8_t setting_num = udi_g_ctrlreq.req.wValue;\n\n\t// Check if device is in configured state\n\tif (UDC_STATE_CONFIGURED!= udc_device_state) {\n\t\treturn false;\n\t}\n\n\t// Check if interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to default setting\n\tb_iface_found = udc_update_iface_desc(iface_num, 0);\n\tif (!b_iface_found) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to current alternate setting\n\tb_iface_found = udc_update_iface_desc(iface_num, setting_num);\n\tif (!b_iface_found) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding USB Device Interface\n\t// (UDI) handler\n\treturn udc_ptr_udi->setup();\n}", "CodeBleu_score": 62.931817918980784}, {"code": "static bool udc_req_iface(void){\n\t\tbool b_setup_valid;\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\t// Check if device is in a configured state\n\tif (UDC_STATE_CONFIGURED!= udc_device_state) {\n\t\treturn false;\n\t}\n\n\t// Get interface number and alternate setting number\n\tiface_num = udi_get_setup_payload()->wIndex;\n\tsetting_num = udi_get_setup_payload()->wValue;\n\n\t// Check if the interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current alternate setting\n\tif (!udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\tb_setup_valid = udc_call_setup_handler(iface_num);\n\n\t// Return the result of the UDI handler's setup function\n\treturn b_setup_valid;\n}", "CodeBleu_score": 66.28431330851627}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}, {"code": "bool udi_msc_enable(void){\n\t#if UDI_MSC_ENABLE_EXT\n  if (!udi_msc_enable_ext()) {\n    return false;\n  }\n#endif\n\n  // Initialize LUNs\n  for (uint8_t lun = 0; lun < UDI_MSC_NB_LUN; lun++) {\n    udi_msc_lun_state[lun] = UDI_MSC_LUN_STATE_UNLOADED;\n  }\n\n  // Check if there are LUNs\n  if (UDI_MSC_NB_LUN == 0) {\n    return false;\n  }\n\n  // Check if the LUNs are available\n  for (uint8_t lun = 0; lun < UDI_MSC_NB_LUN; lun++) {\n    if (!udi_msc_lun_enable(lun)) {\n      return false;\n    }\n  }\n\n  // Unload medium on each LUN\n  for (uint8_t lun = 0; lun < UDI_MSC_NB_LUN; lun++) {\n    udi_msc_lun_state[lun] = UDI_MSC_LUN_STATE_UNLOADED;\n    udi_msc_lun_unmount(lun);\n  }\n\n  // Start MSC process\n  udi_msc_cbw_wait();\n  return true;\n}", "CodeBleu_score": 51.21142675407213}, {"code": "bool udi_msc_enable(void){\n\t", "CodeBleu_score": 1.7772867790678795}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_DEBUG_LEVEL >= 2\n  print_dbg_char('S');\n#endif\n  if (status!= UDD_EP_TRANSFER_OK) {\n    // Transfer error\n    // Wait for a MSC setup reset to restart CBW reception\n    return;\n  }\n  // Transfer OK\n  udi_msc_sense_pass();\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue - nb_sent);\n  udi_msc_csw_process();\n}", "CodeBleu_score": 54.34907111910859}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_DEBUG\n  debug_usb_msc_func_enter();\n#endif\n  if (status!= UDD_EP_TRANSFER_OK) {\n    // Transfer failed\n    // Wait for a MSC setup reset to restart CBW reception\n    udi_msc_wait_setup_reset();\n    return;\n  }\n  // Transfer succeeded\n  // Update sense data\n  udi_msc_sense_pass();\n  // Decrease data residue in CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  // Process updated CSW\n  udi_msc_csw_process();\n#if UDI_MSC_DEBUG\n  debug_usb_msc_func_exit();\n#endif\n}", "CodeBleu_score": 66.31024260540543}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\tif UDI_MSC_DEBUG\n  printf(\"udi_msc_data_sent: %d\n\", nb_sent);\n#endif\n  if (status!= UDD_EP_TRANSFER_OK) {\n    // Transfer aborted\n    // Wait for a MSC setup reset to restart CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_pass();\n  // Update CSW data residue\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(\n      le32_to_cpu(udi_msc_csw.dCSWDataResidue) - nb_sent);\n  // Process CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 62.707100263178226}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t#ifdef UDI_MSC_CBW_DIRECTION_IN\n  if (udi_msc_cbw.dCBWDataTransferLength!= 0) {\n    // Stall next request on the endpoint\n    // based on the direction of the CBW\n    if (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n      // Stall IN endpoint\n      udd_ep_set_stall_in(UDI_MSC_EP_IN);\n    } else {\n      // Stall OUT endpoint\n      udd_ep_set_stall_out(UDI_MSC_EP_OUT);\n    }\n  }\n#endif\n  // Prepare CSW\n  udi_msc_csw.dCSWSignature = cpu_to_le32(UDI_MSC_CSW_SIGNATURE);\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.bCSWStatus = udi_msc_cbw.bCBWCB[0];\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_cbw.dCBWDataTransferLength);\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 63.22518883932035}, {"code": "static void udi_msc_csw_process(void){\n\t", "CodeBleu_score": 2.8494374924614037}, {"code": "static void udi_msc_csw_process(void){\n\t#if UDI_MSC_CBW_MAX_SIZE > 0\n  // Check if there is a non-zero data residue\n  if (udi_msc_cbw.dCBWDataTransferLength!= udi_msc_cbw.dCBWDataResidue) {\n    // Stall next request on endpoint based on direction of CBW\n    if (UDI_MSC_CBW_DIRECTION(udi_msc_cbw.bmCBWFlags)) {\n      // IN endpoint\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    } else {\n      // OUT endpoint\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    }\n  }\n#endif\n  // Prepare CSW\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataResidue;\n  udi_msc_csw.bCSWStatus = udi_msc_cbw.bCBWCBLength? UDI_MSC_CSW_STATUS_CMD_PASSED : UDI_MSC_CSW_STATUS_PHASE_ERROR;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 56.69234780071398}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tcdc_device_struct_t *p_cdc = &cdc_device[port];\n\n\tif (p_cdc->b_dtr!= b_enable) {\n\t\tp_cdc->b_dtr = b_enable;\n\n\t\tif (p_cdc->b_dtr) {\n\t\t\tif (p_cdc->b_rts && p_cdc->baudrate == 1200) {\n\t\t\t\t// Cancel any scheduled reset\n\t\t\t\tcancelReset();\n\t\t\t}\n\t\t} else {\n\t\t\t// Schedule a delayed system reset\n\t\t\tif (p_cdc->baudrate == 1200) {\n\t\t\t\tinitiateReset();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.71191387767294}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\tif (b_enable) {\n\t\tif (cdc_serial_state[port] & USB_CDC_SERIAL_STATE_RX_CARRIER) {\n\t\t\treturn;\n\t\t}\n\t\tcdc_serial_state[port] |= USB_CDC_SERIAL_STATE_RX_CARRIER;\n\t\tif (cdc_line_coding[port].dwDTERate == 1200) {\n\t\t\t/* Schedule a delayed system reset */\n\t\t\tinitiateReset();\n\t\t}\n\t} else {\n\t\tif (!(cdc_serial_state[port] & USB_CDC_SERIAL_STATE_RX_CARRIER)) {\n\t\t\treturn;\n\t\t}\n\t\tcdc_serial_state[port] &= ~USB_CDC_SERIAL_STATE_RX_CARRIER;\n\t\t/* Cancel any scheduled reset */\n\t\tcancelReset();\n\t}\n}", "CodeBleu_score": 36.76563955680891}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\t\t/*\n\t * If the DTR signal is enabled, cancel any scheduled reset.\n\t */\n\tif (b_enable) {\n\t\tcancelReset();\n\t}\n\n\t/*\n\t * Update the DTR status for the specified USB port.\n\t */\n\tg_dtr_status[port] = b_enable;\n\n\t/*\n\t * If the DTR signal is disabled and the DTR rate is 1200, schedule a delayed system reset.\n\t */\n\tif (!b_enable && g_dtr_rate[port] == 1200) {\n\t\tinitiateReset();\n\t}\n}", "CodeBleu_score": 40.90702835208771}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t\t// Handle vendor-specific requests\n\tif (g_usb_request.bmRequestType == USB_SETUP_VENDOR) {\n\t\t// Check the request index\n\t\tswitch (g_usb_request.bRequest) {\n\t\t\tcase 0x04:\n\t\t\t\t// Set up the Microsoft-compatible ID descriptor\n\t\t\t\tg_usb_request.ptr = (void *)g_microsoft_compatible_id_descriptor;\n\t\t\t\tg_usb_request.size = sizeof(g_microsoft_compatible_id_descriptor);\n\t\t\t\treturn true;\n\t\t\tcase 0x05:\n\t\t\t\t// Set up the extended properties descriptor\n\t\t\t\tg_usb_request.ptr = (void *)g_extended_properties_descriptor;\n\t\t\t\tg_usb_request.size = sizeof(g_extended_properties_descriptor);\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 19.163670740280352}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t *payload;\n\tuint16_t size;\n\n\tswitch (usb_setup.bRequest) {\n\tcase 0x04:\n\t\tpayload = (uint8_t *) &microsoft_compatible_id_descriptor;\n\t\tsize = microsoft_compatible_id_descriptor.wLength;\n\t\tbreak;\n\tcase 0x05:\n\t\tpayload = (uint8_t *) &microsoft_extended_properties_descriptor;\n\t\tsize = microsoft_extended_properties_descriptor.wLength;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tusb_control_request.payload = payload;\n\tusb_control_request.size = size;\n\n\treturn true;\n}", "CodeBleu_score": 27.360704156323866}, {"code": "bool usb_task_other_requests(void){\n\t\tuint8_t *payload;\n\tuint16_t size;\n\n\tif (UENUM == 0) {\n\t\treturn false;\n\t}\n\n\tpayload = usb_get_current_payload();\n\tsize = usb_get_current_payload_size();\n\n\tif (usb_get_current_request_type() == (USB_REQ_TYPE_VENDOR | USB_REQ_TYPE_DEVICE)) {\n\t\tswitch (usb_get_current_request_index()) {\n\t\t\tcase 0x04:\n\t\t\t\tpayload = (uint8_t*)microsoft_compatible_id_descriptor;\n\t\t\t\tsize = sizeof(microsoft_compatible_id_descriptor);\n\t\t\t\tbreak;\n\t\t\tcase 0x05:\n\t\t\t\tpayload = (uint8_t*)microsoft_extended_properties_descriptor;\n\t\t\t\tsize = sizeof(microsoft_extended_properties_descriptor);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\tusb_set_current_payload(payload);\n\t\tusb_set_current_payload_size(size);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 19.679029114375954}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tuint16_t i;\n\tif (nbyte == 0)\n\t\treturn;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPDR = 0x00;\n\t\twhile (!(SPSR & (1 << SPIF)));\n\t\tbuf[i] = SPDR;\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 47.81342930509711}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0)\n\t\treturn;\n\tuint16_t i;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPDR = 0xFF;\n\t\twhile (!(SPSR & (1 << SPIF)))\n\t\t\t;\n\t\tbuf[i] = SPDR;\n\t}\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 46.38373940596306}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\t\tif (nbyte == 0) return;\n\tfor (uint16_t i = 0; i < nbyte - 1; i++) {\n\t\tSPI_DR(SPI) = 0xFF;\n\t\twhile (!(SPI_SR(SPI) & SPI_SR_RDRF));\n\t\tbuf[i] = SPI_DR(SPI);\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 53.012884636027046}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\t// Get the relocated interrupt vector table\n\tconst uint32_t *pVectors = (const uint32_t *)SCB->VTOR;\n\t// Disable global interrupts\n\t__disable_irq();\n\t// Get the current handler for the specified IRQ\n\tpfnISR_Handler oldHandler = (pfnISR_Handler)pVectors[irq + 16];\n\t// Replace the current handler with the new handler\n\tpVectors[irq + 16] = (uint32_t)newHandler;\n\t// Re-enable global interrupts\n\t__enable_irq();\n\t// Return the original ISR handler\n\treturn oldHandler;\n}", "CodeBleu_score": 57.59965270773888}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler = NULL;\n\tuint32_t vectorTableOffset = (uint32_t)irq * 4;\n\tuint32_t *vectorTable = (uint32_t *)NVIC_RAM_VECTOR_ADDRESS;\n\n\t__disable_irq();\n\toldHandler = (pfnISR_Handler)vectorTable[vectorTableOffset];\n\tvectorTable[vectorTableOffset] = (uint32_t)newHandler;\n\t__enable_irq();\n\n\treturn oldHandler;\n}", "CodeBleu_score": 44.87602850348515}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\t\tpfnISR_Handler oldHandler;\n\tuint32_t *pVectorTable;\n\n\t/* Get the address of the relocated interrupt vector table */\n\tpVectorTable = (uint32_t *)SCB->VTOR;\n\n\t/* Disable global interrupts */\n\t__disable_irq();\n\n\t/* Retrieve the current handler for the specified IRQ */\n\toldHandler = (pfnISR_Handler)pVectorTable[irq];\n\n\t/* Replace the current handler with the new handler */\n\tpVectorTable[irq] = (uint32_t)newHandler;\n\n\t/* Re-enable global interrupts */\n\t__enable_irq();\n\n\t/* Return the original ISR handler */\n\treturn oldHandler;\n}", "CodeBleu_score": 49.03304793913173}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser_enabled) {\n    if (peek_buffer_fill) {\n      return peek_buffer;\n    }\n    else {\n      int c = getChar();\n      if (c >= 0) {\n        peek_buffer = c;\n        peek_buffer_fill = true;\n        return c;\n      }\n    }\n  }\n#endif\n  return USBSerial.peek();\n}", "CodeBleu_score": 29.6398932893285}, {"code": "int MarlinSerialUSB::peek(){\n\t#if defined(USBCON) && defined(EMERGENCY_PARSER)\n  if (emergency_parser_enabled) {\n    // If the emergency parser is enabled, we need to process the next character\n    // before returning it.\n    while (available() &&!emergency_parser_buffer_full) {\n      emergency_parser_buffer[emergency_parser_buffer_index] = read();\n      if (emergency_parser_buffer[emergency_parser_buffer_index] == '\n') {\n        emergency_parser_buffer[emergency_parser_buffer_index] = '\\0';\n        emergency_parser_buffer_full = true;\n        emergency_parser_buffer_index = 0;\n      }\n      else {\n        emergency_parser_buffer_index++;\n        if (emergency_parser_buffer_index >= EMERGENCY_PARSER_BUFFER_SIZE) {\n          emergency_parser_buffer_index = 0;\n        }\n      }\n    }\n  }\n#endif\n  return Serial_USB.peek();\n}", "CodeBleu_score": 21.33894937017286}, {"code": "int MarlinSerialUSB::peek(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser_enabled) {\n    int c = read();\n    if (c!= -1)\n      return c;\n  }\n#endif\n  return serial_rx_buffer.peek();\n}", "CodeBleu_score": 25.365471119641885}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_parser.available())\n    return emergency_parser.read();\n#endif\n\n  if (usb_serial_class.available()) {\n    char c = usb_serial_class.read();\n    if (c == '\n')\n      usb_serial_class.flush();\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 43.19043312806197}, {"code": "int MarlinSerialUSB::read(){\n\t#if USB_SERIAL_EMERGENCY_PARSER\n  if (emergency_parser.available()) {\n    return emergency_parser.read();\n  }\n#endif\n  if (usb_serial_read_available()) {\n    char c = usb_serial_getchar();\n    if (c == '\\r') return '\n';\n    return c;\n  }\n  return -1;\n}", "CodeBleu_score": 42.882497135935765}, {"code": "int MarlinSerialUSB::read(){\n\t#if ENABLED(EMERGENCY_PARSER)\n  if (emergency_read_pos < EMERGENCY_PARSER_SIZE) {\n    return emergency_read_buffer[emergency_read_pos++];\n  }\n#endif\n  if (usb_serial_available()) {\n    int16_t c = usb_serial_getchar();\n    if (c >= 0) {\n#if ENABLED(EMERGENCY_PARSER)\n      emergency_read_buffer[emergency_read_pos++] = c;\n      if (emergency_read_pos == EMERGENCY_PARSER_SIZE) emergency_read_pos = 0;\n#endif\n      return c;\n    }\n  }\n  return -1;\n}", "CodeBleu_score": 43.6477192416704}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\t\tint count = 0;\n\n\tif (usb_cdc_is_enabled()) {\n\t\tcount = usb_cdc_rx_pending();\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 44.10854914853694}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_cdc_is_enabled()) {\n\t\treturn usb_cdc_rx_available();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 16.96306037381593}, {"code": "int MarlinSerialUSB::available(){\n\t\tif (usb_serial_available()) {\n\t\treturn usb_serial_get_available();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 14.892450390226214}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\twhile (size--) {\n\t\tuint8_t v = ee_Read(pos);\n\t\tif (value) *value++ = v;\n\t\tif (crc) crc16(crc, &v, 1);\n\t\tpos++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 48.741204604252715}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\t", "CodeBleu_score": 7.383824724965686}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tfor (size_t i = 0; i < size; i++) {\n\t\tvalue[i] = ee_Read(pos);\n\t\tif (writing)\n\t\t\tcrc16(crc, &value[i], 1);\n\t\tpos++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.70468945980752}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif 0\n  if (pin == 0) {\n    if (value == 0) {\n      timer0_disable();\n      timer0_detachInterrupt();\n    }\n    else {\n      timer0_attachInterrupt(onTimer0);\n      timer0_enable(TIM_DIV16, TIM_EDGE, TIM_LOOP);\n      timer0_write(value);\n    }\n  }\n  else if (pin == 1) {\n    if (value == 0) {\n      timer1_disable();\n      timer1_detachInterrupt();\n    }\n    else {\n      timer1_attachInterrupt(onTimer1);\n      timer1_enable(TIM_DIV16, TIM_EDGE, TIM_LOOP);\n      timer1_write(value);\n    }\n  }\n  else if (pin == 2) {\n    if (value == 0) {\n      timer2_disable();\n      timer2_detachInterrupt();\n    }\n    else {\n      timer2_attachInterrupt(onTimer2);\n      timer2_enable(TIM_DIV16, TIM_EDGE, TIM_LOOP);\n      timer2_write(value);\n    }\n  }\n  else\n#endif\n  {\n    int8_t cid = get_pwm_channel(pin, freq, res);\n    if (cid >= 0) ledcWrite(cid, value);\n  }\n}", "CodeBleu_score": 39.72631293595209}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif defined(ESP32)\n  if (pin == 10 || pin == 11) { // On ESP32, pins 10 and 11 are not PWM capable\n    pinMode(pin, OUTPUT);\n    digitalWrite(pin, value > 0);\n    return;\n  }\n#endif\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n}", "CodeBleu_score": 36.201897756342625}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tifdef DEBUG_ESP32_DIGITAL\n  Serial.printf(\"analogWrite(%u, %u, %u, %u)\n\", pin, value, freq, res);\n#endif\n  if (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return; // Not a hardware PWM pin!\n  int8_t cid = channel_for_pin(pin);\n  if (cid >= 0) {\n    ledcWrite(cid, value);\n    return;\n  }\n  if (freq == 0) return;\n  cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) ledcWrite(cid, value);\n}", "CodeBleu_score": 39.275646845023275}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= 32\n#error \"Servo delay array length must be 32\"\n#endif\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 48.53226511739302}, {"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= SERVO_CHANNELS\n  static_assert(false, \"SERVO_DELAY_ARRAY_LENGTH!= SERVO_CHANNELS\");\n#endif\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 40.55307052780631}, {"code": "void Servo::move(const int value){\n\t#if SERVO_DELAY_ARRAY_LENGTH!= 0\n  STATIC_ASSERT(SERVO_DELAY_ARRAY_LENGTH == SERVO_CHANNEL_COUNT, \"SERVO_DELAY_ARRAY_LENGTH must be equal to SERVO_CHANNEL_COUNT\");\n#endif\n  if (attach(pin) >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_ARRAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 49.67772426109643}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t\tuint32_t port_data = 0;\n\tfor (int i = 0; i < I2S_PIN_COUNT; i++) {\n\t\tif (i2s_pins[i].duty_cycle == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2s_pins[i].tick_count == 0) {\n\t\t\ti2s_pins[i].state =!i2s_pins[i].state;\n\t\t\ti2s_pins[i].tick_count = i2s_pins[i].duty_cycle;\n\t\t}\n\t\ti2s_pins[i].tick_count--;\n\t\tif (i2s_pins[i].state) {\n\t\t\tport_data |= i2s_pins[i].mask;\n\t\t}\n\t}\n\t*i2s_dma_buffer = port_data;\n\ti2s_dma_buffer++;\n}", "CodeBleu_score": 26.15881715812521}, {"code": "void i2s_push_sample(){\n\t\tuint8_t i;\n\tuint32_t port_data = 0;\n\n\tfor (i = 0; i < I2S_NUM_PINS; i++) {\n\t\tif (i2s_pin[i].duty_cycle > 0) {\n\t\t\tif (i2s_pin[i].duty_cycle <= i2s_pin[i].tick_count) {\n\t\t\t\ti2s_pin[i].pin_state =!i2s_pin[i].pin_state;\n\t\t\t\ti2s_pin[i].tick_count = 0;\n\t\t\t}\n\t\t}\n\t\tport_data |= (i2s_pin[i].pin_state << i2s_pin[i].gpio_pin);\n\t\ti2s_pin[i].tick_count++;\n\t}\n\n\t*i2s_dma_buffer_pos = port_data;\n\ti2s_dma_buffer_pos++;\n}", "CodeBleu_score": 31.767638541885578}, {"code": "void i2s_push_sample(){\n\t\tuint8_t i;\n\tuint8_t *p = (uint8_t *) &i2s_dma_buffer[i2s_dma_buffer_pos];\n\tfor (i = 0; i < I2S_NUM_PINS; i++) {\n\t\tif (i2s_pin[i].duty_cycle) {\n\t\t\tif (i2s_pin[i].duty_count == 0) {\n\t\t\t\ti2s_pin[i].port_state ^= (1 << i2s_pin[i].port_bit);\n\t\t\t\ti2s_pin[i].duty_count = i2s_pin[i].duty_cycle;\n\t\t\t}\n\t\t\ti2s_pin[i].duty_count--;\n\t\t}\n\t\tif (i2s_pin[i].port_state & (1 << i2s_pin[i].port_bit)) {\n\t\t\t*p |= (1 << i2s_pin[i].pin_bit);\n\t\t} else {\n\t\t\t*p &= ~(1 << i2s_pin[i].pin_bit);\n\t\t}\n\t}\n\ti2s_dma_buffer_pos++;\n\tif (i2s_dma_buffer_pos >= I2S_DMA_BUFFER_SIZE) {\n\t\ti2s_dma_buffer_pos = 0;\n\t}\n}", "CodeBleu_score": 32.50583082085415}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer_val;\n\ttimer_val.value = 0;\n\ttimer_val.overflow = 0;\n\n\t// Check if the timer number is valid\n\tif (timer_num >= HAL_TIMER_NUM) {\n\t\treturn timer_val;\n\t}\n\n\t// Get the timer configuration\n\thal_timer_config_t *timer_cfg = &hal_timer_cfg[timer_num];\n\n\t// Check if the timer is running\n\tif (timer_cfg->running == 0) {\n\t\treturn timer_val;\n\t}\n\n\t// Check if the timer is configured for 16-bit mode\n\tif (timer_cfg->mode == HAL_TIMER_MODE_16BIT) {\n\t\t// Read the current counter value from the timer\n\t\tuint16_t counter_value = timer_cfg->timer->TCNT1;\n\n\t\t// Check if the timer has overflowed\n\t\tif (counter_value < timer_cfg->last_value) {\n\t\t\ttimer_val.overflow = 1;\n\t\t}\n\n\t\t// Update the last value\n\t\ttimer_cfg->last_value = counter_value;\n\n\t\t// Set the timer value\n\t\ttimer_val.value = counter_value;\n\t}\n\t// Check if the timer is configured for 32-bit mode\n\telse if (timer_cfg->mode == HAL_TIMER_MODE_32BIT) {\n\t\t// Read the current counter value from the timer\n\t\tuint32_t counter_value = timer_cfg->timer->TCNT1;\n\n\t\t// Check if the timer has overflowed\n\t\tif (counter_value < timer_cfg->last_value) {\n\t\t\ttimer_val.overflow = 1;\n\t\t}\n\n\t\t// Update the last value\n\t\ttimer_cfg->last_value = counter_value;\n\n\t\t// Set the timer value\n\t\ttimer_val.value = counter_value;\n\t}\n\n\treturn timer_val;\n}", "CodeBleu_score": 42.39203356419151}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\tif (timer_num > 2) {\n\t\treturn 0;\n\t}\n\treturn timer_count[timer_num];\n}", "CodeBleu_score": 18.852632769420826}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\t\thal_timer_t timer = HAL_timer_get(timer_num);\n\treturn timer->count;\n}", "CodeBleu_score": 26.19632770086198}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; ++i) {\n\t\tvalue[i] = EEPROM.read(pos);\n\t\tpos++;\n\t\tif (writing)\n\t\t\tcrc16(crc, &value[i], 1);\n\t}\n\treturn false;\n}", "CodeBleu_score": 54.54028708614644}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (size_t i = 0; i < size; ++i) {\n\t\tvalue[i] = EEPROM.read(pos++);\n\t\tif (writing) {\n\t\t\tcrc16(crc, &value[i], 1);\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 53.312802325433985}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (uint8_t i = 0; i < size; i++) {\n\t\tvalue[i] = EEPROM.read(pos);\n\t\tcrc16(crc, &value[i], 1);\n\t\tif (writing) {\n\t\t\tSerial.print(value[i], HEX);\n\t\t\tSerial.print(\" \");\n\t\t}\n\t\tpos++;\n\t}\n\tSerial.println();\n\treturn false;\n}", "CodeBleu_score": 56.31179330398428}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tif (hsd == NULL || src == NULL) {\n\t\treturn false;\n\t}\n\tHAL_SD_ErrorTypedef error = HAL_SD_WriteBlocks(hsd, (uint8_t *) src, block, 1, 5000);\n\tif (error == HAL_SD_ERROR_NONE) {\n\t\treturn true;\n\t}\n\telse {\n\t\tprintf(\"SDIO_WriteBlock: error %d\n\", error);\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 34.01761197040101}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\tuint8_t i;\n\tif (!sdio_handle ||!src) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t *)src, block, 1, 1000) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tprintf(\"SDIO_WriteBlock failed\n\");\n\treturn false;\n}", "CodeBleu_score": 28.473768603969585}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\t\t// Check for null pointers\n\tif (sdio_handle == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: SDIO handle is null\n\");\n\t\treturn false;\n\t}\n\tif (src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: Source pointer is null\n\");\n\t\treturn false;\n\t}\n\n\t// Write the block\n\tuint8_t retries = 0;\n\twhile (retries < SDIO_MAX_RETRIES) {\n\t\tif (HAL_SD_WriteBlocks(sdio_handle, (uint8_t *)src, block, 1, SDIO_TIMEOUT) == HAL_OK) {\n\t\t\treturn true;\n\t\t}\n\t\tretries++;\n\t}\n\n\t// If we get here, we've failed\n\tprintf(\"SDIO_WriteBlock: Failed to write block %d\n\", block);\n\treturn false;\n}", "CodeBleu_score": 41.72857868140929}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tif (timer_num == TEMP_TIMER_CHANNEL) {\n\t\t// Start the temperature timer with the given frequency and prescale\n\t\tHAL_timer_start_frequency(TEMP_TIMER_CHANNEL, frequency, TEMP_TIMER_PRESCALE);\n\t\t// Set the callback priority for temperature\n\t\tHAL_timer_set_priority(TEMP_TIMER_CHANNEL, TEMP_TIMER_PRIORITY);\n\t} else if (timer_num == STEP_TIMER_CHANNEL) {\n\t\t// Start the stepper timer with the given frequency and prescale\n\t\tHAL_timer_start_frequency(STEP_TIMER_CHANNEL, frequency, STEP_TIMER_PRESCALE);\n\t\t// Set the callback priority for stepper\n\t\tHAL_timer_set_priority(STEP_TIMER_CHANNEL, STEP_TIMER_PRIORITY);\n\t} else {\n\t\t// Trigger an assertion failure if the timer channel is invalid\n\t\tHAL_ASSERT(false);\n\t}\n}", "CodeBleu_score": 39.024528078034606}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t\tswitch (timer_num) {\n\t\tcase TIMER_TEMP:\n\t\t\ttimer_init(TIMER_TEMP, frequency, TEMP_TIMER_PRESCALE, TIMER_PRIORITY_TEMP);\n\t\t\tbreak;\n\t\tcase TIMER_STEP:\n\t\t\ttimer_init(TIMER_STEP, frequency, STEP_TIMER_PRESCALE, TIMER_PRIORITY_STEP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\tbreak;\n\t}\n}", "CodeBleu_score": 22.529633748012518}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\t#ifdef DEBUG\n\tassert(timer_num < TIMER_CHANNEL_COUNT);\n#endif\n\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\t// Start the temperature timer with the given frequency and temperature timer prescale\n\t\tHAL_timer_start_raw(TIMER_CHANNEL_TEMPERATURE, frequency, TEMPERATURE_TIMER_PRESCALE);\n\t\t// Set the callback priority for temperature\n\t\tHAL_timer_set_callback_priority(TIMER_CHANNEL_TEMPERATURE, TEMPERATURE_TIMER_PRIORITY);\n\t} else if (timer_num == TIMER_CHANNEL_STEPPER) {\n\t\t// Start the step timer with the given frequency and stepper timer prescale\n\t\tHAL_timer_start_raw(TIMER_CHANNEL_STEPPER, frequency, STEPPER_TIMER_PRESCALE);\n\t\t// Set the callback priority for stepper\n\t\tHAL_timer_set_callback_priority(TIMER_CHANNEL_STEPPER, STEPPER_TIMER_PRIORITY);\n\t} else {\n\t\t// Invalid timer channel\n\t\tassert(false);\n\t}\n}", "CodeBleu_score": 40.39717760699267}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\t\tFILE *file = fopen(filename, \"r+b\");\n\tif (file == NULL) {\n\t\treturn false;\n\t}\n\tfseek(file, 0, SEEK_END);\n\tif (ftell(file) < EEPROM_SIZE) {\n\t\tfseek(file, 0, SEEK_SET);\n\t\tfor (int i = 0; i < EEPROM_SIZE; i++) {\n\t\t\tbuffer[i] = EEPROM_DEFAULT_ERASE_VALUE;\n\t\t}\n\t} else {\n\t\tfseek(file, 0, SEEK_SET);\n\t\tfread(buffer, sizeof(uint8_t), EEPROM_SIZE, file);\n\t}\n\tfclose(file);\n\treturn true;\n}", "CodeBleu_score": 42.15729200739965}, {"code": "bool PersistentStore::access_start(){\n\t\tif (eeprom_file.open(eeprom_file_name, O_RDWR | O_CREAT)) {\n\t\tif (eeprom_file.size() < EEPROM_SIZE) {\n\t\t\teeprom_file.truncate(EEPROM_SIZE);\n\t\t\teeprom_file.seek(0);\n\t\t\tfor (int i = 0; i < EEPROM_SIZE; i++) {\n\t\t\t\teeprom_file.write(EEPROM_DEFAULT_ERASE_VALUE);\n\t\t\t}\n\t\t}\n\t\teeprom_file.seek(0);\n\t\tfor (int i = 0; i < EEPROM_SIZE; i++) {\n\t\t\teeprom_buffer[i] = eeprom_file.read();\n\t\t}\n\t\teeprom_file.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.54417165135383}, {"code": "bool PersistentStore::access_start(){\n\t\t// Open EEPROM file for reading and writing\n\tfile = fopen(filename, \"r+b\");\n\t// Check if EEPROM file exists\n\tif (file == NULL) {\n\t\t// EEPROM file does not exist, so create it\n\t\tfile = fopen(filename, \"w+b\");\n\t\t// Check if EEPROM file was successfully created\n\t\tif (file == NULL) {\n\t\t\t// EEPROM file could not be created, so return false\n\t\t\treturn false;\n\t\t}\n\t\t// Fill buffer with default erase value\n\t\tfor (int i = 0; i < EEPROM_SIZE; i++) {\n\t\t\tbuffer[i] = EEPROM_ERASE_VALUE;\n\t\t}\n\t\t// Write buffer to EEPROM file\n\t\tfwrite(buffer, sizeof(buffer[0]), EEPROM_SIZE, file);\n\t}\n\telse {\n\t\t// EEPROM file exists, so read its contents into the buffer\n\t\tfread(buffer, sizeof(buffer[0]), EEPROM_SIZE, file);\n\t}\n\t// Close EEPROM file\n\tfclose(file);\n\t// Return true to indicate successful access start\n\treturn true;\n}", "CodeBleu_score": 37.44463633837442}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t received = 0;\n\n\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\tfor (i = 0; i < 8; i++) {\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\t\tb <<= 1;\n\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN)) {\n\t\t\treceived |= 0x01;\n\t\t}\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\treceived <<= 1;\n\t}\n\treceived >>= 1;\n\tHAL_Delay(1);\n\treturn received;\n}", "CodeBleu_score": 37.67270104572689}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i, temp = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\t\tb <<= 1;\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n\t\t\ttemp |= 0x01;\n\t\t}\n\t\tif (i < 7) {\n\t\t\ttemp <<= 1;\n\t\t}\n\t}\n\tHAL_Delay(1);\n\treturn temp;\n}", "CodeBleu_score": 37.574273086063585}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\t\tuint8_t i;\n\tuint8_t rx = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n\t\tif (b & 0x80) {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n\t\t} else {\n\t\t\tHAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n\t\t}\n\t\tb <<= 1;\n\t\tHAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN)) {\n\t\t\trx |= 0x01;\n\t\t}\n\t\trx <<= 1;\n\t}\n\trx >>= 1;\n\tHAL_Delay(1);\n\treturn rx;\n}", "CodeBleu_score": 38.400221912759456}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\n\tif (NewState!= DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 77.73179345687848}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t", "CodeBleu_score": 2.355873403718772}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\tuint8_t c = obj->regs->data;\n\n\tif (c & (1 << 7)) {\n\t\tobj->rx_buffer[obj->rx_head] = c;\n\t\tobj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n\t}\n}", "CodeBleu_score": 32.09127585523056}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\t\t// Read the received byte\n\tuint8_t c = obj->device->UDR;\n\t// Check if the parity is correct\n\tif (obj->device->UCSRA & (1 << UPE0)) {\n\t\t// If not, reset the USART\n\t\tobj->device->UCSRA = (1 << UPE0);\n\t\tobj->device->UCSRB = (1 << RXCIE0) | (1 << TXEN0) | (1 << RXEN0);\n\t\treturn;\n\t}\n\t// If there is space available in the receive buffer, store the byte\n\tif (obj->rx_buffer_head!= obj->rx_buffer_tail) {\n\t\tobj->rx_buffer[obj->rx_buffer_head] = c;\n\t\tobj->rx_buffer_head = (obj->rx_buffer_head + 1) % obj->rx_buffer_size;\n\t}\n\t// If enabled, update the emergency parser with the received byte\n\tif (obj->emergency_parser!= NULL) {\n\t\tobj->emergency_parser->update(c);\n\t}\n}", "CodeBleu_score": 40.10628069732164}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (step_timer.initialized &&!step_timer.has_interrupt) {\n\t\t\tstep_timer.has_interrupt = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (temp_timer.initialized &&!temp_timer.has_interrupt) {\n\t\t\ttemp_timer.has_interrupt = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.71151132213092}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (HAL_timer_is_initialized(timer_num) &&!HAL_timer_has_interrupt(timer_num)) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 41.97009454921431}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\t\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (step_timer_initialized &&!step_timer_has_interrupt) {\n\t\t\tstep_timer_has_interrupt = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t} else if (timer_num == MF_TIMER_TEMP) {\n\t\tif (temp_timer_initialized &&!temp_timer_has_interrupt) {\n\t\t\ttemp_timer_has_interrupt = true;\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}", "CodeBleu_score": 35.246295074255976}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn, m := len(s), len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\thashSep, pow := HashStrRev(sep)\n\thash := uint32(0)\n\tfor i := 0; i < m; i++ {\n\t\thash = hash*PrimeRK + uint32(s[n-m+i])\n\t}\n\tif hash == hashSep && s[n-m:n] == sep {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\thash *= PrimeRK\n\t\thash += uint32(s[i])\n\t\thash -= pow * uint32(s[i+m])\n\t\tif hash == hashSep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 50.63460393604965}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\thashsep, pow := HashStrRev(sep)\n\thash := uint32(0)\n\tfor i := n - m; i >= 0; i-- {\n\t\tif i < n-m {\n\t\t\thash *= PrimeRK\n\t\t\thash += uint32(s[i+m])\n\t\t\thash -= pow * uint32(s[i])\n\t\t} else {\n\t\t\tfor j := i; j < i+m; j++ {\n\t\t\t\thash = hash*PrimeRK + uint32(s[j])\n\t\t\t}\n\t\t}\n\t\tif hash == hashsep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 47.571724683301625}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tn := len(s)\n\tm := len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif m > n {\n\t\treturn -1\n\t}\n\thashsep, pow := HashStrRev(sep)\n\thash := uint32(0)\n\tfor i := 0; i < m; i++ {\n\t\thash = hash*PrimeRK + uint32(s[n-m+i])\n\t}\n\tif hash == hashsep && s[n-m:n] == sep {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\thash *= PrimeRK\n\t\thash += uint32(s[i])\n\t\thash -= pow * uint32(s[i+m])\n\t\tif hash == hashsep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 51.295447244667095}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tintr := disableInterrupts()\n\n\t// If there is data in the transmit buffer, send it to the USB endpoint\n\tif usbcdc.txcCount > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data available, so set waitTxc to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore interrupt mask\n\trestoreInterrupts(intr)\n}", "CodeBleu_score": 40.6875837851386}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\toldImask := DisableInterrupts()\n\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txc.Len() > 0 {\n\t\t// Send data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data available, so set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask\n\tRestoreInterrupts(oldImask)\n}", "CodeBleu_score": 43.39493137904662}, {"code": "func (usbcdc *USBCDC) Flush(){\n\t\t// Disable interrupts\n\tinterrupts := getInterruptMask()\n\tdisableInterrupts()\n\n\t// If there is data in the transmit buffer, send it to the USB endpoint\n\tif usbcdc.txc!= nil {\n\t\tusbcdc.txc.SendUSBInPacket()\n\t\tusbcdc.txc = nil\n\t}\n\n\t// If there is no data in the transmit buffer, set waitTxc to false\n\tif usbcdc.txc == nil {\n\t\tusbcdc.waitTxc = false\n\t}\n\n\t// Restore the interrupt mask\n\tsetInterruptMask(interrupts)\n}", "CodeBleu_score": 38.953024863948606}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\t// Clear interrupt flag\n\ti2c.I2C_SR1.ClearBits(i2c.I2C_SR1.Bits() & i2c.I2C_SR1.Bits())\n\t// Generate start condition\n\ti2c.I2C_CR1.SetBits(i2c.I2C_CR1.Bits() | i2c.I2C_CR1_START)\n\t// Wait for start condition to be transmitted\n\tfor (i2c.I2C_SR1.Bits() & i2c.I2C_SR1_SB) == 0 {\n\t}\n\t// Send peripheral address\n\ti2c.I2C_DR.SetBits(uint32(address<<1) | uint32(!write))\n}", "CodeBleu_score": 29.38433019988392}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.ctrl.ClearInterrupt()\n\ti2c.ctrl.SetStart()\n\ti2c.ctrl.Enable()\n\n\tfor!i2c.ctrl.Interrupt() {\n\t}\n\n\ti2c.data.Set(address<<1 | uint8(write))\n\ti2c.ctrl.SetWrite()\n\ti2c.ctrl.SetAck()\n}", "CodeBleu_score": 28.114999516565565}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t\ti2c.CR1.SetBits(i2c.CR1.Bits() | (1 << 0))\n\ti2c.CR1.SetBits(i2c.CR1.Bits() | (1 << 8))\n\ti2c.CR1.SetBits(i2c.CR1.Bits() | (1 << 10))\n\tfor i2c.SR1.GetBits(1 << 0) == 0 {\n\t}\n\ti2c.DR.SetBits(uint32(address << 1))\n\tif!write {\n\t\ti2c.DR.SetBits(i2c.DR.Bits() | (1 << 0))\n\t}\n}", "CodeBleu_score": 29.095027357736953}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size.\n\taddress := uint32(start) * f.blockSize\n\n\t// Wait for any ongoing flash operations to complete.\n\tf.flash.Wait()\n\n\t// Configure the flash for erasing.\n\tf.flash.Configure(flash.Config{\n\t\tMode: flash.Erase,\n\t})\n\n\t// Erase each block in the specified range.\n\tfor i := 0; i < int(len); i++ {\n\t\t// Erase the block at the current address.\n\t\tf.flash.Erase(address)\n\n\t\t// Wait until the flash is no longer busy.\n\t\tf.flash.Wait()\n\n\t\t// Increment the address by the block size.\n\t\taddress += f.blockSize\n\t}\n\n\t// Set the flash back to read mode.\n\tf.flash.Configure(flash.Config{\n\t\tMode: flash.Read,\n\t})\n\n\t// Return nil to indicate successful completion.\n\treturn nil\n}", "CodeBleu_score": 30.64277569381284}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\tstartAddress := start * f.blockSize\n\tfor i := int64(0); i < len; i++ {\n\t\taddress := startAddress + i*f.blockSize\n\t\tf.flash.SetAddress(uint32(address))\n\t\tf.flash.SetCommand(0x20)\n\t\tfor f.flash.GetStatus()&0x01 == 0x01 {\n\t\t}\n\t\tf.flash.SetCommand(0xD0)\n\t\tfor f.flash.GetStatus()&0x80 == 0x80 {\n\t\t}\n\t}\n\tf.flash.SetCommand(0xF0)\n\treturn nil\n}", "CodeBleu_score": 34.27219982616956}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t\t// Calculate the start address based on the block number and block size\n\tstartAddress := start * f.blockSize\n\n\t// Wait for any ongoing flash operations to complete\n\tf.flash.Wait()\n\n\t// Configure the flash for erasing\n\tf.flash.Erase(startAddress, len*f.blockSize)\n\n\t// Wait until the flash is no longer busy\n\tf.flash.Wait()\n\n\t// Set the flash back to read mode\n\tf.flash.ReadMode()\n\n\treturn nil\n}", "CodeBleu_score": 16.109470796225857}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 {\n\t\treturn 0, errors.New(\"negative offset\")\n\t}\n\tif int64(len(p)) > f.Size()-off {\n\t\treturn 0, errors.New(\"write exceeds flash bounds\")\n\t}\n\n\tstart := int(off)\n\tend := start + len(p)\n\tif end%f.WriteBlockSize()!= 0 {\n\t\tend += f.WriteBlockSize() - (end % f.WriteBlockSize())\n\t}\n\tp = append(p, make([]byte, end-len(p))...)\n\n\tf.Flash.EnableWrite()\n\tfor i := start; i < end; i += f.WriteBlockSize() {\n\t\tif err := f.Flash.Write(p[i:i+f.WriteBlockSize()], uint32(i)); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.Flash.WaitForWrite(); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 33.75338144031942}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off < 0 || off > int64(f.size) {\n\t\treturn 0, errors.New(\"offset out of bounds\")\n\t}\n\n\t// Pad the byte slice to fit the write block size\n\tp = append(p, make([]byte, f.writeBlockSize-len(p)%f.writeBlockSize)...)\n\n\t// Enable write mode on the flash memory controller\n\tf.flashController.EnableWrite()\n\n\t// Write the data in blocks and wait for the flash memory to be ready after each write operation\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\terr = f.flashController.Write(uint32(off+int64(i)), p[i:i+f.writeBlockSize])\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t\terr = f.flashController.WaitForReady()\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 29.689501006446996}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"write exceeds flash memory bounds\")\n\t}\n\n\tstart := int(off)\n\tp = append(make([]byte, start-len(f.data)), p...)\n\tp = append(p, make([]byte, f.writeBlockSize-len(p)%f.writeBlockSize)...)\n\n\tf.flashController.EnableWrite()\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tf.flashController.WriteBlock(p[i : i+f.writeBlockSize])\n\t\tif err := f.flashController.WaitUntilReady(); err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tf.data = append(f.data[:start], append(p, f.data[start+len(p):]...)...)\n\n\treturn len(p), nil\n}", "CodeBleu_score": 35.38887292534222}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Dup the fd so we can close it if we fail to open the directory.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\tdefer syscall.Close(dupFd)\n\n\t// Loop until we either succeed or get an error other than EINTR.\n\tfor {\n\t\tdirp, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn dirp, \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 52.729721942958626}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err!= nil {\n\t\treturn 0, \"\", fmt.Errorf(\"failed to dup fd: %v\", err)\n\t}\n\t// Try to open the directory using \"syscall.Fdopendir\" until it succeeds or encounters an error other than \"syscall.EINTR\".\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn dir, \"\", nil\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\t_ = syscall.Close(dupFd)\n\t\t\treturn 0, \"\", fmt.Errorf(\"failed to open dir: %v\", err)\n\t\t}\n\t}\n}", "CodeBleu_score": 53.66853138154417}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t\t// Dup the file descriptor.\n\tdupfd, err := dup(fd)\n\tif err!= nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory.\n\tvar dir uintptr\n\tvar errstr string\n\tfor {\n\t\tdir, err = syscall.Fdopendir(int(dupfd))\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err!= syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err!= nil {\n\t\tclose(dupfd)\n\t\treturn 0, err.Error(), err\n\t}\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 60.156885898139556}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app_desc;\n\tesp_image_metadata_t metadata;\n\tesp_image_verify_bootloader_data(&app_desc, &metadata);\n\treturn (response == FREE_SPACE)? metadata.image_len : metadata.image_len - metadata.image_data_len;\n}", "CodeBleu_score": 25.773037192577352}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app_desc;\n\tesp_image_spi_size_t size;\n\tesp_image_verify(ESP_IMAGE_VERIFY, &size);\n\tesp_app_get_description(&app_desc);\n\tif (response == true) {\n\t\treturn size.image_len - size.image_info_len;\n\t}\n\telse {\n\t\treturn size.image_info_len;\n\t}\n}", "CodeBleu_score": 31.792299910905964}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\t\tesp_app_desc_t app_desc;\n\tesp_image_flash_read(ESP.getSketchAddress() & 0xFFFFFF, (uint32_t*)&app_desc, sizeof(esp_app_desc_t));\n\tif (response) {\n\t\treturn app_desc.flash_size - app_desc.image_len;\n\t} else {\n\t\treturn app_desc.image_len;\n\t}\n}", "CodeBleu_score": 31.178358041872844}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t#if!defined(CONFIG_SPIRAM_SUPPORT)\n  log_w(\"SPIRAM not enabled. MSC will not work\");\n#endif\n  if (!msc_update_get_required_disk_sectors()) {\n    return false;\n  }\n  msc_disk_sectors = msc_update_get_required_disk_sectors();\n  msc_disk_memory = heap_caps_malloc(msc_disk_sectors * DISK_SECTOR_SIZE, MALLOC_CAP_SPIRAM);\n  if (!msc_disk_memory) {\n    log_e(\"Failed to allocate %uKB of RAM\", (msc_disk_sectors * DISK_SECTOR_SIZE) / 1024);\n    return false;\n  }\n  memset(msc_disk_memory, 0, msc_disk_sectors * DISK_SECTOR_SIZE);\n  log_d(\"Disk memory at 0x%08X\", msc_disk_memory);\n  msc_update_setup_boot_sector(msc_disk_memory, volume_label, serial_number);\n  msc_update_setup_fat(msc_disk_memory, msc_table_sectors);\n  msc_update_setup_root_dir(msc_disk_memory);\n  return true;\n}", "CodeBleu_score": 38.89999282415532}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\t", "CodeBleu_score": 2.800147042174422}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGD(TAG, \"%s: offset 0x%08x, size %d\", __FUNCTION__, offset, size);\n\tesp_err_t err;\n\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"offset 0x%08x is not aligned with sector size %d\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\terr = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"esp_partition_erase_range failed with %d\", err);\n\t\treturn err;\n\t}\n\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"esp_partition_write failed with %d\", err);\n\t\treturn err;\n\t}\n\n\treturn ESP_OK;\n}", "CodeBleu_score": 50.70496551474335}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGD(TAG, \"%s: offset 0x%08x, size %d\", __func__, offset, size);\n\tesp_err_t err;\n\tsize_t sector_size = partition->erase_size;\n\tuint32_t sector_offset = offset & (sector_size - 1);\n\tuint32_t sector_addr = offset - sector_offset;\n\tuint32_t sector_end = offset + size;\n\tuint32_t write_size = size + sector_offset;\n\tif (sector_end > sector_addr + sector_size) {\n\t\twrite_size += sector_size - (sector_end & (sector_size - 1));\n\t}\n\tESP_LOGD(TAG, \"%s: sector_offset 0x%08x, sector_addr 0x%08x, sector_end 0x%08x, write_size %d\", __func__, sector_offset, sector_addr, sector_end, write_size);\n\tif (sector_offset!= 0) {\n\t\tuint32_t erase_size = sector_size - sector_offset;\n\t\tESP_LOGD(TAG, \"%s: erase_size %d\", __func__, erase_size);\n\t\terr = esp_partition_erase_range(partition, sector_addr, erase_size);\n\t\tif (err!= ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"%s: failed to erase sector at offset 0x%08x, size %d\", __func__, sector_addr, erase_size);\n\t\t\treturn err;\n\t\t}\n\t}\n\tESP_LOGD(TAG, \"%s: writing data at offset 0x%08x, size %d\", __func__, sector_addr, write_size);\n\terr = esp_partition_write(partition, sector_addr, data, write_size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"%s: failed to write data at offset 0x%08x, size %d\", __func__, sector_addr, write_size);\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 46.74998636592621}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\t\tESP_LOGD(TAG, \"msc_update_write: offset 0x%x, size %d\", offset, size);\n\n\tif (offset % partition->erase_size!= 0) {\n\t\tESP_LOGE(TAG, \"Offset 0x%x is not aligned with sector size %d\", offset, partition->erase_size);\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\n\tesp_err_t err = esp_partition_erase_range(partition, offset, size);\n\tif (err!= ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to erase partition: %s\", esp_err_to_name(err));\n\t\treturn err;\n\t}\n\n\treturn esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 51.64126705346512}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = 0;\n\twhile (*in && len < maxlen) {\n\t\tuint8_t c = hex_char_to_byte(*in++);\n\t\tif (c == 0x10)\n\t\t\tcontinue;\n\t\tuint8_t c2 = hex_char_to_byte(*in++);\n\t\tif (c2 == 0x10)\n\t\t\tcontinue;\n\t\t*out++ = (c << 4) | c2;\n\t\tlen++;\n\t}\n\treturn len;\n}", "CodeBleu_score": 38.630246100674526}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t outlen = 0;\n\twhile (*in && maxlen--) {\n\t\tuint8_t c = hex_char_to_byte(*in++);\n\t\tif (c > 0x0f)\n\t\t\tcontinue;\n\t\tif (outlen & 1) {\n\t\t\t*out++ |= c;\n\t\t\toutlen++;\n\t\t} else\n\t\t\t*out = c << 4;\n\t}\n\treturn outlen;\n}", "CodeBleu_score": 40.97813948361077}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tze_t len = 0;\n\twhile (*in && len < maxlen) {\n\t\tuint8_t c = hex_char_to_byte(*in++);\n\t\tif (c == 0x10)\n\t\t\tcontinue;\n\t\tuint8_t c2 = hex_char_to_byte(*in++);\n\t\tif (c2 == 0x10)\n\t\t\tcontinue;\n\t\t*out++ = (c << 4) | c2;\n\t\tlen++;\n\t}\n\treturn len;\n}", "CodeBleu_score": 38.630246100674526}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\t\tint freeSize;\n\n\tif (txRingBuffer == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(txRingBufferLock, TX_RING_BUFFER_LOCK_TIMEOUT) == pdTRUE) {\n\t\tfreeSize = txRingBuffer->availableForWrite();\n\t\txSemaphoreGive(txRingBufferLock);\n\t\treturn freeSize;\n\t} else {\n\t\treturn 0;\n\t}\n}", "CodeBleu_score": 57.76961538630832}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!tx_buffer) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, TX_LOCK_TIMEOUT) == pdTRUE) {\n\t\tint free = tx_buffer->availableForStore();\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 48.81586538883447}, {"code": "int HWCDC::availableForWrite(void){\n\t\tif (!tx_ring) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_lock, 1000 / portTICK_PERIOD_MS) == pdTRUE) {\n\t\tint avail = tx_ring->availableForStore();\n\t\txSemaphoreGive(tx_lock);\n\t\treturn avail;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 50.96083519554744}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t_mutex.lock();\n\t_onReceiveCB = function;\n\tif (_onReceiveCB!= NULL) {\n\t\t_rxTimeout = 0;\n\t\t_fifoFullThreshold = 1;\n\t\tif (!_eventTask) {\n\t\t\t_createEventTask();\n\t\t}\n\t}\n\t_mutex.unlock();\n}", "CodeBleu_score": 31.52816025476025}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t// Lock the serial mutex\n\tportENTER_CRITICAL(&_mutex);\n\t// Assign the provided callback function to \"_onReceiveCB\"\n\t_onReceiveCB = function;\n\t// Configure the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n\tif (_onReceiveCB) {\n\t\t// If the callback is not NULL, set the FIFO full threshold\n\t\t_rxFIFO->setFullThreshold(1);\n\t\t// Create an event task if it does not already exist\n\t\tif (!_eventTask) {\n\t\t\t_createEventTask(NULL);\n\t\t}\n\t}\n\t// Unlock the serial mutex\n\tportEXIT_CRITICAL(&_mutex);\n}", "CodeBleu_score": 26.376303560653476}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t\t_onReceiveCB = function;\n\t_onlyOnTimeout = onlyOnTimeout;\n\n\tif (_onReceiveCB!= NULL) {\n\t\t_rxTimeout = 0;\n\t\t_rxFIFOFullThreshold = 1;\n\t\t_createEventTask();\n\t}\n}", "CodeBleu_score": 29.84162789846152}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) break;\n\t\tchar c_char = (char)c;\n\t\tbuffer[index] = c_char;\n\t\tif (c_char == terminator) break;\n\t\tindex++;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 66.7017099378248}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) break;\n\t\tchar c_char = (char)c;\n\t\tbuffer[index] = c_char;\n\t\tif (c_char == terminator) break;\n\t\tindex++;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 66.7017099378248}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\t\tif (length < 1) return 0;\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0) break;\n\t\tchar ch = (char)c;\n\t\tbuffer[index++] = ch;\n\t\tif (ch == terminator) break;\n\t}\n\tbuffer[index] = 0;\n\treturn index;\n}", "CodeBleu_score": 65.69240681933938}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t#if defined(ESP32)\n  if (pin == 4 || pin == 16 || pin == 21 || pin == 22 || pin == 25 || pin == 26 || pin == 27 || pin == 32 || pin == 33 || pin == 34 || pin == 35 || pin == 36 || pin == 39) {\n    log_e(\"Pin %d is not a PWM pin\", pin);\n    return;\n  }\n#endif\n\n  log_v(\"Tone on pin %d with frequency %d and duration %ld\", pin, frequency, duration);\n  if (_tone_pin_available(pin)) {\n    _tone_init();\n    tone_msg_t msg;\n    msg.pin = pin;\n    msg.frequency = frequency;\n    msg.duration = duration;\n    msg.command = TONE_START;\n    xQueueSend(_tone_queue, &msg, 0);\n  } else {\n    log_e(\"Pin %d is in use\", pin);\n  }\n}", "CodeBleu_score": 46.975546600816706}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t\tif (tone_init() == 0) {\n\t\treturn;\n\t}\n\n\ttone_msg_t msg;\n\tmsg.pin = pin;\n\tmsg.frequency = frequency;\n\tmsg.duration = duration;\n\n\tif (xQueueSend(_tone_queue, &msg, 0)!= pdTRUE) {\n\t\tlog_e(\"Could not send tone msg\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 30.433825190854456}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t#if defined(ARDUINO_ARCH_ESP32)\n  if (pin == 25 || pin == 26) {\n    log_e(\"Tone on pin %d not supported\", pin);\n    return;\n  }\n#endif\n  log_v(\"Tone on pin %d with frequency %d and duration %ld\", pin, frequency, duration);\n\n  if (tone_pin_available(pin)) {\n    tone_init();\n    tone_msg_t msg = {\n     .cmd = TONE_CMD_START,\n     .pin = pin,\n     .freq = frequency,\n     .duration = duration,\n    };\n    xQueueSend(_tone_queue, &msg, portMAX_DELAY);\n  } else {\n    log_e(\"Tone on pin %d already in use. Stop it first.\", pin);\n  }\n}", "CodeBleu_score": 60.97984917443999}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!usbStarted) {\n\t\twebUSBEnabled = enabled;\n\t\tif (enabled) {\n\t\t\tif (usbVersion < 0x0210) {\n\t\t\t\tusbVersion = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 53.65519056704201}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (!started) {\n\t\twebusb = enabled;\n\t\tif (enabled) {\n\t\t\tif (usb_version < 0x0210) {\n\t\t\t\tusb_version = 0x0210;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 59.49827638707947}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\t\tif (started) return false;\n\twebusb = enabled;\n\treturn true;\n}", "CodeBleu_score": 18.380420132493953}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\t\tuint32_t len = 0;\n\tuint8_t* buf = nullptr;\n\n\tif (this->_cdc->read(&buf, &len)) {\n\t\tif (this->_rxQueue.isFull()) {\n\t\t\tthis->_rxOverflowEvent.post(len);\n\t\t\tthis->_errorEvent.post(USB_CDC_RX_OVERFLOW);\n\t\t}\n\t\telse {\n\t\t\tfor (uint32_t i = 0; i < len; i++) {\n\t\t\t\tthis->_rxQueue.put(buf[i]);\n\t\t\t}\n\t\t\tthis->_rxEvent.post(len);\n\t\t}\n\t}\n}", "CodeBleu_score": 19.55626054928327}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t c;\n\tuint16_t len = 0;\n\twhile(CDC_Device_BytesReceived(&VirtualSerial_CDC_Interface) && len < USB_CDC_RX_BUFFER_SIZE) {\n\t\tif(CDC_Device_ReceiveByte(&VirtualSerial_CDC_Interface, &c) == ENDPOINT_RWSTREAM_NoError) {\n\t\t\trxBuffer[len++] = c;\n\t\t}\n\t}\n\tif(len) {\n\t\tif(rxQueue.post(rxBuffer, len)!= osOK) {\n\t\t\tevents.post(USB_CDC_RX_OVERFLOW, len);\n\t\t\tUSB_CDC_LOG(\"USB CDC RX OVERFLOW: %d\n\", len);\n\t\t} else {\n\t\t\tevents.post(USB_CDC_RX, len);\n\t\t}\n\t}\n}", "CodeBleu_score": 20.89929516975187}, {"code": "void USBCDC::_onRX(){\n\t\tuint8_t data;\n\tuint32_t len;\n\tuint32_t dropped;\n\n\t// read data from the USB CDC device\n\tlen = USBCDC::CDC_Device_ReceiveByte(&_cdcInterfaceInfo, &data);\n\n\t// if data was received\n\tif (len) {\n\t\t// attempt to send the data to the receive queue\n\t\tif (xQueueSendToBack(_rxQueue, &data, 0)!= pdTRUE) {\n\t\t\t// if the queue is full, post an overflow event with the number of dropped bytes\n\t\t\tdropped = uxQueueSpacesAvailable(_rxQueue);\n\t\t\txQueueSendToBack(_eventQueue, &dropped, 0);\n\t\t\tUSBCDC::log(USBCDC::LOG_ERROR, \"USBCDC::_onRX: Queue is full. Dropped %d bytes.\n\", dropped);\n\t\t}\n\n\t\t// post a receive event with the length of the received data\n\t\txQueueSendToBack(_eventQueue, &len, 0);\n\t}\n}", "CodeBleu_score": 18.796228046996248}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot was found with the specified name.\"})\n\t\treturn\n\t}\n\n\tdevices := robot.Devices\n\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 32.70657949196657}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\tname := mux.Vars(req)[\"name\"]\n\trobot, err := a.robotStore.GetRobot(name)\n\tif err!= nil {\n\t\thttp.Error(res, fmt.Sprintf(`{\"error\": \"No robot found with name %s\"}`, name), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\tjson.NewEncoder(res).Encode(devices)\n}", "CodeBleu_score": 25.267242641852594}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t\t// Get the robot name from the URL path\n\tvars := mux.Vars(req)\n\trobotName := vars[\"name\"]\n\n\t// Check if a robot with the given name exists\n\trobot, err := a.robotExists(robotName)\n\tif err!= nil {\n\t\t// If the robot does not exist, return an error message\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"No robot found with the specified name\"})\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot\n\tdevices, err := a.getRobotDevices(robot)\n\tif err!= nil {\n\t\t// If there was an error getting the devices, return an error message\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": \"Error getting devices for robot\"})\n\t\treturn\n\t}\n\n\t// Create a JSON response with the devices\n\tresponse := map[string]interface{}{\n\t\t\"devices\": devices,\n\t}\n\n\t// Write the JSON response to the HTTP response writer\n\ta.writeJSON(res, http.StatusOK, response)\n}", "CodeBleu_score": 36.08587170491803}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\t// If the robot is not found, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the name '\" + robotName + \"' was found.\"))\n\t\treturn\n\t}\n\n\t// If the robot is found, iterate through its connections, convert them to JSON format, and write them to the HTTP response\n\tconnections := robot.Connections()\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"Error converting connections to JSON: \" + err.Error()))\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 32.66791772456382}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Check if the robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err!= nil {\n\t\thttp.Error(res, fmt.Sprintf(\"No robot with name %s found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Iterate through the robot's connections and convert them to JSON format\n\tconnections := make([]Connection, 0)\n\tfor _, connection := range robot.Connections {\n\t\tconnections = append(connections, Connection{\n\t\t\tName: connection.Name,\n\t\t\tType: connection.Type,\n\t\t\tURL:  connection.URL,\n\t\t})\n\t}\n\n\t// Write the connections to the HTTP response\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 44.626391086439874}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif!ok {\n\t\t// If the robot is not found, write an error message to the HTTP response\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// If the robot is found, iterate through its connections, convert them to JSON format, and write them to the HTTP response\n\tconnectionsJSON, err := json.Marshal(robot.connections)\n\tif err!= nil {\n\t\thttp.Error(res, fmt.Sprintf(\"Error converting connections to JSON: %v\", err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 32.63482303776893}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\tdeviceName := vars[\"device\"]\n\tcommand := vars[\"command\"]\n\n\trobot, err := a.getRobot(robotName)\n\tif err!= nil {\n\t\ta.writeJSONResponse(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice := robot.GetDevice(deviceName)\n\tif device == nil {\n\t\ta.writeJSONResponse(res, fmt.Sprintf(\"Device '%s' not found on robot '%s'\", deviceName, robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\terr = device.Command(command)\n\tif err!= nil {\n\t\ta.writeJSONResponse(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\ta.writeJSONResponse(res, fmt.Sprintf(\"Command '%s' executed on device '%s' on robot '%s'\", command, deviceName, robotName), http.StatusOK)\n}", "CodeBleu_score": 39.11287088826681}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\tdeviceName := vars[\"device\"]\n\n\trobot, err := a.Robot(robotName)\n\tif err!= nil {\n\t\ta.sendErrorResponse(res, http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\ta.sendErrorResponse(res, http.StatusNotFound, errors.New(\"device not found\"))\n\t\treturn\n\t}\n\n\terr = device.Command(req.URL.Query().Get(\"command\"))\n\tif err!= nil {\n\t\ta.sendErrorResponse(res, http.StatusInternalServerError, err)\n\t\treturn\n\t}\n\n\ta.sendSuccessResponse(res)\n}", "CodeBleu_score": 48.04214910753508}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t\t// Parse the URL query parameters\n\tquery := req.URL.Query()\n\trobotName := query.Get(\"robot\")\n\tdeviceName := query.Get(\"device\")\n\tcommand := query.Get(\"command\")\n\n\t// Retrieve the robot from the registry\n\trobot, err := a.registry.GetRobot(robotName)\n\tif err!= nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\n\t// Retrieve the device from the robot\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err!= nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device\n\terr = device.CallMethod(command)\n\tif err!= nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\n\t// Write the success message as a JSON response\n\ta.writeSuccess(res, fmt.Sprintf(\"Command %s executed successfully on device %s of robot %s\", command, deviceName, robotName))\n}", "CodeBleu_score": 44.16154178645127}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Continue to next handler\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.46358299945588}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\trealm := \"Please enter your username and password for this site\"\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"`+realm+`\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Unauthorised.\n\"))\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.5831529572546}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 54.225221194845254}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\t// Lock the sensor for reading.\n\ta.Lock()\n\tdefer a.Unlock()\n\n\t// Check if the connection supports analog reading.\n\tif!a.connection.SupportsAnalog() {\n\t\treturn 0, 0, errors.New(\"analog sensor read not supported\")\n\t}\n\n\t// Retrieve the raw sensor value.\n\traw, err := a.connection.AnalogRead(a.port)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration.\n\tscaled := float64(raw)\n\tif a.minValue!= a.maxValue {\n\t\tscaled = (scaled - float64(a.minValue)) / (float64(a.maxValue) - float64(a.minValue))\n\t}\n\n\t// Update the last read values.\n\ta.lastValue = raw\n\ta.lastScaledValue = scaled\n\n\t// Return both the raw and scaled values.\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 52.12350253699284}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\tif a.AnalogSensor == nil {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor not connected\")\n\t}\n\tif!a.AnalogSensor.HasAnalog() {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor does not support analog reading\")\n\t}\n\tvalue, err := a.AnalogSensor.ReadAnalog()\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := a.scaleAnalogValue(value)\n\ta.lastRawValue = value\n\ta.lastScaledValue = scaledValue\n\treturn value, scaledValue, nil\n}", "CodeBleu_score": 42.826584171192}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.Lock()\n\tdefer a.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"Not connected\")\n\t}\n\n\tif!a.connection.SupportsAnalog() {\n\t\treturn 0, 0, errors.New(\"Connection does not support analog\")\n\t}\n\n\trawValue, err := a.connection.AnalogSensorRead(a.port)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaledValue := a.scaleValue(rawValue)\n\ta.lastReadRawValue = rawValue\n\ta.lastReadScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 48.3474643849086}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(d.Pin())\n\treturn d\n}", "CodeBleu_score": 33.94688415616846}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\treturn &GroveSoundSensorDriver{AnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...)}\n}", "CodeBleu_score": 23.90462439919489}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\td := &GroveSoundSensorDriver{AnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...)}\n\td.SetName(fmt.Sprintf(\"Grove Sound Sensor %s\", pin))\n\treturn d\n}", "CodeBleu_score": 36.37223359074135}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Soft reset\n\terr := d.writeRegister(CommandReg, PCD_RESETPHASE)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the PowerDown bit in CommandReg to be cleared\n\tfor {\n\t\tcommand, err := d.readRegister(CommandReg)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif command&(1<<4) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(1 * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 56.82251311895236}, {"code": "func (d *MFRC522Common) softReset() error{\n\t\t// Reset\n\tif err := d.writeRegister(CommandReg, PCD_RESETPHASE); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the PowerDown bit in CommandReg to be cleared\n\tfor {\n\t\tcommand, err := d.readRegister(CommandReg)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif command&PCD_RESETPHASE == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 58.12225844073345}, {"code": "func (d *MFRC522Common) softReset() error{\n\t", "CodeBleu_score": 2.257776667160384}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tn, err := d.readRegister(FIFO_LEVEL_REG)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\tif n > uint8(len(backData)) {\n\t\treturn 0, errors.New(\"fifo buffer overflow\")\n\t}\n\n\tif n == 0 {\n\t\treturn 0, errors.New(\"empty fifo buffer\")\n\t}\n\n\tfor i := uint8(0); i < n; i++ {\n\t\tbackData[i], err = d.readRegister(FIFO_DATA_REG)\n\t\tif err!= nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tlastBits, err := d.readRegister(CONTROL_REG)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\tlastBits = lastBits & 0x07\n\n\treturn lastBits, nil\n}", "CodeBleu_score": 50.35790911175981}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\tif len(backData) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tn := d.readRegister(d.FIFOLevelReg)\n\tif n > len(backData) {\n\t\treturn 0, errors.New(\"number of bytes available in the FIFO is less than the expected length of the byte slice\")\n\t}\n\n\tif n == 0 {\n\t\tn = 1\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i] = d.readRegister(d.FIFODataReg)\n\t}\n\n\treturn d.readRegister(d.ControlReg) & 0x07, nil\n}", "CodeBleu_score": 30.167174593088575}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t\t//Serial.print(F(\"Reading \")); Serial.print(n); Serial.println(F(\" bytes\"));\n\tif len(backData) == 0 {\n\t\treturn 0, errors.New(\"Nothing to read\")\n\t}\n\n\t//Serial.print(F(\"Reading \")); Serial.print(n); Serial.println(F(\" bytes\"));\n\tif len(backData) == 0 {\n\t\treturn 0, errors.New(\"Nothing to read\")\n\t}\n\n\t//Serial.println(F(\"Reading: \"));\n\tn := len(backData)\n\tif n > 64 {\n\t\treturn 0, errors.New(\"Can not read more than 64 bytes\")\n\t}\n\terr := d.readRegister(RegFIFOLevel, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tfifoLevel := backData[0]\n\tif fifoLevel < n {\n\t\treturn 0, errors.New(\"Can not read more than fifoLevel bytes\")\n\t}\n\n\terr = d.readRegister(RegFIFOData, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\n\t//Serial.print(F(\"Read \")); Serial.print(n); Serial.println(F(\" bytes\"));\n\t//dump_byte_array(backData, n);\n\n\t// Read the number of bits received\n\terr = d.readRegister(RegControl, backData)\n\tif err!= nil {\n\t\treturn 0, err\n\t}\n\tnBits := (backData[0] & 0x07) * 8\n\n\tif n > nBits {\n\t\treturn 0, errors.New(\"Can not read more than nBits bytes\")\n\t}\n\treturn nBits, nil\n}", "CodeBleu_score": 44.72682151797392}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tlog.Printf(\"piccHalt()\")\n\t// Build command buffer\n\tcmd := make([]byte, 2)\n\tcmd[0] = PICC_CMD_HALT\n\tcmd[1] = 0\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\n\t// Add CRC_A\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tHALT command, this response shall be interpreted as 'not acknowledge'.\n\t// We interpret that this way: Only ACK is nack.\n\tif err := d.write(cmd); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for all the PICCs in the field to return a max of 1 ms.\n\tif err := d.waitFor(1); err!= nil {\n\t\treturn err\n\t}\n\n\t// At this point the PICCs are halted.\n\t// Now we can send the next command.\n\n\treturn nil\n}", "CodeBleu_score": 29.04741237750344}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t", "CodeBleu_score": 1.2890370581259236}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t\tlog.Debug(\"piccHalt\")\n\t// Build command buffer\n\tcmd := []byte{\n\t\tMFRC522_PICC_CMD_HALT, // Code for HALT\n\t\t0,                     // Dummy; should be set to zero.\n\t}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC_A\n\tcmd = append(cmd, crc[0])\n\tcmd = append(cmd, crc[1])\n\t// Send the command.\n\t// The standard says:\n\t//\t\tIf the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\n\t//\t\tHALT command, this response shall be interpreted as 'not acknowledge'.\n\t// We interpret that this way: Only STATUS_TIMEOUT is an success, all other results are 'not acknowledge'\n\terr := d.transceive(cmd, true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.63927108213933}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\t// Read 16 bytes from the specified block\n\treturn d.piccReadValue(block, 16)\n}", "CodeBleu_score": 5.078907267975966}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tbuffer := make([]byte, 16)\n\tstatus := d.piccReadRaw(block, buffer)\n\tif status!= STATUS_OK {\n\t\treturn nil, errors.New(\"piccRead: \" + status.String())\n\t}\n\treturn buffer, nil\n}", "CodeBleu_score": 16.160365932571068}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t\tif block > 63 {\n\t\treturn nil, errors.New(\"Invalid block number\")\n\t}\n\n\t// Build command buffer\n\tcmd := []byte{PICC_READ, block}\n\tcrc := d.piccCalculateCRC(cmd)\n\tcmd = append(cmd, crc[0], crc[1])\n\n\t// Transmit command buffer to card\n\tif err := d.piccTransmit(cmd); err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Read response\n\tresp, err := d.piccReceive(18)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Check response\n\tif resp[0]!= PICC_READ {\n\t\treturn nil, errors.New(\"Invalid response\")\n\t}\n\tif resp[1]!= 0 {\n\t\treturn nil, errors.New(\"Invalid response\")\n\t}\n\tif resp[2]!= 16 {\n\t\treturn nil, errors.New(\"Invalid response\")\n\t}\n\tif resp[3]!= 0 {\n\t\treturn nil, errors.New(\"Invalid response\")\n\t}\n\n\t// Check CRC\n\tcrc = d.piccCalculateCRC(resp[0:16])\n\tif crc[0]!= resp[16] || crc[1]!= resp[17] {\n\t\treturn nil, errors.New(\"Invalid CRC\")\n\t}\n\n\t// Return data\n\treturn resp[4:16], nil\n}", "CodeBleu_score": 43.088169447691186}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Clear the collision register\n\td.write(RegColl, 0x80)\n\n\t// Set the request mode\n\terr := d.write(RegBitFraming, (reqMode<<4)&0x70)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the length of the answer buffer\n\terr = d.write(RegControl, 0x00)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Transceive the request\n\t_, err = d.transceive(piccRequestCmd, nil, answer)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check if the answer buffer is at least 2 bytes long\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"piccRequest: answer buffer too small\")\n\t}\n\n\t// Check if the PICC responded with a valid SAK\n\tif answer[0]!= 0x08 && answer[0]!= 0x00 {\n\t\treturn errors.New(\"piccRequest: invalid SAK\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.68362208337538}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\t// Clear the collision register\n\tif err := d.clearRegister(MFRC522_Coll); err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request mode\n\tif err := d.setRegister(MFRC522_BitFraming, reqMode); err!= nil {\n\t\treturn err\n\t}\n\n\t// Transceive the request command\n\tif err := d.transceive(MFRC522_PICC_REQA, answer); err!= nil {\n\t\treturn err\n\t}\n\n\t// Check the answer buffer length\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"piccRequest: invalid answer length\")\n\t}\n\n\t// Check the SAK\n\tsak := answer[0]\n\tif (sak & 0x04)!= 0x04 {\n\t\treturn errors.New(\"piccRequest: invalid SAK\")\n\t}\n\n\t// Return the status\n\treturn nil\n}", "CodeBleu_score": 61.191220552083806}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\t// Clear the collision register\n\terr := d.writeRegister(MFRC522RegisterColl, 0x80)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Set the request mode\n\treqMode &= 0x87\n\terr = d.writeRegister(MFRC522RegisterBitFraming, reqMode)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Transceive the request\n\treturn d.transceive(answer, MFRC522CommandTransceive, MFRC522StatusCodeOk, 0, 0)\n}", "CodeBleu_score": 52.47418904508147}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.stepPin.DigitalWrite(gpio.LOW); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Duration(d.stepDelay) * time.Millisecond)\n\tif err := d.stepPin.DigitalWrite(gpio.HIGH); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNum++\n\t} else {\n\t\td.stepNum--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 65.83319830907288}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.stepPin.DigitalWrite(false); err!= nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif err := d.stepPin.DigitalWrite(true); err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 68.12214984625685}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\t\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.DigitalWrite(false)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(time.Duration(d.delay) * time.Microsecond)\n\n\terr = d.stepPin.DigitalWrite(true)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 0 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 61.43147284302716}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.stopChan!= nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.stopChan = make(chan bool)\n\td.wg.Add(1)\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tticker := time.NewTicker(d.interval)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tdist, err := d.GetDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t} else {\n\t\t\t\t\td.distanceChan <- dist\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}", "CodeBleu_score": 36.63569234350635}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"Distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitorChan = make(chan bool)\n\td.distanceMonitorWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorWaitGroup.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWaitGroup.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopDistanceMonitorChan:\n\t\t\t\treturn\n\t\t\tcase <-time.After(d.distanceMonitorInterval):\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err!= nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\n\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distanceChan <- distance\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\n\treturn nil\n}", "CodeBleu_score": 47.0070701053057}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.monitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChan = make(chan bool)\n\td.monitorWaitGroup = new(sync.WaitGroup)\n\td.monitorWaitGroup.Add(1)\n\n\tgo d.startDistanceMonitor()\n\n\treturn nil\n}", "CodeBleu_score": 26.67643427664338}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, duration time.Duration, state string, timestamp uint32, tick uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else {\n\t\t\td.duration <- time.Since(start)\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.95647154586618}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar start time.Time\n\treturn func(pin int, timestamp time.Duration, state string, value uint32, timestamp1 uint32) {\n\t\tif state == \"rising\" {\n\t\t\tstart = timestamp\n\t\t} else if state == \"falling\" {\n\t\t\td.duration <- timestamp.Sub(start)\n\t\t\tstart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.33550684869069}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\t\tvar pulseStart time.Time\n\treturn func(pin int, timestamp time.Duration, pinEvent string, pinValue uint32, timestampValue uint32) {\n\t\tif pinEvent == \"rising\" {\n\t\t\tpulseStart = timestamp\n\t\t} else if pinEvent == \"falling\" {\n\t\t\td.pulseDuration <- timestamp.Sub(pulseStart)\n\t\t\tpulseStart = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.79555596989167}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\t// Lock the measurement mutex to ensure exclusive access.\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor by setting the trigger pin to high for 10 microseconds.\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\t// Wait for the echo pin to go high, indicating the start of the echo pulse.\n\tif err := d.echoPin.WaitForEdge(machine.PinEdgeRising, d.timeout); err!= nil {\n\t\treturn err\n\t}\n\n\t// Start the timer for measuring the pulse width.\n\td.timer.Reset()\n\td.timer.Start()\n\n\t// Wait for the echo pin to go low, indicating the end of the echo pulse.\n\tif err := d.echoPin.WaitForEdge(machine.PinEdgeFalling, d.timeout); err!= nil {\n\t\treturn err\n\t}\n\n\t// Stop the timer and store the measured time in microseconds.\n\td.timer.Stop()\n\td.measuredTime = d.timer.ReadMicroseconds()\n\n\treturn nil\n}", "CodeBleu_score": 53.045787211920825}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.trigger(); err!= nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tselect {\n\tcase <-d.measurementComplete:\n\t\t// Measurement complete\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// Timeout\n\t\treturn errors.New(\"timeout\")\n\t}\n}", "CodeBleu_score": 42.76233367717229}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\td.trigger()\n\ttimeout := time.After(d.timeout)\n\tselect {\n\tcase <-d.echo:\n\t\td.time = time.Since(d.startTime)\n\tcase <-timeout:\n\t\treturn errors.New(\"HCSR04Driver: timeout\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 41.4985403480085}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\t\n    try:\n        return self.fetch_authentication_token_from_env()\n    except AccountNotAuthorized:\n        try:\n            return self.fetch_authentication_token_from_local_state()\n        except AccountNotAuthorized:\n            try:\n                return self.fetch_authentication_token_from_refresh_token()\n            except AccountNotAuthorized:\n                raise\n\n", "CodeBleu_score": 11.44160934812417}, {"code": "def fetch_authentication_token(self)\n\t\n    if self.auth_token:\n        return self.auth_token\n\n    if self.local_state.get(\"access_token\") and self.local_state.get(\"access_token_expires_at\") > time.time():\n        self.auth_token = self.local_state[\"access_token\"]\n        return self.auth_token\n\n    if self.local_state.get(\"refresh_token\"):\n        try:\n            self.auth_token = self.fetch_json_data(\n                self.token_url,\n                method=\"POST\",\n                headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n                body={\n                    \"grant_type\": \"refresh_token\",\n                    \"refresh_token\": self.local_state[\"refresh_token\"],\n                    \"client_id\": self.client_id,\n                    \"client_secret\": self.client_secret,\n                },\n            )[\"access_token\"]\n            self.local_state[\"access_token\"] = self.auth_token\n            self.local_state[\"access_token_expires_at\"] = time.time() + 3600\n            self.local_state.save()\n            return self.auth_token\n        except HTTPClientError as exc:\n            if exc.status_code == 400:\n                self.local_state.clear()\n                self.local_state.save()\n            raise AccountNotAuthorized(exc) from exc\n\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 41.310300341281526}, {"code": "def fetch_authentication_token(self)\n\t\n    token = os.getenv(\"TOKEN\")\n    if token:\n        return token\n\n    local_state = self.load_local_state()\n    if local_state and local_state.get(\"expires_at\") and local_state.get(\"access_token\"):\n        if local_state[\"expires_at\"] > datetime.now().timestamp():\n            return local_state[\"access_token\"]\n\n    if local_state and local_state.get(\"refresh_token\"):\n        try:\n            response = self.fetch_json_data(\n                \"https://accounts.spotify.com/api/token\",\n                method=\"POST\",\n                headers={\n                    \"Authorization\": f\"Basic {base64.b64encode(f'{self.client_id}:{self.client_secret}'.encode()).decode()}\",\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                },\n                body=f\"grant_type=refresh_token&refresh_token={local_state['refresh_token']}\",\n            )\n        except HTTPClientError as exc:\n            if exc.status_code == 400:\n                raise AccountNotAuthorized(exc) from exc\n            raise\n\n        if response.get(\"access_token\"):\n            local_state[\"access_token\"] = response[\"access_token\"]\n            local_state[\"expires_at\"] = datetime.now().timestamp() + response[\"expires_in\"]\n            self.save_local_state(local_state)\n            return response[\"access_token\"]\n\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 41.1391976271731}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\t\n    refresh_token = self.session.get(\"refresh_token\")\n    self.session.clear()\n    if refresh_token:\n        try:\n            self.fetch_json_data(\n                \"POST\",\n                \"/v1/logout\",\n                data={\"refresh_token\": refresh_token},\n                allow_redirects=False,\n            )\n        except AccountError:\n            pass\n    return True", "CodeBleu_score": 56.79488971965677}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.session.cookies.get(\"refresh_token\")\n        self.session.delete(\"session\")\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            data={\"refresh_token\": refresh_token},\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 53.13949759811993}, {"code": "def logout(self)\n\t\n    try:\n        refresh_token = self.session.get(\"refresh_token\")\n        self.session.clear()\n        self.fetch_json_data(\n            \"POST\",\n            \"/v1/logout\",\n            data=json.dumps({\"refresh_token\": refresh_token}),\n            headers={\"Content-Type\": \"application/json\"},\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 45.934656185151326}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\t\n    result = []\n    for package in self.packages.values():\n        if package.optional:\n            continue\n        package_info = {\n            \"name\": package.name,\n            \"version\": package.version,\n            \"revision\": package.revision,\n            \"source_url\": package.source_url,\n        }\n        result.append(package_info)\n    return result\n\n", "CodeBleu_score": 34.17405844223178}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for pkg in self.pm.get_packages():\n        if not pkg.optional:\n            pkg_name = pkg.name\n            pkg_version = pkg.version\n            pkg_source_url = pkg.source_url\n            pkg_info = {\n                'name': pkg_name,\n               'version': pkg_version,\n               'source_url': pkg_source_url\n            }\n            packages.append(pkg_info)\n    return packages\n\n", "CodeBleu_score": 29.802153069779223}, {"code": "def dump_used_packages(self)\n\t\n    packages = []\n    for package in self.pm.get_packages():\n        if not package.optional:\n            package_info = {\n                \"name\": package.name,\n                \"version\": package.version,\n            }\n            if package.external:\n                package_info[\"source\"] = package.source\n            packages.append(package_info)\n    return packages\n\n", "CodeBleu_score": 29.501631498391617}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    env = env.lower()\n    if env not in cls.platforms:\n        raise exception.UndefinedEnvPlatformError(env, cls.platforms.keys())\n    platform = cls.platforms[env](autoinstall=autoinstall)\n    platform.configure(env, targets=targets)\n    return platform\n\n", "CodeBleu_score": 33.13332061186459}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    if not targets:\n        targets = []\n    env = env.lower()\n    if env not in cls.config.env:\n        raise exception.UndefinedEnvPlatformError(env, cls.config.env.keys())\n    platform = cls.config.env[env]\n    if not platform:\n        raise exception.UndefinedEnvPlatformError(env, cls.config.env.keys())\n    if autoinstall:\n        platform.autoinstall = True\n    env = cls(platform, env, targets)\n    env.configure_packages()\n    return env\n\n", "CodeBleu_score": 36.75279419846028}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\t\n    env_config = cls.project_config.get_env_config(env)\n    platform = env_config.get(\"platform\")\n    if not platform:\n        raise exception.UndefinedEnvPlatformError(env)\n    platform = platform.split(\"::\")\n    platform_cls = cls.platform_registry.get_platform_class(platform[0])\n    platform_spec = platform_cls.get_platform_spec(platform[1])\n    platform_spec[\"env\"] = env\n    platform_spec[\"autoinstall\"] = autoinstall\n    platform_spec[\"project_config\"] = cls.project_config\n    platform_spec[\"project_packages\"] = cls.project_packages\n    return cls(platform_spec, env_config, targets)\n\n", "CodeBleu_score": 32.00833225482912}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_I2C_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission();\n\tWire.requestFrom(AXP192_I2C_ADDRESS, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 63.0936843825611}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_ADDR);\n\tWire.write(Addr);\n\tWire.endTransmission(false);\n\tWire.requestFrom(AXP192_ADDR, Size);\n\tfor (uint8_t i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 59.716051890720045}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\t\tWire.beginTransmission(AXP192_ADDRESS);\n\tWire.write(Addr);\n\tWire.endTransmission(false);\n\tWire.requestFrom(AXP192_ADDRESS, Size);\n\tfor (int i = 0; i < Size; i++) {\n\t\tBuff[i] = Wire.read();\n\t}\n}", "CodeBleu_score": 62.283895510794984}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP_DEBUG\n    Serial.print(\"AXP192::DeepSleep: time_in_us: \");\n    Serial.println(time_in_us);\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x33, (uint8_t)(time_in_us >> 16));\n        Write1Byte(0x34, (uint8_t)(time_in_us >> 8));\n        Write1Byte(0x35, (uint8_t)(time_in_us));\n        Write1Byte(0x32, Read8bit(0x32) | (1 << 4));\n    } else {\n        Write1Byte(0x32, Read8bit(0x32) & ~(1 << 4));\n    }\n    Write1Byte(0x31, Read8bit(0x31) | (1 << 7));\n}", "CodeBleu_score": 53.70268578371955}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t#ifdef AXP192_DEBUG\n    Serial.println(\"Entering deep sleep\");\n#endif\n    SetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x33, 0x01);  // Enable timer\n        Write2Bytes(0x34, time_in_us);\n    } else {\n        Write1Byte(0x33, 0x00);  // Disable timer\n    }\n    Write1Byte(0x32, 0xC3);  // Initiate deep sleep\n}", "CodeBleu_score": 41.921832466663176}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t", "CodeBleu_score": 3.410829817826662}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\t#ifdef HAS_ILI9341\n  int16_t y = tft.getCursorY();\n  if (tteBar) {\n    if (y >= (tft.height() - tteBottom)) {\n      y = tteTop;\n    }\n  } else {\n    if (y >= (tft.height() - tteBottom)) {\n      y = 0;\n    }\n  }\n  tft.fillRect(0, y, tft.width(), tteHeight, color);\n  y += tteHeight;\n  scrollAddress(y);\n  return y;\n#endif\n}", "CodeBleu_score": 19.75572837883189}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y_old = y;\n\tif (tteBar) {\n\t\ttft.fillRect(0, 0, tft.width(), TOP_FIXED_AREA, color);\n\t\ty = TOP_FIXED_AREA;\n\t} else {\n\t\ttft.fillRect(0, y, tft.width(), LINE_HEIGHT, color);\n\t\ty += LINE_HEIGHT;\n\t\tif (y >= tft.height() - BOTTOM_FIXED_AREA) y = 0;\n\t}\n\tscrollAddress(y);\n\treturn y_old;\n}", "CodeBleu_score": 23.268750754739404}, {"code": "int Display::scroll_line(uint32_t color){\n\t\tint y = tteBar? 12 : 0;\n\tif (y >= (DISPLAY_HEIGHT - (tteBar? 12 : 0))) y = 0;\n\ttft.fillRect(0, y, DISPLAY_WIDTH, 8, color);\n\ty += 8;\n\tscrollAddress(y);\n\treturn y;\n}", "CodeBleu_score": 8.959988000799694}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->beginAP(ssids)) {\n\t\treturn false;\n\t}\n\n\tif (!this->beginHTML(access_points)) {\n\t\treturn false;\n\t}\n\n\tthis->startAP();\n\n\treturn true;\n}", "CodeBleu_score": 58.9654479140931}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tif (!this->setupAccessPoints(ssids)) {\n\t\treturn false;\n\t}\n\tif (!this->setupHTMLContent(access_points)) {\n\t\treturn false;\n\t}\n\tthis->startAP();\n\treturn true;\n}", "CodeBleu_score": 58.02047279323037}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t\tthis->ssids = ssids;\n\tthis->access_points = access_points;\n\n\t// setup access points\n\tif (!this->setupAPs()) {\n\t\treturn false;\n\t}\n\n\t// setup HTML content\n\tif (!this->setupHTML()) {\n\t\treturn false;\n\t}\n\n\t// start portal\n\tthis->startAP();\n\n\treturn true;\n}", "CodeBleu_score": 57.30817350942582}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue_in == NULL) {\n\t\t\tqueue_in = new Queue<GpsInterface_data_t>(queue_size);\n\t\t\tqueue_out = new Queue<GpsInterface_data_t>(queue_size);\n\t\t\tqueue_text = new Queue<GpsInterface_text_t>(queue_size);\n\t\t\tqueue_text_in = new Queue<GpsInterface_text_t>(queue_size);\n\t\t}\n\t\treturn;\n\t}\n\tqueue_enabled_flag = true;\n\tflush();\n}", "CodeBleu_score": 12.432749999889655}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tqueue_enabled_flag = true;\n\t\tqueue.flush();\n\t\ttext = \"\";\n\t\ttext_in = \"\";\n\t} else {\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 9.559354357707289}, {"code": "void GpsInterface::enable_queue(){\n\t\tif (queue_enabled_flag) {\n\t\tif (queue_is_empty()) {\n\t\t\tqueue.clear();\n\t\t\ttext = \"\";\n\t\t\ttext_in = \"\";\n\t\t}\n\t} else {\n\t\tqueue.clear();\n\t\ttext = \"\";\n\t\ttext_in = \"\";\n\t\tqueue_enabled_flag = true;\n\t}\n}", "CodeBleu_score": 11.489471079652123}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new Queue<NmeaSentence>();\n}", "CodeBleu_score": 36.66405110133526}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (queue_nmea!= NULL) {\n\t\tdelete queue_nmea;\n\t}\n\tqueue_nmea = new queue<string>();\n}", "CodeBleu_score": 36.38462407402785}, {"code": "void GpsInterface::flush_queue_nmea(){\n\t\tif (nmea_queue) {\n\t\tdelete nmea_queue;\n\t}\n\tnmea_queue = new queue<string>;\n}", "CodeBleu_score": 34.13250500691686}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\t/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n\n\tint32_t x, y;\n\tfor(y = area->y1; y <= area->y2; y++) {\n\t\tfor(x = area->x1; x <= area->x2; x++) {\n\t\t\t/* Put a pixel to the display. For example: */\n\t\t\tILI9341_DrawPixel(x, y, *color_p);\n\t\t\tcolor_p++;\n\t\t}\n\t}\n\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 37.85223737882237}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t\tuint16_t x, y;\n\tuint16_t w = (area->x2 - area->x1 + 1);\n\tuint16_t h = (area->y2 - area->y1 + 1);\n\tuint16_t *p = (uint16_t *)color_p;\n\n\t// Write the data to the display\n\tili9341_set_addr_window(area->x1, area->y1, w, h);\n\tili9341_write_data(p, w * h);\n\n\t// Notify the driver that flushing is complete\n\tlv_disp_flush_ready(disp);\n}", "CodeBleu_score": 37.217448352840634}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t", "CodeBleu_score": 3.2016194322392506}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < menu->getMenuList()->size(); i++) {\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"  \";\n\t\t}\n\t\tcout << menu->getMenuList()->at(i)->getName() << endl;\n\t\tshowMenuList(menu->getMenuList()->at(i), layer + 1);\n\t}\n\tcout << endl;\n}", "CodeBleu_score": 45.89618676609511}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\tif (menu == NULL) {\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < layer; i++) {\n\t\tcout << \"    \";\n\t}\n\tcout << menu->getName() << endl;\n\tfor (int i = 0; i < menu->getMenuList().size(); i++) {\n\t\tshowMenuList(menu->getMenuList()[i], layer + 1);\n\t}\n\tif (menu->getMenuList().size() == 0) {\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tcout << \"    \";\n\t\t}\n\t\tcout << \"    \" << menu->getName() << endl;\n\t}\n}", "CodeBleu_score": 46.47675930859761}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\t\t// Iterates through all menu nodes and prints each node's name with indentation proportional to the layer level.\n\tfor (int i = 0; i < menu->getMenuNodes().size(); i++) {\n\t\t// Prints the node name with indentation proportional to the layer level.\n\t\tfor (int j = 0; j < layer; j++) {\n\t\t\tcout << \"   \";\n\t\t}\n\t\tcout << menu->getMenuNodes()[i]->getName() << endl;\n\t\t// If the node is a menu, it recursively calls the function for the submenu.\n\t\tif (menu->getMenuNodes()[i]->getType() == \"menu\") {\n\t\t\tshowMenuList(dynamic_cast<Menu*>(menu->getMenuNodes()[i]), layer + 1);\n\t\t}\n\t}\n\t// Prints an empty line.\n\tcout << endl;\n}", "CodeBleu_score": 44.57668275872342}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint ssidCount = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = generateRandomSSID();\n\t\tint channel = generateRandomChannel();\n\t\tString mac = generateRandomMAC();\n\t\taddSSID(ssid, channel, mac);\n\t\tssidCount++;\n\t}\n\treturn ssidCount;\n}", "CodeBleu_score": 25.939606360238294}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint generated = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tString ssid = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tchar c = (char) random(97, 123);\n\t\t\tssid += c;\n\t\t}\n\t\tint channel = random(1, 14);\n\t\tString mac = \"\";\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tchar c = (char) random(48, 58);\n\t\t\tmac += c;\n\t\t\tif (j < 5) mac += \":\";\n\t\t}\n\t\tgenerated++;\n\t\tSerial.println(\"SSID: \" + ssid + \" | Channel: \" + String(channel) + \" | MAC: \" + mac);\n\t}\n\treturn generated;\n}", "CodeBleu_score": 40.5245522076626}, {"code": "int WiFiScan::generateSSIDs(int count){\n\t\tint i;\n\tint channel;\n\tString mac;\n\tString ssid;\n\tfor (i = 0; i < count; i++) {\n\t\tchannel = random(1, 14);\n\t\tmac = randomMAC();\n\t\tssid = randomSSID();\n\t\tSerial.print(\"SSID: \");\n\t\tSerial.print(ssid);\n\t\tSerial.print(\" Channel: \");\n\t\tSerial.print(channel);\n\t\tSerial.print(\" MAC: \");\n\t\tSerial.println(mac);\n\t\taddSSID(ssid, channel, mac);\n\t}\n\treturn i;\n}", "CodeBleu_score": 35.53997125793822}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 48.4204446846163}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}, {"code": "def create_topic(project_id, topic_name)\n\t\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.876354332507866}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    token = {\n        'iat': datetime.datetime.utcnow(),\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 56.64796094364441}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    iat = datetime.utcnow()\n    exp = iat + timedelta(minutes=60)\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    return encoded_jwt.decode(\"utf-8\")\n\n", "CodeBleu_score": 45.617794421224275}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t\n    # Create a JWT using the project ID as the audience, the current time as the issued at time, and an expiration time of 1 hour from now.\n    iat = datetime.utcnow()\n    exp = iat + timedelta(hours=1)\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": project_id,\n    }\n    # Read the private key from the specified file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    # Create a JWT using the specified algorithm.\n    jwt = encode(payload, private_key, algorithm=algorithm)\n    return jwt.decode(\"utf-8\")\n\n", "CodeBleu_score": 42.616641708607396}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode('utf-8'))\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        preview_capture(os.path.join(os.path.dirname(__file__), 'image.jpg'))\n        image_url = upload_file(os.path.join(os.path.dirname(__file__), 'image.jpg'), args.bucket_name)\n        print('Image uploaded to {}'.format(image_url))\n        publish_event(image_url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 49.16609544607707}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    payload = str(message.payload.decode('utf-8'))\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(payload, message.topic, str(message.qos)))\n    if payload == 'on':\n        print('Capturing image')\n        preview_capture('preview.jpg')\n        print('Uploading file to bucket')\n        url = upload_file('preview.jpg', args.bucket_name)\n        print('Publishing URL to event topic')\n        publish_event(url)\n    else:\n        print('off')\n\n", "CodeBleu_score": 41.02074158667879}, {"code": "def on_message(unused_client, unused_userdata, message)\n\t\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        message.payload, message.topic, str(message.qos)))\n    if message.payload.decode('utf-8') == 'on':\n        print('Turning on the camera')\n        preview_capture('image.jpg')\n        print('Uploading image to Cloud Storage')\n        url = upload_file('image.jpg', args.bucket_name)\n        print('Publishing image URL to Cloud IoT Core')\n        publish_event(args.project_id, args.cloud_region, args.registry_id, args.device_id, 'image', url)\n    else:\n        print('Turning off the camera')\n\n", "CodeBleu_score": 39.901457471720015}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection via MQTT\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        default=\"test-registry\",\n        help=\"Cloud IoT registry name\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        default=\"test-device\",\n        help=\"Cloud IoT device name\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=\"rsa_private.pem\",\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Which type of message to publish.\",\n    )\n    parser.add_argument(\n        \"--message_data\",\n        default=\"Hello World\",\n        help=\"The message data to publish.\",\n    )\n    parser.add_argument(\n        \"--gateway_id\",\n        default=\"test-gateway\",\n        help=\"Gateway ID\",\n    )\n    parser.add_argument(\n        \"--gateway_region\",\n        default=\"us-central1\",\n        help=\"Gateway region\",\n    )\n    parser.add_argument(\n        \"--gateway", "CodeBleu_score": 35.44552529210156}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT device connection.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region.\",\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        required=True,\n        help=\"Cloud IoT Core registry ID.\",\n    )\n    parser.add_argument(\n        \"--device_id\",\n        required=True,\n        help=\"Cloud IoT Core device ID.\",\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=os.path.join(\n            os.path.dirname(__file__),\n            \"rsa_private.pem\",\n        ),\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=os.path.join(\n            os.path.dirname(__file__),\n            \"roots.pem\",\n        ),\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\",\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Indicates whether the message to be published is a 'event' or a'state'.\",\n    )\n    parser.add_argument(\n        \"--jwt_expires_minutes\",\n        type=int,\n        default=20,\n        help=\"Expiration time, in minutes, for JWT tokens.\",\n    )\n    parser.add_argument(\n        \"--", "CodeBleu_score": 37.2149926949361}, {"code": "def parse_command_line_args()\n\t\n    parser = argparse.ArgumentParser(\n        description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name\")\n    parser.add_argument(\n        \"--subscription_name\",\n        default=\"projects/{}/subscriptions/{}\".format(os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), \"sub-1\"),\n        required=True,\n        help=\"Pub/Sub subscription name\")\n    parser.add_argument(\n        \"--algorithm\", choices=(\"RS256\", \"ES256\"), required=True, help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\")\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\")\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        default=8883,\n        help=\"MQTT bridge port.\")\n    parser.add_argument(\n        \"--client_id\",\n        default=\"projects/{}/locations/{}/registries/{}/devices/{}\".format(os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), \"us-central1\", \"my-registry\", \"my-device\"),\n        help=\"MQTT client id.\")\n    parser.add_argument(\n        \"--cloud_region\",\n        default=\"us-central1\",\n        help=\"GCP cloud region\")\n    parser.add_argument(\n        \"--registry_id\",\n        default=\"my-registry\",\n        help=\"Cloud IoT registry id\")\n    parser.add_argument(\n        \"--device_id\",\n        default=\"my-device\",\n        help=\"Cloud IoT device id\")\n    parser.add_argument(\n        \"--private_key_file\",\n        default=\"rsa_private.pem\",\n        help=\"Path to private key file.\")\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Which topic to publish to.\")\n    parser.", "CodeBleu_score": 38.02682123277417}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\t\n    # Create a client for the Google Cloud IoT Core service using the discovery API URL.\n    client = discovery.build(\n        'cloudiot',\n        'v1',\n        discoveryServiceUrl=DISCOVERY_API_URL,\n        credentials=service_account.Credentials.from_service_account_file(\n            service_account_json,\n            scopes=SCOPES,\n        ),\n    )\n    return client\n\n", "CodeBleu_score": 9.290565959746736}, {"code": "def get_client(service_account_json)\n\t\n    # Create a client for the Cloud IoT Core service.\n    # https://cloud.google.com/iot/docs/how-tos/getting-started\n    # https://cloud.google.com/iot/docs/reference/cloudiot/rest/\n    # https://cloud.google.com/iot/docs/reference/libraries/\n    # https://googleapis.github.io/google-api-python-client/docs/dyn/cloudiot_v1.projects.locations.registries.html\n\n    # The service account needs the following roles:\n    # - roles/cloudiot.admin\n    # - roles/pubsub.publisher\n    # - roles/pubsub.subscriber\n    # - roles/pubsub.viewer\n    # - roles/viewer\n    # - roles/pubsub.admin\n    # - roles/iam.serviceAccountUser\n    # - roles/iam.serviceAccountTokenCreator\n    # - roles/iam.serviceAccountKeyAdmin\n    # - roles/iam.serviceAccountAdmin\n\n    # The service account needs the following scopes:\n    # - https://www.googleapis.com/auth/cloud-platform\n    # - https://www.googleapis.com/auth/pubsub\n\n    # The service account needs the following API enabled:\n    # - Cloud IoT Core API\n    # - Cloud Pub/Sub API\n\n    # The service account needs the following permissions:\n    # - cloudiot.registries.getIamPolicy\n    # - cloudiot.registries.setIamPolicy\n    # - cloudiot.registries.create\n    # - cloudiot.registries.get\n    # - cloudiot.registries.update\n    # - cloudiot.registries.delete\n    # - cloudiot.devices.create\n    # - cloudiot.devices.get\n    # - cloudiot.devices.update\n    # - cloudiot.devices.delete\n    # - cloudiot.devices.getIamPolicy\n    # - cloudiot.devices.setIamPolicy\n    # - cloudiot.devices.sendCommandToDevice\n    # - cloudiot.devices.bindDeviceToGateway\n    # - cloudiot.devices.unbindDeviceFromGateway\n    # - pubsub.topics.attachSubscription\n    # - pubsub.topics.create\n    # - pubsub.topics.delete\n    # - pubsub.topics.get\n    # - pubsub.topics.getIamPolicy\n    # - pubsub.topics.list\n    # - pubsub.topics.publish\n    # - pubsub", "CodeBleu_score": 0.625}, {"code": "def get_client(service_account_json)\n\t\n    # Create a client for the Cloud IoT Core service using the discovery API URL.\n    client = discovery.build(\n        serviceName=\"cloudiot\",\n        version=\"v1\",\n        discoveryServiceUrl=\"https://cloudiot.googleapis.com/$discovery/rest\",\n        credentials=service_account.Credentials.from_service_account_file(\n            service_account_json,\n            scopes=[\n                \"https://www.googleapis.com/auth/cloud-platform\",\n                \"https://www.googleapis.com/auth/cloudiot\",\n            ],\n        ),\n    )\n    return client\n\n", "CodeBleu_score": 29.627825192678003}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  if hash_method =='sha1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method =='sha256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method =='sha384':\n        asn1_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method =='sha512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n\n    asn1_hash = b''.join([asn1_code, hash_value])\n    padded_hash = _pad_for_signing(asn1_hash, priv_key.size_in_bytes())\n    return priv_key.encrypt(padded_hash, None)[0]\n\n", "CodeBleu_score": 27.357271834644802}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t  if hash_method =='sha1':\n        asn1_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method =='sha256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method =='sha512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    hash_asn1 = asn1_code + hash_value\n    padded_hash = _pad_for_signing(hash_asn1, priv_key.size_in_bytes())\n    return priv_key.encrypt(padded_hash, 0)[0]\n\n", "CodeBleu_score": 22.954023442029488}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t   asn1_code = _ASN1_CODES[hash_method]\n    if not asn1_code:\n        raise ValueError('Invalid hash method')\n\n    hash_asn1 = b''.join([asn1_code, hash_value])\n    hash_asn1_padded = _pad_for_signing(hash_asn1, priv_key.size_in_bytes())\n\n    return priv_key.encrypt(hash_asn1_padded, padding.PKCS1v15())\n\n", "CodeBleu_score": 25.438212476660066}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t try:\n        # convert the signature to an integer\n        sig_int = int.from_bytes(signature, byteorder='big')\n\n        # decrypt the signature\n        clearsig = pub_key.decrypt(sig_int)\n\n        # determine the hash method\n        method_name = _find_method_hash(clearsig)\n\n        # compute the hash of the message\n        message_hash = compute_hash(message, method_name)\n\n        # reconstruct the expected padded hash\n        expected_padded_hash = _pad_for_signing(message_hash, len(clearsig))\n\n        # verify the signature\n        if clearsig!= expected_padded_hash:\n            raise VerificationError('Verification failed')\n\n        return method_name\n    except ValueError:\n        raise VerificationError('Verification failed')\n", "CodeBleu_score": 51.125566083930096}, {"code": "def verify(message, signature, pub_key)\n\t if isinstance(signature, str):\n        signature = signature.encode()\n    if isinstance(message, str):\n        message = message.encode()\n    if isinstance(pub_key, str):\n        pub_key = pub_key.encode()\n    if isinstance(message, bytes):\n        message = BytesIO(message)\n    if isinstance(signature, bytes):\n        signature = BytesIO(signature)\n    if isinstance(pub_key, bytes):\n        pub_key = BytesIO(pub_key)\n    if isinstance(message, BytesIO):\n        message = message.read()\n    if isinstance(signature, BytesIO):\n        signature = signature.read()\n    if isinstance(pub_key, BytesIO):\n        pub_key = pub_key.read()\n    if isinstance(message, str):\n        message = message.encode()\n    if isinstance(signature, str):\n        signature = signature.encode()\n    if isinstance(pub_key, str):\n        pub_key = pub_key.encode()\n    if isinstance(message, bytes):\n        message = BytesIO(message)\n    if isinstance(signature, bytes):\n        signature = BytesIO(signature)\n    if isinstance(pub_key, bytes):\n        pub_key = BytesIO(pub_key)\n    if isinstance(message, BytesIO):\n        message = message.read()\n    if isinstance(signature, BytesIO):\n        signature = signature.read()\n    if isinstance(pub_key, BytesIO):\n        pub_key = pub_key.read()\n    if isinstance(message, str):\n        message = message.encode()\n    if isinstance(signature, str):\n        signature = signature.encode()\n    if isinstance(pub_key, str):\n        pub_key = pub_key.encode()\n    if isinstance(message, bytes):\n        message = BytesIO(message)\n    if isinstance(signature, bytes):\n        signature = BytesIO(signature)\n    if isinstance(pub_key, bytes):\n        pub_key = BytesIO(pub_key)\n    if isinstance(message, BytesIO):\n        message = message.read()\n    if isinstance(signature, BytesIO):\n        signature = signature.read()\n    if isinstance(pub_key, BytesIO):\n        pub_key = pub_key.read()\n    if isinstance(message, str):\n        message = message.encode()\n    if isinstance(signature, str):\n        signature = signature.encode()\n    if isinstance(pub", "CodeBleu_score": 23.246175900759457}, {"code": "def verify(message, signature, pub_key)\n\t # Convert the signature to an integer\n    signature_int = int.from_bytes(signature, byteorder='big')\n\n    # Decrypt the signature using the public key\n    clearsig = pub_key.decrypt(signature_int)\n\n    # Determine the hash method used\n    hash_method = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    message_hash = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(message_hash, pub_key.size_in_bytes())\n\n    # Check if the expected padded hash matches the clear signature\n    if clearsig!= expected_padded_hash:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n", "CodeBleu_score": 24.066414400923524}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t\tuint8_t res = 0;\n\tuint32_t epoch = 0;\n\tepoch = getTime();\n\tif (epoch > 0) {\n\t\tupdateJWT(epoch);\n\t\tres = connectToMQTTClient();\n\t\tmqttSubscribe = true;\n\t\tdebug_printInfo(\"MQTT: Connecting to MQTT broker\");\n\t} else {\n\t\tdebug_printError(\"MQTT: Failed to get time\");\n\t}\n}", "CodeBleu_score": 22.42795699685739}, {"code": "static void connectMQTT(){\n\t\tuint32_t epoch = 0;\n\tuint8_t res = 0;\n\n\tdebug_printInfo(\"MQTT: Connecting...\");\n\tres = CRYPTO_CLIENT_getTime(&epoch);\n\tif (res == 0) {\n\t\tupdateJWT(epoch);\n\t\tconnectMQTTClient();\n\t\tmqttSubscribe = 1;\n\t} else {\n\t\tdebug_printError(\"MQTT: Error getting time\");\n\t}\n}", "CodeBleu_score": 20.49487828336049}, {"code": "static void connectMQTT(){\n\t\tif (timeValid) {\n\t\tupdateJWT(timeClient.getEpoch());\n\t}\n\tmqttClient.connect(cid, projectId, mqttPassword);\n\tmqttSubscribe = true;\n\tdebug_printInfo(\"MQTT: Connecting\");\n}", "CodeBleu_score": 42.48522629778007}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (str[i] < '0' || str[i] > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + str[i] - '0';\n\t}\n\t*num = n;\n\treturn str + width;\n}", "CodeBleu_score": 26.761317409199957}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tconst uint8_t* s = str;\n\tuint32_t n = 0;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tif (!isdigit(*s)) {\n\t\t\treturn str;\n\t\t}\n\t\tn = n * 10 + (*s - '0');\n\t\ts++;\n\t}\n\t*num = n;\n\treturn s;\n}", "CodeBleu_score": 27.917930162444506}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\t\tuint32_t result = 0;\n\tuint8_t c;\n\tint i;\n\tfor (i = 0; i < width; i++) {\n\t\tc = str[i];\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tresult = result * 10 + (c - '0');\n\t}\n\t*num = result;\n\treturn str + width;\n}", "CodeBleu_score": 28.73818854308397}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\t", "CodeBleu_score": 3.0838444091196067}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t#if ATCA_CA_SUPPORT\n    int ret = ATCA_SUCCESS;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCA_BAD_PARAM;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcah_verify_extern(ca_public_key, tbs_digest, signature);\n    if (ret!= ATCA_SUCCESS) {\n        return ret;\n    }\n\n    return ATCA_SUCCESS;\n#else\n    return ATCA_FUNC_NOT_SUPPORTED;\n#endif\n}", "CodeBleu_score": 75.14184449813821}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t\tint ret = 0;\n\tuint8_t tbs_digest[32];\n\tuint8_t signature[64];\n\tuint8_t signature_size = 0;\n\tuint8_t signature_offset = 0;\n\n\tif (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n\t\treturn ATCACERT_E_BAD_PARAMS;\n\t}\n\n\tret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size, &signature_offset);\n\tif (ret!= ATCACERT_E_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = atcah_verify_extern(tbs_digest, signature, ca_public_key);\n\n\treturn ret;\n}", "CodeBleu_score": 70.14447302317296}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\t#if defined(ATCA_HAL_I2C) || defined(ATCA_HAL_SPI) || defined(ATCA_HAL_KIT_HID)\n    atcacert_verify_cert_params_t verify_params;\n    int                           ret = 0;\n\n    verify_params.cert_def = cert_def;\n    verify_params.cert     = cert;\n    verify_params.cert_size = cert_size;\n    verify_params.ca_public_key = ca_public_key;\n    verify_params.ca_public_key_size = sizeof(verify_params.ca_public_key);\n    verify_params.verify_cert_cb = atcacert_verify_cert_hw_impl;\n    verify_params.verify_cert_ctx = NULL;\n    ret = atcacert_verify_cert(&verify_params);\n\n    return ret;\n#else\n    return ATCACERT_E_NOT_IMPLEMENTED;\n#endif\n}", "CodeBleu_score": 32.96459675635863}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t//    if(timer == NULL)\n//        return false;\n    if(timer == listHead)\n    {\n        listHead = timer->next;\n        if(listHead == NULL)\n        {\n            stopTimeouts();\n            return true;\n        }\n        else\n        {\n            startTimerAtHead();\n            return true;\n        }\n    }\n\n    timerStruct_t *current = listHead;\n    timerStruct_t *previous = NULL;\n    while(current!= NULL)\n    {\n        if(current == timer)\n        {\n            previous->next = current->next;\n            if(current->next == NULL)\n            {\n                stopTimeouts();\n                return true;\n            }\n            else\n            {\n                startTimerAtHead();\n                return true;\n            }\n        }\n        previous = current;\n        current = current->next;\n    }\n    return false;\n}", "CodeBleu_score": 49.51459613318476}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t\ttimerStruct_t * volatile *prev = list;\n\twhile (*prev!= NULL) {\n\t\tif (*prev == timer) {\n\t\t\t*prev = timer->next;\n\t\t\treturn true;\n\t\t}\n\t\tprev = &(*prev)->next;\n\t}\n\treturn false;\n}", "CodeBleu_score": 19.61387989735918}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\t//    if(timer == NULL)\n//        return false;\n    if(timer == NULL)\n    {\n        return false;\n    }\n\n    if(timer->prev!= NULL)\n    {\n        timer->prev->next = timer->next;\n    }\n    else\n    {\n        *list = timer->next;\n    }\n\n    if(timer->next!= NULL)\n    {\n        timer->next->prev = timer->prev;\n    }\n\n    timer->prev = NULL;\n    timer->next = NULL;\n    return true;\n}", "CodeBleu_score": 21.549395096786295}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\ttstrSocket* pstrSocket = NULL;\n\tsint8 s8Ret = SOCK_ERR_INVALID;\n\tif (socket < 0 || socket >= MAX_BSD_SOCKETS) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tpstrSocket = &gastrSockets[socket];\n\tif (pstrSocket->bIsUsed == 0) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tpstrSocket->bIsUsed = 0;\n\ts8Ret = close(socket);\n\tif (s8Ret == SOCK_ERR_NO_ERROR) {\n\t\treturn BSD_SUCCESS;\n\t}\n\tif (s8Ret == SOCK_ERR_INVALID) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t} else if (s8Ret == SOCK_ERR_INVALID_ARG) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t} else {\n\t\tbsd_setErrNo(BSD_EIO);\n\t}\n\treturn BSD_ERROR;\n}", "CodeBleu_score": 47.78469124122943}, {"code": "int BSD_close(int socket){\n\ttstrSocket *pstrSocket = NULL;\n\tsint8 ret;\n\n\tpstrSocket = bsd_getSocket(socket);\n\tif (pstrSocket == NULL) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\n\tif (pstrSocket->socketState == NOT_A_SOCKET) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\n\tret = close(socket);\n\tif (ret!= SOCK_ERR_NO_ERROR) {\n\t\tif (ret == SOCK_ERR_INVALID) {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_EIO);\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\n\tpstrSocket->socketState = NOT_A_SOCKET;\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 48.87950175353634}, {"code": "int BSD_close(int socket){\n\tsint8 ret;\n\ttstrSocket *pstrSocket;\n\tpstrSocket = bsd_getSocket(socket);\n\tif (pstrSocket == NULL) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tpstrSocket->state = BSD_NOT_A_SOCKET;\n\tret = close(socket);\n\tif (ret == SOCK_ERR_INVALID_ARG) {\n\t\tbsd_setErrNo(BSD_EBADF);\n\t\treturn BSD_ERROR;\n\t}\n\tif (ret == SOCK_ERR_INVALID) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 45.498019747655825}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tsint8\ts8Ret;\n\tuint8\tu8Backlog = backlog;\n\n\ts8Ret = listen(socket, u8Backlog);\n\n\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(s8Ret);\n\t\treturn BSD_ERROR;\n\t}\n\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 25.717735513733906}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8\ts8Ret;\n\tsint8\ts8Error;\n\n\ts8Ret = listen(socket, backlog);\n\n\tif(s8Ret!= SOCK_ERR_NO_ERROR)\n\t{\n\t\ts8Error = bsd_getErrNo();\n\t\tif(s8Error == SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 32.76645889041209}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8 s8Ret = SOCK_ERR_INVALID_ARG;\n\n\tif (socket >= 0 && (gastrSockets[socket].bIsUsed == 1)) {\n\t\ttstrListenCmd strListen;\n\n\t\tstrListen.sock = socket;\n\t\tstrListen.u8BackLog = backlog;\n\t\tstrListen.u16SessionID = gastrSockets[socket].u16SessionID;\n\n\t\ts8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8 *) &strListen,\n\t\t\t\tsizeof(tstrListenCmd), NULL, 0, 0);\n\t\tif (s8Ret!= SOCK_ERR_NO_ERROR) {\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 36.56807210170549}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t", "CodeBleu_score": 6.68431387677649}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint ret = 0;\n\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)addr;\n\n\tif (addr->sa_family!= AF_INET) {\n\t\tbsd_setErrNo(BSD_EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\n\tret = accept(socket, (struct sockaddr *)addr_in, addrlen);\n\tif (ret == -1) {\n\t\tif (socket < 0) {\n\t\t\tbsd_setErrNo(BSD_EBADF);\n\t\t} else {\n\t\t\tbsd_setErrNo(BSD_ECONNABORTED);\n\t\t}\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 33.144625502413874}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\t\tint s8Ret = SOCK_ERR_INVALID_ARG;\n\tstruct sockaddr_in * addr_in = (struct sockaddr_in *) addr;\n\n\tif (addr == NULL || addrlen == NULL) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn SOCK_ERR_INVALID_ARG;\n\t}\n\n\tif (addr_in->sin_family!= AF_INET) {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t\treturn SOCK_ERR_INVALID_ARG;\n\t}\n\n\tif (socket >= 0 && (gastrSockets[socket].bIsUsed == 1)) {\n\t\ts8Ret = accept(socket, (struct sockaddr *) addr, addrlen);\n\t} else {\n\t\tbsd_setErrNo(BSD_EINVAL);\n\t}\n\n\treturn s8Ret;\n}", "CodeBleu_score": 35.94678198202536}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\t\tdebug_printInfo(\"MQTT: Connecting\");\n\t// get the current time\n\ttime_t now;\n\ttime(&now);\n\tif (now < 1510592825) {\n\t\t// set a default time if not valid\n\t\tnow = 1510592825;\n\t}\n\tupdateJWT(now);\n\t// connect to the broker\n\tmqtt_connect(&client, &broker, cid, NULL, mqttPassword, 0, 0, mqtt_connected, 0);\n\t// set a flag to send a subscribe packet once connected\n\tsubscribe_sent = 0;\n}", "CodeBleu_score": 42.01531729122291}, {"code": "static void connectMQTT(){\n\t\tdebug_printInfo(\"MQTT: Connecting to MQTT broker\");\n\n\tuint32_t epoch = 0;\n\tif (CRYPTO_CLIENT_getTime(&epoch) == 0) {\n\t\tupdateJWT(epoch);\n\t} else {\n\t\tdebug_printError(\"MQTT: Failed to get time\");\n\t}\n\n\tif (epoch > 0) {\n\t\tmqtt_connect(epoch);\n\t\tmqtt_subscribe_flag = 1;\n\t}\n}", "CodeBleu_score": 43.14039657440217}, {"code": "static void connectMQTT(){\n\t\tint8_t ret = 0;\n\tuint32_t epoch = 0;\n\tuint8_t res = 0;\n\tuint8_t tries = 0;\n\n\twhile (tries < 5) {\n\t\tepoch = getEpoch();\n\t\tif (epoch!= 0) {\n\t\t\tbreak;\n\t\t}\n\t\ttries++;\n\t\tdebug_printError(\"MQTT: Failed to get epoch time, retrying...\");\n\t\tdelay(1000);\n\t}\n\n\tif (epoch == 0) {\n\t\tdebug_printError(\"MQTT: Failed to get epoch time, exiting...\");\n\t\treturn;\n\t}\n\n\tupdateJWT(epoch);\n\n\tdebug_printInfo(\"MQTT: Connecting to %s:%d...\", mqttBroker, mqttPort);\n\tret = client.connect(mqttClientId, mqttUsername, mqttPassword);\n\tif (ret!= 0) {\n\t\tdebug_printError(\"MQTT: Failed to connect, rc=%d, retrying...\", ret);\n\t\tdelay(5000);\n\t\treturn;\n\t}\n\n\tdebug_printInfo(\"MQTT: Connected!\");\n\tmqttConnected = true;\n\tmqttSubscribe = true;\n}", "CodeBleu_score": 29.2620554670326}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\t#if defined(MQTT_DEBUG)\n   debug_printf(\"CLOUD_disconnect: Disconnecting from the cloud service\n\");\n#endif\n   if (mqttState == CONNECTED) {\n      mqttContext* connectionInfo = getMQTTConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 54.25459329803848}, {"code": "void CLOUD_disconnect(void){\n\t\tmqttContext connectionInfo;\n\tMQTT_GetClientConnectionInfo(&connectionInfo);\n\tif (mqttState == CONNECTED) {\n\t\tmqttState = MQTT_Disconnect(&connectionInfo);\n\t\tDEBUG_print(\"MQTT Disconnected\");\n\t}\n}", "CodeBleu_score": 48.90040117009054}, {"code": "void CLOUD_disconnect(void){\n\t#if (CLOUD_DEBUG == 1)\n   debug_printf(\"CLOUD_disconnect\n\");\n#endif\n\n   if (mqttState == CONNECTED) {\n      mqttContext* connectionInfo = mqttGetClientConnectionInfo();\n      MQTT_Disconnect(connectionInfo);\n   }\n}", "CodeBleu_score": 55.92475938352058}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret;\n\tuint8_t u8SecType = M2M_WIFI_SEC_INVALID;\n\ttstrM2mWifiConnInfo conn_info;\n\tmemset(&conn_info, 0, sizeof(tstrM2mWifiConnInfo));\n\tif (passed_wifi_creds) {\n\t\t// Connect to a new access point\n\t\tswitch (wifi_settings.security) {\n\t\tcase WIFI_SECURITY_OPEN:\n\t\t\tu8SecType = M2M_WIFI_SEC_OPEN;\n\t\t\tbreak;\n\t\tcase WIFI_SECURITY_WEP:\n\t\t\tu8SecType = M2M_WIFI_SEC_WEP;\n\t\t\tbreak;\n\t\tcase WIFI_SECURITY_WPA_PSK:\n\t\t\tu8SecType = M2M_WIFI_SEC_WPA_PSK;\n\t\t\tbreak;\n\t\tcase WIFI_SECURITY_WPA2_PSK:\n\t\t\tu8SecType = M2M_WIFI_SEC_WPA_WPA2_PSK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tu8SecType = M2M_WIFI_SEC_INVALID;\n\t\t\tbreak;\n\t\t}\n\t\tconn_info.u8SecType = u8SecType;\n\t\tconn_info.u8Ch = wifi_settings.channel;\n\t\tmemcpy(conn_info.au8SSID, wifi_settings.ssid, sizeof(wifi_settings.ssid));\n\t\tconn_info.u8SsidLen = strlen((char *)wifi_settings.ssid);\n\t\tconn_info.u8PmkLen = wifi_settings.password_len;\n\t\tmemcpy(conn_info.au8PMK, wifi_settings.password, sizeof(wifi_settings.password));\n\t\tret = m2m_wifi_connect(&conn_info);\n\t} else {\n\t\t// Connect to the default access point\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret!= M2M_SUCCESS) {\n\t\tlog_printf(\"Failed to connect to Wi-Fi access point.\n\");\n\t\tnetworking_error = true;\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 47.21246463199935}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret;\n\tif (passed_wifi_creds == 1) {\n\t\tret = m2m_wifi_connect(WIFI_SSID, strlen(WIFI_SSID), WIFI_AUTH, (void*)WIFI_PASS, WIFI_CHANNEL);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret!= M2M_SUCCESS) {\n\t\tprintf(\"m2m_wifi_connect call error!(%d)\\r\n\", ret);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.32432531475056}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t\tsint8 ret;\n\tif (passed_wifi_creds == 1) {\n\t\tret = m2m_wifi_connect(wifi_ssid, M2M_strlen(wifi_ssid), wifi_security, (void*) wifi_password, wifi_channel);\n\t} else {\n\t\tret = m2m_wifi_default_connect();\n\t}\n\tif (ret!= M2M_SUCCESS) {\n\t\tprintf(\"wifi_connectToAp: m2m_wifi_connect call failed!\\r\n\");\n\t\tupdate_networking_error_status(1);\n\t\treturn false;\n\t}\n\treturn true;\n}", "CodeBleu_score": 53.89525025005844}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\t", "CodeBleu_score": 0.7730807380978455}, {"code": "async function DisplaySensors(map){\n\t\tvar client = new GraphQLClient(url, {\n\t\theaders: {\n\t\t\tauthorization: \"Bearer \" + token,\n\t\t},\n\t});\n\n\tconst query = `query {\n\t\tsensors {\n\t\t\tid\n\t\t\tname\n\t\t\tlatitude\n\t\t\tlongitude\n\t\t\tstatus\n\t\t\tdescription\n\t\t\ttype\n\t\t}\n\t}`;\n\n\tconst response = await client.request(query);\n\tconsole.log(response);\n\n\tif (response.sensors) {\n\t\tconsole.log(\"Retrieved sensors\");\n\t\tfor (let i = 0; i < response.sensors.length; i++) {\n\t\t\tlet sensor = response.sensors[i];\n\t\t\tlet marker = new mapboxgl.Marker({\n\t\t\t\tcolor: sensor.status === \"active\"? \"green\" : \"red\",\n\t\t\t\tdraggable: false,\n\t\t\t})\n\t\t\t\t.setLngLat([sensor.longitude, sensor.latitude])\n\t\t\t\t.setPopup(\n\t\t\t\t\tnew mapboxgl.Popup({ offset: 25 }) // add popups\n\t\t\t\t\t\t.setHTML(\n\t\t\t\t\t\t\t\"<h3>\" +\n\t\t\t\t\t\t\t\tsensor.name +\n\t\t\t\t\t\t\t\t\"</h3><p>\" +\n\t\t\t\t\t\t\t\tsensor.description +\n\t\t\t\t\t\t\t\t\"</p>\"\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.addTo(map);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.70452104685462}, {"code": "async function DisplaySensors(map){\n\t\t// Create a new client\n\tconst client = new GraphQLClient(apiUrl, {\n\t\theaders: {\n\t\t\t'Content-Type': 'application/json',\n\t\t\t'Authorization': `Bearer ${token}`\n\t\t}\n\t});\n\n\t// Send a GraphQL query to fetch sensor data\n\tconst query = `query {\n\t\tsensors {\n\t\t\tid\n\t\t\tname\n\t\t\tlat\n\t\t\tlon\n\t\t}\n\t}`;\n\n\t// Fetch the data\n\tconst response = await client.request(query);\n\n\t// Log the API response\n\tconsole.log(response);\n\n\t// Check if the response contains data\n\tif (response.sensors) {\n\t\t// Log the retrieval of sensors\n\t\tconsole.log('Retrieved sensors:', response.sensors);\n\n\t\t// Iterate through each sensor\n\t\tresponse.sensors.forEach(sensor => {\n\t\t\t// Create a marker for the sensor\n\t\t\tconst marker = new google.maps.Marker({\n\t\t\t\tposition: { lat: sensor.lat, lng: sensor.lon },\n\t\t\t\tmap: map,\n\t\t\t\ttitle: sensor.name\n\t\t\t});\n\n\t\t\t// Add a click event listener to the marker\n\t\t\tmarker.addListener('click', () => {\n\t\t\t\t// Display the sensor details in a popup\n\t\t\t\tconst contentString = `<div id=\"content\">\n\t\t\t\t\t<div id=\"siteNotice\"></div>\n\t\t\t\t\t<h1 id=\"firstHeading\" class=\"firstHeading\">${sensor.name}</h1>\n\t\t\t\t\t<div id=\"bodyContent\">\n\t\t\t\t\t\t<p>Sensor ID: ${sensor.id}</p>\n\t\t\t\t\t\t<p>Latitude: ${sensor.lat}</p>\n\t\t\t\t\t\t<p>Longitude: ${sensor.lon}</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>`;\n\n\t\t\t\t// Create a new info window with the content\n\t\t\t\tconst infowindow = new google.maps.InfoWindow({\n\t\t\t\t\tcontent: contentString\n\t\t\t\t});\n\n\t\t\t\t// Open the info window\n\t\t\t\tinfowindow.open(map, marker);\n\t\t\t});\n\t\t});\n\t} else {\n\t\t// Log an error message if no sensors were retrieved\n\t\tconsole.error('Error: No sensors found.');\n\t}\n}", "CodeBleu_score": 37.09380090806286}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = \"rgba(255, 255, 255, 0)\";\n\tmarker.style.border = \"1px solid #000000\";\n\treturn marker;\n}", "CodeBleu_score": 44.31522162279576}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tconst marker = document.createElement('div');\n\tmarker.id = sensor.id;\n\tmarker.className ='sensor-marker';\n\tmarker.style.backgroundColor = '#4285F4';\n\tmarker.style.border = '1px solid #4285F4';\n\treturn marker;\n}", "CodeBleu_score": 43.78078605656809}, {"code": "const CreateSensorMarker = (sensor) =>{\n\t\tlet marker = document.createElement(\"div\");\n\tmarker.id = sensor.id;\n\tmarker.className = \"sensor-marker\";\n\tmarker.style.backgroundColor = sensor.color;\n\tmarker.style.borderColor = sensor.color;\n\treturn marker;\n}", "CodeBleu_score": 45.438724561581814}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    # Construct the module path\n    module_path = f\"homeassistant.auth.mfa.{module_name}\"\n\n    # Attempt to import the module\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Failed to import MFA module %s: %s\", module_path, err)\n        raise\n\n    # Process the module's requirements if they exist\n    if module.REQUIREMENTS:\n        # Check if the requirements have already been processed\n        if module_path not in hass.data.setdefault(\n            DATA_MFA_REQUIREMENTS, set()\n        ):\n            # Process the requirements\n            if not (await async_process_requirements(hass, module.REQUIREMENTS)):\n                return None\n\n            # Add the module path to the set of processed requirements\n            hass.data[DATA_MFA_REQUIREMENTS].add(module_path)\n\n    return module\n", "CodeBleu_score": 40.68115234952915}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    try:\n        return await async_import_module(hass, module_name)\n    except ModuleNotFoundError as err:\n        if err.name!= module_name:\n            raise\n        if module_name in _MFA_MODULES_PROCESSED:\n            _LOGGER.debug(\n                \"Skipping MFA module %s installation as it has already been processed\",\n                module_name,\n            )\n            return await async_import_module(hass, module_name)\n        _LOGGER.debug(\n            \"Processing MFA module %s installation\",\n            module_name,\n        )\n        _MFA_MODULES_PROCESSED.add(module_name)\n        module_path = module_name.replace(\".\", \"/\")\n        try:\n            module_spec = importlib.util.find_spec(module_path)\n            if module_spec is None:\n                raise ImportError(f\"No module named {module_path}\")\n            module_path = module_spec.origin\n            if module_path is None:\n                raise ImportError(f\"No module named {module_path}\")\n            if module_spec.submodule_search_locations is not None:\n                module_path = module_spec.submodule_search_locations[0]\n            if module_path is None:\n                raise ImportError(f\"No module named {module_path}\")\n            module_path = os.path.dirname(module_path)\n        except ImportError as err:\n            _LOGGER.error(\n                \"Failed to find MFA module %s installation path: %s\",\n                module_name,\n                err,\n            )\n            raise\n        requirements_path = os.path.join(module_path, \"requirements.txt\")\n        if not os.path.exists(requirements_path):\n            _LOGGER.debug(\n                \"Skipping MFA module %s installation as it has no requirements\",\n                module_name,\n            )\n            return await async_import_module(hass, module_name)\n        try:\n            with open(requirements_path, encoding=\"utf-8\") as file:\n                requirements = [\n                    line.strip()\n                    for line in file.readlines()\n                    if line.strip() and not line.startswith(\"#\")\n                ]\n            if not requirements:\n                _LOGGER.debug(\n                    \"Skipping MFA module %s installation as it has no requirements\",\n                    module_name,\n                )\n                return await async_import_module(hass, module_name)\n        except", "CodeBleu_score": 36.6279165506196}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\t\n    module_path = f\"homeassistant.components.auth_mfa_{module_name}\"\n    try:\n        module = await async_import_module(hass, module_path)\n    except ModuleNotFoundError as err:\n        raise ImportError(f\"Unable to import module {module_path}\") from err\n    except ImportError as err:\n        raise ImportError(f\"Unable to import module {module_path}\") from err\n    if module.REQUIREMENTS and not SKIP_PIP:\n        if not hass.data.get(f\"{module_path}_requirements_installed\"):\n            await async_process_requirements(hass, module.REQUIREMENTS)\n            hass.data[f\"{module_path}_requirements_installed\"] = True\n    return module\n", "CodeBleu_score": 41.76168605360742}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not self.data:\n        self.data = []\n    for user in self.data:\n        if user.get(\"user_id\") == user_id:\n            user[\"pin\"] = setup_data.get(\"pin\")\n            return\n    self.data.append({\"user_id\": user_id, \"pin\": setup_data.get(\"pin\")})\n\n", "CodeBleu_score": 43.947708671089316}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    pin = setup_data.get(PIN_DATA_KEY)\n    if not pin:\n        raise InvalidSetupDataError(\"Missing PIN\")\n    if not await self._validate_pin(pin):\n        raise InvalidSetupDataError(\"Invalid PIN\")\n    for user in self._data:\n        if user[\"user_id\"] == user_id:\n            user[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 60.27931672817568}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t\n    if not isinstance(setup_data, dict):\n        raise TypeError(\"setup_data must be a dictionary\")\n    if \"pin\" not in setup_data:\n        raise KeyError(\"setup_data must contain a 'pin' key\")\n    if not isinstance(setup_data[\"pin\"], str):\n        raise TypeError(\"setup_data['pin'] must be a string\")\n    if len(setup_data[\"pin\"])!= 4:\n        raise ValueError(\"setup_data['pin'] must be a 4-digit string\")\n    if not user_id:\n        raise ValueError(\"user_id must be a non-empty string\")\n    for user in self._data:\n        if user[\"user_id\"] == user_id:\n            user[\"pin\"] = setup_data[\"pin\"]\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": setup_data[\"pin\"]})\n\n", "CodeBleu_score": 43.455677222385845}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        data = await self._store.async_load()\n        if not data:\n            data = {}\n\n        self._user_settings = {\n            user_id: NotifySetting(user_id, user_data)\n            for user_id, user_data in data.items()\n        }\n        self._loaded = True\n", "CodeBleu_score": 39.09745889298129}, {"code": "async def _async_load(self) -> None\n\t\n    async with self._init_lock:\n        if self._loaded:\n            return\n        if data := await self._store.async_load():\n            self._data = data\n        else:\n            self._data = {}\n        self._loaded = True\n        for user_id in self._data:\n            self._data[user_id] = NotifySetting(\n                user_id,\n                self._data[user_id],\n                self._store,\n                self._async_get_user_settings,\n                self._async_get_user_id,\n            )\n\n", "CodeBleu_score": 30.77723540144203}, {"code": "async def _async_load(self) -> None\n\t\n    if self._initialized:\n        return\n\n    async with self._init_lock:\n        if self._initialized:\n            return\n\n        if not (data := await self._store.async_load()):\n            data = {}\n\n        self._users = {\n            user_id: NotifySetting(\n                data.get(user_id, {}).get(\"notify_enabled\", True),\n                data.get(user_id, {}).get(\"notify_all_states\", False),\n                data.get(user_id, {}).get(\"notify_recovered\", False),\n                data.get(user_id, {}).get(\"notify_new\", False),\n                data.get(user_id, {}).get(\"notify_changed\", False),\n                data.get(user_id, {}).get(\"notify_renamed\", False),\n                data.get(user_id, {}).get(\"notify_removed\", False),\n            )\n            for user_id in self._hass.auth.users.keys()\n        }\n\n        self._initialized = True\n", "CodeBleu_score": 41.251998365337315}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    if not await self._async_load_settings(user_id):\n        return False\n    settings = self._settings.get(user_id)\n    if not settings:\n        return False\n    return await self._async_validate(settings, user_input)\n", "CodeBleu_score": 41.751899468940344}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self._async_load_user_settings(user_id)\n    settings = self._user_settings.get(user_id)\n    if not settings:\n        return False\n    return await self._async_validate_user_input(settings, user_input)", "CodeBleu_score": 39.70176182696131}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t\n    await self.async_load_user_settings(user_id)\n    user_settings = self._user_settings.get(user_id)\n    if not user_settings:\n        return False\n    if user_settings.get(CONF_OTP_SECRET) is None:\n        return False\n    if user_settings.get(CONF_OTP_PROVIDER) is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        validate_totp,\n        user_input[CONF_OTP_CODE],\n        user_settings[CONF_OTP_SECRET],\n        user_settings[CONF_OTP_PROVIDER],\n    )", "CodeBleu_score": 55.48393959258985}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entities.get(entity_id)\n    if not entity:\n        return None\n    device = entity.device\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 40.803909651167025}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity = perm_lookup.entity_registry.async_get(entity_id)\n    if entity is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(entity.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 65.15812611625086}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\t\n    entity_entry = perm_lookup.entity_entries.get(entity_id)\n    if entity_entry is None:\n        return None\n\n    device_entry = entity_entry.device_entry\n    if device_entry is None:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 54.951834163958566}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_ in policies:\n        for category in policy_:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [policy_.get(category) for policy_ in policies]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 65.46180635448506}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n\n    for source in policies:\n        for category, value in source.items():\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [src.get(category) for src in policies]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 57.39754058548813}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for p in policies:\n        for category, source in p.items():\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [p[c] for c in p if c in seen]\n            policy[category] = _merge_policies(category_sources)\n\n    return cast(PolicyType, policy)\n\n", "CodeBleu_score": 56.70800788697194}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        return await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n\n", "CodeBleu_score": 21.96385078805294}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        return await async_import_module(hass, f\"homeassistant.auth.providers.{provider}\")\n    except ModuleNotFoundError as err:\n        raise HomeAssistantError(\n            f\"Failed to import auth provider module {provider}\"\n        ) from err\n\n", "CodeBleu_score": 17.970161947613516}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\t\n    try:\n        module = await async_import_module(hass, f\"auth_providers.{provider}\")\n    except ModuleNotFoundError:\n        raise HomeAssistantError(f\"Unable to import auth provider {provider}\") from None\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not module.REQUIREMENTS:\n        return module\n    if not hass.data.get(DATA_REQUIREMENTS):\n        hass.data[DATA_REQUIREMENTS] = set()\n    if not hass.data[DATA_REQUIREMENTS].isdisjoint(module.REQUIREMENTS):\n        return module\n    hass.data[DATA_REQUIREMENTS].update(module.REQUIREMENTS)\n    await async_process_requirements(hass, module.REQUIREMENTS)\n    return module\n", "CodeBleu_score": 41.442921793745136}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 95.53851299396959}, {"code": "async def async_load(self) -> None\n\t\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data", "CodeBleu_score": 95.53851299396959}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = user.password_hash.encode(\"utf-8\")\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash) or bcrypt.checkpw(dummy_hash, password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password.\")\n    raise InvalidAuth(\"Invalid username or password.\")\n\n", "CodeBleu_score": 38.22679354686083}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = normalize_username(username)\n    dummy_hash = bcrypt.hashpw(password.encode(\"utf-8\"), bcrypt.gensalt())\n    for user in self.users.values():\n        if user.username == username:\n            password_hash = base64.b64decode(user.password_hash)\n            if not bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                raise InvalidAuth()\n            return\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth()\n\n", "CodeBleu_score": 37.834314197539555}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t\n    username = normalize(username)\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = user.password.encode(\"utf-8\")\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    if bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        raise InvalidAuth(\"Invalid username\")\n    else:\n        raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 37.19216234487726}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(message=\"user_not_found\")\n\n", "CodeBleu_score": 30.447577566562973}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 27.737411357011872}, {"code": "def async_remove_auth(self, username: str) -> None\n\t\n    username = normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 27.737411357011872}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self.async_initialize()\n    try:\n        self._data.remove_user(credentials.username)\n        await self.async_save()\n    except ValueError:\n        pass\n\n", "CodeBleu_score": 46.53810219911419}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.username)\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 45.68638533055355}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\t\n    if not self._initialized:\n        await self.async_initialize()\n    try:\n        await self._store.async_remove_credentials(credentials.username)\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 47.34315572426549}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if thread.ident is None:\n            joined.add(thread)\n            continue\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        thread.raise_exc(SystemExit)\n    return joined\n\n", "CodeBleu_score": 54.6982213070223}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or thread.ident is None:\n            joined.add(thread)\n            continue\n\n        thread_timeout = timeout / len(threads)\n        try:\n            thread.join(thread_timeout)\n        except RuntimeError:\n            pass\n        else:\n            if not thread.is_alive():\n                joined.add(thread)\n                continue\n\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n\n        try:\n            thread._tstate_lock.acquire()\n            thread._interrupt_exc(SystemExit)\n        except RuntimeError:\n            pass\n\n    return joined\n\n", "CodeBleu_score": 59.05578399062653}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\t\n    joined_threads: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive() and thread.ident is not None:\n            thread.join(timeout)\n            if thread.is_alive():\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n                thread._stop()  # type: ignore[attr-defined]\n        joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 46.9791705211015}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Identify all non-main, non-daemon, alive threads\n    non_main_threads = [\n        thread\n        for thread in threading.enumerate()\n        if not thread.is_daemon() and thread.name!= \"MainThread\"\n    ]\n    # Calculate the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = 0.5\n    # Attempt to join each thread within the calculated timeout and log a warning if joining a thread fails\n    for thread in non_main_threads:\n        thread.join(timeout=timeout)\n        if thread.is_alive():\n            logging.warning(\n                f\"Thread {thread.name} failed to join within {timeout} seconds. It will be terminated.\"\n            )\n            thread.terminate()\n\n", "CodeBleu_score": 29.150021030844115}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    main_thread = threading.main_thread()\n    threads = threading.enumerate()\n    alive_threads = [thread for thread in threads if thread.is_alive() and thread is not main_thread and not thread.daemon]\n    if alive_threads:\n        total_timeout = 10\n        timeout_per_thread = total_timeout / len(alive_threads)\n        for thread in alive_threads:\n            try:\n                thread.join(timeout_per_thread)\n            except RuntimeError:\n                logger.warning(f\"Failed to join thread {thread.name}.\")\n\n", "CodeBleu_score": 33.93004174033738}, {"code": "def deadlock_safe_shutdown() -> None\n\t\n    # Get all non-main, non-daemon, alive threads\n    remaining_threads = [t for t in threading.enumerate() if t is not threading.current_thread() and not t.daemon]\n\n    # Calculate timeout for each thread\n    timeout = SHUTDOWN_TIMEOUT / len(remaining_threads)\n\n    # Join each thread within the calculated timeout\n    for thread in remaining_threads:\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            logger.warning(f\"Failed to join thread {thread.name}\")\n\n", "CodeBleu_score": 29.99879707093338}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    # If there are setups remaining or the previous state was not empty, send a dispatcher signal with the remaining setups.\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self.hass.bus.async_fire(\n            SIGNAL_DISPATCHER_REMAINING_WITH_SETUP_STARTED,\n            {\"remaining_with_setup_started\": remaining_with_setup_started},\n        )\n    # Update the internal flag to reflect whether there are remaining setups.\n    self._remaining_with_setup_started = bool(remaining_with_setup_started)", "CodeBleu_score": 47.611049914979084}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self.async_send_signal(\n            self._signal_dispatcher_remaining_with_setup_started,\n            remaining_with_setup_started,\n        )\n        self._remaining_with_setup_started = remaining_with_setup_started\n    else:\n        self._remaining_with_setup_started = {}\n\n", "CodeBleu_score": 47.11102599285008}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\t\n    if remaining_with_setup_started or self._remaining_setups_with_started:\n        self._remaining_setups_with_started = remaining_with_setup_started\n        self.async_call_later(self._async_dispatch, self._delay, remaining_with_setup_started)\n    else:\n        self._remaining_setups_with_started = None\n        self._async_dispatcher.async_fire(\n            SIGNAL_INTERNAL_DISPATCHER,\n            {\n                ATTR_DOMAIN: self._domain,\n                ATTR_DISPATCHER_ID: self._dispatcher_id,\n                ATTR_DISPATCHER_SIGNAL: self._dispatcher_signal,\n            },\n        )\n\n", "CodeBleu_score": 36.93228056607746}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    generated_content = generate_and_validate(integrations)\n\n    if not config.is_component_enabled(\"bluetooth\"):\n        return\n\n    if config.cache.get(\"bluetooth.py\") == generated_content:\n        return\n\n    config.cache[\"bluetooth.py\"] = generated_content\n\n    config.add_error(\n        {\n            \"domain\": \"bluetooth\",\n            \"message\": (\n                \"The file bluetooth.py is not up to date. \"\n                \"Run 'python3 -m script.hassfest' to fix.\"\n            ),\n            \"fixable\": True,\n            \"severity\": Severity.WARNING,\n        }\n    )", "CodeBleu_score": 39.53750191231472}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate the content of bluetooth.py\n    generated_content = generate_and_validate(integrations)\n\n    # Check if specific integrations are being validated\n    if config.skip_integrations:\n        # Read the current content of bluetooth.py\n        with open(config.path(\"custom_components\", \"bluetooth.py\"), \"r\") as f:\n            current_content = f.read()\n\n        # Compare the generated content with the current content\n        if generated_content!= current_content:\n            # Add an error to the configuration indicating that bluetooth.py is not up to date\n            config.add_error(\n                {\n                    \"filename\": \"bluetooth.py\",\n                    \"message\": \"The content of bluetooth.py is not up to date.\",\n                    \"fixable\": True,\n                    \"fix_message\": \"Update bluetooth.py\",\n                    \"details\": {\n                        \"current_content\": current_content,\n                        \"generated_content\": generated_content,\n                    },\n                }\n            )\n    else:\n        # Write the generated content to bluetooth.py\n        with open(config.path(\"custom_components\", \"bluetooth.py\"), \"w\") as f:\n            f.write(generated_content)", "CodeBleu_score": 36.830061357248596}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\t\n    # Generate and validate bluetooth data\n    bluetooth_content = generate_and_validate(integrations)\n\n    # Check if specific integrations are not being validated\n    if config.skip_bluetooth_validation:\n        # Read the current content of bluetooth.py\n        with open(\n            config.config_dir / \"generated\" / \"bluetooth.py\", encoding=\"utf-8\"\n        ) as f:\n            current_content = f.read()\n\n        # Compare the generated content with the current content\n        if current_content!= bluetooth_content:\n            # Add an error to the configuration indicating that bluetooth.py is not up to date\n            config.add_error(\n                {\n                    \"domain\": \"bluetooth\",\n                    \"message\": \"bluetooth.py is not up to date\",\n                    \"fixable\": True,\n                    \"suggestion\": \"Run'scripts/gen_bluetooth.py'\",\n                }\n            )\n\n    # Store the generated content in the configuration cache\n    config.cache[\"bluetooth\"] = bluetooth_content", "CodeBleu_score": 41.418082748558504}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create the request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropbox.com/oauth2/token\", nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Set the request body\n\tbody := url.Values{\n\t\t\"grant_type\":    {\"refresh_token\"},\n\t\t\"refresh_token\": {d.refreshToken},\n\t\t\"client_id\":     {d.appKey},\n\t\t\"client_secret\": {d.appSecret},\n\t}\n\treq.PostForm = body\n\n\t// Send the request\n\tresp, err := http.DefaultClient.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the response status code\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"refresh token request failed with status code: %d\", resp.StatusCode)\n\t}\n\n\t// Parse the response body\n\tvar result map[string]interface{}\n\terr = json.NewDecoder(resp.Body).Decode(&result)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.accessToken = result[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 49.15210811742149}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a new HTTP client\n\tclient := &http.Client{}\n\n\t// Create a new HTTP request with the refresh token, app key, and app secret\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.appKey+\":\"+d.appSecret)))\n\tq := req.URL.Query()\n\tq.Add(\"grant_type\", \"refresh_token\")\n\tq.Add(\"refresh_token\", d.refreshToken)\n\treq.URL.RawQuery = q.Encode()\n\n\t// Send the request and check for errors\n\tresp, err := client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check the response status code\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"refreshToken: %s\", body)\n\t}\n\n\t// Parse the JSON response\n\tvar result map[string]interface{}\n\terr = json.Unmarshal(body, &result)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.accessToken = result[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 47.37878018771382}, {"code": "func (d *Dropbox) refreshToken() error{\n\t\t// Create a new HTTP client with the default timeout\n\tclient := &http.Client{\n\t\tTimeout: time.Second * 10,\n\t}\n\n\t// Create a new HTTP request with the POST method, the token endpoint URL, and the form data\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropbox.com/oauth2/token\", strings.NewReader(\"grant_type=refresh_token&refresh_token=\"+d.refreshToken+\"&client_id=\"+d.appKey+\"&client_secret=\"+d.appSecret))\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request and handle the response\n\tresp, err := client.Do(req)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the response status code\n\tif resp.StatusCode!= http.StatusOK {\n\t\treturn fmt.Errorf(\"refresh token failed: %s\", resp.Status)\n\t}\n\n\t// Read the response body\n\tbody, err := io.ReadAll(resp.Body)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Parse the response as JSON\n\tvar result map[string]interface{}\n\terr = json.Unmarshal(body, &result)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Check if the response contains an access token\n\taccessToken, ok := result[\"access_token\"]\n\tif!ok {\n\t\treturn fmt.Errorf(\"refresh token failed: access token not found\")\n\t}\n\n\t// Update the access token\n\td.accessToken = accessToken.(string)\n\n\treturn nil\n}", "CodeBleu_score": 46.312854883656975}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Create a new HTTP request with the given method and URL\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header with the access token\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\n\t// Include parameters for supporting all drives\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\tq.Add(\"includeItemsFromAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\t// Customize the request if a callback is provided\n\tif callback!= nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request and handle errors, including refreshing the token if a 401 error occurs\n\tfor {\n\t\t// Send the request\n\t\tres, err := d.client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Handle errors\n\t\tif res.StatusCode == http.StatusUnauthorized {\n\t\t\t// Refresh the token if a 401 error occurs\n\t\t\terr := d.refreshToken()\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Retry the request after refreshing the token\n\t\t\tcontinue\n\t\t} else if res.StatusCode >= 400 {\n\t\t\t// Return an error if the request fails\n\t\t\treturn nil, fmt.Errorf(\"request failed with status code %d\", res.StatusCode)\n\t\t}\n\n\t\t// Read the response body\n\t\tbody, err := ioutil.ReadAll(res.Body)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Close the response body\n\t\tdefer res.Body.Close()\n\n\t\t// Set the response structure if provided\n\t\tif resp!= nil {\n\t\t\terr = json.Unmarshal(body, resp)\n\t\t\tif err!= nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\t// Return the response body or an error if the request fails\n\t\treturn body, nil\n\t}\n}", "CodeBleu_score": 51.65324487447553}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Create a new HTTP request with the given method and URL\n\treq, err := http.NewRequest(method, url, nil)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the authorization header with the access token\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\n\t// Include parameters for supporting all drives\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\tq.Add(\"includeItemsFromAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\t// Customize the request if a callback is provided\n\tif callback!= nil {\n\t\tif err := callback(req); err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Send the request and handle the response\n\trespBody, err := d.sendRequest(req, resp)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Return the response body or an error if the request fails\n\treturn respBody, nil\n}", "CodeBleu_score": 48.117644053826524}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\t\t// Set the authorization header with the access token and include parameters for supporting all drives.\n\theaders := map[string]string{\n\t\t\"Authorization\": \"Bearer \" + d.token.AccessToken,\n\t\t\"X-Goog-Drive-Resource-Keys\": \"true\",\n\t}\n\n\t// If a callback is provided, it customizes the request.\n\tif callback!= nil {\n\t\tcallback(url, method, headers)\n\t}\n\n\t// Send the request and handle errors.\n\tres, err := base.Request(url, method, headers)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// If a response structure is provided, it sets the request result.\n\tif resp!= nil {\n\t\terr = json.Unmarshal(res, resp)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If the request returns a 401 error, refresh the token and retry the request.\n\tif res.StatusCode == 401 {\n\t\terr := d.refreshToken()\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\t// Return the response body or an error if the request fails.\n\treturn res.Body, nil\n}", "CodeBleu_score": 53.18895285222026}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Get the file size\n\tsize := stream.Size()\n\n\t// Calculate the chunk size based on the file size\n\tchunkSize := int64(5 * 1024 * 1024) // 5 MB\n\tif size < chunkSize {\n\t\tchunkSize = size\n\t}\n\n\t// Create a buffer to hold the chunk data\n\tbuf := make([]byte, chunkSize)\n\n\t// Create a new HTTP request for the upload\n\treq, err := http.NewRequestWithContext(ctx, \"POST\", url, nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers for the upload\n\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"Content-Length\", strconv.FormatInt(chunkSize, 10))\n\n\t// Create a new HTTP client for the upload\n\tclient := &http.Client{}\n\n\t// Loop through the file and upload it in chunks\n\tfor offset := int64(0); offset < size; offset += chunkSize {\n\t\t// Check if the context was cancelled\n\t\tif ctx.Err()!= nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Read the next chunk from the file\n\t\tn, err := stream.Read(buf)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the request body for the chunk\n\t\treq.Body = io.NopCloser(bytes.NewReader(buf[:n]))\n\n\t\t// Send the request for the chunk\n\t\tresp, err := client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// Check the response status code\n\t\tif resp.StatusCode!= http.StatusOK {\n\t\t\treturn fmt.Errorf(\"upload failed: %s\", resp.Status)\n\t\t}\n\n\t\t// Update the offset for the next chunk\n\t\toffset += int64(n)\n\n\t\t// Set the new Content-Range header for the next chunk\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+chunkSize-1, size))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 47.944227196397755}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t\t// Calculate the chunk size\n\tchunkSize := int64(256 * 1024 * 1024)\n\tfileSize := stream.Size()\n\tchunkCount := int(math.Ceil(float64(fileSize) / float64(chunkSize)))\n\n\t// Initialize the progress bar\n\tbar := progressbar.Default(fileSize)\n\n\t// Loop through each chunk\n\tfor i := 0; i < chunkCount; i++ {\n\t\t// Check if the context is cancelled\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Calculate the chunk offset and size\n\t\toffset := int64(i) * chunkSize\n\t\tsize := int64(math.Min(float64(chunkSize), float64(fileSize-offset)))\n\n\t\t// Create a new HTTP request for the chunk\n\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, stream.Reader())\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the chunk range and size headers\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+size-1, fileSize))\n\t\treq.Header.Set(\"Content-Length\", strconv.FormatInt(size, 10))\n\n\t\t// Send the chunk request and handle the response\n\t\tres, err := d.client.Do(req)\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer res.Body.Close()\n\n\t\t// Check the response status code\n\t\tif res.StatusCode!= http.StatusOK && res.StatusCode!= http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"invalid response status code: %d\", res.StatusCode)\n\t\t}\n\n\t\t// Update the progress bar\n\t\tbar.Add64(size)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 40.47891732249709}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t", "CodeBleu_score": 2.2520696341262694}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Get the JSON data from the request context\n\tdata := ctx.Get(\"data\").(map[string]interface{})\n\n\t// Get the \"mount_point\" value from the JSON data\n\tmountPoint, ok := data[\"mount_point\"].(string)\n\tif!ok {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\n\t\t\t\"error\": \"Invalid request body\",\n\t\t})\n\t}\n\n\t// If the mount point is empty, return a client error response\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\n\t\t\t\"error\": \"Mount point cannot be empty\",\n\t\t})\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\terr := Unmount(mountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\t// Delete the corresponding configuration\n\terr = DeleteConfig(mountPoint)\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"message\": \"Storage unmounted successfully\",\n\t})\n}", "CodeBleu_score": 37.55466888041587}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\tvar reqBody map[string]interface{}\n\tif err := ctx.Bind(&reqBody); err!= nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\tmountPoint := reqBody[\"mount_point\"].(string)\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point is empty\")\n\t}\n\tif err := storage.Umount(mountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\tif err := config.DeleteStorageConfig(mountPoint); err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\treturn ctx.JSON(http.StatusOK, \"Successfully unmounted storage\")\n}", "CodeBleu_score": 35.09567566367671}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t\t// Get the JSON data from the request context\n\tdata := ctx.Get(\"data\").(map[string]interface{})\n\n\t// Get the \"mount_point\" value from the JSON data\n\tmountPoint := data[\"mount_point\"].(string)\n\n\t// If the mount point is empty, return a client error response\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"mount_point is required\"})\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point\n\tif err := storage.Umount(mountPoint); err!= nil {\n\t\t// If unmounting fails, return a service error response\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := config.DeleteStorage(mountPoint); err!= nil {\n\t\t// If deleting the configuration fails, return a service error response\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Storage unmounted successfully\"})\n}", "CodeBleu_score": 36.59977480829747}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"missing path\",\n\t\t})\n\t}\n\n\tif!fileExists(path) {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"file does not exist\",\n\t\t})\n\t}\n\n\treturn ctx.File(path)\n}", "CodeBleu_score": 36.81486322715147}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 35.38878870306143}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 34.41585688454594}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tif err := sendNotification(name, message[\"message\"]); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}", "CodeBleu_score": 49.84342485816204}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the name parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map\n\tvar message map[string]string\n\tif err := ctx.Bind(&message); err!= nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\t// Replace this with your notification code\n\tfmt.Printf(\"Sending notification to %s: %s\n\", name, message[\"message\"])\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"status\": \"success\"})\n}", "CodeBleu_score": 40.31641908985056}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t\t// Get the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Create an empty message map\n\tvar message map[string]interface{}\n\n\t// Bind the request body to the message map\n\tif err := ctx.Bind(&message); err!= nil {\n\t\t// If binding fails, return a bad request error with the binding error message\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification using the \"name\" and \"message\"\n\tsendNotification(name, message)\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}", "CodeBleu_score": 39.27830326961197}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the HTTP request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to a list of connections\n\tconnections = append(connections, ws)\n\t// Ensure that the message sending service is running\n\tgo sendMessages()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tfmt.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(string(message))\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.59373159052047}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\t// Upgrade the connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\t// Add the new connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Start the message sending service if it is not already running\n\tif!messageServiceRunning {\n\t\tgo sendMessage()\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read a message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\t// Remove the connection from the list of connections\n\t\t\tfor i, conn := range connections {\n\t\t\t\tif conn == ws {\n\t\t\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tlog.Printf(\"Message type: %v\nMessage: %s\nError: %v\n\", messageType, message, err)\n\t}\n\treturn nil\n}", "CodeBleu_score": 42.7394022311222}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err!= nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tgo messageSender()\n\n\t// Loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err!= nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Message type: %T\n\", msg)\n\t\tlog.Printf(\"Message: %s\n\", msg)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.527960073262385}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get system hardware info\n\tsystemHardwareInfo := system.GetSystemHardwareInfo()\n\n\t// Return system hardware info\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 7.460189481531082}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\tvar driveInfo, cpuInfo string\n\tvar err error\n\n\tdriveInfo, err = getDriveInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\tcpuInfo, err = getCPUInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]string{\n\t\t\"drive_info\": driveInfo,\n\t\t\"cpu_info\":   cpuInfo,\n\t})\n}", "CodeBleu_score": 22.40175113992226}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t\t// Get system hardware information\n\thardwareInfo, err := system.GetHardwareInfo()\n\tif err!= nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}", "CodeBleu_score": 11.714059312310422}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := s.systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif strings.HasPrefix(service, \"casaos-\") {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 62.118167300289784}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\tservices, err := systemctl.ListServices()\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service.Name, \"casaos\") {\n\t\t\tif service.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 70.61790344214982}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\t\t// Get a list of services matching the pattern\n\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Separate the services into running and not running lists\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\t// Return a map with boolean keys indicating the running status, each pointing to the corresponding list of service names\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 72.91474069073215}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message to a JSON string\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message for notification '%s': %s\", name, err.Error())\n\t\treturn\n\t}\n\n\t// Publish the notification to the message bus\n\terr = i.bus.Publish(name, string(messageJSON))\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to publish notification '%s': %s\", name, err.Error())\n\t\treturn\n\t}\n\n\tlog.Printf(\"Published notification '%s'\", name)\n}", "CodeBleu_score": 36.480463580760876}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings\n\tmessageJSON := make(map[string]string)\n\tfor key, value := range message {\n\t\tjsonValue, err := json.Marshal(value)\n\t\tif err!= nil {\n\t\t\tlog.Printf(\"Error serializing message value '%s': %s\", key, err)\n\t\t\tcontinue\n\t\t}\n\t\tmessageJSON[key] = string(jsonValue)\n\t}\n\n\t// Create the event to be published\n\tevent := &event.Event{\n\t\tName:    name,\n\t\tMessage: messageJSON,\n\t}\n\n\t// Publish the event to the message bus\n\terr := i.bus.Publish(event)\n\tif err!= nil {\n\t\tlog.Printf(\"Error publishing event '%s': %s\", name, err)\n\t\treturn\n\t}\n\n\t// Log the success\n\tlog.Printf(\"Sent event '%s'\", name)\n}", "CodeBleu_score": 43.306005097359716}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t\t// Serialize the message values to JSON strings.\n\tmessageJSON, err := json.Marshal(message)\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to serialize message values to JSON: %s\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to the message bus.\n\terr = i.bus.Publish(name, string(messageJSON))\n\tif err!= nil {\n\t\tlog.Printf(\"Failed to publish event to message bus: %s\", err)\n\t\treturn\n\t}\n\n\t// Log the success.\n\tlog.Printf(\"Successfully published event to message bus: %s\", name)\n}", "CodeBleu_score": 36.98263781063835}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClient()\n\terr := client.Initialize(c.RuntimePath)\n\tif err!= nil {\n\t\tclient.SetServer(err.Error())\n\t} else {\n\t\tclient.SetServer(client.Address())\n\t}\n\treturn client\n}", "CodeBleu_score": 22.828893400120602}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClient()\n\taddress, err := c.Runtime.GetMessageBusAddress()\n\tif err!= nil {\n\t\tclient.SetServer(err.Error())\n\t} else {\n\t\tclient.SetServer(address)\n\t}\n\treturn client\n}", "CodeBleu_score": 25.527821844078442}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t\tclient := message_bus.NewClient()\n\taddress, err := c.Runtime.GetMessageBusAddress()\n\tif err!= nil {\n\t\tclient.SetServer(err.Error())\n\t} else {\n\t\tclient.SetServer(address)\n\t}\n\treturn client\n}", "CodeBleu_score": 25.527821844078442}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}, {"code": "func GetIP(request *http.Request) string{\n\t\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 53.44245846638746}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t\tmodulesDir := c.modulesDir\n\tentryFilePath := c.entryFilePath\n\tif _, err := os.Stat(modulesDir); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"Modules directory does not exist: %v\", modulesDir)\n\t}\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"Entry file does not exist: %v\", entryFilePath)\n\t}\n\tvar entryFiles []string\n\terr := filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err!= nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif filepath.Base(path) == \"entry.json\" {\n\t\t\tentryFiles = append(entryFiles, path)\n\t\t}\n\t\treturn nil\n\t})\n\tif err!= nil {\n\t\tlog.Fatalf(\"Error walking modules directory: %v\", err)\n\t}\n\tvar entries []string\n\tfor _, entryFile := range entryFiles {\n\t\tcontent, err := ioutil.ReadFile(entryFile)\n\t\tif err!= nil {\n\t\t\tlog.Printf(\"Error reading entry file: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tentries = append(entries, string(content))\n\t}\n\tentryFileContent := \"[\" + strings.Join(entries, \",\") + \"]\"\n\terr = ioutil.WriteFile(entryFilePath, []byte(entryFileContent), 0644)\n\tif err!= nil {\n\t\tlog.Fatalf(\"Error writing entry file: %v\", err)\n\t}\n\tlog.Printf(\"Entry file generated successfully: %v\", entryFilePath)\n}", "CodeBleu_score": 46.61073541034813}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t", "CodeBleu_score": 0.8799536362483878}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get list of network interfaces\n\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get list of network names from system service\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over interfaces and network names\n\tfor _, iface := range ifaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\t// Check if interface name matches network name\n\t\t\tif iface.Name == networkName {\n\t\t\t\t// Return MAC address of matching interface\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// No matching interface found\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 56.472743385500316}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces\n\tifaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names\n\tfor _, iface := range ifaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\tif iface.Name == networkName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 56.472743385500316}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\t\t// Get a list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get a list of network names from the system service\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err!= nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names\n\tfor _, iface := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\t// Check if the interface name matches the network name\n\t\t\tif iface.Name == name {\n\t\t\t\t// Return the MAC address of the interface\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no matching interface is found, return an error\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 60.227853257812015}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t iRet = 0;\n\tSApplicationObj *pApp = pTscObj->pApp;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tiRet = -1;\n\t\tgoto end;\n\t}\n\n\tif (pApp!= NULL) {\n\t\tpApp->iReqCount++;\n\t\tpApp->iCurReqCount++;\n\t\tpApp->iCurTscCount++;\n\t}\n\n\tpRequest->pTscObj = pTscObj;\n\tpRequest->iRefCount++;\n\tpTscObj->iReqCount++;\n\n\tlog_debug(\"Registered request %p for TSC %p (app %p)\", pRequest, pTscObj, pApp);\n\nend:\n\treturn iRet;\n}", "CodeBleu_score": 34.23700007085417}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t iReturn = 0;\n\n\tif (pRequest == NULL) {\n\t\tiReturn = -1;\n\t\tgoto bail;\n\t}\n\n\tif (pTscObj == NULL) {\n\t\tiReturn = -1;\n\t\tgoto bail;\n\t}\n\n\tif (pRequest->pRequestObj!= NULL) {\n\t\tiReturn = -1;\n\t\tgoto bail;\n\t}\n\n\tpRequest->pRequestObj = pRequest;\n\tpRequest->iRefCount++;\n\tpTscObj->iRequestCount++;\n\n\tif (pTscObj->pApplication!= NULL) {\n\t\tpTscObj->pApplication->iRequestCount++;\n\t\tpTscObj->pApplication->iCurrentRequestCount++;\n\t}\n\n\tlogDebug(\"Registered new request 0x%p, request count %d\", pRequest, pTscObj->iRequestCount);\n\nbail:\n\treturn iReturn;\n}", "CodeBleu_score": 39.147055464507204}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\t\tint32_t status;\n\n\t/* Add reference to the request object */\n\tstatus = addReference(pRequest);\n\tif (status!= STATUS_SUCCESS) {\n\t\tlogMessage(LOG_ERROR_LEVEL, \"registerRequest: addReference failed\n\");\n\t\treturn status;\n\t}\n\n\t/* Increment request count for the associated TSC object */\n\tstatus = incrementRequestCount(pTscObj);\n\tif (status!= STATUS_SUCCESS) {\n\t\tlogMessage(LOG_ERROR_LEVEL, \"registerRequest: incrementRequestCount failed\n\");\n\t\treturn status;\n\t}\n\n\t/* Update application request summary, if applicable */\n\tif (pTscObj->pApplication!= NULL) {\n\t\tstatus = updateAppRequestSummary(pTscObj->pApplication, pRequest);\n\t\tif (status!= STATUS_SUCCESS) {\n\t\t\tlogMessage(LOG_ERROR_LEVEL, \"registerRequest: updateAppRequestSummary failed\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/* Log debug information about the new request */\n\tlogMessage(LOG_DEBUG_LEVEL, \"registerRequest: registered new request %s\n\", pRequest->requestId);\n\n\treturn STATUS_SUCCESS;\n}", "CodeBleu_score": 39.930102400457265}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t\tchar *pDb = pRequest->pPrimaryDb;\n\tif (pDb && strcmp(pDb, exceptDb)) {\n\t\treturn true;\n\t}\n\tpDb = pRequest->pDbList;\n\twhile (pDb) {\n\t\tchar *pDot = strchr(pDb, '.');\n\t\tif (pDot) {\n\t\t\tpDb = pDot + 1;\n\t\t}\n\t\tif (strcmp(pDb, exceptDb) == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tpDb = pDb->pNext;\n\t}\n\treturn true;\n}", "CodeBleu_score": 44.98682628620468}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\t", "CodeBleu_score": 3.907047286077039}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool rfp = false;\n\tif (code == RPC_ERR_REDIRECT) {\n\t\tswitch (msgType) {\n\t\t\tcase TMSG_RPC_CALL:\n\t\t\tcase TMSG_RPC_REPLY:\n\t\t\tcase TMSG_RPC_ERROR:\n\t\t\tcase TMSG_RPC_NOTIFY:\n\t\t\tcase TMSG_RPC_NOTIFY_ACK:\n\t\t\t\trfp = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trfp = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn rfp;\n}", "CodeBleu_score": 31.245368921042914}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tbool rfp = false;\n\n\tif (code == 0) {\n\t\tif (msgType == TMSG_CLIENT_RPC_REQUEST || msgType == TMSG_CLIENT_RPC_REQUEST_NO_REPLY || msgType == TMSG_CLIENT_RPC_REQUEST_NO_REPLY_NO_ACK) {\n\t\t\trfp = true;\n\t\t}\n\t}\n\n\treturn rfp;\n}", "CodeBleu_score": 35.722140631500295}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\t\tif (code == 404 || code == 405 || code == 406 || code == 415 || code == 417 || code == 429 || code == 503) {\n\t\tif (msgType!= TMSG_TYPE_RPC_REQUEST && msgType!= TMSG_TYPE_RPC_REQUEST_ONEWAY && msgType!= TMSG_TYPE_RPC_REQUEST_STREAM) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 42.03054384829852}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pRequest;\n\tSHashObj *pRequestNext;\n\tint64_t   rid;\n\tint       nRet;\n\n\tpRequest = pRequests->pFirst;\n\twhile (pRequest) {\n\t\tpRequestNext = pRequest->pNext;\n\t\trid          = pRequest->rid;\n\t\tnRet         = acquireRequest(rid);\n\t\tif (nRet < 0) {\n\t\t\tpRequest = pRequestNext;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pRequest->pQuery) {\n\t\t\ttaosStopQuery(pRequest->pQuery);\n\t\t}\n\n\t\treleaseRequest(rid);\n\t\tpRequest = pRequestNext;\n\t}\n}", "CodeBleu_score": 40.103522322942375}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tint64_t rid;\n\tint32_t ret;\n\tif (pRequests == NULL) return;\n\n\tfor (int32_t i = 0; i < pRequests->size; i++) {\n\t\tif (pRequests->data[i]!= NULL) {\n\t\t\trid = pRequests->data[i]->rid;\n\t\t\tret = acquireRequest(rid);\n\t\t\tif (ret < 0) continue;\n\t\t\tret = stopRequest(rid);\n\t\t\tif (ret < 0) continue;\n\t\t\treleaseRequest(rid);\n\t\t}\n\t}\n}", "CodeBleu_score": 39.96203494049138}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\t\tSHashObj *pReq = NULL;\n\tSRequest *pRequest = NULL;\n\tint64_t rid;\n\tint32_t ret;\n\n\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\tpReq = pRequests->pFirst;\n\twhile (pReq) {\n\t\trid = pReq->key;\n\t\tpRequest = (SRequest *)pReq->value;\n\t\tif (pRequest!= NULL) {\n\t\t\tif (pRequest->query!= NULL) {\n\t\t\t\tret = taosStopQuery(pRequest->query);\n\t\t\t\tif (ret!= TAOS_SUCCESS) {\n\t\t\t\t\ttaosErrorLog(NULL, \"Failed to stop query\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treleaseRequest(rid);\n\t\t}\n\n\t\tpReq = pReq->pNext;\n\t}\n}", "CodeBleu_score": 38.78097258282307}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\t\tif (!tscIsCrashReportingEnabled()) {\n\t\treturn;\n\t}\n\n\tif (!tscAtomicCompareExchange(&clientStop, 0, 1)) {\n\t\tTSC_LOG(\"Crash report thread is already stopped\");\n\t\treturn;\n\t}\n\n\twhile (tscAtomicLoad(&clientStop)) {\n\t\ttscSleep(100);\n\t}\n}", "CodeBleu_score": 64.41937068101335}, {"code": "void tscStopCrashReport(){\n\t\tif (!crashReportingEnabled) {\n\t\treturn;\n\t}\n\tif (atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n\t\tLOGD(\"Crash report thread is already stopped\");\n\t\treturn;\n\t}\n\twhile (clientStop) {\n\t\tLOGD(\"Waiting for crash report thread to stop\");\n\t\tsleep(1);\n\t}\n}", "CodeBleu_score": 61.51106778684717}, {"code": "void tscStopCrashReport(){\n\t\tif (g_crashReportEnabled == 0) {\n\t\treturn;\n\t}\n\tif (atomic_compare_exchange_strong(&g_clientStop, &g_clientStop, 1) == 0) {\n\t\tLOG_INFO(\"Crash report thread is already stopped\");\n\t\treturn;\n\t}\n\twhile (g_clientStop) {\n\t\tLOG_INFO(\"Waiting for crash report thread to stop...\");\n\t\tsleep(1);\n\t}\n}", "CodeBleu_score": 57.75879752330192}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\t", "CodeBleu_score": 4.375116026529019}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3CallbackData *data = (S3CallbackData *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 77.087868488297}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3_CALLBACK_DATA *data = (S3_CALLBACK_DATA *) callbackData;\n\tif (properties->contentLength > 0) {\n\t\tdata->contentLength = properties->contentLength;\n\t} else {\n\t\tdata->contentLength = 0;\n\t}\n\treturn S3StatusOK;\n}", "CodeBleu_score": 76.72388146097194}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\t\tS3PutObjectHandler *data = (S3PutObjectHandler *) callbackData;\n\tint64_t contentLength = 0;\n\n\tif (properties->contentLength > 0) {\n\t\tcontentLength = properties->contentLength;\n\t}\n\n\tdata->contentLength = contentLength;\n\n\treturn S3StatusOK;\n}", "CodeBleu_score": 59.860763118883874}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  if (taosMkDir(tsCheckpointBackupDir, TD_DIR_CREATE)!= 0) {\n    uError(\"[rsync] mkdir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsRsyncConfFile)!= 0) {\n    uError(\"[rsync] generate conf file error, file:%s\", tsRsyncConfFile);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --port=%d --config=%s\", tsRsyncPort, tsRsyncConfFile);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n\n#ifdef WINDOWS\n  char* argv[10] = {0};\n  char* envp[10] = {0};\n  argv[0] = \"rsync\";\n  argv[1] = \"--daemon\";\n  argv[2] = \"--port\";\n  argv[3] = \"873\";\n  argv[4] = \"--config\";\n  argv[5] = path;\n\n  PROCESS_INFORMATION pi;\n  STARTUPINFO si;\n  memset(&si, 0, sizeof(STARTUPINFO));\n  si.cb = sizeof(STARTUPINFO);\n  si.dwFlags = STARTF_USESHOWWINDOW;\n  si.wShowWindow = SW_HIDE;\n\n  if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n    uError(\"[rsync] create process error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  CloseHandle(pi.hProcess);\n  CloseHandle(pi.hThread);\n#else\n  int ret = system(cmd);\n  if (ret!= 0) {\n    uError(\"[rsync] system error, cmd:%s\", cmd);\n    return;\n  }\n#endif\n\n  uInfo(\"[rsync] start rsync server success, port:%d\", tsRsyncPort);\n}", "CodeBleu_score": 54.34087971470355}, {"code": "void startRsync(){\n\tfndef WINDOWS\n  if (tsCheckpointBackupDir == NULL) return;\n\n  if (taosCreateDir(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n\n  if (generateConfigFile(tsCheckpointBackupDir) < 0) {\n    uError(\"[rsync] generate conf file error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  char cmd[PATH_MAX * 2] = {0};\n  snprintf(cmd, PATH_MAX * 2, \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointPort);\n  uDebug(\"[rsync] start rsync daemon cmd:%s\", cmd);\n  int ret = system(cmd);\n  if (ret == 0) {\n    uInfo(\"[rsync] start rsync daemon success\");\n  } else {\n    uError(\"[rsync] start rsync daemon error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  }\n#endif\n}", "CodeBleu_score": 49.43809463385559}, {"code": "void startRsync(){\n\tfdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n  if (taosCreateDir(path)!= 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, path, ERRNO_ERR_DATA);\n    return;\n  }\n#else\n  if (taosCreateDir(tsCheckpointBackupDir)!= 0) {\n    uError(\"[rsync] create dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n#endif\n\n  removeEmptyDir();\n\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%s%s\", tsCheckpointBackupDir, \"rsync.conf\");\n  if (generateConfigFile(confDir)!= 0) {\n    uError(\"[rsync] generate conf file error, dir:%s\", confDir);\n    return;\n  }\n\n  char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --config=%s --port=%d\", confDir, tsCheckpointBackupPort);\n  uDebug(\"[rsync] start cmd:%s\", cmd);\n  int32_t pid = taosStartProcess(cmd);\n  if (pid > 0) {\n    uDebug(\"[rsync] start rsync server success, pid:%d\", pid);\n  } else {\n    uError(\"[rsync] start rsync server error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 66.2091061000445}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\t\tif (dispatcherId == null) {\n\t\tthrow new IllegalArgumentException(\"The dispatcher ID cannot be null\");\n\t}\n\tif (dispatcherId.isEmpty()) {\n\t\tthrow new IllegalArgumentException(\"The dispatcher ID cannot be empty\");\n\t}\n\tif (!dispatchers.containsKey(dispatcherId)) {\n\t\tthrow new RuntimeException(\"The dispatcher with ID \" + dispatcherId + \" is not registered\");\n\t}\n\tdispatchers.get(dispatcherId).shutdown();\n\tdispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 40.375479982925995}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\t// TODO implement here\n}", "CodeBleu_score": 2.950171161196606}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t\t// TODO Auto-generated method stub\n}", "CodeBleu_score": 2.950171161196606}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t", "CodeBleu_score": 13.361017427649136}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//        TbActorId[] children = getChildren(parent);\n//        if (children!= null) {\n//            for (TbActorId child : children) {\n//                if (childFilter.test(child)) {\n//                    tell(child, msg, highPriority);\n//                }\n//            }\n//        } else {\n//            log.warn(\"No children for actor \" + parent);\n//        }\n    }", "CodeBleu_score": 13.466092382761225}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\t//        TbActorId[] children = parent.getChildren();\n        TbActorId[] children = parent.getChildren();\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                try {\n                    tell(child, msg, highPriority);\n                } catch (Exception e) {\n                    log.warn(\"Failed to send message to child: \" + child, e);\n                }\n            }\n        }\n    }", "CodeBleu_score": 52.372671673449524}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (destroying.get() == DESTROYING) {\n\t\tif (highPriority && msg.getType() == RULE_NODE_UPDATED_MSG) {\n\t\t\t// This is a high priority message, we can try to reinitialize the actor\n\t\t\ttryInit(1);\n\t\t} else {\n\t\t\t// Notify the message that the actor has stopped\n\t\t\tmsg.notifyActorStopped();\n\t\t}\n\t} else {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\ttryProcessQueue(true);\n\t}\n}", "CodeBleu_score": 46.41839249395785}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tf (ready.get() == READY) {\n\t\tif (highPriority) {\n\t\t\thighPriorityMsgs.add(msg);\n\t\t} else {\n\t\t\tnormalPriorityMsgs.add(msg);\n\t\t}\n\t\ttryProcessQueue(true);\n\t} else if (ready.get() == DESTROYING && msg instanceof TbRuleNodeUpdatedMsg) {\n\t\tif (tryInit(0)) {\n\t\t\tlog.trace(\"[{}] Reinitializing actor after destroying\", selfId);\n\t\t\thighPriorityMsgs.add(msg);\n\t\t\ttryProcessQueue(true);\n\t\t}\n\t} else {\n\t\tlog.trace(\"[{}] Actor is not ready, msg: {}\", selfId, msg);\n\t\tmsg.notifyActorStopped();\n\t}\n}", "CodeBleu_score": 48.65090294335083}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\t/ 1. \u9ad8\u4f18\u5148\u7ea7\u7684\u6d88\u606f\u653e\u5230\u9ad8\u4f18\u5148\u7ea7\u961f\u5217\u4e2d\uff0c\u666e\u901a\u4f18\u5148\u7ea7\u7684\u6d88\u606f\u653e\u5230\u666e\u901a\u4f18\u5148\u7ea7\u961f\u5217\u4e2d\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    // 2. \u5c1d\u8bd5\u5904\u7406\u6d88\u606f\u961f\u5217\n    tryProcessQueue(true);\n}", "CodeBleu_score": 36.282648167308906}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\t If the actor is not ready, it means that it is being initialized.\n// In this case, we process only the initialization messages.\n// If the initialization fails, we set the stop reason and destroy the actor.\n        if (ready.get()!= READY) {\n            while (true) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg == null) {\n                    msg = normalPriorityMsgs.poll();\n                    if (msg == null) {\n                        break;\n                    }\n                }\n                try {\n                    actor.process(msg);\n                } catch (Throwable t) {\n                    log.error(\"[{}] Failed to process initialization message: {}\", selfId, t);\n                    stopReason = TbActorStopReason.FAILED;\n                    destroy(t);\n                    return;\n                }\n            }\n            ready.set(READY);\n            log.trace(\"[{}] Initialization is finished\", selfId);\n            dispatcher.onActorReady(selfId);\n            return;\n        }\n\n        int processed = 0;\n        while (processed < mailboxThroughput) {\n            TbActorMsg msg = highPriorityMsgs.poll();\n            if (msg == null) {\n                msg = normalPriorityMsgs.poll();\n                if (msg == null) {\n                    break;\n                }\n            }\n            try {\n                actor.process(msg);\n                processed++;\n            } catch (Throwable t) {\n                log.error(\"[{}] Failed to process message: {}\", selfId, t);\n                if (actor.getProcessFailureStrategy() == TbActorProcessFailureStrategy.STOP) {\n                    stopReason = TbActorStopReason.FAILED;\n                    destroy(t);\n                    return;\n                }\n            }\n        }\n        busy.set(FREE);\n        if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n            log.trace(\"[{}] MessageBox is empty\", selfId);\n        } else {\n            dispatcher.getExecutor().execute(this::processMailbox);\n        }\n    }", "CodeBleu_score": 47.77178187314291}, {"code": "private void processMailbox(){\n\thile (true) {\n\t\tif (destroyInProgress.get()) {\n\t\t\treturn;\n\t\t}\n\t\tif (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n\t\t\tready.set(READY);\n\t\t\tbusy.set(FREE);\n\t\t\ttryProcessQueue(false);\n\t\t\treturn;\n\t\t}\n\t\tif (throughputLimit.get() > 0) {\n\t\t\tthroughputLimit.decrementAndGet();\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tTbActorMsg msg = null;\n\t\tif (!highPriorityMsgs.isEmpty()) {\n\t\t\tmsg = highPriorityMsgs.poll();\n\t\t} else {\n\t\t\tmsg = normalPriorityMsgs.poll();\n\t\t}\n\t\tif (msg!= null) {\n\t\t\ttry {\n\t\t\t\tif (ready.get() == NOT_READY) {\n\t\t\t\t\tmsg.onTbActorStopped(stopReason);\n\t\t\t\t} else {\n\t\t\t\t\tactor.process(msg);\n\t\t\t\t}\n\t\t\t} catch (TbActorInitializationException e) {\n\t\t\t\tstopReason = TbActorStopReason.INITIALIZATION_FAILURE;\n\t\t\t\tdestroy(e);\n\t\t\t\treturn;\n\t\t\t} catch (Exception e) {\n\t\t\t\tlog.warn(\"[{}] Failed to process message: {}\", selfId, e);\n\t\t\t\tif (actor.getProcessFailureStrategy().equals(TbActorProcessFailureStrategy.STOP)) {\n\t\t\t\t\tstopReason = TbActorStopReason.PROCESS_FAILURE;\n\t\t\t\t\tdestroy(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 32.213237182030376}, {"code": "private void processMailbox(){\n\t", "CodeBleu_score": 0.7727339233596167}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\t\n}", "CodeBleu_score": 1.5678822020925003}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n    stopReason = TbActorStopReason.STOPPED;\n}\ndestroyInProgress.set(true);\ndispatcher.getExecutor().execute(() -> {\n    try {\n        ready.set(NOT_READY);\n        actor.destroy(stopReason, cause);\n        highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n    } catch (Throwable t) {\n        log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n    }\n});\n}", "CodeBleu_score": 95.84987495142298}, {"code": "public void destroy(Throwable cause){\n\t\tif (stopReason == null) {\n\t\tstopReason = TbActorStopReason.STOPPED;\n\t}\n\tdestroyInProgress.set(true);\n\tdispatcher.getExecutor().execute(() -> {\n\t\ttry {\n\t\t\tready.set(NOT_READY);\n\t\t\tactor.destroy(stopReason, cause);\n\t\t\thighPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t\tnormalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n\t\t} catch (Throwable t) {\n\t\t\tlog.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n\t\t}\n\t});\n}", "CodeBleu_score": 92.47258027809767}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t", "CodeBleu_score": 5.262946726493438}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\t// TODO: Implement the operation...\n\treturn false;\n}", "CodeBleu_score": 5.42861630904345}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\t\tif (tenantId.equals(systemTenantId)) {\n\t\treturn true;\n\t}\n\tTenantProfile tenantProfile = tenantProfileRepository.findByTenantId(tenantId);\n\tif (tenantProfile == null) {\n\t\tif (ignoreTenantNotFound) {\n\t\t\treturn true;\n\t\t}\n\t\tthrow new TenantProfileNotFoundException(tenantId);\n\t}\n\tRateLimitConfig rateLimitConfig = tenantProfile.getRateLimitConfig();\n\tif (rateLimitConfig == null) {\n\t\treturn true;\n\t}\n\tRateLimit rateLimit = rateLimitConfig.getRateLimit(api, level);\n\tif (rateLimit == null) {\n\t\treturn true;\n\t}\n\tRateLimitCheckResult result = rateLimit.check();\n\tif (result.isExceeded()) {\n\t\trateLimitNotificationService.processRateLimitNotification(api, tenantId, rateLimit, result);\n\t}\n\treturn result.isOk();\n}", "CodeBleu_score": 47.97814676815787}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t\t// TODO: implement\n}", "CodeBleu_score": 1.5735629692275181}, {"code": "public void evictTimeoutSessions(){\n\t\t// calculate the expiration time based on the current time minus the inactivity timeout\n\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\n\t// iterate over the entries in the DTLS sessions map\n\tIterator<Map.Entry<String, DtlsSession>> it = dtlsSessions.entrySet().iterator();\n\twhile (it.hasNext()) {\n\t\tMap.Entry<String, DtlsSession> entry = it.next();\n\t\tDtlsSession session = entry.getValue();\n\n\t\t// remove those with a last activity time older than the calculated expiration time\n\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\tit.remove();\n\t\t\tlogger.debug(\"Removed expired DTLS session with peer address \" + entry.getKey());\n\t\t}\n\t}\n}", "CodeBleu_score": 41.967353638401626}, {"code": "public void evictTimeoutSessions(){\n\t\t// TODO Auto-generated method stub\n\ttry {\n\t\t// Calculate the expiration time based on the current time minus the inactivity timeout\n\t\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\n\t\t// Iterate over the entries in the DTLS sessions map\n\t\tfor (Map.Entry<String, DtlsSession> entry : sessions.entrySet()) {\n\t\t\t// Get the session ID and session object\n\t\t\tString sessionId = entry.getKey();\n\t\t\tDtlsSession session = entry.getValue();\n\n\t\t\t// Check if the session's last activity time is older than the expiration time\n\t\t\tif (session.getLastActivityTime() < expirationTime) {\n\t\t\t\t// Remove the session from the map\n\t\t\t\tsessions.remove(sessionId);\n\n\t\t\t\t// Log the removal\n\t\t\t\tlog.info(\"Evicted DTLS session \" + sessionId + \" due to inactivity timeout\");\n\t\t\t}\n\t\t}\n\t} catch (Exception e) {\n\t\tlog.error(\"Error evicting DTLS sessions: \" + e.getMessage());\n\t}\n}", "CodeBleu_score": 39.71415937887639}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\treturn timeseries.entrySet().stream()\n\t\t\t.map(entry -> new TsKvEntry(entry.getKey(), parseValues(entry.getValue())))\n\t\t\t.collect(Collectors.toList());\n}", "CodeBleu_score": 17.49991376675283}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tList<TsKvEntry> tsKvEntries = new ArrayList<>();\n\tif (!timeseries.isEmpty()) {\n\t\tfor (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n\t\t\tList<KvEntry> kvEntries = new ArrayList<>();\n\t\t\tfor (JsonNode value : entry.getValue()) {\n\t\t\t\tkvEntries.add(parseValue(entry.getKey(), value));\n\t\t\t}\n\t\t\ttsKvEntries.add(new TsKvEntry(entry.getKey(), kvEntries));\n\t\t}\n\t}\n\treturn tsKvEntries;\n}", "CodeBleu_score": 30.34765063191841}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\t\tif (timeseries == null || timeseries.isEmpty()) {\n\t\treturn Collections.emptyList();\n\t}\n\n\treturn timeseries.entrySet().stream()\n\t\t\t.map(entry -> {\n\t\t\t\tList<KvEntry> values = entry.getValue().stream()\n\t\t\t\t\t\t.map(value -> parseValue(entry.getKey(), value))\n\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\t\treturn new TsKvEntry(entry.getKey(), values);\n\t\t\t})\n\t\t\t.collect(Collectors.toList());\n}", "CodeBleu_score": 39.93241918036935}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\t\tMap<String, String> params = new HashMap<>();\n\tparams.put(\"refreshToken\", this.refreshToken);\n\tString response = this.sendRequest(this.authEndpoint, \"POST\", params);\n\tJsonNode tokenInfo = Json.parse(response);\n\tthis.setTokenInfo(System.currentTimeMillis() + this.clientServerTimeDiff, tokenInfo);\n}", "CodeBleu_score": 46.26645385426419}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\tString responseBody = sendRequest(requestMap, \"POST\", \"/auth\");\n\tsetTokenInfo(System.currentTimeMillis(), JsonUtils.jsonStringToNode(responseBody));\n}", "CodeBleu_score": 36.86818424955978}, {"code": "public void refreshToken(){\n\t\tMap<String, String> requestMap = new HashMap<>();\n\trequestMap.put(\"refreshToken\", this.refreshToken);\n\ttry {\n\t\tString response = this.sendRequest(this.authUrl, \"POST\", requestMap);\n\t\tJsonNode responseJson = JsonUtils.parseJson(response);\n\t\tthis.setTokenInfo(System.currentTimeMillis() + this.clientServerTimeDiff, responseJson);\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t}\n}", "CodeBleu_score": 45.185596863375956}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\t//        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", );\n        try {\n            JsonNode tokenInfo = sendPostRequest(loginUrl, loginRequest);\n            setTokenInfo(tokenInfo);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }", "CodeBleu_score": 48.40204786507763}, {"code": " private void doLogin(){\n\t\tlong ts = System.currentTimeMillis();\n\tMap<String, String> loginRequest = new HashMap<>();\n\tloginRequest.put(\"username\", this.username);\n\tloginRequest.put(\"password\", );\n\tJsonNode tokenInfo = sendRequest(\"POST\", \"/api/auth/login\", loginRequest);\n\tsetTokenInfo(ts, tokenInfo);\n}", "CodeBleu_score": 58.846898162132455}, {"code": " private void doLogin(){\n\t//        long ts = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", );\n        JsonNode response = doPost(loginUrl, loginRequest);\n        setTokenInfo(response);\n    }", "CodeBleu_score": 43.16792653983097}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.getForEntity(\n\t\t\t\t\"/api/device/{deviceId}\", Device.class, deviceId);\n\t\tif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 59.477011950846446}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.exchange(\n\t\t\t\t\"/api/device/{deviceId}\",\n\t\t\t\tHttpMethod.GET,\n\t\t\t\tnull,\n\t\t\t\tDevice.class,\n\t\t\t\tdeviceId.getId());\n\n\t\tif (response.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 59.50534168662425}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\t\ttry {\n\t\tResponseEntity<Device> response = restTemplate.exchange(\n\t\t\t\t\"/api/device/{deviceId}\",\n\t\t\t\tHttpMethod.GET,\n\t\t\t\tnull,\n\t\t\t\tDevice.class,\n\t\t\t\tdeviceId.getId());\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpClientErrorException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 59.74914470277754}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\ttry {\n\t\tDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n\t\tResponseEntity<Device> response = restTemplate.postForEntity(baseUrl + \"/api/device-with-credentials\", deviceWithCredentials, Device.class);\n\t\treturn Optional.of(response.getBody());\n\t} catch (HttpStatusCodeException e) {\n\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\treturn Optional.empty();\n\t\t}\n\t\tthrow e;\n\t}\n}", "CodeBleu_score": 63.31375409310841}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\treturn Optional.ofNullable(restTemplate.postForObject(apiUrl + \"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class));\n}", "CodeBleu_score": 13.94527696467599}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\t\tDeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n\treturn this.restTemplate.postForObject(this.baseUrl + \"/api/device-with-credentials\", deviceWithCredentials, Device.class);\n}", "CodeBleu_score": 21.036248108407275}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tval = addr;\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n\t}\n\treturn this;\n}", "CodeBleu_score": 95.67310060368143}, {"code": "brightness(addr, val){\n\t", "CodeBleu_score": 2.026480482306344}, {"code": "brightness(addr, val){\n\t\tif (arguments.length === 1) {\n\t\tval = addr;\n\t\tthis.each(function(device) {\n\t\t\tthis.brightness(device, val);\n\t\t});\n\t} else {\n\t\tthis.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n\t}\n\treturn this;\n}", "CodeBleu_score": 95.67310060368143}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\t\n}", "CodeBleu_score": 1.622727129683248}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}, {"code": "device(addr){\n\t\tconst bound = {};\n\n\t/* keys from prototype */\n\tObject.keys(LedControl.prototype).forEach(key => {\n\t\tbound[key] = this[key].bind(this, addr);\n\t});\n\n\t/* functions from interface */\n\tObject.getOwnPropertyNames(this).forEach(key => {\n\t\tif (this[key] && typeof this[key] === \"function\") {\n\t\t\tbound[key] = this[key].bind(this, addr);\n\t\t}\n\t});\n\treturn bound;\n}", "CodeBleu_score": 96.28295927493981}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function (duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function');\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\t\t\tconst timeout = setTimeout(() => {\n\t\t\t\t\t\treject(new Error(`Timeout of ${duration}ms exceeded for ${element.id}`));\n\t\t\t\t\t}, duration);\n\t\t\t\t\telement[method](() => {\n\t\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tpromises.push(promise);\n\t\t\t});\n\t\t\treturn Promise.all(promises).then(() => callback());\n\t\t};\n\t});\n}", "CodeBleu_score": 44.37949558939582}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach((method) => {\n\t\ttarget[method] = function (duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('Callback is not a function');\n\t\t\t}\n\t\t\tconst promises = [];\n\t\t\tthis.forEach((element) => {\n\t\t\t\tpromises.push(element[method](duration));\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 38.56577917963835}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\t\tmethods.forEach(method => {\n\t\ttarget[method] = function(duration, callback) {\n\t\t\tif (typeof duration === 'function') {\n\t\t\t\tcallback = duration;\n\t\t\t\tduration = 1000;\n\t\t\t}\n\t\t\tif (typeof callback!== 'function') {\n\t\t\t\tthrow new Error('callback must be a function');\n\t\t\t}\n\t\t\tlet promises = [];\n\t\t\tthis.forEach(element => {\n\t\t\t\tlet promise = new Promise(resolve => {\n\t\t\t\t\telement[method](duration, resolve);\n\t\t\t\t});\n\t\t\t\tpromises.push(promise);\n\t\t\t});\n\t\t\tPromise.all(promises).then(() => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\t});\n}", "CodeBleu_score": 47.68518708600571}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n\n}", "CodeBleu_score": 74.03081486126135}, {"code": "listen(){\n\tart the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 65.06379801572368}, {"code": "listen(){\n\t state = priv.get(this);\nlet input = \"\";\n\n// Start the read loop\nthis.io.serialRead(state.portId, data => {\n\n  input += new Buffer(data).toString(\"ascii\");\n  const sentences = input.split(\"\\r\n\");\n\n  if (sentences.length > 1) {\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  }\n});\n}", "CodeBleu_score": 74.03081486126135}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint16_t buf_size = 0;\n\tuint8_t num_channels = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels_list[i] < config->num_channels) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tbuf_size = num_channels * config->resolution;\n\n\tif (buf_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"buffer size insufficient for %d channels\", num_channels);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->num_channels = num_channels;\n\tdata->buf_size = buf_size;\n\n\treturn 0;\n}", "CodeBleu_score": 34.40052809924497}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tstruct adc_ad559x_data *data = dev->data;\n\tint num_channels = 0;\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (num_channels > data->num_channels) {\n\t\tLOG_ERR(\"Number of channels in sequence is greater than number of channels in device\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options & ADC_SEQ_OPT_OVERWRITE) {\n\t\tif (sequence->buffer_size < num_channels * sizeof(uint16_t)) {\n\t\t\tLOG_ERR(\"Buffer size is insufficient for ADC sequence\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tif (sequence->buffer_size < num_channels * sequence->resolution * sizeof(uint16_t)) {\n\t\t\tLOG_ERR(\"Buffer size is insufficient for ADC sequence\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.07161288277952}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\t\tconst struct ad559x_config *cfg = dev->config;\n\tconst struct ad559x_data *data = dev->data;\n\tuint8_t *buffer = sequence->buffer;\n\tuint8_t buffer_size = sequence->buffer_size;\n\tuint8_t num_channels = 0;\n\tuint8_t num_samples = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < AD559X_NUM_CHANNELS; i++) {\n\t\tif (sequence->channels[i].channel_id!= ADC_CHANNEL_ID_UNUSED) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (cfg->mode == AD559X_MODE_SINGLE) {\n\t\tnum_samples = 1;\n\t} else {\n\t\tnum_samples = sequence->options->oversampling;\n\t}\n\n\tif (buffer_size < num_channels * num_samples) {\n\t\tLOG_ERR(\"Insufficient memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->num_channels = num_channels;\n\tdata->num_samples = num_samples;\n\tdata->buffer = buffer;\n\n\treturn 0;\n}", "CodeBleu_score": 33.91215089194496}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_context *ctx = &adc_ad559x_context[config->device_id];\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= 12) {\n\t\tLOG_ERR(\"Only 12-bit resolution is supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels > 16) {\n\t\tLOG_ERR(\"Only 16 channels are supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tadc_context_start_read(ctx, sequence);\n\tadc_context_wait_for_completion(ctx);\n\n\treturn 0;\n}", "CodeBleu_score": 49.32487769936644}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution!= 16) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\tif (channels == 0 || channels > config->num_channels) {\n\t\tLOG_ERR(\"Invalid channel\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Buffer size insufficient\");\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->channels = sequence->channels;\n\tdata->resolution = sequence->resolution;\n\tdata->oversampling = sequence->oversampling;\n\tdata->options = sequence->options;\n\n\treturn adc_ad559x_start_read_context(dev);\n}", "CodeBleu_score": 58.31702923879254}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\t\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\tif (sequence->resolution!= config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution: %u\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels!= config->channels) {\n\t\tLOG_ERR(\"Invalid channels: %u\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = adc_context_start_read(&data->ctx, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn adc_context_wait_for_completion(&data->ctx);\n}", "CodeBleu_score": 73.89293250129604}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = DEV_DATA(ctx->dev);\n\tstruct adc_channel_cfg *channel_cfg = ctx->channel_cfg;\n\tint i;\n\n\tfor (i = 0; i < ctx->channel_count; i++) {\n\t\tdata->channels[i] = channel_cfg[i].channel_id;\n\t}\n\n\tdata->buffer = ctx->buffer;\n\tdata->buffer_size = ctx->buffer_size;\n\tdata->repeat_buffer = ctx->repeat_buffer;\n\tdata->repeat_buffer_size = ctx->repeat_buffer_size;\n\n\tk_sem_give(&data->start_sem);\n}", "CodeBleu_score": 33.31457180499672}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->adc_data;\n\tstruct device *dev = ctx->dev;\n\tstruct adc_sequence *sequence = &data->sequence;\n\tuint32_t channels = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < data->channels; i++) {\n\t\tchannels |= BIT(data->channel_ids[i]);\n\t}\n\tsequence->channels = channels;\n\tsequence->buffer = data->buffer;\n\tsequence->buffer_size = data->buffer_size;\n\tsequence->oversampling = data->oversampling;\n\tsequence->calibrate = false;\n\tsequence->resolution = data->resolution;\n\n\tdata->repeat_buffer = data->buffer;\n\tdata->repeat_buffer_length = data->buffer_size;\n\tdata->repeat_buffer_index = 0;\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 32.43367923500113}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\t\tstruct adc_data *data = ctx->adc_data;\n\tstruct adc_device *dev = &data->dev;\n\tstruct adc_repeat_buffer *repeat_buffer = &data->repeat_buffer;\n\tuint8_t i;\n\n\tfor (i = 0; i < ctx->num_channels; i++) {\n\t\tdata->channels[i] = ctx->channels[i];\n\t}\n\tdata->num_channels = ctx->num_channels;\n\n\tif (data->num_channels > 0) {\n\t\tadc_repeat_buffer_init(repeat_buffer, data->buffer, data->buffer_size, data->num_channels);\n\t\tadc_repeat_buffer_reset(repeat_buffer);\n\t}\n\n\tadc_repeat_buffer_set_callback(repeat_buffer, adc_context_repeat_buffer_callback, ctx);\n\n\tadc_start_read(dev, data->channels, data->num_channels, repeat_buffer);\n\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 30.7723036193209}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = ctx->adc_data_container;\n\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tadc_data_container->buffer_pointer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 46.06184475309036}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = (struct adc_data_container *)ctx->adc_data_container;\n\tif (repeat_sampling) {\n\t\tadc_data_container->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tadc_data_container->buffer_pointer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 45.668063150672296}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\t\tstruct adc_data_container *adc_data_container = (struct adc_data_container *) ctx->adc_data_container;\n\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = adc_data_container->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = adc_data_container->buffer;\n\t}\n}", "CodeBleu_score": 36.76049765386714}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->dev->config;\n\tint ret;\n\tuint16_t adc_val;\n\tuint8_t channel;\n\n\twhile (1) {\n\t\t/* Wait for semaphore */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Check if ADC context is complete */\n\t\tif (data->complete) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Read ADC channels */\n\t\tfor (channel = 0; channel < config->num_channels; channel++) {\n\t\t\tif (data->active_channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &adc_val);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %u: %d\", channel, ret);\n\t\t\t\t\tdata->complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdata->adc_buf[channel] = adc_val;\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tk_sem_give(&data->sem);\n\t}\n\n\t/* Signal that sampling is done */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 51.9662607292402}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tonst struct adc_ad559x_config *config = data->dev->config;\n\tuint16_t result;\n\tint ret;\n\n\twhile (1) {\n\t\t/* Wait for semaphore */\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\t/* Iterate through active channels */\n\t\tfor (uint8_t channel = 0; channel < config->channels_count; channel++) {\n\t\t\tif (data->channels_enabled & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\t\t\tdata->adc_context.complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdata->adc_context.buffer[channel] = result;\n\t\t\t}\n\t\t}\n\n\t\t/* Signal that sampling is done */\n\t\tdata->adc_context.buffer_ready = true;\n\t\tk_sem_give(&data->adc_context.sync);\n\t}\n}", "CodeBleu_score": 52.052578504289116}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tnt ret;\n\tuint16_t result;\n\tuint8_t channel;\n\n\t/*\n\t * Wait for a semaphore to be released, then iterate through the active channels.\n\t */\n\twhile (1) {\n\t\t/*\n\t\t * Wait for a semaphore to be released, then iterate through the active channels.\n\t\t */\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\t/*\n\t\t * If the sampling is not done, iterate through the active channels.\n\t\t */\n\t\tif (!data->acq_done) {\n\t\t\tfor (channel = 0; channel < data->channels_count; channel++) {\n\t\t\t\t/*\n\t\t\t\t * If the channel is active, read the ADC value and store the result in a buffer.\n\t\t\t\t */\n\t\t\t\tif (data->channels_map & BIT(channel)) {\n\t\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tLOG_ERR(\"ADC channel %d read failed: %d\", channel, ret);\n\t\t\t\t\t\tdata->acq_done = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdata->results[channel] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Signal that the sampling is done.\n\t\t */\n\t\tk_sem_give(&data->acq_done_sem);\n\t}\n}", "CodeBleu_score": 53.73384609349293}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tint rc;\n\tuint8_t reg_val[2];\n\n\tk_sleep(K_MSEC(config->ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc!= 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val[0] & ADS1112_REG_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc!= 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 64.12211604518274}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tint rc;\n\tuint8_t reg_val[1] = {0};\n\n\t/* Wait for the device to be ready */\n\tk_sleep(K_MSEC(config->ready_time));\n\n\t/* Check the status of the device */\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\t/* If the device is not ready, sleep for 100us and check again */\n\twhile (reg_val[0] & ADS1112_CONFIG_OS_MASK) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 61.18275368333238}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\t\tconst struct ads1112_config *config = dev->config;\n\tuint8_t reg_val[2] = {0};\n\tint rc = 0;\n\n\tk_sleep(K_MSEC(config->ready_time));\n\n\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\tif (rc < 0) {\n\t\treturn rc;\n\t}\n\n\twhile (!(reg_val[0] & ADS1112_REG_CONFIG_RDY)) {\n\t\tk_sleep(K_USEC(100));\n\n\t\trc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, reg_val);\n\t\tif (rc < 0) {\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 65.66020387894916}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tsize_t required_buffer_size = 0;\n\n\t/*\n\t * The required buffer size is calculated based on the number of samplings in the sequence, including any extra samplings specified in the sequence options.\n\t * The extra samplings are taken into account by adding the number of extra samplings to the number of samplings in the sequence.\n\t * The required buffer size is then calculated by multiplying the total number of samplings by the size of each sample, which is 2 bytes in this case.\n\t * The calculated required buffer size is then compared to the actual buffer size provided in the sequence.\n\t * If the required buffer size is greater than the actual buffer size, an error message is logged and an error code is returned.\n\t * Otherwise, the buffer size is sufficient and 0 is returned to indicate success.\n\t */\n\trequired_buffer_size = (sequence->options->extra_samplings + sequence->channels) * 2;\n\n\tif (required_buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is insufficient for the sequence\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 35.149205208064096}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tconst struct ads1112_config *config = sequence->resolution == 8? &ads1112_8bit_config : &ads1112_12bit_config;\n\tsize_t buffer_size = sequence->channels * sequence->options->extra_samplings * config->buffer_size_per_channel;\n\tif (buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size is too small for the specified number of channels and extra samplings\");\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 23.212635242095676}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\t\tint required_buffer_size = sequence->resolution * sequence->channels * (sequence->extra_samplings + sequence->steps);\n\tif (required_buffer_size > sequence->buffer_size) {\n\t\tLOG_ERR(\"Buffer size insufficient for ADC sequence.\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 26.548196607522296}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = ads1112_start_read(dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_wait_for_read_completion(dev);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 62.08833093944983}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\tret = adc_context_start_read(&data->ctx, dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = adc_context_wait_for_completion(&data->ctx);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 63.49060895672798}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tint ret;\n\tconst struct ads1112_data *data = dev->data;\n\tstruct ads1112_context *ctx = &data->ctx;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tctx->buffer = sequence->buffer;\n\tctx->buffer_size = sequence->buffer_size;\n\tctx->sample_count = sequence->options->sampling_delay;\n\n\tret = ads1112_start_read(dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_read_wait(dev);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 59.51680078679351}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint err = 0;\n\tstruct device *dev;\n\tstruct codec_config *cfg;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tcfg = codec_get_config(dev);\n\tif (!cfg) {\n\t\tshell_error(sh, \"failed to get device config\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = codec_apply_config(dev, cfg);\n\tif (err) {\n\t\tshell_error(sh, \"failed to apply config\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 59.46272604989373}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tstruct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\n\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties to %s\n\", argv[1]);\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Properties applied to %s\", argv[1]);\n\n\treturn 0;\n}", "CodeBleu_score": 55.81404016174139}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\t\tint ret;\n\tstruct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Invalid number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = apply_codec_properties(dev);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply codec properties\");\n\t\treturn ret;\n\t}\n\n\tshell_print(sh, \"Codec properties applied\");\n\n\treturn 0;\n}", "CodeBleu_score": 60.924524914814334}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_start(dev);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to start I2S device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_stop(dev);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"Failed to stop I2S device\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Unsupported I2S trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 37.72773391459877}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_PLAYBACK, I2S_CMD_START);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"I2S start failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_PLAYBACK, I2S_CMD_STOP);\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"I2S stop failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t} else {\n\t\tLOG_ERR(\"Unsupported trigger command\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 32.951124821845724}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t\tconst struct mpxxdtyy_i2s_config *config = dev->config;\n\tstruct mpxxdtyy_i2s_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_CONFIGURED) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_ACTIVE;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid I2S state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tdata->state = MPXXDTYY_I2S_STATE_CONFIGURED;\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid I2S state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Invalid I2S command\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2s_trigger(config->i2s_dev, cmd);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to trigger I2S device\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 56.11723307902001}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_ON;\n\t}\n\n\tif (config->blink_on) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 65.35100244445748}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x08;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_DISPLAY_ON;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_CURSOR_ON;\n\t}\n\n\tif (config->blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_CMD_BLINK_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, false, cmd, config->mode);\n}", "CodeBleu_score": 63.5639321287737}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tnst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\n\tuint8_t cmd = AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CMD;\n\n\tif (data->cursor_blink) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CURSOR_BLINK;\n\t}\n\n\tif (data->cursor_show) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_OFF_CURSOR_SHOW;\n\t}\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_ON_OFF_DISPLAY_ON;\n\t}\n\n\tauxdisplay_hd44780_command(dev, AUXDISPLAY_HD44780_RS_CMD, cmd, config->mode);\n}", "CodeBleu_score": 74.43992399297257}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\n\tif (config->busy_gpio.port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (gpio_pin_get(config->busy_gpio.port, config->busy_gpio.pin)) {\n\t\tdata->busy = true;\n\t} else {\n\t\tdata->busy = false;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 69.43475988394579}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint busy_gpio_status;\n\tint ret;\n\n\tif (!config->busy_gpio_port) {\n\t\tLOG_ERR(\"Busy GPIO port not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_dt(config->busy_gpio_port, &busy_gpio_status);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to get busy GPIO status\");\n\t\treturn ret;\n\t}\n\n\treturn busy_gpio_status;\n}", "CodeBleu_score": 60.135627489705215}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\t\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (!config->busy_gpio.port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get_raw(config->busy_gpio.port, config->busy_gpio.pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 67.62773300263743}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\t/* Construct the buffer to be sent to the LCD device */\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\t/* Write the buffer to the LCD device using the I2C bus */\n\tret = i2c_write_dt(&config->i2c, buffer, sizeof(buffer));\n\n\t/* Introduce a delay before returning */\n\tk_sleep(K_MSEC(config->delay_after_special_command));\n\n\treturn ret;\n}", "CodeBleu_score": 70.53997169710608}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tif (i2c_write(config->i2c, buffer, sizeof(buffer), config->i2c_address)!= 0) {\n\t\treturn -EIO;\n\t}\n\n\tk_busy_wait(config->special_command_delay);\n\n\treturn 0;\n}", "CodeBleu_score": 63.02623088391337}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\t\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\tint ret;\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\tret = i2c_write_dt(&config->i2c, buf, 2);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_msleep(config->special_command_delay);\n\n\treturn 0;\n}", "CodeBleu_score": 62.92195713566612}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (size > bbram_data->size) {\n\t\tLOG_ERR(\"Invalid size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\tLOG_ERR(\"Invalid offset\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_data->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 62.65197759278269}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bb_data = dev->data;\n\tsize_t mem_size = bb_data->mem_size;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset > mem_size || (offset + size) > mem_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bb_data->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 63.64002317519262}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\tuint8_t *bbram_mem = bbram_data->mem;\n\tint ret = 0;\n\n\tif (offset + size > bbram_data->mem_size) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tmemcpy(data, bbram_mem + offset, size);\n\nout:\n\treturn ret;\n}", "CodeBleu_score": 55.51943439736746}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *emul_data = dev->data;\n\tuint8_t *bbram_data = emul_data->data;\n\tint ret = 0;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > emul_data->size) {\n\t\treturn -EIO;\n\t}\n\n\tif (emul_data->status.is_invalid) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram_data[offset], data, size);\n\n\treturn ret;\n}", "CodeBleu_score": 50.74667276266707}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\n\tif (size > BBRAM_EMUL_MAX_WRITE_SIZE) {\n\t\treturn -EIO;\n\t}\n\n\tif (offset + size > bbram_data->size) {\n\t\treturn -EIO;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram_data->data[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 56.52799586749309}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\t\tstruct bbram_emul_data *bbram_data = dev->data;\n\tconst struct bbram_emul_config *bbram_cfg = dev->config;\n\n\tif (size > bbram_cfg->size) {\n\t\tLOG_ERR(\"Write size is greater than BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_cfg->size) {\n\t\tLOG_ERR(\"Write offset + size is greater than BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_data->status.is_invalid) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(bbram_data->memory + offset, data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 61.53504814972119}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device name\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 83.64562055127294}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tif (argc < 2) {\n\t\tshell_error(sh, \"missing device argument\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 79.96154839114837}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\t\tint err;\n\tchar *endptr;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"missing argument for device\");\n\t\treturn -ENOENT;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"device '%s' not found\", argv[1]);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 75.79581806628273}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_context *h4 = dev->data;\n\tconst struct h4_config *config = dev->config;\n\tint remaining = sizeof(h4->hdr) - h4->hdr_len;\n\tint ret;\n\n\tif (remaining > 0) {\n\t\tret = uart_fifo_read(config->uart, &h4->hdr[h4->hdr_len], remaining);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read header data: %d\", ret);\n\t\t} else {\n\t\t\th4->hdr_len += ret;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.718807173895655}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tstruct h4_context *ctx = dev->data;\n\tint ret;\n\tuint8_t *buf = ctx->hdr_buf;\n\tint cnt = ctx->hdr_cnt;\n\tint len = ctx->hdr_len;\n\n\twhile (cnt < len) {\n\t\tret = uart_fifo_read(ctx->uart_dev, buf + cnt, len - cnt);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read header\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcnt += ret;\n\t}\n\n\tctx->hdr_cnt = cnt;\n}", "CodeBleu_score": 37.305858086846946}, {"code": "static void h4_read_hdr(const struct device *dev){\n\t\tint ret;\n\tuint8_t *buf;\n\tint len;\n\n\tbuf = h4_hdr.buf;\n\tlen = h4_hdr.len;\n\n\tret = uart_fifo_read(dev, buf, len);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read header\");\n\t} else {\n\t\th4_hdr.len -= ret;\n\t\th4_hdr.buf += ret;\n\t}\n}", "CodeBleu_score": 43.98631811633756}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t bytes_read = 0;\n\tsize_t bytes_to_read;\n\n\twhile (len > 0) {\n\t\tbytes_to_read = MIN(len, sizeof(buf));\n\t\tif (uart_fifo_read(uart, buf, bytes_to_read)!= bytes_to_read) {\n\t\t\tLOG_ERR(\"Failed to read %d bytes from UART\", bytes_to_read);\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_read += bytes_to_read;\n\t\tlen -= bytes_to_read;\n\t}\n\n\treturn bytes_read;\n}", "CodeBleu_score": 37.82395471298238}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t read_len = 0;\n\tsize_t total_read_len = 0;\n\tint err = 0;\n\n\twhile (len > 0) {\n\t\tread_len = MIN(len, sizeof(buf));\n\t\terr = uart_fifo_read(uart, buf, read_len);\n\t\tif (err < 0) {\n\t\t\tLOG_ERR(\"Error reading UART: %d\", err);\n\t\t\treturn 0;\n\t\t}\n\n\t\ttotal_read_len += read_len;\n\t\tlen -= read_len;\n\t}\n\n\treturn total_read_len;\n}", "CodeBleu_score": 44.760483538286685}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\t\tuint8_t buf[33];\n\tsize_t count = 0;\n\tsize_t n = 0;\n\n\twhile (count < len) {\n\t\tn = MIN(len - count, sizeof(buf));\n\t\tif (h4_read(uart, buf, n)!= n) {\n\t\t\tLOG_ERR(\"Failed to read %zu bytes from UART\", n);\n\t\t\treturn 0;\n\t\t}\n\t\tcount += n;\n\t}\n\n\treturn count;\n}", "CodeBleu_score": 43.67112187124286}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tstruct zbus_channel_data *data = chan->data;\n\tunsigned int highest_priority = 0;\n\tint i;\n\tzbus_lock_channel(data);\n\tfor (i = 0; i < chan->num_observers; i++) {\n\t\tif (chan->observers[i].priority > highest_priority && chan->observers[i].enabled) {\n\t\t\thighest_priority = chan->observers[i].priority;\n\t\t}\n\t}\n\tdata->highest_observer_priority = highest_priority;\n\tzbus_unlock_channel(data);\n}", "CodeBleu_score": 23.918292907253136}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tint i;\n\tint highest = 0;\n\tint priority;\n\tstruct zbus_observer *obs;\n\tstruct zbus_channel_data *data = chan->data;\n\tpthread_mutex_lock(&data->mutex);\n\tfor (i = 0; i < data->observers.len; i++) {\n\t\tobs = data->observers.data[i];\n\t\tpriority = obs->priority;\n\t\tif (priority < highest && obs->enabled) {\n\t\t\thighest = priority;\n\t\t}\n\t}\n\tdata->highest_observer_priority = highest;\n\tpthread_mutex_unlock(&data->mutex);\n}", "CodeBleu_score": 31.442895654222134}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\t\tuint32_t highest_priority = 0;\n\tconst struct zbus_observer *obs;\n\tconst struct zbus_observer *obs_end;\n\tuint32_t priority;\n\n\tzbus_channel_data_lock(chan);\n\tobs = chan->observers;\n\tobs_end = obs + chan->num_observers;\n\tfor (; obs < obs_end; obs++) {\n\t\tif (obs->enabled) {\n\t\t\tpriority = obs->priority;\n\t\t\tif (priority < highest_priority) {\n\t\t\t\thighest_priority = priority;\n\t\t\t}\n\t\t}\n\t}\n\tzbus_channel_data_unlock(chan);\n\n\tchan->highest_observer_priority = highest_priority;\n}", "CodeBleu_score": 29.48612873422204}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tfor (int16_t i = 0; i < _zbus_chan_obs_size; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\tif (observation->obs == obs) {\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 22.370150942872787}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tfor (int16_t i = 0; i < _zbus_chan_data_count; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tobservation_mask->enabled = true;\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.31093125369939}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tfor (int16_t i = 0; i < _zbus_chan_data.end_idx; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation!= NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tobservation_mask->enabled = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 17.72968170493722}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (in_interrupt_context()) {\n\t\treturn -2;\n\t}\n\n\tif (obs->priority!= 0) {\n\t\treturn -3;\n\t}\n\n\tspinlock_lock(&obs->lock);\n\tobs->priority = get_thread_priority_min();\n\tupdate_all_channels_hop(obs);\n\tspinlock_unlock(&obs->lock);\n\n\treturn 0;\n}", "CodeBleu_score": 45.21091334539768}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (in_interrupt_context()) {\n\t\treturn -1;\n\t}\n\n\tspinlock_lock(&zbus_obs_lock);\n\n\tobs->priority = KERNEL_PRIORITY_MAX;\n\n\tupdate_all_channels_hop(obs);\n\n\tspinlock_unlock(&zbus_obs_lock);\n\n\treturn 0;\n}", "CodeBleu_score": 49.286797806648615}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tint ret = 0;\n\n\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\n\tspin_lock(&obs->lock);\n\tobs->priority = MIN(obs->priority, k_thread_priority_get(k_current_get()));\n\tupdate_all_channels_hop(obs);\n\tspin_unlock(&obs->lock);\n\n\treturn ret;\n}", "CodeBleu_score": 45.3190302195693}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_timeout(timeout);\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 47.551832951980074}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"chan must be not NULL\");\n\n\ttimeout = _zbus_adjust_timeout(timeout);\n\n\tk_timepoint_t end_time = sys_timepoint_timeout(timeout);\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 47.551832951980074}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\tZBUS_ASSERT(chan!= NULL, \"chan must be not NULL\");\n\n\tk_timeout_t adjusted_timeout = timeout;\n\tk_timepoint_t end_time = K_TIMEOUT_ABS_TIME_END_NOW;\n\tint prio = 0;\n\n\tif (k_is_in_isr()) {\n\t\tadjusted_timeout = K_NO_WAIT;\n\t} else {\n\t\tend_time = sys_timeout_end_calc(timeout);\n\t}\n\n\tint err = chan_lock(chan, adjusted_timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 55.022123723255156}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t\tif (enable) {\n\t\tETH->IMR |= Int;\n\t} else {\n\t\tETH->IMR &= ~Int;\n\t}\n}", "CodeBleu_score": 18.692663087524686}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\t", "CodeBleu_score": 4.374803510003657}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t", "CodeBleu_score": 2.546149641071209}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *pTxDesc;\n\n\tpTxDesc = pTxDescTail;\n\n\twhile (pTxDesc!= pTxDescHead) {\n\t\tif (pTxDesc->status & ETH_TX_DESC_STATUS_OWN) {\n\t\t\tpTxDesc = (ETH_TX_DESC *) pTxDesc->pNext;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pTxDesc == pTxDescHead) {\n\t\treturn 0;\n\t}\n\n\tpTxDescTail = pTxDesc;\n\n\treturn pTxDesc;\n}", "CodeBleu_score": 45.84020798377391}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\t\tETH_TX_DESC *tx_desc;\n\tuint32_t curr_tx_desc;\n\n\tcurr_tx_desc = ETH->ETH_DMATxDescTail;\n\ttx_desc = (ETH_TX_DESC *) curr_tx_desc;\n\twhile (tx_desc->ETH_TDES0 & ETH_TDES0_OWN) {\n\t\tcurr_tx_desc = (curr_tx_desc == ETH_TX_DESC_LAST)? ETH_TX_DESC_FIRST : (curr_tx_desc + 16);\n\t\ttx_desc = (ETH_TX_DESC *) curr_tx_desc;\n\t}\n\treturn tx_desc;\n}", "CodeBleu_score": 46.046654065874165}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tRT_ASSERT(device!= RT_NULL);\n\tcyp_dac_t *cyp_dac = (cyp_dac_t *)device->parent.user_data;\n\trt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\trt_err_t ret = RT_EOK;\n\n\tif (Cy_CSDIDAC_OutputEnable(cyp_dac->base, cyp_dac_channel, *value)!= CY_CSDIDAC_SUCCESS) {\n\t\tLOG_E(\"Failed to initialize DAC channel %d for device %s\", channel, device->parent.parent.name);\n\t\tret = -RT_ERROR;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 51.64941067973249}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tcyp_adc_t cyp_adc = (cyp_adc_t)device;\n\tcy_rslt_t result;\n\tcy_stc_csdidac_config_t config;\n\tcy_stc_csdidac_context_t context;\n\trt_uint32_t cyp_adc_channel = cyp_adc_get_channel(channel);\n\n\tRT_ASSERT(cyp_adc!= RT_NULL);\n\n\t/* Initialize the DAC channel */\n\tconfig.dacMode = CY_CSDIDAC_MODE_NORMAL;\n\tconfig.dacRef = CY_CSDIDAC_REF_VDDA;\n\tconfig.dacPolarity = CY_CSDIDAC_POLARITY_POSITIVE;\n\tconfig.dacRange = CY_CSDIDAC_RANGE_2X;\n\tconfig.dacVref = CY_CSDIDAC_VREF_VDDA;\n\tconfig.dacOutput = cyp_adc_channel;\n\n\tresult = Cy_CSDIDAC_Init(&cyp_adc->base, &config, &context);\n\tif (result!= CY_CSDIDAC_SUCCESS) {\n\t\trt_kprintf(\"Failed to initialize DAC channel %d on device %s, error code %d\n\", channel, device->parent.name, result);\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* Enable the DAC output */\n\tCy_CSDIDAC_OutputEnable(&cyp_adc->base, cyp_adc_channel, *value);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 49.97425474328919}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\t\tstruct cyp_adc_device *cyp_adc = RT_NULL;\n\tcy_rslt_t ret;\n\trt_uint32_t cyp_adc_channel;\n\n\tRT_ASSERT(device!= RT_NULL);\n\tcyp_adc = (struct cyp_adc_device *)device->parent.user_data;\n\tRT_ASSERT(cyp_adc!= RT_NULL);\n\n\tcyp_adc_channel = cyp_adc_get_channel(channel);\n\n\tret = Cy_CSDIDAC_OutputEnable(cyp_adc->base, cyp_adc_channel, *value);\n\tif (ret!= CY_CSDIDAC_SUCCESS) {\n\t\tLOG_E(\"Failed to enable DAC output for channel %d on device %s\", channel, device->parent.name);\n\t\treturn -RT_ERROR;\n\t}\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 55.42553882851314}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\trt_uint32_t flash_end_addr = FLASH_END_ADDR;\n\tif (addr + size > flash_end_addr) {\n\t\trt_kprintf(\"Error: ifx_flash_read_32k: addr + size > flash_end_addr\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) addr;\n\t\taddr++;\n\t}\n\treturn size;\n}", "CodeBleu_score": 46.73119265125255}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\trt_uint32_t i;\n\n\tif (addr + size > 0x400000) {\n\t\trt_kprintf(\"Invalid argument: address + size > 0x400000\n\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 40.944162461008574}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\t\tif (addr + size > FLASH_MEM_SIZE) {\n\t\trt_kprintf(\"Error: ifx_flash_read_32k: address out of range\n\");\n\t\treturn -1;\n\t}\n\n\trt_uint32_t i;\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 42.45462726619085}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 29.825080229112366}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer);\n\tcyhal_timer_t *cy_timer = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(cy_timer);\n}", "CodeBleu_score": 24.29492473780335}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\t\tRT_ASSERT(timer!= RT_NULL);\n\tcyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->parent.user_data;\n\treturn cyhal_timer_read(timer_obj);\n}", "CodeBleu_score": 29.825080229112366}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\t\tint ret;\n\twhile (true) {\n\t\tret = pthread_mutex_lock(&dfs_mutex);\n\t\tif (ret == 0) {\n\t\t\treturn;\n\t\t} else if (ret!= EBUSY) {\n\t\t\tassert(false);\n\t\t}\n\t}\n}", "CodeBleu_score": 27.884081793261238}, {"code": "void dfs_lock(void){\n\t\tint ret;\n\n\twhile ((ret = pthread_mutex_lock(&dfs_lock_mutex)) == EBUSY)\n\t\t;\n\tassert(ret == 0);\n}", "CodeBleu_score": 18.90213628918788}, {"code": "void dfs_lock(void){\n\t\tint rc;\n\twhile ((rc = pthread_mutex_lock(&dfs_mutex))!= 0) {\n\t\tif (rc == EBUSY) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tassert(0);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.661390782967235}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\tint index;\n\n\tif (startfd < 0)\n\t\tstartfd = 0;\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (!fdt->fds[fd])\n\t\t\treturn fd;\n\t}\n\n\t/* No free slot found, expand fdtable */\n\tindex = fd_slot_expand(fdt, fd);\n\tif (index < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 34.03405551911909}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (fdt->fds[fd] == NULL) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\t/* expand the fd table if no empty slot is found */\n\tif (fd_slot_expand(fdt, fd) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 38.07498685732765}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\t\tint fd;\n\n\tif (startfd < 0) {\n\t\tstartfd = 0;\n\t}\n\tfor (fd = startfd; fd < fdt->maxfd; fd++) {\n\t\tif (!fdt->fds[fd]) {\n\t\t\treturn fd;\n\t\t}\n\t}\n\n\tif (fd_slot_expand(fdt, fd) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}", "CodeBleu_score": 37.41549536131142}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tint err = (int)error;\n\tif (err < 0) {\n\t\terr = -err;\n\t}\n\tfor (i = 0; i < sizeof(err_table) / sizeof(err_table[0]); i++) {\n\t\tif (err_table[i].err == err) {\n\t\t\treturn err_table[i].err_str;\n\t\t}\n\t}\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 55.783899441368966}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint i;\n\tint err_code = error;\n\n\tif (err_code < 0) {\n\t\terr_code = -err_code;\n\t}\n\n\tfor (i = 0; i < sizeof(err_string_tbl) / sizeof(err_string_tbl[0]); i++) {\n\t\tif (err_code == err_string_tbl[i].num) {\n\t\t\treturn err_string_tbl[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 58.875228142151}, {"code": "const char *rt_strerror(rt_err_t error){\n\t\tint err = (int)error;\n\tint i;\n\n\tif (err < 0) {\n\t\terr = -err;\n\t}\n\n\tfor (i = 0; i < sizeof(err_string_table) / sizeof(err_string_table[0]); i++) {\n\t\tif (err == err_string_table[i].num) {\n\t\t\treturn err_string_table[i].str;\n\t\t}\n\t}\n\n\treturn \"EUNKNOW\";\n}", "CodeBleu_score": 59.086004547664174}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\t/* take idle spinlock */\n\tlevel = rt_hw_spin_lock(&rt_thread_idle_lock);\n\n\t/* find an empty slot */\n\tif (rt_thread_idle_hook_index < RT_THREAD_IDLE_HOOK_MAX) {\n\t\trt_thread_idle_hook[rt_thread_idle_hook_index++] = hook;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* release idle spinlock */\n\trt_hw_spin_unlock(&rt_thread_idle_lock);\n\n\treturn result;\n}", "CodeBleu_score": 28.200568217877265}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\tregister rt_base_t temp;\n\trt_err_t result;\n\tstruct rt_thread *thread;\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* get current thread */\n\tthread = rt_thread_self();\n\n\t/* set hook */\n\tif (thread->idle_hook_list < RT_THREAD_IDLE_HOOKS_NUMBER) {\n\t\tthread->idle_hook[thread->idle_hook_list] = hook;\n\t\tthread->idle_hook_list ++;\n\n\t\tresult = RT_EOK;\n\t} else {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(temp);\n\n\treturn result;\n}", "CodeBleu_score": 25.488951038613973}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\t\tregister rt_base_t temp;\n\tstruct rt_thread_idle_hook *idle_hook;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\ttemp = rt_hw_interrupt_disable();\n\n\tidle_hook = rt_thread_idle_hook_first;\n\twhile (idle_hook!= RT_NULL) {\n\t\tif (idle_hook->hook == RT_NULL) {\n\t\t\tidle_hook->hook = hook;\n\t\t\trt_hw_interrupt_enable(temp);\n\t\t\treturn RT_EOK;\n\t\t}\n\t\tidle_hook = idle_hook->next;\n\t}\n\n\trt_hw_interrupt_enable(temp);\n\n\treturn -RT_EFULL;\n}", "CodeBleu_score": 37.602225805272646}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\tregister rt_uint32_t temp;\n\tregister rt_uint32_t level;\n\tregister rt_uint32_t index;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* get current hook index */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_MAX; index ++)\n\t{\n\t\tif (idle_hook[index] == hook)\n\t\t{\n\t\t\t/* remove hook */\n\t\t\tidle_hook[index] = RT_NULL;\n\n\t\t\t/* restore interrupt */\n\t\t\trt_hw_interrupt_enable(level);\n\n\t\t\treturn RT_EOK;\n\t\t}\n\t}\n\n\t/* restore interrupt */\n\trt_hw_interrupt_enable(level);\n\n\t/* not found */\n\treturn -RT_ENOSYS;\n}", "CodeBleu_score": 45.83957763729298}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_ubase_t index;\n\trt_err_t result;\n\n\t/* lock scheduler */\n\tRT_DEBUG_SCHEDULER_LOCK();\n\n\t/* find hook */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_NUM; index++) {\n\t\tif (rt_thread_idle_hook[index] == hook) {\n\t\t\t/* remove hook */\n\t\t\trt_thread_idle_hook[index] = RT_NULL;\n\n\t\t\t/* unlock scheduler */\n\t\t\tRT_DEBUG_SCHEDULER_UNLOCK();\n\n\t\t\t/* return result */\n\t\t\tresult = RT_EOK;\n\t\t\tgoto __exit;\n\t\t}\n\t}\n\n\t/* unlock scheduler */\n\tRT_DEBUG_SCHEDULER_UNLOCK();\n\n\t/* return result */\n\tresult = -RT_ENOSYS;\n\n__exit:\n\n\treturn result;\n}", "CodeBleu_score": 47.40444820165281}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\t\trt_uint32_t index;\n\trt_err_t result = RT_EOK;\n\n\t/* lock scheduler */\n\trt_enter_critical();\n\n\t/* search hook */\n\tfor (index = 0; index < RT_THREAD_IDLE_HOOK_NUMBER; index++) {\n\t\tif (_rt_thread_idle_hook[index] == hook) {\n\t\t\t_rt_thread_idle_hook[index] = RT_NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no found */\n\tif (index == RT_THREAD_IDLE_HOOK_NUMBER) {\n\t\tresult = RT_ERROR;\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical();\n\n\treturn result;\n}", "CodeBleu_score": 47.15884229341848}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\n\trt_enter_critical();\n\n\t/* get thread from suspension list */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\t/* remove thread from suspension list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\n\t\t/* set error */\n\t\tthread->error = thread_error;\n\t}\n\n\trt_exit_critical();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.92144993453362}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\tregister rt_base_t temp;\n\tregister rt_thread_t thread;\n\n\t/* disable interrupt */\n\ttemp = rt_hw_interrupt_disable();\n\n\t/* resume all thread in the suspension list */\n\twhile ((thread = rt_list_entry(susp_list->next, struct rt_thread, tlist))!= RT_NULL) {\n\t\t/* remove thread from suspension list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* set error number and resume from suspend */\n\t\tthread->error = thread_error;\n\t\trt_thread_resume(thread);\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(temp);\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 30.333200846092147}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\t\trt_thread_t thread;\n\n\t/* ensure scheduler is unlocked */\n\trt_enter_critical();\n\n\t/* resume all threads in the list */\n\twhile ((thread = rt_list_entry(susp_list->next, rt_thread_t, tlist))!= RT_NULL) {\n\t\t/* remove thread from suspended list */\n\t\trt_list_remove(&(thread->tlist));\n\n\t\t/* set error number */\n\t\tthread->error = thread_error;\n\n\t\t/* resume thread */\n\t\trt_thread_resume(thread);\n\t}\n\n\t/* scheduler is locked */\n\trt_exit_critical();\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 31.54709822636148}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old_console;\n\trt_device_t new_console;\n\n\t/* save the current console device */\n\told_console = rt_console_device;\n\n\t/* find the new console device */\n\tnew_console = rt_device_find(name);\n\n\t/* check if the new console device is the same as the current console device */\n\tif (new_console!= old_console) {\n\t\t/* check if the new console device is valid */\n\t\tif (new_console!= RT_NULL && new_console->type == RT_Device_Class_Char) {\n\t\t\t/* close the current console device if it exists */\n\t\t\tif (old_console!= RT_NULL) {\n\t\t\t\trt_device_close(old_console);\n\t\t\t}\n\n\t\t\t/* open the new console device with read/write and stream flags */\n\t\t\tif (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n\t\t\t\t/* set the new console device */\n\t\t\t\trt_console_device = new_console;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* return the old console device */\n\treturn old_console;\n}", "CodeBleu_score": 55.37429269333644}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old;\n\n\tRT_ASSERT(name!= RT_NULL);\n\n\t/* save current console device */\n\told = rt_console_get_device();\n\n\t/* find new console device */\n\trt_console_device = rt_device_find(name);\n\n\t/* if new console device is different from current one */\n\tif (rt_console_device!= old) {\n\t\t/* if new console device is valid */\n\t\tif (rt_console_device!= RT_NULL) {\n\t\t\t/* close old console device */\n\t\t\tif (old!= RT_NULL) {\n\t\t\t\trt_device_close(old);\n\t\t\t}\n\n\t\t\t/* open new console device */\n\t\t\tif (rt_device_open(rt_console_device, RT_DEVICE_FLAG_STREAM | RT_DEVICE_FLAG_RDWR) == RT_EOK) {\n\t\t\t\t/* set new console device */\n\t\t\t\trt_console_set_device_imp(rt_console_device);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn old;\n}", "CodeBleu_score": 49.577306244196215}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\t\trt_device_t old;\n\trt_device_t console;\n\n\tRT_ASSERT(name!= RT_NULL);\n\n\t/* save the old console device */\n\told = rt_console_get_device();\n\n\t/* find the new console device */\n\tconsole = rt_device_find(name);\n\tif (console!= RT_NULL) {\n\t\t/* check if it is the same as the current console device */\n\t\tif (console!= old) {\n\t\t\t/* close the old console device */\n\t\t\tif (old!= RT_NULL) {\n\t\t\t\trt_device_close(old);\n\t\t\t}\n\n\t\t\t/* set the new console device */\n\t\t\trt_device_open(console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n\t\t\trt_console_set_device_imp(console);\n\t\t}\n\t}\n\n\treturn old;\n}", "CodeBleu_score": 43.0124118478858}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint length = 0;\n\tstruct rt_object *object = NULL;\n\tstruct rt_object_class *class = rt_object_get_class(type);\n\n\trt_spin_lock(&class->lock);\n\trt_list_for_each_entry(object, &class->object_list, list) {\n\t\tlength++;\n\t}\n\trt_spin_unlock(&class->lock);\n\n\treturn length;\n}", "CodeBleu_score": 26.696553005001434}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tint count = 0;\n\tstruct rt_object_class *class;\n\trt_spinlock_lock(&rt_object_class_lock);\n\tclass = rt_object_class_get(type);\n\tif (class) {\n\t\tstruct rt_object *object;\n\t\tlist_for_each_entry(object, &class->object_list, list) {\n\t\t\tcount++;\n\t\t}\n\t}\n\trt_spinlock_unlock(&rt_object_class_lock);\n\treturn count;\n}", "CodeBleu_score": 31.099365464249168}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\t\tstruct rt_object_class *object_class;\n\tint count = 0;\n\n\tobject_class = rt_object_class_get(type);\n\tif (object_class == NULL) {\n\t\treturn 0;\n\t}\n\n\trt_spinlock_lock(&object_class->lock);\n\tcount = object_class->length;\n\trt_spinlock_unlock(&object_class->lock);\n\n\treturn count;\n}", "CodeBleu_score": 28.006761652113422}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t\tRT_ASSERT(object!= RT_NULL);\n\n\tif (object->type_info!= RT_NULL) {\n\t\tif (object->type_info->detach_hook!= RT_NULL) {\n\t\t\tobject->type_info->detach_hook(object);\n\t\t}\n\n\t\trt_object_information_t info = object->type_info;\n\n\t\trt_spin_lock(&info->list_lock);\n\t\trt_list_remove(&(object->list));\n\t\trt_spin_unlock(&info->list_lock);\n\n\t\tobject->type = 0;\n\t}\n}", "CodeBleu_score": 47.12075385039897}, {"code": "void rt_object_detach(rt_object_t object){\n\t\trt_object_information_t object_information;\n\tRT_ASSERT(object!= RT_NULL);\n\n\t/* get object information */\n\tobject_information = rt_object_get_information(object->type);\n\tif (object_information!= RT_NULL) {\n\t\t/* invoke object detach hook */\n\t\tif (object_information->detach_hook!= RT_NULL) {\n\t\t\tobject_information->detach_hook(object);\n\t\t}\n\n\t\t/* lock object spinlock */\n\t\trt_spin_lock_irqsave(&(object->spinlock));\n\n\t\t/* remove from object list */\n\t\trt_list_remove(&(object->list));\n\n\t\t/* unlock object spinlock */\n\t\trt_spin_unlock_irqrestore(&(object->spinlock));\n\n\t\t/* set object type to zero */\n\t\tobject->type = 0;\n\t}\n}", "CodeBleu_score": 43.204395285246875}, {"code": "void rt_object_detach(rt_object_t object){\n\t\tif (object!= RT_NULL) {\n\t\tif (object->type_info->detach_hook!= RT_NULL) {\n\t\t\tobject->type_info->detach_hook(object);\n\t\t}\n\n\t\trt_object_information_t info = object->type_info;\n\t\trt_spin_lock(&info->list_lock);\n\t\trt_list_remove(&(object->list));\n\t\trt_spin_unlock(&info->list_lock);\n\n\t\tobject->type = RT_Object_Class_None;\n\t}\n}", "CodeBleu_score": 45.48671459405993}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\n\t/* object check */\n\tRT_ASSERT(obj!= RT_NULL);\n\tRT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n\t/* check if object has a destroy method */\n\tif (obj->destroy!= RT_NULL) {\n\t\t/* call the destroy method */\n\t\tresult = obj->destroy(obj);\n\t} else {\n\t\t/* set result to success */\n\t\tresult = RT_EOK;\n\t}\n\n\t/* delete object */\n\trt_object_delete(obj);\n\n\t/* return result of the destroy operation */\n\treturn result;\n}", "CodeBleu_score": 43.61635832068394}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result;\n\trt_object_t object = (rt_object_t)obj;\n\tstruct rt_object_information *information;\n\n\t/* object check */\n\tRT_ASSERT(object!= RT_NULL);\n\tRT_ASSERT(object->type == RT_Object_Class_Custom);\n\n\tinformation = rt_object_get_information((enum rt_object_class_type)object->type);\n\tRT_ASSERT(information!= RT_NULL);\n\n\t/* call destroy method */\n\tif (information->destroy!= RT_NULL)\n\t\tresult = information->destroy(object);\n\telse\n\t\tresult = RT_EOK;\n\n\t/* delete object */\n\trt_object_delete(object);\n\n\treturn result;\n}", "CodeBleu_score": 43.8767609186855}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\tt_err_t result = RT_EOK;\n\trt_object_t object = obj;\n\n\t/* object check */\n\tRT_ASSERT(object!= RT_NULL);\n\tRT_ASSERT(!(object->type & RT_Object_Class_Static));\n\tRT_ASSERT(object->type & RT_Object_Class_Custom);\n\n\t/* check if object has a destroy method */\n\tif (object->destroy) {\n\t\t/* call the destroy method */\n\t\tresult = object->destroy(object);\n\t}\n\n\t/* delete object */\n\trt_object_delete(object);\n\n\treturn result;\n}", "CodeBleu_score": 45.37600861799671}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\tef RT_USING_SMP\n    rt_cpu_t cpu;\n    rt_base_t level;\n#endif /* RT_USING_SMP */\n    rt_thread_t thread;\n\n    /* get current thread */\n    thread = rt_thread_self();\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* close thread */\n    rt_thread_close(thread);\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 39.01825248342544}, {"code": "static void _thread_exit(void){\n\tdefined(RT_USING_USER_MAIN) && defined(RT_USING_FINSH)\n    extern void finsh_set_device(const char* device);\n#endif\n\n    rt_thread_t thread;\n    rt_uint8_t stat;\n\n    thread = rt_thread_self();\n    stat = rt_sched_thread_get_stat(thread);\n\n    if (stat!= RT_THREAD_CLOSE)\n    {\n        /* set thread status */\n        rt_sched_thread_close(thread);\n\n#if defined(RT_USING_USER_MAIN) && defined(RT_USING_FINSH)\n        /* set finsh device */\n        if (thread->user_entry == RT_NULL)\n            finsh_set_device(RT_NULL);\n#endif\n    }\n\n    /* do scheduler */\n    rt_schedule();\n}", "CodeBleu_score": 56.52121059289451}, {"code": "static void _thread_exit(void){\n\tdefined(RT_USING_HOOK)\n    rt_thread_t thread;\n    rt_base_t level;\n\n    level = rt_hw_interrupt_disable();\n    thread = rt_current_thread;\n    rt_hw_interrupt_enable(level);\n\n    /* invoke thread exit hook */\n    rt_thread_exit_hook(thread);\n#endif\n\n    /* close thread */\n    rt_thread_close(rt_current_thread);\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 62.62744325612174}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t\tstruct thread *thread = parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\t_sched_lock();\n\tif (thread->state == THREAD_SUSPENDED) {\n\t\tthread->error = ETIMEDOUT;\n\t\t_list_remove(&thread->list);\n\t\t_list_add(&thread->list, &_ready_list);\n\t\t_sched_unlock();\n\t\t_sched_reschedule();\n\t} else {\n\t\t_sched_unlock();\n\t}\n}", "CodeBleu_score": 30.05579715361335}, {"code": "static void _thread_timeout(void *parameter){\n\t\t_thread_t *thread = (_thread_t *)parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tif (thread->magic!= THREAD_MAGIC) {\n\t\treturn;\n\t}\n\n\tif (thread->state!= THREAD_STATE_SUSPENDED) {\n\t\treturn;\n\t}\n\n\t_scheduler_lock();\n\tthread->error = ETIMEDOUT;\n\t_thread_remove_from_suspend_list(thread);\n\t_thread_insert_into_ready_list(thread);\n\t_scheduler_unlock();\n}", "CodeBleu_score": 38.874225341718954}, {"code": "static void _thread_timeout(void *parameter){\n\t\tthread_t thread = (thread_t)parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tscheduler_lock();\n\tif (thread->state == THREAD_STATE_SUSPENDED) {\n\t\tthread->error = ETIMEDOUT;\n\t\tthread->state = THREAD_STATE_READY;\n\t\tlist_remove(&thread->suspend_list);\n\t\tlist_insert(&thread->ready_list, &ready_list);\n\t\tscheduler_unlock();\n\t\tscheduler_reschedule();\n\t} else {\n\t\tscheduler_unlock();\n\t}\n}", "CodeBleu_score": 31.301898937520058}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\t/* Lock the thread's spinlock */\n\tspinlock_lock(&thread->spinlock);\n\n\t/* Check if the thread is waiting on a mutex */\n\tif (thread->pending_object!= NULL) {\n\t\t/* Remove the thread from the mutex's waiting list */\n\t\tlist_remove(&thread->pending_object->waiting_list, &thread->pending_object_node);\n\n\t\t/* Clear the pending object */\n\t\tthread->pending_object = NULL;\n\t}\n\n\t/* Release all mutexes the thread has taken */\n\t_thread_release_all_mutexes(thread);\n\n\t/* Release the thread's spinlock */\n\tspinlock_unlock(&thread->spinlock);\n}", "CodeBleu_score": 15.720743202446243}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\trt_spinlock_lock(&thread->spinlock);\n\tif (thread->pending_object!= NULL) {\n\t\trt_object_t object = thread->pending_object;\n\t\tthread->pending_object = NULL;\n\t\tif (object->type == RT_Object_Class_Mutex) {\n\t\t\trt_mutex_t mutex = (rt_mutex_t)object;\n\t\t\trt_list_remove(&thread->list);\n\t\t\tmutex->waiting_list_size--;\n\t\t}\n\t}\n\trt_spinlock_unlock(&thread->spinlock);\n}", "CodeBleu_score": 21.06952902456909}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\t\tif (thread->state == RT_THREAD_SUSPEND) {\n\t\t/* the thread is waiting on a mutex */\n\t\trt_object_t object = thread->pending_object;\n\t\tif (object!= RT_NULL) {\n\t\t\trt_mutex_t mutex = (rt_mutex_t)object;\n\t\t\trt_base_t level;\n\n\t\t\t/* remove thread from mutex's waiting list */\n\t\t\tlevel = rt_hw_interrupt_disable();\n\t\t\trt_list_remove(&(thread->tlist));\n\t\t\trt_hw_interrupt_enable(level);\n\n\t\t\t/* clear the pending object */\n\t\t\tthread->pending_object = RT_NULL;\n\t\t}\n\t}\n\telse if (thread->state == RT_THREAD_READY) {\n\t\t/* the thread has taken a mutex */\n\t\trt_base_t level;\n\n\t\t/* restore the original priority */\n\t\tlevel = rt_hw_interrupt_disable();\n\t\tthread->current_priority = thread->init_priority;\n\t\trt_hw_interrupt_enable(level);\n\t}\n}", "CodeBleu_score": 38.54879327878798}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t) thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* check thread is in the initialization state */\n\tif (thread->stat == RT_THREAD_INIT) {\n\t\t/* initialize thread priority */\n\t\trt_thread_init_priority(thread);\n\n\t\t/* reset thread state */\n\t\tthread->stat = RT_THREAD_SUSPEND;\n\n\t\t/* resume thread */\n\t\tresult = rt_thread_resume(thread);\n\t} else {\n\t\tresult = -RT_EBUSY;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 55.32102486458841}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t result;\n\t/* parameter check */\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\t/* check thread is not in the initialization state */\n\tif (thread->stat == RT_THREAD_INIT) {\n\t\t/* set thread name */\n\t\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\t\t/* set thread priority */\n\t\tthread->current_priority = thread->init_priority;\n\t\t/* reset thread state */\n\t\tthread->stat = RT_THREAD_SUSPEND;\n\t\t/* resume thread */\n\t\tresult = rt_thread_resume(thread);\n\t} else {\n\t\t/* error code */\n\t\tresult = -RT_ERROR;\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.75754533051516}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t ret;\n\n\tRT_ASSERT(thread!= RT_NULL);\n\tRT_ASSERT(rt_object_get_type((rt_object_t) thread) == RT_Object_Class_Thread);\n\n\tLOG_D(\"thread startup: %s\", thread->parent.name);\n\n\t/* set thread's priority */\n\trt_thread_control(thread, RT_THREAD_CTRL_SET_PRIORITY, RT_NULL);\n\n\t/* set thread's priority attribute */\n\trt_thread_control(thread, RT_THREAD_CTRL_SET_PRIORITY_ATTR, RT_NULL);\n\n\t/* reset thread's state */\n\tthread->stat = RT_THREAD_INIT;\n\n\t/* resume thread */\n\tret = rt_thread_resume(thread);\n\n\t/* trigger scheduler */\n\trt_schedule();\n\n\treturn ret;\n}", "CodeBleu_score": 55.54616416155951}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t timer;\n\n\t/* get highest level list */\n\tlist = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n\t/* check if list is empty */\n\tif (rt_list_isempty(list)) {\n\t\treturn -RT_ETIMEOUT;\n\t}\n\n\t/* get first timer entry */\n\ttimer = rt_list_entry(list->next, rt_timer_t, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n\t/* set timeout tick */\n\t*timeout_tick = timer->timeout_tick;\n\n\treturn RT_EOK;\n}", "CodeBleu_score": 58.26023935990447}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t timer;\n\n\t/* get the highest level of the timer skip list */\n\tlist = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n\t/* check if the list is empty */\n\tif (rt_list_isempty(list)) {\n\t\t/* the list is empty */\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get the first timer entry */\n\ttimer = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n\t/* set the timeout tick to the timer's timeout value */\n\t*timeout_tick = timer->timeout_tick;\n\n\t/* return RT_EOK */\n\treturn RT_EOK;\n}", "CodeBleu_score": 62.62626910606288}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\t\trt_list_t *list;\n\trt_timer_t timer;\n\trt_tick_t tick;\n\n\t/* get the highest level of the timer skip list */\n\tlist = &timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1];\n\n\t/* check if the highest level of the timer skip list is not empty */\n\tif (rt_list_isempty(list)) {\n\t\t/* the list is empty, return an error code */\n\t\treturn -RT_ERROR;\n\t}\n\n\t/* get the first timer entry */\n\ttimer = rt_list_entry(list->next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n\t/* get the timer's timeout value */\n\ttick = timer->timeout_tick;\n\n\t/* set the provided timeout tick to the timer's timeout value */\n\t*timeout_tick = tick;\n\n\t/* return RT_EOK */\n\treturn RT_EOK;\n}", "CodeBleu_score": 56.85640506961166}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t#ifdef RT_USING_TIMER_ALL_SOFT\n    flag |= RT_TIMER_FLAG_SOFT_TIMER;\n#endif\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check parameters */\n    RT_ASSERT(timeout!= RT_NULL);\n    RT_ASSERT(time > 0);\n\n    /* allocate object */\n    rt_timer_t timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer!= RT_NULL)\n    {\n        /* initialize object */\n        _timer_init(timer, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}", "CodeBleu_score": 61.15600228963758}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* check parameter */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer!= RT_NULL)\n\t{\n\t\t/* initialize object */\n\t\t_timer_init(timer, timeout, parameter, time, flag);\n\t}\n\n\treturn timer;\n}", "CodeBleu_score": 57.054141967770434}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\t\trt_timer_t timer;\n\n\t/* check parameters */\n\tRT_ASSERT(timeout!= RT_NULL);\n\tRT_ASSERT(time > 0);\n\n\t/* allocate object */\n\ttimer = (rt_timer_t) rt_object_allocate(RT_Object_Class_Timer, name);\n\tif (timer == RT_NULL) {\n\t\treturn RT_NULL;\n\t}\n\n\t/* initialize timer */\n\t_timer_init(timer, timeout, parameter, time, flag);\n\n\treturn timer;\n}", "CodeBleu_score": 70.77537080392271}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\tvar err error\n\tvar recorder *httptest.ResponseRecorder\n\n\t// Process the request through each handler\n\tfor _, handler := range a.handlers {\n\t\trecorder = httptest.NewRecorder()\n\t\thandler(recorder, req)\n\n\t\t// Check for unauthorized status\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\terr = fmt.Errorf(\"not authorized\")\n\t\t\tbreak\n\t\t}\n\n\t\t// Copy the recorder's headers to the original response\n\t\tfor header, values := range recorder.HeaderMap {\n\t\t\tres.Header()[header] = values\n\t\t}\n\t}\n\n\t// If all handlers pass without unauthorized status, forward the request to the router\n\tif err == nil {\n\t\ta.router.ServeHTTP(res, req)\n\t} else {\n\t\t// If any handler returns a \"401 Unauthorized\" status, send a \"Not Authorized\" error response\n\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\tres.Write([]byte(\"Not Authorized\"))\n\t}\n}", "CodeBleu_score": 48.5804883160641}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Pass the request through each handler in the chain\n\tfor _, handler := range a.handlers {\n\t\t// Capture the response using the recorder\n\t\thandler.ServeHTTP(recorder, req)\n\n\t\t// Copy the recorder's headers to the original response\n\t\tfor key, values := range recorder.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\n\t\t// If the recorder's status code is \"401 Unauthorized\", send a \"Not Authorized\" error response and stop processing\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Forward the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 61.45627485823526}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t\t// Create a recorder to capture the response\n\trecorder := httptest.NewRecorder()\n\n\t// Pass the request through the handlers\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\n\t\t// If the response is unauthorized, return a \"Not Authorized\" error\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Copy the recorder's headers to the original response\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\n\t// If all handlers pass without unauthorized status, forward the request to the router\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 60.866202327825604}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t", "CodeBleu_score": 2.29984901754818}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t", "CodeBleu_score": 2.29984901754818}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t\tlog.Println(\"robeaux\")\n\t// Get the URL path\n\tpath := req.URL.Path\n\tlog.Println(path)\n\t// Check if the path is a directory\n\tif strings.HasSuffix(path, \"/\") {\n\t\tpath += \"index.html\"\n\t}\n\n\t// Check if the path is a valid asset\n\tif strings.HasPrefix(path, \"/assets/\") {\n\t\t// Get the file extension\n\t\text := filepath.Ext(path)\n\t\t// Set the Content-Type header based on the file extension\n\t\tswitch ext {\n\t\tcase \".js\":\n\t\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t\tcase \".css\":\n\t\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t\tcase \".html\":\n\t\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\t}\n\n\t\t// Get the asset from the filesystem\n\t\tasset, err := fs.ReadFile(path)\n\t\tif err!= nil {\n\t\t\t// Handle error\n\t\t\tlog.Println(\"Asset not found:\", path)\n\t\t\thttp.Error(res, \"Asset not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\t// Write the asset content to the response\n\t\tres.Write(asset)\n\t} else {\n\t\t// Handle invalid asset\n\t\tlog.Println(\"Invalid asset:\", path)\n\t\thttp.Error(res, \"Invalid asset\", http.StatusNotFound)\n\t}\n}", "CodeBleu_score": 49.2419190129009}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Find the robot using the master instance\n\trobot := a.master.Robot(robotName)\n\n\t// If the robot is found, gather its connections and convert them to JSON format\n\tif robot!= nil {\n\t\tconnections := robot.Connections()\n\t\tjsonResponse, err := json.Marshal(connections)\n\t\tif err!= nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Write the JSON response containing the connections\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(jsonResponse)\n\t} else {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\thttp.Error(res, fmt.Sprintf(\"No robot found with name %s\", robotName), http.StatusNotFound)\n\t}\n}", "CodeBleu_score": 32.215958851693884}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Find the robot using the master instance\n\trobot, err := a.master.GetRobot(robotName)\n\tif err!= nil {\n\t\t// If the robot is not found, write a JSON error message\n\t\twriteJSONError(res, http.StatusNotFound, fmt.Sprintf(\"No robot found with name: %s\", robotName))\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections := robot.GetConnections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err!= nil {\n\t\t// If there is an error converting to JSON, write a JSON error message\n\t\twriteJSONError(res, http.StatusInternalServerError, fmt.Sprintf(\"Error converting connections to JSON: %v\", err))\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 37.683291937993665}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot := a.master.GetRobot(robotName)\n\tif robot == nil {\n\t\ta.writeJSONError(res, req, \"No robot found with the specified name\")\n\t\treturn\n\t}\n\tconnections := robot.GetConnections()\n\ta.writeJSONResponse(res, req, connections)\n}", "CodeBleu_score": 28.436262969766744}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"Not Authorized\n\"))\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.46751555614203}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.25288087038935}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\t\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif!ok ||!secureCompare(user, username) ||!secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 52.25288087038935}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.423369332856396}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\t// Calculate the slope and intercept for the scaling transformation\n\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Calculate the scaled value\n\t\tscaled := slope * input + intercept\n\n\t\t// Clamp the scaled value within the target range\n\t\tif scaled < float64(toMin) {\n\t\t\tscaled = float64(toMin)\n\t\t} else if scaled > float64(toMax) {\n\t\t\tscaled = float64(toMax)\n\t\t}\n\n\t\t// Convert the scaled value to an integer and return it\n\t\tvalue = int(scaled)\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.39698025746945}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\t\tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope * fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t} else if value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 53.17342140370616}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.isValid() {\n\t\treturn 0, 0, errors.New(\"invalid connection\")\n\t}\n\n\traw, err := a.Connection.AnalogSensorRead(a.Pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 45.778322548052216}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif!a.connection.AnalogSensorReadSupported() {\n\t\treturn 0, 0, errors.New(\"analog sensor read not supported\")\n\t}\n\n\traw, err := a.connection.AnalogSensorRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 47.122897641770045}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif!a.connection.IsAnalogSensor() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\traw, err := a.connection.AnalogSensorRead(a.pin)\n\tif err!= nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 46.83725079268131}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMax - m * float64(fromMax)\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 52.60020625208235}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 50.014168640519465}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\t\tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\treturn func(input int) float64 {\n\t\treturn m * float64(input) + n\n\t}\n}", "CodeBleu_score": 52.72203710343628}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(\"Grove Piezo Vibration Sensor\")\n\td.AddEvent(\"vibration\")\n\td.On(\"data\", func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(\"vibration\", true)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 41.87397359742909}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...),\n\t\tthreshold:          1000,\n\t}\n}", "CodeBleu_score": 15.847020384882654}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: drivers.NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\td.SetName(\"Grove Piezo Vibration Sensor\")\n\td.AddEvent(VibrationEvent)\n\td.On(\"data\", func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(VibrationEvent, true)\n\t\t}\n\t})\n\treturn d\n}", "CodeBleu_score": 40.827998978154554}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.pin == nil {\n\t\treturn errors.New(\"BuzzerDriver: pin is nil\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"BuzzerDriver: hz must be positive\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"BuzzerDriver: duration must be positive\")\n\t}\n\n\t// Calculate the tone period based on the given frequency\n\ttonePeriod := 1 / hz\n\n\t// Calculate the tempo based on the buzzer's beats per minute (bpm)\n\ttempo := 60 / d.bpm\n\n\t// Calculate the number of iterations required to match the desired duration\n\titerations := int(duration / tempo)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < iterations; i++ {\n\t\tif err := d.pin.High(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Second)\n\t\tif err := d.pin.Low(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod/2) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.95375409987248}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\tif d.Pin == nil {\n\t\treturn errors.New(\"Buzzer driver not properly initialized\")\n\t}\n\n\t// Calculate the tone period based on the given frequency (hz) and the tempo based on the buzzer's beats per minute (bpm).\n\ttonePeriod := 1000000.0 / hz\n\ttempo := 60000.0 / d.Bpm\n\n\t// Calculate the number of tone periods needed to match the desired tempo.\n\tnumPeriods := math.Floor(duration / tempo)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\n\tfor i := 0.0; i < numPeriods; i++ {\n\t\tif err := d.Pin.High(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Microsecond)\n\t\tif err := d.Pin.Low(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 57.13570180991627}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\t\t// Calculate the tone period based on the given frequency\n\ttonePeriod := 1 / hz\n\n\t// Calculate the tempo based on the buzzer's beats per minute (bpm)\n\ttempo := 60 / d.bpm\n\n\t// Calculate the number of tone periods required to match the desired tempo\n\tnumPeriods := int(duration / tempo)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period, repeating this process for the desired duration\n\tfor i := 0; i < numPeriods; i++ {\n\t\tif err := d.On(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\t\tif err := d.Off(); err!= nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(tonePeriod) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 60.51363077748678}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 29.330632377623555}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif d.sleepPin == nil {\n\t\treturn errors.New(\"EasyDriver: No sleep pin configured\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 30.02896929999378}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\t\tif!d.sleepPin.IsSet() {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\td.stop()\n\td.sleepPin.SetLow()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 27.123970409334785}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif!a.pinsInitialized {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.pinParams(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err := a.newAnalogPin(path, params)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 47.003322882898}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"Pins map not initialized\")\n\t}\n\tif _, ok := a.Pins[id]; ok {\n\t\treturn a.Pins[id], nil\n\t}\n\n\tpath, params := a.translate(id)\n\tpin := newAnalogPin(path, params)\n\ta.Pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 39.173142761039806}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\t\tif!a.pinsInitialized {\n\t\treturn nil, errors.New(\"AnalogPinsAdaptor not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translateID(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\tpin := a.newAnalogPin(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 48.18486538962261}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id, 1)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.DigitalWrite(val)\n}", "CodeBleu_score": 62.04210382516895}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.DigitalWrite(val)\n}", "CodeBleu_score": 61.68491757545838}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\t\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.getDigitalPin(id)\n\tif err!= nil {\n\t\treturn err\n\t}\n\treturn pin.DigitalWrite(val)\n}", "CodeBleu_score": 61.68491757545838}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins) == 0 {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected to any pins\")\n\t}\n\n\topts = append(opts, gobot.WithPinMode(gobot.Mode(a.DefaultMode)))\n\topts = append(opts, gobot.WithPinPull(gobot.Pull(a.DefaultPull)))\n\n\tpin, err := a.Pins.Get(id, opts...)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 37.022580379492034}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.Connected() {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\tvar pin gobot.DigitalPinOptioner\n\tvar err error\n\n\tfor _, p := range a.pins {\n\t\tif p.ID() == id {\n\t\t\tpin = p\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif pin == nil {\n\t\tpin, err = a.digitalPinFromID(id)\n\t\tif err!= nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ta.pins = append(a.pins, pin)\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 42.579468437466204}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif!a.Connected() {\n\t\treturn nil, errors.New(\"adaptor not connected\")\n\t}\n\n\t// Apply options to the pin's existing options\n\tfor _, opt := range opts {\n\t\topt(a.pins[id])\n\t}\n\n\t// Try to retrieve the pin by its ID\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\n\t// Translate the ID to obtain chip and line information\n\tchip, line, err := a.translatePinID(id)\n\tif err!= nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new digital pin, initialize it, and store it\n\tpin = &digitalPin{\n\t\tchip:     chip,\n\t\tline:     line,\n\t\tmode:     gobot.PinMode(a.defaultMode),\n\t\tpull:     gobot.PinPull(a.defaultPull),\n\t\tinverted: a.defaultInverted,\n\t\tname:     id,\n\t\tadaptor:  a,\n\t}\n\n\tif err := pin.init(); err!= nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}", "CodeBleu_score": 51.7504573472807}]}
