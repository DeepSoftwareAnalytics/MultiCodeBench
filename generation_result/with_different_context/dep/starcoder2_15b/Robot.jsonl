{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get the list of required files from the server\n\tauto requiredFiles = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\tif (download) {\n\t\t// Check if each file exists locally\n\t\tfor (const auto &requiredFile : requiredFiles) {\n\t\t\tif (!FileTransfer::FileExists(requiredFile)) {\n\t\t\t\t// If the file is not found, request it from the server and log the download action\n\t\t\t\t_pimpl->Log(\"Downloading file: \" + requiredFile);\n\t\t\t\tRequestFile(requiredFile);\n\t\t\t} else {\n\t\t\t\t// If the file exists, log that it is found in the cache\n\t\t\t\t_pimpl->Log(\"File found in cache: \" + requiredFile);\n\t\t\t}\n\t\t}\n\t}\n\treturn requiredFiles;\n}", "CodeBleu_score": 67.91820418639526}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get a list of required files from a specified folder\n\t// If the download flag is set to true, check if each file exists locally\n\t// If a file is not found, request the file and log the download action\n\t// If the file exists, log that the file is found in the cache\n\t// Finally, return the list of required files\n\tauto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\tif (download) {\n\t\tfor (const auto &file : required_files) {\n\t\t\tif (!FileTransfer::FileExists(file)) {\n\t\t\t\tRequestFile(file);\n\t\t\t\tLOG_INFO(\"Downloaded file: \" + file);\n\t\t\t} else {\n\t\t\t\tLOG_INFO(\"Found file in cache: \" + file);\n\t\t\t}\n\t\t}\n\t}\n\treturn required_files;\n}", "CodeBleu_score": 63.109555385073094}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t\t// Get the list of files from the server\n\tauto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\t// Check if the files are present locally\n\tfor (const auto &file : files) {\n\t\tif (download &&!FileTransfer::FileExists(file)) {\n\t\t\t// If the file is not found locally, request it from the server\n\t\t\tRequestFile(file);\n\t\t\t// Log the download action\n\t\t\tLog::Info(\"Downloaded file: \" + file);\n\t\t} else {\n\t\t\t// If the file is found locally, log that it is found in the cache\n\t\t\tLog::Info(\"Found file in cache: \" + file);\n\t\t}\n\t}\n\t// Return the list of required files\n\treturn files;\n}", "CodeBleu_score": 55.73209453073492}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef _WIN32\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation[0]!= 0.0 || transform.translation[1]!= 0.0) {\n      std::string warning = \"WARNING: SpringArm and SpringArmGhost attachment types are ill-formed when the translation is only in the 'z' axis. \"\n                            \"The spawned actor will be spawned with a translation of (0, 0, 0).\";\n      std::cout << warning << std::endl;\n    }\n  }\n#endif\n  return SpawnActorWithParent_Internal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 48.86056962290727}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#if 0\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation.x() == 0.0f &&\n        transform.translation.y() == 0.0f) {\n      LOG(WARNING) << \"Warning: A SpringArm or SpringArmGhost attachment \"\n          \"should not have a translation in the 'x' and 'y' axes. \"\n          \"Please check the transform you provided.\";\n    }\n  }\n#endif\n\n  return SpawnActorInternal(description, transform, parent, attachment_type,\n                            socket_name);\n}", "CodeBleu_score": 43.82436190092135}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\t#ifdef _WIN32\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation.x!= 0 || transform.translation.y!= 0) {\n      LOG_WARNING(\"SpringArm and SpringArmGhost attachments should only be attached to actors with a translation in the 'z' axis. This is an ill-formed transformation.\");\n    }\n  }\n#endif\n  return SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 41.447542324629026}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t#ifdef _WIN32\n  if (m_pClient->IsConnected()) {\n    auto token = m_pClient->SubscribeToGBuffer(ActorId, GBufferId);\n    auto tokenData = token.GetData();\n    m_pClient->SubscribeToStreamingClient(tokenData, callback);\n  }\n#endif\n}", "CodeBleu_score": 40.879040162527716}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t", "CodeBleu_score": 7.083333333333333}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t#if!defined(DISABLE_RPC_CALLS)\n  // Get token for the G-buffer\n  rpc::GBufferToken token = GetGBufferToken(ActorId, GBufferId);\n\n  // Copy the token data\n  uint32_t token_data[rpc::GBUFFER_TOKEN_SIZE];\n  memcpy(token_data, token.data, sizeof(token_data));\n\n  // Subscribe to the G-buffer\n  m_rpc_client->SubscribeToGBuffer(\n    token_data,\n    [callback](rpc::Buffer buffer) {\n      callback(Buffer(buffer.data, buffer.size));\n    });\n#endif\n}", "CodeBleu_score": 44.141118456527565}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> nav = GetNavigation();\n\tif (nav == nullptr) {\n\t\tnav = std::make_shared<WalkerNavigation>(this);\n\t\tSetNavigation(nav);\n\t}\n\treturn nav;\n}", "CodeBleu_score": 40.97430420769992}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tstd::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t\tSetNavigation(navigation);\n\t}\n\treturn navigation;\n}", "CodeBleu_score": 37.30578216758509}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\t\tif (m_pNavigation == nullptr) {\n\t\tm_pNavigation = std::make_shared<WalkerNavigation>();\n\t}\n\treturn m_pNavigation;\n}", "CodeBleu_score": 25.28677778486781}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\ttime_point start_time = clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tif (clock::now() - start_time > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tyield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 25.00886017897429}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::high_resolution_clock::now();\n\tauto end = start + timeout;\n\twhile (episode.GetFrame() < frame) {\n\t\tif (std::chrono::high_resolution_clock::now() > end) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 40.59537479275419}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\t\tauto start = std::chrono::steady_clock::now();\n\twhile (episode.GetFrame() < frame) {\n\t\tif (std::chrono::steady_clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}", "CodeBleu_score": 34.74974821785}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tGetReadyLoadEpisode(map_name, reset_settings, map_layers);\n\treturn EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 13.11906379187322}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t#ifdef _WIN32\n    std::string map_name_win = map_name;\n    std::replace(map_name_win.begin(), map_name_win.end(), '/', '\\\\');\n    map_name = map_name_win;\n#endif\n    rpc::LoadEpisodeRequest request;\n    request.set_map_name(map_name);\n    request.set_reset_settings(reset_settings);\n    request.set_map_layers(map_layers);\n    rpc::LoadEpisodeResponse response = _client->LoadEpisode(request);\n    if (response.status() == rpc::Status::SUCCESS) {\n      _current_episode_id = response.episode_id();\n      _current_episode_map_name = map_name;\n      return EpisodeProxy{shared_from_this()};\n    } else {\n      throw std::runtime_error(\"Failed to load episode.\");\n    }\n  }", "CodeBleu_score": 38.25270963370448}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\t\tif (map_name.empty()) {\n\t\tmap_name = \"empty\";\n\t}\n\tif (map_name.find(\".xml\") == std::string::npos) {\n\t\tmap_name += \".xml\";\n\t}\n\tif (map_name.find(\"/\") == std::string::npos) {\n\t\tmap_name = \"maps/\" + map_name;\n\t}\n\tauto request = rpc::LoadEpisodeRequest(map_name, reset_settings, map_layers);\n\tauto response = client.call(\"loadEpisode\", request);\n\tif (response.error()) {\n\t\tthrow std::runtime_error(response.error().message());\n\t}\n\treturn EpisodeProxy{shared_from_this(), response.result().episode_id};\n}", "CodeBleu_score": 33.05182825691683}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\tif (controller.GetWalkerID() == \"\") {\n\t\tthrow std::invalid_argument(\"The walker ID is empty.\");\n\t}\n\tif (m_episode == nullptr) {\n\t\tthrow std::invalid_argument(\"The episode is null.\");\n\t}\n\tauto walker = m_episode->GetWalker(controller.GetWalkerID());\n\tif (walker == nullptr) {\n\t\tthrow std::invalid_argument(\"The walker with ID \" + controller.GetWalkerID() + \" was not found.\");\n\t}\n\tif (m_episode->GetNavigation() == nullptr) {\n\t\tm_episode->CreateNavigation();\n\t}\n\tm_episode->GetNavigation()->RegisterWalker(controller.GetWalkerID());\n}", "CodeBleu_score": 53.949264539076026}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// TODO: check if the walker exists, throw an exception if it doesn't\n\t// TODO: assert that the episode is not null\n\t// TODO: create navigation if it is missing\n\t// TODO: register the walker with the controller's ID\n}", "CodeBleu_score": 3.474280175871659}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\t\t// Retrieve the walker associated with the controller\n\tauto walker = GetWalker(controller.GetWalkerId());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker \" + controller.GetWalkerId() + \" not found.\");\n\t}\n\n\t// Assert that the episode is not null\n\tassert(episode!= nullptr);\n\n\t// Create navigation if it is missing\n\tif (episode->navigation == nullptr) {\n\t\tepisode->navigation = std::make_shared<Navigation>(episode->map);\n\t}\n\n\t// Register the walker with the controller's ID\n\tepisode->navigation->RegisterWalker(controller.GetWalkerId(), walker);\n}", "CodeBleu_score": 55.960069772189236}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef _WIN32\n    if (gc == GarbageCollectionPolicy::DESTROY_ON_EPISODE_END && parent!= nullptr) {\n      throw std::invalid_argument(\"Cannot specify a parent actor with DESTROY_ON_EPISODE_END garbage collection policy\");\n    }\n#else\n    if (gc == GarbageCollectionPolicy::DESTROY_ON_EPISODE_END && parent!= nullptr) {\n      throw std::invalid_argument(\"Cannot specify a parent actor with DESTROY_ON_EPISODE_END garbage collection policy\");\n    }\n#endif\n    auto actor = blueprint.Spawn(transform, parent, attachment_type, socket_name);\n    if (actor == nullptr) {\n      return nullptr;\n    }\n    if (gc == GarbageCollectionPolicy::DESTROY_ON_EPISODE_END) {\n      current_episode_->RegisterActor(actor);\n    } else if (gc == GarbageCollectionPolicy::DESTROY_ON_SCENE_CHANGE) {\n      current_scene_->RegisterActor(actor);\n    }\n    if (parent!= nullptr) {\n      parent->RegisterChild(actor);\n    }\n    LogMessage(\"Spawned actor with id \" + std::to_string(actor->GetId()));\n    return actor;\n  }", "CodeBleu_score": 41.335675480078336}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef _WIN32\n    // On Windows, we need to convert the socket name to a wide string.\n    std::wstring socket_name_wide;\n    if (!socket_name.empty()) {\n      socket_name_wide = utf8_to_wide(socket_name);\n    }\n    auto actor = shared_from_this()->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name_wide);\n#else\n    auto actor = shared_from_this()->SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name);\n#endif\n    return actor;\n  }", "CodeBleu_score": 39.33969128811823}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t#ifdef BUILD_GRPC\n    // Create the actor\n    auto actor = std::make_shared<Actor>(blueprint, transform, parent, attachment_type, socket_name);\n    // Register the actor in the current episode\n    GetCurrentEpisode().RegisterActor(actor, gc);\n    // Log the actor creation\n    LogActorCreation(actor);\n    // Return the actor\n    return actor;\n#else\n    throw std::runtime_error(\"The GRPC extension is not built. Please rebuild the simulator with BUILD_GRPC=ON\");\n#endif\n  }", "CodeBleu_score": 27.907825445968125}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t\n}", "CodeBleu_score": 10.221038326534257}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef _WIN32\n  std::lock_guard<std::mutex> lock(_mutex);\n#endif\n  if (!episode) {\n    throw std::runtime_error(\"Episode not valid\");\n  }\n  auto id = sensor.GetId();\n  if (sensor.IsCamera()) {\n    _cameraSensorCallbacks[id] = callback;\n  } else if (sensor.IsLidar()) {\n    _lidarSensorCallbacks[id] = callback;\n  } else if (sensor.IsRaySensor()) {\n    _raySensorCallbacks[id] = callback;\n  } else {\n    _sensorCallbacks[id] = callback;\n  }\n  _client->SubscribeToStream(\n      sensor.GetId(),\n      [this, id](const std::string &data) {\n        auto sensorData = _client->Deserialize(data);\n        if (sensorData->GetEpisodeId()!= episode->GetId()) {\n          return;\n        }\n        if (_sensorCallbacks.find(id)!= _sensorCallbacks.end()) {\n          _sensorCallbacks[id](sensorData);\n        } else if (_cameraSensorCallbacks.find(id)!=\n                   _cameraSensorCallbacks.end()) {\n          _cameraSensorCallbacks[id](sensorData);\n        } else if (_lidarSensorCallbacks.find(id)!=\n                   _lidarSensorCallbacks.end()) {\n          _lidarSensorCallbacks[id](sensorData);\n        } else if (_raySensorCallbacks.find(id)!= _raySensorCallbacks.end()) {\n          _raySensorCallbacks[id](sensorData);\n        }\n      });\n}", "CodeBleu_score": 42.67552132282763}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t#ifdef _WIN32\n  if (episode_id == 0) {\n    throw std::runtime_error(\n        \"Cannot subscribe to sensor data stream because no episode has been created.\");\n  }\n#else\n  if (episode_id == 0) {\n    throw std::runtime_error(\n        \"Cannot subscribe to sensor data stream because no episode has been created.\");\n  }\n#endif\n  // Get the sensor's data stream.\n  const auto stream_id = sensor.GetStreamId();\n  // Subscribe to the sensor's data stream.\n  client->SubscribeToStream(stream_id, [=](const std::string &data) {\n    // Deserialize the sensor data.\n    auto sensor_data = sensor::Deserialize(data);\n    // Associate the sensor data with the current episode.\n    sensor_data->SetEpisodeId(episode_id);\n    // Invoke the callback with the sensor data.\n    callback(sensor_data);\n  });\n}", "CodeBleu_score": 43.38666476908734}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\tstd::vector<WalkerHandle> walkers;\n// load the walkers\nLoadWalkers(episode, walkers);\n// check if the list is empty\nif (walkers.empty()) return;\n// check if the walkers exist\nCheckIfWalkerExist(walkers, episode->GetState());\n// update the vehicles in the crowd\nUpdateVehiclesInCrowd(episode, false);\n// update the crowd\n_nav.UpdateCrowd();\n// apply the states to the walkers\nstd::vector<carla::geom::Transform> transforms;\nstd::vector<float> speeds;\nfor (auto &&walker : walkers) {\n  // get the transform\n  ActorSnapshot snapshot = episode->GetState().GetActorSnapshot(walker.walker);\n  transforms.push_back(snapshot.transform);\n  // get the speed\n  speeds.push_back(snapshot.velocity.Length());\n}\n// apply the states\n_simulator.lock()->ApplyWalkerBatchState(transforms, speeds);\n// check if any walker is dead\nfor (auto &&walker : walkers) {\n  // get the snapshot\n  ActorSnapshot snapshot = episode->GetState().GetActorSnapshot(walker.walker);\n  // check if it's dead\n  if (snapshot.killed) {\n    // remove from the crowd\n    _nav.RemoveAgent(walker.walker);\n    // destroy the controller\n    _simulator.lock()->DestroyActor(walker.controller);\n    // unregister from list\n    UnregisterWalker(walker.walker, walker.controller);\n  }\n}\n}", "CodeBleu_score": 42.98494559660767}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load the current walkers\n    std::vector<WalkerHandle> walkers = LoadWalkers(episode);\n    if (walkers.empty()) return;\n\n    // check if the walker still exist\n    CheckIfWalkerExist(walkers, *episode->GetState());\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // apply states to walkers\n    std::vector<carla::geom::Transform> transforms;\n    std::vector<float> speeds;\n    for (auto &&walker : walkers) {\n      // get the transform\n      transforms.push_back(episode->GetState()->GetActorSnapshot(walker.walker).transform);\n      // get the speed\n      speeds.push_back(episode->GetState()->GetActorSnapshot(walker.walker).velocity.Length());\n    }\n    // apply the states in batch\n    _simulator.lock()->ApplyTransformAndSpeed(transforms, speeds);\n\n    // check if any walker is dead\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = episode->GetState()->GetActorSnapshot(walker.walker);\n      if (snapshot.health <= 0) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 43.21576416885402}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t\n// load the walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n\n    // check if the list is empty\n    if (walkers.empty())\n      return;\n\n    // check if walkers exist\n    CheckIfWalkerExist(walkers, *episode->GetState());\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update crowd\n    _nav.UpdateCrowd();\n\n    // apply states to walkers\n    std::vector<carla::geom::Transform> transforms;\n    std::vector<float> speeds;\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = episode->GetState()->GetActorSnapshot(walker.walker);\n      // get transform\n      transforms.emplace_back(snapshot.transform);\n      // get speed\n      speeds.emplace_back(snapshot.velocity.Length());\n    }\n\n    // apply to simulator\n    _simulator.lock()->ApplyTransformAndSpeed(transforms, speeds);\n\n    // check if walkers are dead\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = episode->GetState()->GetActorSnapshot(walker.walker);\n      // check if dead\n      if (snapshot.is_alive == false) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 45.14567945549853}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t", "CodeBleu_score": 4.932770825794737}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t", "CodeBleu_score": 4.932770825794737}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\t", "CodeBleu_score": 4.932770825794737}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tstd::vector<SharedPtr<Blueprint>> result;\n\tfor (auto blueprint : blueprints) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tstd::string attr_value = blueprint->GetAttribute(name);\n\t\t\tif (attr_value == value) {\n\t\t\t\tresult.push_back(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn MakeSharedPtr<BlueprintLibrary>(result);\n}", "CodeBleu_score": 33.96653485746373}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tstd::vector<Blueprint> result;\n\tfor (const auto& blueprint : blueprints) {\n\t\tif (blueprint.attributes.find(name)!= blueprint.attributes.end()) {\n\t\t\tconst auto& attribute = blueprint.attributes.at(name);\n\t\t\tif (attribute.values.empty()) {\n\t\t\t\tif (attribute.value == value) {\n\t\t\t\t\tresult.push_back(blueprint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (std::find(attribute.values.begin(), attribute.values.end(), value)!= attribute.values.end()) {\n\t\t\t\t\tresult.push_back(blueprint);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn std::make_shared<BlueprintLibrary>(result);\n}", "CodeBleu_score": 45.5379506404158}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\t\tauto result = std::make_shared<BlueprintLibrary>();\n\tfor (auto& blueprint : blueprints) {\n\t\tauto attr = blueprint->GetAttribute(name);\n\t\tif (attr) {\n\t\t\tif (attr->GetValue() == value || attr->GetRecommendedValues().count(value)) {\n\t\t\t\tresult->AddBlueprint(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 33.484102256397}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tif (path.empty()) {\n\t\treturn false;\n\t}\n\n\tstd::string fullPath = GetFullPath(path);\n\n\tif (ValidatePath(fullPath)) {\n\t\tFILE* file = fopen(fullPath.c_str(), \"wb\");\n\t\tif (file) {\n\t\t\tfwrite(content.data(), sizeof(uint8_t), content.size(), file);\n\t\t\tfclose(file);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 36.52122566934576}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullpath = GetFullPath(path);\n\tif (ValidatePath(fullpath)) {\n\t\tstd::ofstream file(fullpath, std::ios::out | std::ios::binary | std::ios::trunc);\n\t\tif (file.is_open()) {\n\t\t\tfile.write((char*)content.data(), content.size());\n\t\t\tfile.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 40.38754548650824}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\t\tstd::string fullPath = GetFullFilePath(path);\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 39.13995474596425}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t// Get the parent's bounding box\n    const auto &parent_bounds = parent_->GetBounds(frame);\n// Calculate the location by adding the parent's bounding box location to the transform's location\n    const auto location = parent_bounds->location + transform.location;\n// Compute the four corners of the bounding box by rotating the extents based on the yaw angle\n    const auto corners = {\n        Rotate(transform.yaw, {-0.5f * transform.extents.x, -0.5f * transform.extents.y, 0.0f}) + location,\n        Rotate(transform.yaw, {0.5f * transform.extents.x, -0.5f * transform.extents.y, 0.0f}) + location,\n        Rotate(transform.yaw, {0.5f * transform.extents.x, 0.5f * transform.extents.y, 0.0f}) + location,\n        Rotate(transform.yaw, {-0.5f * transform.extents.x, 0.5f * transform.extents.y, 0.0f}) + location};\n// Return a shared pointer to a Bounds object containing the frame number and the calculated corners\n    return std::make_shared<Bounds>(frame, corners);\n  }", "CodeBleu_score": 44.18286846745539}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t//    std::cout << \"MakeBounds\" << std::endl;\n    const auto &location = transform.location;\n    const auto &extents = transform.extents;\n    const auto corners = std::array<geom::Location, 4>{\n        Rotate(transform.yaw, location + geom::Location{extents.x, -extents.y, 0}),\n        Rotate(transform.yaw, location + geom::Location{extents.x, extents.y, 0}),\n        Rotate(transform.yaw, location + geom::Location{-extents.x, extents.y, 0}),\n        Rotate(transform.yaw, location + geom::Location{-extents.x, -extents.y, 0})};\n    return std::make_shared<const LaneInvasionCallback::Bounds>(frame, corners);\n  }", "CodeBleu_score": 43.613126696851}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\t//    // Get the transform's location and yaw angle.\n//    const auto &location = transform.location;\n//    const auto &yaw = transform.yaw;\n//\n//    // Get the parent's bounding box.\n//    const auto &parent_bounds = parent_bounds_[frame];\n//\n//    // Calculate the location of the bounding box.\n//    const auto &bounds_location = parent_bounds->location + location;\n//\n//    // Calculate the four corners of the bounding box.\n//    const auto &bounds_corners = Rotate(yaw, parent_bounds->extents);\n//\n//    // Return a shared pointer to the bounding box.\n//    return std::make_shared<const Bounds>(frame, bounds_location, bounds_corners);\n//  }", "CodeBleu_score": 6.625397345875101}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tauto lights = _server->GetLights();\n\n\t// Update the local light states\n\tfor (auto light : lights) {\n\t\t_lights[light.first] = light.second;\n\t}\n\n\t// Create new light objects if they do not already exist in the _lights map\n\tfor (auto light : _lights) {\n\t\tif (!_lightObjects.count(light.first)) {\n\t\t\t_lightObjects[light.first] = new LightObject(light.first, light.second);\n\t\t}\n\t}\n}", "CodeBleu_score": 29.11160218556948}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Retrieve the light states from the server\n\tstd::vector<LightState> lightStates = server->GetLightStates();\n\n\t// Update the local light states\n\tfor (const LightState& lightState : lightStates) {\n\t\t// Check if the light already exists in the _lights map\n\t\tauto it = _lights.find(lightState.id);\n\t\tif (it == _lights.end()) {\n\t\t\t// If the light does not exist, create a new light object and add it to the _lights map\n\t\t\tLight* light = new Light(lightState.id, lightState.name, lightState.state);\n\t\t\t_lights[lightState.id] = light;\n\t\t} else {\n\t\t\t// If the light already exists, update its state\n\t\t\tit->second->UpdateState(lightState.state);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.254306616002374}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Retrieve the light states from the server\n\tstd::vector<LightState> lightStates = _server->GetLightStates();\n\n\t// Update the local light states\n\tfor (LightState lightState : lightStates) {\n\t\t_lightStates[lightState.id] = lightState;\n\t}\n\n\t// Create new light objects if they do not already exist in the _lights map\n\tfor (auto& lightState : _lightStates) {\n\t\tif (_lights.find(lightState.first) == _lights.end()) {\n\t\t\t_lights[lightState.first] = new Light(lightState.second.id, lightState.second.state, lightState.second.color);\n\t\t}\n\t}\n}", "CodeBleu_score": 36.06260577021063}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (m_dirty) {\n\t\tm_mutex.lock();\n\t\tif (m_dirty) {\n\t\t\t// Create message\n\t\t\tMessage msg;\n\t\t\tmsg.SetMessageType(Message::MessageType::LIGHT_STATE);\n\t\t\tmsg.SetSender(m_player_id);\n\t\t\tmsg.SetRecipient(0);\n\t\t\tmsg.SetContent(m_lights);\n\n\t\t\t// Send message\n\t\t\tm_client->Send(msg);\n\n\t\t\t// Clear changes\n\t\t\tm_dirty = false;\n\t\t}\n\t\tm_mutex.unlock();\n\t}\n}", "CodeBleu_score": 17.828847088715435}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tif (!this->dirty) {\n\t\treturn;\n\t}\n\n\tthis->mutex.lock();\n\n\tif (this->dirty) {\n\t\tif (discard_client) {\n\t\t\tthis->changes.clear();\n\t\t}\n\n\t\tstd::string message = this->CreateMessage();\n\n\t\tthis->mutex.unlock();\n\n\t\tthis->server_connection->Send(message);\n\n\t\tthis->mutex.lock();\n\n\t\tthis->dirty = false;\n\t}\n\n\tthis->mutex.unlock();\n}", "CodeBleu_score": 11.638060253257164}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\t\tstd::lock_guard<std::mutex> lock(light_mutex_);\n\tif (light_dirty_ &&!discard_client) {\n\t\tlight_dirty_ = false;\n\t\tstd::string message = CreateMessage(light_states_);\n\t\tserver_connection_.Send(message);\n\t}\n}", "CodeBleu_score": 18.665754283913774}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->context.id == \"sensor.other.v2x_custom\") {\n\t\tthis->context.episode->Send(message);\n\t} else {\n\t\tLog::Debug(\"ServerSideSensor::Send\", \"Sensor ID does not match \\\"sensor.other.v2x_custom\\\". Sensor ID: \" + this->context.id);\n\t}\n}", "CodeBleu_score": 40.774278535225946}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\tif (this->GetID()!= \"sensor.other.v2x_custom\") {\n\t\tDEBUG_MESSAGE(\"ServerSideSensor::Send called but sensor's ID is not sensor.other.v2x_custom, returning.\");\n\t\treturn;\n\t}\n\tthis->GetEpisode()->Send(this->GetContext(), message);\n}", "CodeBleu_score": 48.23975757331107}, {"code": "void ServerSideSensor::Send(std::string message){\n\t\t// Debug message\n\tLOG(DEBUG) << \"ServerSideSensor::Send called\";\n\n\t// Check if the sensor's ID is \"sensor.other.v2x_custom\"\n\tif (this->GetID() == \"sensor.other.v2x_custom\") {\n\t\t// Send a message to the episode using the sensor's context\n\t\tthis->GetEpisode()->Send(message, this->GetContext());\n\t} else {\n\t\t// Log a warning\n\t\tLOG(WARNING) << \"The sensor's ID is not \\\"sensor.other.v2x_custom\\\"\";\n\t}\n}", "CodeBleu_score": 43.59673893453145}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\t", "CodeBleu_score": 3.793800984027329}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t\t// Register the AI controller with the episode\n\tEpisode::Instance()->RegisterAIController(this);\n\n\t// Retrieve the walker actor\n\twalkerActor = GetOwner()->GetComponent<WalkerActor>();\n\n\t// Add the walker actor to the navigation system with its current location\n\tNavigationSystem::Instance()->AddActor(walkerActor, walkerActor->GetTransform()->GetPosition());\n\n\t// Disable the physics simulation and collisions for the walker actor\n\twalkerActor->SetPhysicsEnabled(false);\n\twalkerActor->SetCollisionsEnabled(false);\n}", "CodeBleu_score": 32.35608214092576}, {"code": "void WalkerAIController::Start(){\n\t\t// Register with the episode\n\tepisode = Episode::Get();\n\tepisode->RegisterAIController(this);\n\n\t// Get the walker actor\n\twalker = Cast<AWalker>(GetPawn());\n\n\t// Add the walker actor to the navigation system\n\tif (walker && walker->GetController()) {\n\t\tUWorld* world = GetWorld();\n\t\tUNavigationSystemV1* navSys = UNavigationSystemV1::GetCurrent(world);\n\t\tif (navSys) {\n\t\t\tnavSys->AddActorToNavigation(walker, walker->GetActorLocation());\n\t\t}\n\t}\n\n\t// Disable the walker actor's physics simulation and collisions\n\tif (walker) {\n\t\twalker->SetActorEnableCollision(false);\n\t\twalker->SetActorTickEnabled(false);\n\t}\n}", "CodeBleu_score": 40.757579946546315}, {"code": "void WalkerAIController::Start(){\n\t\t// Add this AI controller to the episode\n\tEpisode::Get()->AddAIController(this);\n\n\t// Get the walker actor\n\twalker = GetPawn();\n\n\t// Add the walker to the navigation system with its current location\n\tNavigation::Get()->AddActor(walker, walker->GetLocation());\n\n\t// Disable the physics simulation and collisions for the walker actor\n\twalker->SetPhysicsEnabled(false);\n\twalker->SetCollisionsEnabled(false);\n}", "CodeBleu_score": 29.216392263050807}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\t// Get the navigation instance\n\tauto nav_inst = GetEpisode()->GetNavigationInstance();\n\n\t// Check if the navigation instance is valid\n\tif (!nav_inst) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Navigation instance is not valid.\"));\n\t\treturn;\n\t}\n\n\t// Get the parent walker\n\tauto walker = Cast<AWalker>(GetPawn());\n\n\t// Check if the walker is valid\n\tif (!walker) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Walker is not valid.\"));\n\t\treturn;\n\t}\n\n\t// Set the maximum speed for the walker\n\twalker->SetMaxSpeed(nav_inst, max_speed);\n}", "CodeBleu_score": 44.43658429646322}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tauto nav_instance = GetEpisode()->GetNavigationInstance();\n\tif (nav_instance) {\n\t\tauto walker = Cast<AWalker>(GetParentActor());\n\t\tif (walker) {\n\t\t\twalker->SetMaxSpeed(max_speed);\n\t\t} else {\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Walker not found!\"));\n\t\t}\n\t} else {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation instance not found!\"));\n\t}\n}", "CodeBleu_score": 44.93179845654296}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\t\tUNavigationSystemV1* nav_sys = UNavigationSystemV1::GetCurrent(GetWorld());\n\tif (nav_sys) {\n\t\tAAIController* controller = GetParentController();\n\t\tif (controller) {\n\t\t\tif (!controller->SetMaxSpeed(max_speed)) {\n\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to set max speed for walker %s\"), *GetName());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to find walker %s\"), *GetName());\n\t\t}\n\t}\n\telse {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to find navigation system\"));\n\t}\n}", "CodeBleu_score": 41.418468386585275}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> previous = _map->GetPreviousWaypoints(this, distance);\n\tfor (auto waypoint : previous) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.397469701275874}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<SharedPtr<Waypoint>> previous = map->GetPrevious(this->GetId(), distance);\n\tfor (SharedPtr<Waypoint> waypoint : previous) {\n\t\tresult.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint->GetId(), waypoint->GetLatitude(), waypoint->GetLongitude(), waypoint->GetElevation(), waypoint->GetMap())));\n\t}\n\treturn result;\n}", "CodeBleu_score": 53.69786356475564}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\t\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<Waypoint*> previous = map->GetPreviousWaypoints(this, distance);\n\tfor (auto wp : previous) {\n\t\tresult.push_back(SharedPtr<Waypoint>(wp));\n\t}\n\treturn result;\n}", "CodeBleu_score": 43.15910622654056}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tfor (auto signal : signals) {\n\t\tif (std::find(result.begin(), result.end(), signal->GetLandmark()) == result.end()) {\n\t\t\tSharedPtr<Waypoint> waypoint = SharedPtr<Waypoint>(new Waypoint(signal->GetPosition()));\n\t\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(waypoint, signal->GetSignalType()));\n\t\t\tresult.push_back(landmark);\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 46.387069800587774}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tstd::vector<SharedPtr<Signal>> unique_signals;\n\tfor (auto signal : signals) {\n\t\tbool found = false;\n\t\tfor (auto unique_signal : unique_signals) {\n\t\t\tif (signal == unique_signal) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tunique_signals.push_back(signal);\n\t\t}\n\t}\n\tfor (auto signal : unique_signals) {\n\t\tSharedPtr<Waypoint> waypoint = signal->GetWaypoint();\n\t\tSharedPtr<Landmark> landmark = SharedPtr<Landmark>(new Landmark(waypoint, signal));\n\t\tresult.push_back(landmark);\n\t}\n\treturn result;\n}", "CodeBleu_score": 48.67508910991501}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\t\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\tfor (auto signal : signals) {\n\t\tif (std::find(result.begin(), result.end(), signal->GetLandmark()) == result.end()) {\n\t\t\tresult.push_back(signal->GetLandmark());\n\t\t}\n\t}\n\treturn result;\n}", "CodeBleu_score": 28.07527366488898}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t", "CodeBleu_score": 3.171605579650036}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t// Apply settings to episode and get identifier\n\tuint64_t identifier = _episode.Lock()->ApplySettings(settings);\n\n\t// Set timeout\n\ttime_duration local_timeout = timeout.milliseconds() == 0?\n\t\t_episode.Lock()->GetNetworkingTimeout() : timeout;\n\n\t// If the settings include a fixed delta time, verify it\n\tif (settings.fixed_delta_time() > 0) {\n\t\t// Get the number of ticks to verify\n\t\tuint64_t num_ticks = 10;\n\n\t\t// Get the current time\n\t\ttime_point start_time = high_resolution_clock::now();\n\n\t\t// Tick the episode\n\t\tfor (uint64_t i = 0; i < num_ticks; i++) {\n\t\t\tTick(local_timeout);\n\t\t}\n\n\t\t// Get the time elapsed\n\t\ttime_point end_time = high_resolution_clock::now();\n\t\ttime_duration elapsed_time = end_time - start_time;\n\n\t\t// Get the expected time elapsed\n\t\ttime_duration expected_time = time_duration(settings.fixed_delta_time() * num_ticks);\n\n\t\t// Get the difference\n\t\ttime_duration difference = elapsed_time - expected_time;\n\n\t\t// Get the absolute difference\n\t\ttime_duration absolute_difference = difference.is_negative()? -difference : difference;\n\n\t\t// If the difference is too large, log a warning\n\t\tif (absolute_difference > time_duration(100000)) {\n\t\t\tLog::Warning(\"The fixed delta time of %d microseconds is not being applied correctly.\", settings.fixed_delta_time());\n\t\t}\n\t}\n\n\t// Return the identifier\n\treturn identifier;\n}", "CodeBleu_score": 48.67719646729882}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\tifdef _WIN32\n    time_duration local_timeout = timeout.milliseconds() == 0?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n#else\n    time_duration local_timeout = timeout.total_milliseconds() == 0?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n#endif\n    uint64_t id = _episode.Lock()->ApplySettings(settings);\n    if (settings.fixed_delta_time()!= 0) {\n        uint64_t fixed_delta_time = settings.fixed_delta_time();\n        uint64_t max_delta = fixed_delta_time * 0.1;\n        uint64_t min_delta = fixed_delta_time * 0.05;\n        uint64_t max_ticks = 100;\n        uint64_t tick_count = 0;\n        uint64_t total_delta = 0;\n        uint64_t last_tick = 0;\n        uint64_t tick = 0;\n        do {\n            tick = Tick(local_timeout);\n            if (tick == last_tick) {\n                break;\n            }\n            last_tick = tick;\n            uint64_t delta = tick - last_tick;\n            total_delta += delta;\n            if (delta > max_delta || delta < min_delta) {\n                break;\n            }\n            tick_count++;\n        } while (tick_count < max_ticks);\n        if (tick_count < max_ticks) {\n            std::stringstream ss;\n            ss << \"Fixed delta time \" << fixed_delta_time << \" was not applied correctly. Delta time was \" << total_delta / tick_count << \" over \" << tick_count << \" ticks.\";\n            _episode.Lock()->LogWarning(ss.str());\n        }\n    }\n    return id;\n  }", "CodeBleu_score": 47.143006842079004}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tconst Vector2& p, const Vector2& a, const Vector2& b\n}", "CodeBleu_score": 10.721958881681147}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\tfloat x1, float y1, float x2, float y2, float px, float py\n}", "CodeBleu_score": 6.604713552554794}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t\t(const glm::vec2& point, const glm::vec2& segmentStart, const glm::vec2& segmentEnd) -> std::pair<float, float> {\n\t\tfloat segmentLengthSquared = glm::length2(segmentEnd - segmentStart);\n\t\tif (segmentLengthSquared == 0.0f) {\n\t\t\treturn {0.0f, glm::distance(point, segmentStart)};\n\t\t}\n\t\tfloat t = glm::dot(point - segmentStart, segmentEnd - segmentStart) / segmentLengthSquared;\n\t\tt = glm::clamp(t, 0.0f, 1.0f);\n\t\tglm::vec2 projection = segmentStart + t * (segmentEnd - segmentStart);\n\t\treturn {t, glm::distance(point, projection)};\n\t}\n}", "CodeBleu_score": 43.46959903467218}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t#ifdef DEBUG\n    assert(vertices.size() >= 3);\n#endif\n    index_type initial_index = GetVerticesNum();\n    AddVertices(vertices);\n    for (size_t i = 2; i < vertices.size(); i++) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i - 1);\n      AddIndex(initial_index + i);\n    }\n  }", "CodeBleu_score": 50.881491213078654}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t#ifdef _DEBUG\n    assert(vertices.size() >= 3);\n#endif\n    index_type initial_index = _vertices.size();\n    AddVertices(vertices);\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n      AddIndex(initial_index);\n      AddIndex(initial_index + i + 1);\n      AddIndex(initial_index + i + 2);\n    }\n  }", "CodeBleu_score": 48.49353306924772}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\t\tassert(vertices.size() >= 3);\n\tindex_type initial_index = GetVerticesNum();\n\tAddVertices(vertices);\n\tfor (size_t i = 1; i < vertices.size() - 1; ++i) {\n\t\tAddIndex(initial_index);\n\t\tAddIndex(initial_index + i);\n\t\tAddIndex(initial_index + i + 1);\n\t}\n}", "CodeBleu_score": 49.86466596948475}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message) {\n\t\tlog_error(\"Invalid message.\");\n\t\treturn;\n\t}\n\n\tstrand_.post([this, message]() {\n\t\tif (!socket_.is_open()) {\n\t\t\tlog_error(\"Cannot write to closed socket.\");\n\t\t\treturn;\n\t\t}\n\n\t\tboost::asio::async_write(socket_, message->GetBuffers(), [this, message](const boost::system::error_code &error, std::size_t bytes_transferred) {\n\t\t\tHandleSent(error, message, bytes_transferred);\n\t\t});\n\t});\n}", "CodeBleu_score": 28.511220301104135}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\t// Ensure the message is valid.\n\tif (!message->IsValid()) {\n\t\tLOG_ERROR_S << \"Invalid message.\";\n\t\treturn;\n\t}\n\n\t// Post a lambda to the strand for execution.\n\tm_strand->post([this, message]() {\n\t\t// Ensure the socket is open.\n\t\tif (!m_socket.is_open()) {\n\t\t\tLOG_ERROR_S << \"Socket is not open.\";\n\t\t\treturn;\n\t\t}\n\n\t\t// Set a timeout.\n\t\tm_socket.expires_from_now(boost::posix_time::seconds(10));\n\n\t\t// Initiate an asynchronous write.\n\t\tboost::asio::async_write(m_socket, message->GetBuffer(), [this, message](const boost::system::error_code &ec, std::size_t) {\n\t\t\t// Handle the result.\n\t\t\thandle_sent(ec, message);\n\t\t});\n\t});\n}", "CodeBleu_score": 28.105618513477477}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\t\tif (!message->IsValid()) {\n\t\tCARLA_LOG_ERROR(\"message is invalid\");\n\t\treturn;\n\t}\n\n\tauto self = shared_from_this();\n\tstrand.post([self, message]() {\n\t\tif (!self->socket.is_open()) {\n\t\t\tCARLA_LOG_ERROR(\"socket is closed\");\n\t\t\treturn;\n\t\t}\n\n\t\tself->socket.async_write_some(boost::asio::buffer(message->GetData(), message->GetSize()), [self, message](const boost::system::error_code &error, std::size_t bytes_transferred) {\n\t\t\tif (error) {\n\t\t\t\tif (error == boost::asio::error::operation_aborted) {\n\t\t\t\t\tCARLA_LOG_DEBUG(\"write operation aborted\");\n\t\t\t\t} else {\n\t\t\t\t\tCARLA_LOG_ERROR(\"write error: \" << error);\n\t\t\t\t}\n\t\t\t\tself->Close();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (bytes_transferred!= message->GetSize()) {\n\t\t\t\tCARLA_LOG_ERROR(\"write error: \" << bytes_transferred << \"!= \" << message->GetSize());\n\t\t\t\tself->Close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\t});\n}", "CodeBleu_score": 39.05328794550568}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t", "CodeBleu_score": 4.868655198172263}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer so that the blocked accept() call will unblock.\n\ttimer_.cancel();\n\n\tif (!ec) {\n\t\t// No error code means that the connection was successfully accepted.\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t}\n\n\t// Check that the socket is still open.\n\tif (socket_.is_open()) {\n\t\t// The connection is not open so we need to close it ourselves.\n\t\tsocket_.close();\n\t}\n\n\t// Run the callback.\n\ton_closed(ec);\n\n\t// Log that the session has been closed.\n\tstd::cout << \"Session closed.\" << std::endl;\n}", "CodeBleu_score": 52.82111585463868}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\t\t// Cancel the deadline timer so that the blocked accept() call will unblock.\n\ttimer_.cancel();\n\n\t// If we're not connected, there is no work to be done other than logging.\n\tif (!socket_.is_open()) {\n\t\treturn;\n\t}\n\n\t// Shut down the accept socket.\n\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\n\t// There is no longer an open connection.\n\tsocket_.close(ec);\n\n\t// Run the on_closed callback.\n\ton_closed();\n\n\t// Log that the session has been closed.\n\tstd::cout << \"Session closed.\" << std::endl;\n}", "CodeBleu_score": 42.9150765573416}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar buffer[MAX_BUFFER_SIZE];\n\tsprintf(buffer, \"%s\", \"Are you alive?\");\n\tlogger->Log(buffer, \"PrimaryCommands::SendIsAlive\", \"Sending\", \"Command\");\n\twrite(nextRouter, buffer, MAX_BUFFER_SIZE);\n\tlogger->Log(\"Waiting for response...\", \"PrimaryCommands::SendIsAlive\", \"Receiving\", \"Command\");\n\tread(nextRouter, buffer, MAX_BUFFER_SIZE);\n\tlogger->Log(buffer, \"PrimaryCommands::SendIsAlive\", \"Receiving\", \"Command\");\n}", "CodeBleu_score": 33.66704439172218}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\tchar buffer[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\tLogger::Log(buffer, Logger::DEBUG);\n\tRouter::Write(buffer, YOU_ALIVE);\n\tLogger::Log(\"Waiting for response...\", Logger::DEBUG);\n\tRouter::Read(buffer, YOU_ALIVE);\n\tLogger::Log(buffer, Logger::DEBUG);\n}", "CodeBleu_score": 30.77406150804734}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t\t// Create a buffer with the message\n\tchar buffer[MAX_BUFFER_SIZE];\n\tstrcpy(buffer, \"Are you alive?\");\n\t// Log the sending action\n\tLog::LogMessage(buffer);\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\tWriteBuffer(buffer, YOU_ALIVE);\n\t// Wait for the response from the system\n\tWaitForResponse();\n}", "CodeBleu_score": 17.027036227654012}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if sensor is on any secondary server\n\tbool found = false;\n\tfor (int i = 0; i < secondary_server_count; i++) {\n\t\tif (secondary_servers[i].sensor_id == sensor_id) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\t// Create buffer with sensor ID\n\t\tuint8_t buffer[5];\n\t\tbuffer[0] = (uint8_t) (sensor_id >> 24);\n\t\tbuffer[1] = (uint8_t) (sensor_id >> 16);\n\t\tbuffer[2] = (uint8_t) (sensor_id >> 8);\n\t\tbuffer[3] = (uint8_t) (sensor_id);\n\t\tbuffer[4] = 0;\n\n\t\t// Send ENABLE_ROS command to secondary server\n\t\trouter.SendCommand(secondary_servers[i].server_id, ENABLE_ROS, buffer, 5);\n\n\t\t// Wait for response\n\t\tuint8_t response_buffer[1];\n\t\trouter.GetResponse(response_buffer, 1);\n\n\t\t// Process response\n\t\tif (response_buffer[0] == 1) {\n\t\t\t// Sensor enabled for ROS\n\t\t\tlog.LogMessage(LOG_INFO, \"Enabled sensor %d for ROS.\", sensor_id);\n\t\t} else {\n\t\t\t// Sensor not enabled for ROS\n\t\t\tlog.LogMessage(LOG_ERROR, \"Failed to enable sensor %d for ROS.\", sensor_id);\n\t\t}\n\t} else {\n\t\t// Sensor not found on any secondary server\n\t\tlog.LogMessage(LOG_ERROR, \"Sensor %d not found on any secondary server.\", sensor_id);\n\t}\n}", "CodeBleu_score": 39.75633945534731}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\tif(sensor_id == 0) {\n\t\tROS_ERROR(\"PrimaryCommands::SendEnableForROS: Sensor ID is 0.\");\n\t\treturn;\n\t}\n\n\tif(sensor_id > 255) {\n\t\tROS_ERROR(\"PrimaryCommands::SendEnableForROS: Sensor ID is too large.\");\n\t\treturn;\n\t}\n\n\t// Create a buffer to send\n\tchar buffer[2];\n\tbuffer[0] = sensor_id;\n\tbuffer[1] = '\\0';\n\n\t// Send the ENABLE_ROS command to the server\n\tint result = router.SendCommand(ENABLE_ROS, buffer);\n\n\t// If the command was not sent, log an error and return\n\tif(result!= 0) {\n\t\tROS_ERROR(\"PrimaryCommands::SendEnableForROS: Failed to send ENABLE_ROS command to server.\");\n\t\treturn;\n\t}\n\n\t// Wait for a response from the server\n\tresult = router.WaitForResponse();\n\n\t// If the response was not received, log an error and return\n\tif(result!= 0) {\n\t\tROS_ERROR(\"PrimaryCommands::SendEnableForROS: Failed to receive response from server.\");\n\t\treturn;\n\t}\n\n\t// If the response was received, process it\n\tresult = router.ProcessResponse();\n\n\t// If the response was not processed, log an error and return\n\tif(result!= 0) {\n\t\tROS_ERROR(\"PrimaryCommands::SendEnableForROS: Failed to process response from server.\");\n\t\treturn;\n\t}\n}", "CodeBleu_score": 34.314585285580634}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t\t// Check if sensor has been activated on any secondary server\n\tbool found = false;\n\tfor (int i = 0; i < num_secondary_servers; i++) {\n\t\tif (secondary_server_sensors[i].find(sensor_id)!= secondary_server_sensors[i].end()) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\t// Create buffer with sensor ID\n\t\tchar buffer[sizeof(stream_id)];\n\t\tmemcpy(buffer, &sensor_id, sizeof(stream_id));\n\n\t\t// Send ENABLE_ROS command to server\n\t\trouter->SendCommand(ENABLE_ROS, buffer, sizeof(stream_id));\n\n\t\t// Wait for and process server's response\n\t\trouter->WaitForResponse();\n\t\trouter->ProcessResponse();\n\t}\n\telse {\n\t\t// Sensor not found on any server\n\t\tLog::Error(\"PrimaryCommands::SendEnableForROS\", \"Sensor not found on any secondary server.\");\n\t}\n}", "CodeBleu_score": 45.246321458432156}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t#ifdef _DEBUG\n  log_info(\"getting token for sensor \", sensor_id);\n#endif\n  auto it = _tokens.find(sensor_id);\n  if (it!= _tokens.end()) {\n    log_info(\"sensor already activated\");\n    return it->second;\n  }\n  auto token = SendGetToken(sensor_id);\n  _tokens.emplace(sensor_id, token);\n  _secondary_tokens.emplace(token, sensor_id);\n  return token;\n}", "CodeBleu_score": 47.529276304990184}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t#ifdef DEBUG_PRIMARY_COMMANDS\n  log_info(\"getting token for sensor \", sensor_id);\n#endif\n  if (is_sensor_activated(sensor_id)) {\n#ifdef DEBUG_PRIMARY_COMMANDS\n    log_info(\"sensor \", sensor_id, \" already activated\");\n#endif\n    return _sensor_id_to_token[sensor_id];\n  }\n  log_info(\"enabling sensor \", sensor_id, \" on secondary server\");\n  EnableSensor(sensor_id);\n  auto new_token = SendGetToken(sensor_id);\n  _sensor_id_to_token[sensor_id] = new_token;\n  _token_to_sensor_id[new_token] = sensor_id;\n  return new_token;\n}", "CodeBleu_score": 38.16723116296708}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\t//  log_info(\"getting token for sensor \", sensor_id);\n  // check if sensor is already activated\n  if (_token_map.count(sensor_id)) {\n    log_info(\"sensor \", sensor_id, \" already activated, returning existing token\");\n    return _token_map[sensor_id];\n  }\n\n  // enable sensor on secondary\n  log_info(\"sensor \", sensor_id, \" not activated, enabling on secondary\");\n  _secondary_commands->Enable(sensor_id);\n\n  // get new token\n  auto new_token = SendGetToken(sensor_id);\n\n  // update maps\n  _token_map[sensor_id] = new_token;\n  _sensor_map[new_token.get_stream_id()] = sensor_id;\n\n  return new_token;\n}", "CodeBleu_score": 43.668697136765886}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}, {"code": "bool Navigation::Load(const std::string &filename){\n\t\tstd::ifstream f;\n\tstd::istream_iterator<uint8_t> start(f), end;\n\n\t// read the whole file\n\tf.open(filename, std::ios::binary);\n\tif (!f.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<uint8_t> content(start, end);\n\tf.close();\n\n\t// parse the content\n\treturn Load(std::move(content));\n}", "CodeBleu_score": 96.46913236743846}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\t// TODO: Implement\n\treturn false;\n}", "CodeBleu_score": 2.9814015382011623}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (m_pNavMesh == nullptr || m_pCrowd == nullptr)\n\t\treturn false;\n\n\tint walkerIndex = -1;\n\tint vehicleIndex = -1;\n\tif (m_walkerMapping.find(id)!= m_walkerMapping.end()) {\n\t\twalkerIndex = m_walkerMapping[id];\n\t}\n\telse if (m_vehicleMapping.find(id)!= m_vehicleMapping.end()) {\n\t\tvehicleIndex = m_vehicleMapping[id];\n\t}\n\telse {\n\t\treturn false;\n\t}\n\n\tm_pCrowd->lock();\n\tif (walkerIndex!= -1) {\n\t\tm_pCrowd->removeAgent(walkerIndex);\n\t\tm_walkerManager->RemoveAgent(walkerIndex);\n\t\tm_walkerMapping.erase(id);\n\t}\n\telse if (vehicleIndex!= -1) {\n\t\tm_pCrowd->removeAgent(vehicleIndex);\n\t\tm_vehicleManager->RemoveAgent(vehicleIndex);\n\t\tm_vehicleMapping.erase(id);\n\t}\n\tm_pCrowd->unlock();\n\treturn true;\n}", "CodeBleu_score": 42.96177956060927}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\t\tif (!ready) {\n\t\treturn false;\n\t}\n\tif (crowd == NULL) {\n\t\treturn false;\n\t}\n\n\tint index = -1;\n\tfor (int i = 0; i < walkers.size(); i++) {\n\t\tif (walkers[i]->GetID() == id) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index!= -1) {\n\t\t// found walker\n\t\tEnterCriticalSection(&crowdCriticalSection);\n\t\tcrowd->removeAgent(index);\n\t\tLeaveCriticalSection(&crowdCriticalSection);\n\t\twalkerManager->Remove(walkers[index]);\n\t\twalkers.erase(walkers.begin() + index);\n\t\twalkerIds.erase(walkerIds.begin() + index);\n\t\treturn true;\n\t}\n\n\tindex = -1;\n\tfor (int i = 0; i < vehicles.size(); i++) {\n\t\tif (vehicles[i]->GetID() == id) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (index!= -1) {\n\t\t// found vehicle\n\t\tEnterCriticalSection(&crowdCriticalSection);\n\t\tcrowd->removeAgent(index);\n\t\tLeaveCriticalSection(&crowdCriticalSection);\n\t\tvehicleManager->Remove(vehicles[index]);\n\t\tvehicles.erase(vehicles.begin() + index);\n\t\tvehicleIds.erase(vehicleIds.begin() + index);\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 48.760187260493204}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tstd::vector<VehicleCollisionInfo> vehicles;\n//    for (auto &vehicle : vehicles_info) {\n//      VehicleCollisionInfo info;\n//      info.id = vehicle.first;\n//      info.bounding = vehicle.second.bounding;\n//      info.transform = vehicle.second.transform;\n//      vehicles.push_back(info);\n//    }\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    // get the list of current vehicles\n    std::set<ActorId> current_vehicles;\n    for (auto &vehicle : _mapped_vehicles_id) {\n      current_vehicles.insert(vehicle.first);\n    }\n\n    // add or update the vehicles\n    for (auto &vehicle : vehicles) {\n      // check if it exists\n      auto it = current_vehicles.find(vehicle.id);\n      if (it!= current_vehicles.end()) {\n        // remove from the list\n        current_vehicles.erase(it);\n        // add or update\n        AddOrUpdateVehicle(vehicle);\n      } else {\n        // add\n        AddVehicle(vehicle);\n      }\n    }\n\n    // remove the vehicles that are not in the list\n    for (auto &vehicle : current_vehicles) {\n      RemoveAgent(vehicle);\n    }\n\n    return true;\n  }", "CodeBleu_score": 58.33600596575735}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\ttd::cout << \"UpdateVehicles\" << std::endl;\n\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    // get the set of current vehicles\n    std::set<ActorId> current_vehicles;\n    for (auto it = _mapped_vehicles_id.begin(); it!= _mapped_vehicles_id.end(); ++it) {\n      current_vehicles.insert(it->first);\n    }\n\n    // add or update vehicles\n    for (auto it = vehicles.begin(); it!= vehicles.end(); ++it) {\n      // remove from current vehicles\n      current_vehicles.erase(it->id);\n      // add or update\n      AddOrUpdateVehicle(*it);\n    }\n\n    // remove the rest of vehicles\n    for (auto it = current_vehicles.begin(); it!= current_vehicles.end(); ++it) {\n      RemoveAgent(*it);\n    }\n\n    return true;\n  }", "CodeBleu_score": 45.53650332834245}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tf DEBUG_NAVIGATION\n    std::cout << \"Navigation::UpdateVehicles: \" << vehicles.size() << std::endl;\n#endif\n\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd!= nullptr);\n\n    // get the current set of vehicles\n    std::set<ActorId> current_vehicles;\n    for (auto &it : _mapped_vehicles_id) {\n      current_vehicles.insert(it.first);\n    }\n\n    // add or update vehicles\n    for (auto &vehicle : vehicles) {\n      // check if this vehicle exists\n      auto it = current_vehicles.find(vehicle.id);\n      if (it!= current_vehicles.end()) {\n        // remove from the set\n        current_vehicles.erase(it);\n      }\n\n      // add or update vehicle\n      AddOrUpdateVehicle(vehicle);\n    }\n\n    // remove vehicles not updated\n    for (auto &id : current_vehicles) {\n      RemoveAgent(id);\n    }\n\n    return true;\n  }", "CodeBleu_score": 54.20956658021089}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tauto actor = GetActor(id);\n\tif (actor == nullptr) {\n\t\treturn false;\n\t}\n\n\tauto vehicle = dynamic_cast<Vehicle *>(actor);\n\tif (vehicle!= nullptr) {\n\t\treturn vehicle->IsNear(distance, direction);\n\t}\n\n\tauto walker = dynamic_cast<Walker *>(actor);\n\tif (walker!= nullptr) {\n\t\treturn walker->IsNear(distance, direction);\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 37.94913607194577}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\tstd::lock_guard<std::mutex> lock(_mutex);\n\tconst auto &walker = _walkers.find(id);\n\tconst auto &vehicle = _vehicles.find(id);\n\tif (walker!= _walkers.end()) {\n\t\treturn HasVehicleNear(walker->second, distance, direction);\n\t} else if (vehicle!= _vehicles.end()) {\n\t\treturn HasVehicleNear(vehicle->second, distance, direction);\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 52.880488067891804}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t\t// check if the actor is a walker\n\tauto actor = _world->GetActor(id);\n\tif (actor->IsWalker()) {\n\t\tauto walker = std::static_pointer_cast<Walker>(actor);\n\t\t// check if the walker is mapped\n\t\tauto it = _walker_map.find(walker->GetId());\n\t\tif (it!= _walker_map.end()) {\n\t\t\t// check if the walker is near\n\t\t\treturn _crowd->HasVehicleNear(it->second, distance, direction);\n\t\t}\n\t} else {\n\t\t// check if the actor is a vehicle\n\t\tauto vehicle = std::static_pointer_cast<Vehicle>(actor);\n\t\t// check if the vehicle is mapped\n\t\tauto it = _vehicle_map.find(vehicle->GetId());\n\t\tif (it!= _vehicle_map.end()) {\n\t\t\t// check if the vehicle is near\n\t\t\treturn _crowd->HasVehicleNear(it->second, distance, direction);\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 46.456183756466615}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto current_point = info.route_points[info.current_route_point];\n\tWalkerEventVisitor visitor(info, delta);\n\treturn boost::apply_visitor(visitor, current_point->event);\n}", "CodeBleu_score": 43.753539848489076}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\tauto &route = info.route;\n\tauto &context = info.context;\n\tauto &route_point = info.route_point;\n\tauto &route_index = info.route_index;\n\tauto &route_length = info.route_length;\n\n\t// if the walker has reached the end of the route, return\n\tif (route_index >= route_length) {\n\t\treturn EventResult::Finished;\n\t}\n\n\t// update the route point\n\troute_point = route[route_index];\n\n\t// create a visitor to execute the event\n\tWalkerEventVisitor visitor(context, delta);\n\n\t// execute the event\n\treturn boost::variant2::visit(visitor, route_point.event);\n}", "CodeBleu_score": 50.570078301516574}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\t\t// Get the current route point for the walker\n\tauto routePoint = info.route.GetRoutePoint(info.routePointIndex);\n\t// Create the walker event visitor with the current context\n\tWalkerEventVisitor visitor(id, info.context, delta);\n\t// Process the event at the current route point\n\treturn boost::variant2::visit(visitor, routePoint.event);\n}", "CodeBleu_score": 59.10871613955201}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n// Iterate through each road node\n    for (pugi::xml_node road_node : xml.children(\"road\")) {\n      const int road_id = road_node.attribute(\"id\").as_int();\n\n      // Iterate through each lane section node\n      for (pugi::xml_node lane_section_node : road_node.children(\"lanes\")) {\n        const double s = lane_section_node.attribute(\"s\").as_double();\n\n        // Iterate through each lane node\n        for (pugi::xml_node lane_node : lane_section_node.children(\"lane\")) {\n          const int lane_id = lane_node.attribute(\"id\").as_int();\n\n          // Create a new lane\n          map_builder.CreateLane(road_id, lane_id, s);\n        }\n\n        // Parse left lanes\n        ParseLanes(lane_section_node, \"left\", s, road_id, map_builder);\n\n        // Parse center lanes\n        ParseLanes(lane_section_node, \"center\", s, road_id, map_builder);\n\n        // Parse right lanes\n        ParseLanes(lane_section_node, \"right\", s, road_id, map_builder);\n      }\n    }\n  }", "CodeBleu_score": 51.62865419602103}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t\n//    std::cout << \"Parsing Lanes\" << std::endl;\n    for (pugi::xml_node road_node : xml.children(\"OpenDRIVE\").children(\"road\")) {\n      road::RoadId road_id = road_node.attribute(\"id\").as_int();\n      road::Road *road = map_builder.GetRoad(road_id);\n      for (pugi::xml_node lanes_node : road_node.children(\"lanes\")) {\n        for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n          const double s = lane_section_node.attribute(\"s\").as_double();\n          ParseLanes(lane_section_node, road_id, s, map_builder);\n        }\n      }\n    }\n  }", "CodeBleu_score": 47.97063575389364}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t#ifdef LIBCARLA_INCLUDED_FROM_UE4\n    UE_LOG(LogCarla, Error, TEXT(\"LaneParser::Parse is not implemented.\"));\n#endif // LIBCARLA_INCLUDED_FROM_UE4\n  }", "CodeBleu_score": 9.388823679783695}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tmatched_ = info.total_count;\n\t\tif (matched_ == 1) {\n\t\t\tfirst_connection_ = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_ = info.total_count;\n\t} else {\n\t\tEFD_LOG(efd::efdError, \"CarlaListenerImpl::on_publication_matched: invalid publication matched status\");\n\t}\n}", "CodeBleu_score": 62.36418935977388}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tmatched_count_++;\n\t\tif (matched_count_ == 1) {\n\t\t\t// This is the first matched publication.\n\t\t\t// Set the first connection flag.\n\t\t\tfirst_connection_ = true;\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count_--;\n\t} else {\n\t\t// An invalid count change was detected.\n\t\t// This should not happen.\n\t\tstd::cerr << \"CarlaListenerImpl::on_publication_matched: invalid count change: \" << info.current_count_change << std::endl;\n\t}\n}", "CodeBleu_score": 59.30887497021846}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tmatched_count_++;\n\t\tif (matched_count_ == 1) {\n\t\t\twriter->enable();\n\t\t}\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count_--;\n\t} else {\n\t\tstd::cerr << \"Invalid publication matched status\" << std::endl;\n\t}\n}", "CodeBleu_score": 46.572164103887125}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\tm_subscriber->matched_count++;\n\t\tm_subscriber->first_connected = true;\n\t} else if (info.current_count_change == -1) {\n\t\tm_subscriber->matched_count--;\n\t\tif (m_subscriber->matched_count == 0) {\n\t\t\tm_subscriber->subscriber->delete_datareader(reader);\n\t\t\tm_subscriber->subscriber->delete_subscriber(m_subscriber->subscriber);\n\t\t\tdelete m_subscriber;\n\t\t}\n\t} else {\n\t\tstd::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: received an invalid change count.\" << std::endl;\n\t}\n}", "CodeBleu_score": 45.634267761364825}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t++matched_count_;\n\t\tfirst_connected_ = true;\n\t} else if (info.current_count_change == -1) {\n\t\t--matched_count_;\n\t\tif (matched_count_ == 0) {\n\t\t\treader->get_subscriber()->delete_contained_entities();\n\t\t\treader->get_subscriber()->delete_subscriber();\n\t\t}\n\t} else {\n\t\tstd::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid subscription count change\" << std::endl;\n\t}\n}", "CodeBleu_score": 56.38221281817856}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\t\tif (info.current_count_change == 1) {\n\t\t// This is a new subscription.\n\t\tm_subscriber->m_matchedCount++;\n\t\tm_subscriber->m_firstConnected = true;\n\t} else if (info.current_count_change == -1) {\n\t\t// This is an existing subscription that just went away.\n\t\tm_subscriber->m_matchedCount--;\n\t\tif (m_subscriber->m_matchedCount == 0) {\n\t\t\t// No more subscriptions.\n\t\t\tm_subscriber->destroy();\n\t\t}\n\t} else {\n\t\t// Something went wrong.\n\t\tLOG_ERROR(\"CarlaSubscriberListenerImpl::on_subscription_matched: invalid subscription count change.\");\n\t}\n}", "CodeBleu_score": 50.53677697748383}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::KEY_MAX_SIZE);\n\t// Serialize encapsulation\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tser.serialize_encapsulation();\n\t// Serialize the object:\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>CarlaCollisionEvent::getKeyMaxCdrSerializedSize()) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor(uint8_t i = 0;i<CarlaCollisionEvent::KEY_MAX_SIZE;i++) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t} else {\n\t\tfor(uint8_t i = 0;i<CarlaCollisionEvent::KEY_MAX_SIZE;i++) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 67.71670406461908}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n\n\t// Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize()>16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t} else {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 90.14251374111247}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\t\tif (!m_isGetKeyDefined) {\n\t\treturn false;\n\t}\n\tCarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n\tp_type->serializeKey(ser);\n\tif (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n\t\tm_md5.init();\n\t\tm_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n\t\tm_md5.finalize();\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_md5.digest[i];\n\t\t}\n\t}\n\telse {\n\t\tfor (uint8_t i = 0; i < 16; ++i) {\n\t\t\thandle->value[i] = m_keyBuffer[i];\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 94.49807331062286}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\t// Object that manages the raw buffer.\n\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\t// Object that serializes the data.\n\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Set the encapsulation\n\n\ttry {\n\t\t// Serialize encapsulation\n\t\tser.serialize_encapsulation();\n\n\t\t// Serialize the object:\n\t\tp_type->serialize(ser); // Serialize the object\n\t} catch (eprosima::fastcdr::exception::Exception& /*exception*/) {\n\t\treturn false;\n\t}\n\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n\treturn true;\n}", "CodeBleu_score": 88.81996342232745}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\ttry {\n\t\tser.serialize(p_type->throttle);\n\t\tser.serialize(p_type->steering);\n\t\tser.serialize(p_type->brake);\n\t\tser.serialize(p_type->hand_brake);\n\t\tser.serialize(p_type->reverse);\n\t} catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n\treturn true;\n}", "CodeBleu_score": 83.25264159634894}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\t\tCarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\teprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\t// Object that manages the raw buffer.\n\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\t// Object that serializes the data.\n\n\tpayload->encapsulation = ser.end_encapsulation();\n\n\ttry {\n\t\t// Serialize encapsulation.\n\t\tser.serialize_encapsulation();\n\n\t\tp_type->serialize(ser); // Serialize the object:\n\t} catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n\t\treturn false;\n\t}\n\n\tpayload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n\treturn true;\n}", "CodeBleu_score": 85.13808619155098}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t", "CodeBleu_score": 2.091037435451118}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\t// Only do this if the target has not been set yet\n\tif (target_set)\n\t\treturn;\n\n\t// Decode the message\n\tmavlink_message_t message;\n\tmavlink_status_t status;\n\tmavlink_msg_decode(&msg, &status);\n\n\t// If the message is not one we should track, exit\n\tif (msg.msgid!= MAVLINK_MSG_ID_GLOBAL_POSITION_INT && msg.msgid!= MAVLINK_MSG_ID_GPS_RAW_INT && msg.msgid!= MAVLINK_MSG_ID_VFR_HUD && msg.msgid!= MAVLINK_MSG_ID_ATTITUDE && msg.msgid!= MAVLINK_MSG_ID_HEARTBEAT && msg.msgid!= MAVLINK_MSG_ID_RAW_IMU && msg.msgid!= MAVLINK_MSG_ID_SCALED_PRESSURE && msg.msgid!= MAVLINK_MSG_ID_SERVO_OUTPUT_RAW && msg.msgid!= MAVLINK_MSG_ID_RC_CHANNELS_RAW && msg.msgid!= MAVLINK_MSG_ID_RC_CHANNELS_SCALED && msg.msgid!= MAVLINK_MSG_ID_SYSTEM_TIME && msg.msgid!= MAVLINK_MSG_ID_STATUSTEXT)\n\t\treturn;\n\n\t// If the target system ID is not set, set it and request position and air pressure data streams from the target\n\tif (target_system_id == 0) {\n\t\ttarget_system_id = msg.sysid;\n\n\t\t// Request position and air pressure data streams from the target\n\t\tmavlink_msg_request_data_stream_pack(target_system_id, target_component_id, mavlink_channel, MAV_DATA_STREAM_POSITION, 1, 1000);\n\t\tmavlink_msg_request_data_stream_pack(target_system_id, target_component_id, mavlink_channel, MAV_DATA_STREAM_EXTRA1, 1, 1000);\n\t}\n\n\t// Flag that the target has been set\n\ttarget_set = true;\n}", "CodeBleu_score": 32.966701300024894}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\t\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// decode the message\n\tmavlink_message_t message = msg;\n\tmavlink_msg_decode(&message, system_id, component_id, &msg);\n\n\t// check if the target has been set\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\t// check if the message type is one that should be tracked\n\tif (message.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT || message.msgid == MAVLINK_MSG_ID_ATTITUDE || message.msgid == MAVLINK_MSG_ID_LOCAL_POSITION_NED || message.msgid == MAVLINK_MSG_ID_VFR_HUD || message.msgid == MAVLINK_MSG_ID_GPS_RAW_INT || message.msgid == MAVLINK_MSG_ID_GPS_STATUS || message.msgid == MAVLINK_MSG_ID_RAW_PRESSURE || message.msgid == MAVLINK_MSG_ID_SCALED_PRESSURE) {\n\t\t// set the target system ID\n\t\tif (target_system_id == 0) {\n\t\t\ttarget_system_id = message.sysid;\n\t\t}\n\n\t\t// request position and air pressure data streams from the target\n\t\tif (target_system_id == message.sysid) {\n\t\t\tif (message.msgid == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n\t\t\t\trequest_stream(target_system_id, target_component_id, MAV_DATA_STREAM_POSITION, 1, 1);\n\t\t\t}\n\n\t\t\tif (message.msgid == MAVLINK_MSG_ID_RAW_PRESSURE) {\n\t\t\t\trequest_stream(target_system_id, target_component_id, MAV_DATA_STREAM_EXTRA1, 1, 1);\n\t\t\t}\n\n\t\t\tif (message.msgid == MAVLINK_MSG_ID_SCALED_PRESSURE) {\n\t\t\t\trequest_stream(target_system_id, target_component_id, MAV_DATA_STREAM_EXTRA1, 1, 1);\n\t\t\t}\n\t\t}\n\n\t\t// flag that the target has been set\n\t\ttarget_set = true;\n\t}\n}", "CodeBleu_score": 35.14735305012659}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 52.5051219441432}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK_Tracker_Base::_handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_baro_calibration_needed = true;\n\t}\n\treturn result;\n}", "CodeBleu_score": 64.0201864762736}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\t\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_alt_cal_needed = true;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 51.541313775857624}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n\tif (packet.param1 == 1.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tgcs_arm_motors();\n\t} else if (packet.param1 == 0.0) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tgcs_disarm_motors();\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 50.34150730879461}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\tif (packet.param1 == 1.0) {\n\t\t// arm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (packet.param1 == 0) {\n\t\t// disarm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}", "CodeBleu_score": 42.55553964850331}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t\t// Check if the component id is correct\n\tif (packet.target_component!= _compid) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is supported\n\tif (packet.command!= MAV_CMD_COMPONENT_ARM_DISARM) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is valid\n\tif (packet.param1 < 0.0 || packet.param1 > 1.0) {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n\n\t// Check if the command is accepted\n\tif (packet.param1 == 1.0) {\n\t\t// Arm the servos\n\t\t_arm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\t// Disarm the servos\n\t\t_disarm_servos();\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n}", "CodeBleu_score": 50.7187826714384}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (gcs[i].available()) {\n\t\t\tif (gcs[i].get_txspace() > 20) {\n\t\t\t\tgcs[i].send_message(msg_request_data_stream(sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.67931957992486}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n\t\tif (gcs[i].available() && gcs[i].get_channel()!= MAVLINK_COMM_0) {\n\t\t\tif (gcs[i].initialised()) {\n\t\t\t\tif (gcs[i].get_channel() == MAVLINK_COMM_0) {\n\t\t\t\t\t// If we are using the USB channel, we can't send any datastreams, as it is used for the bootloader\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// send request to start datastream\n\t\t\t\tgcs[i].send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 10, 1);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 46.577931524701285}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t\tfor (uint8_t i=0; i<num_channels; i++) {\n\t\tif (channels[i]->available_payload_space() >= MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN) {\n\t\t\tchannels[i]->send_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, sysid, compid, MAV_DATA_STREAM_POSITION, 1000000/GCS_UPDATE_POSITION_RATE, 1);\n\t\t\treturn;\n\t\t}\n\t}\n}", "CodeBleu_score": 45.81228609300152}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Get AHRS instance\n\tAHRS *ahrs = AHRS::get_instance();\n\t// Check for zero pitch cosine\n\tif (ahrs->cos_pitch == 0) {\n\t\treturn false;\n\t}\n\t// Calculate earth frame pitch and yaw\n\tef_pitch = pitch + ahrs->pitch;\n\tef_yaw = yaw + ahrs->yaw;\n\treturn true;\n}", "CodeBleu_score": 42.68497198371385}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Get the AHRS instance\n\tAHRS* ahrs = ahrs_get_instance();\n\tif (ahrs == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Check for a zero pitch cosine\n\tif (ahrs->cos_pitch == 0) {\n\t\treturn false;\n\t}\n\n\t// Calculate the earth frame pitch and yaw\n\tef_pitch = atan2f(ahrs->sin_pitch, ahrs->cos_pitch);\n\tef_yaw = yaw + ahrs->yaw;\n\n\t// Return true if the pitch cosine is not zero\n\treturn true;\n}", "CodeBleu_score": 38.386720960989166}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\t\t// Get the AHRS instance\n\tAHRS *ahrs = AHRS::getInstance();\n\n\t// Check for zero pitch cosine to avoid division by zero\n\tif (ahrs->get_cos_pitch()!= 0) {\n\t\t// Calculate the earth frame pitch and yaw using trigonometric conversions\n\t\tef_pitch = atan2(sin(yaw) * ahrs->get_cos_pitch(), cos(yaw) * ahrs->get_cos_pitch());\n\t\tef_yaw = atan2(sin(pitch) * ahrs->get_cos_pitch(), cos(pitch) * ahrs->get_cos_pitch());\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 49.62061992910593}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t\t// get navigation status and parameters\n    const AP_AHRS &ahrs = AP::ahrs();\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    Parameters &g = tracker.g;\n\n    // update the target yaw and pitch in centidegrees\n    float yaw = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100);\n    float pitch = nav_status.altitude;\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate the angle error in earth frame\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // if the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n    if ((nav_status.distance >= 0) || (g.min_distance <= 0)) {\n        // update the pitch servo\n        g.pidPitch2Srv.set_target_rate(pitch * 0.01);\n        g.pidPitch2Srv.set_actual_rate(ahrs.pitch_sensor * 0.01);\n        g.pidPitch2Srv.update();\n        tracker.pitch_servo_out_filt.set_and_filter(g.pidPitch2Srv.get_pid_output());\n\n        // update the yaw servo\n        g.pidYaw2Srv.set_target_rate(yaw * 0.01);\n        g.pidYaw2Srv.set_actual_rate(ahrs.yaw_sensor * 0.01);\n        g.pidYaw2Srv.update();\n        tracker.yaw_servo_out_filt.set_and_filter(g.pidYaw2Srv.get_pid_output());\n    }\n}", "CodeBleu_score": 60.006155712410305}, {"code": "void Mode::update_auto(void){\n\t\t// if we are using a navigation source, and we have a valid target\n\tif (tracker.nav_status.source!= Tracker::NavStatus::SOURCE_NONE && tracker.nav_status.valid) {\n\t\t// calculate the pitch and yaw angles in centidegrees\n\t\tfloat pitch = tracker.nav_status.pitch;\n\t\tfloat yaw = tracker.nav_status.bearing;\n\n\t\t// check if we need to reverse the direction\n\t\tbool direction_reversed = get_ef_yaw_direction();\n\n\t\t// calculate the angle error\n\t\tcalc_angle_error(pitch, yaw, direction_reversed);\n\n\t\t// if we have a valid target distance or we don't have a minimum distance set\n\t\tif (tracker.nav_status.valid_distance || tracker.g.min_distance == 0) {\n\t\t\t// update the pitch and yaw servos\n\t\t\tupdate_servos();\n\t\t}\n\t}\n}", "CodeBleu_score": 30.597430507823542}, {"code": "void Mode::update_auto(void){\n\t\t// update target yaw and pitch\n    update_target_yaw_pitch();\n\n    // check if the direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error\n    calc_angle_error(tracker.nav_status.pitch, tracker.nav_status.yaw, direction_reversed);\n\n    // update pitch and yaw servos\n    update_pitch_servo();\n    update_yaw_servo();\n}", "CodeBleu_score": 14.9068126892392}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t\tif (gps.new_data) {\n\t\tgps.new_data = false;\n\n\t\tif (gps.last_message_time!= gps.last_message_time_prev) {\n\t\t\tgps.last_message_time_prev = gps.last_message_time;\n\n\t\t\tif (gps.status >= 3) {\n\t\t\t\tif (gps.ground_start_countdown > 0) {\n\t\t\t\t\tif (gps.location_valid()) {\n\t\t\t\t\t\tgps.ground_start_countdown = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgps.ground_start_countdown = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (gps.ground_start_countdown == 1) {\n\t\t\t\t\tgps.ground_start_countdown = 0;\n\t\t\t\t\tgps.set_home();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 27.78902748218457}, {"code": "void Tracker::update_GPS(void){\n\t\t// update GPS data\n\tgps.update();\n\t// check if the last message time has changed and if the GPS status is at least 3D fix\n\tif (gps.last_message_time!= last_gps_message_time && gps.status >= 3) {\n\t\t// set the last message time\n\t\tlast_gps_message_time = gps.last_message_time;\n\t\t// set the GPS data\n\t\tset_GPS_data();\n\t\t// check if the ground start countdown has reached one\n\t\tif (ground_start_countdown == 1) {\n\t\t\t// check if the current location is valid\n\t\t\tif (gps.location.lat!= 0 && gps.location.lng!= 0) {\n\t\t\t\t// set the home location\n\t\t\t\tset_home_location();\n\t\t\t}\n\t\t\t// reset the ground start countdown\n\t\t\tground_start_countdown = 0;\n\t\t}\n\t\t// check if the ground start countdown is not zero\n\t\tif (ground_start_countdown!= 0) {\n\t\t\t// decrement the ground start countdown\n\t\t\tground_start_countdown--;\n\t\t}\n\t}\n}", "CodeBleu_score": 38.155418708133084}, {"code": "void Tracker::update_GPS(void){\n\t\tgps.update();\n\tif (gps.last_message_time!= last_gps_time) {\n\t\tlast_gps_time = gps.last_message_time;\n\t\tif (gps.status >= 3) {\n\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\tif (gps.valid_location()) {\n\t\t\t\t\tground_start_countdown = 1;\n\t\t\t\t\thome_location = gps.location;\n\t\t\t\t} else {\n\t\t\t\t\tground_start_countdown = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tground_start_countdown = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 37.96567601708052}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 10.0f) {\n\t\t//Serial.println(\"pitch > 10.0f\");\n\t\t//Serial.println(pitch);\n\t\tpitch_onoff_servo.write(180);\n\t\t//Serial.println(\"servo on\");\n\t}\n\telse if (pitch < -10.0f) {\n\t\t//Serial.println(\"pitch < -10.0f\");\n\t\t//Serial.println(pitch);\n\t\tpitch_onoff_servo.write(0);\n\t\t//Serial.println(\"servo off\");\n\t}\n\telse {\n\t\tpitch_onoff_servo.write(90);\n\t}\n}", "CodeBleu_score": 15.768974058940977}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0) {\n\t\t//pitch up\n\t\t_pitch_onoff_servo->set_angle(180);\n\t} else {\n\t\t//pitch down\n\t\t_pitch_onoff_servo->set_angle(0);\n\t}\n}", "CodeBleu_score": 13.330991056649037}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\t\tif (pitch > 0.0) {\n\t\tpitch = 0.0;\n\t}\n\telse if (pitch < -90.0) {\n\t\tpitch = -90.0;\n\t}\n\t_pitch_onoff_servo.write(90 + pitch);\n}", "CodeBleu_score": 12.67509660819512}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\t// perform base class checks\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check barometer reference\n\tif (flags.arming_flags & ARMING_CHECK_BARO) {\n\t\tif (fabsf(barometer.get_altitude() - ahrs.get_altitude()) > g.arming_check_altitude_max) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_HIGH, PSTR(\"Altitude disparity too large\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 28.025041926280004}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = AP_Arming::barometer_checks(display_failure);\n\tif (ret && (arming_flags & ARMING_CHECK_BARO)) {\n\t\t// check baro reference\n\t\tif (barometer->get_barometer() == NULL) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Baro reference not set\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check baro altitude\n\t\tfloat baro_alt = barometer->get_altitude();\n\t\tif (baro_alt < 0) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Baro altitude invalid\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// check baro altitude vs inertial nav altitude\n\t\tfloat diff = baro_alt - inertial_nav.get_altitude();\n\t\tif (diff > g.arm_baro_alt_diff || diff < -g.arm_baro_alt_diff) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Baro altitude discrepancy\"));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 46.77390718746523}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\t\tbool ret = AP_Arming::barometer_checks(display_failure);\n\tif (ret && (arming_flags & ARMING_CHECK_BARO)) {\n\t\tfloat baro_alt = ahrs.get_barometer_alt();\n\t\tfloat inav_alt = inertial_nav.get_altitude();\n\t\tfloat baro_diff = baro_alt - inav_alt;\n\t\tif (fabsf(baro_diff) > g.arming_check_baro_diff) {\n\t\t\tif (display_failure) {\n\t\t\t\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Baro alt: %.1f, Inav alt: %.1f, diff: %.1f\"), baro_alt, inav_alt, baro_diff);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn ret;\n}", "CodeBleu_score": 43.72989481669103}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (g.rtl_altitude_source == RTL_ALTITUDE_SOURCE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 31.01744409547732}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (_terrain_source == TERRAIN_SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (_terrain_source == TERRAIN_SOURCE_DATABASE && _rtl_altitude_type == RTL_ALTITUDE_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 51.829993944551425}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\t\tif (g.rtl_altitude_source == RTL_ALTITUDE_SOURCE_TERRAIN_DATABASE && g.rtl_altitude_type == RTL_ALTITUDE_TYPE_TERRAIN) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 44.43518353042893}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t\t// run the rate controller at the desired rate\n\tif (g.rc_3.get_failsafe()) {\n\t\t// if we are in failsafe, run the rate controller at the desired rate\n\t\t// but don't run the position controller\n\t\tif (g.rc_loop_timer.expired(LOOP_RATE_MS)) {\n\t\t\tg.rc_loop_timer.start();\n\t\t\trate_controller->run();\n\t\t}\n\t} else {\n\t\t// run the rate controller at the desired rate\n\t\tif (g.rc_loop_timer.expired(LOOP_RATE_MS)) {\n\t\t\tg.rc_loop_timer.start();\n\t\t\trate_controller->run();\n\t\t}\n\t}\n}", "CodeBleu_score": 46.53852785703765}, {"code": "void Copter::run_rate_controller(){\n\t\t// set the loop time for the attitude, position, and motor controllers\n\t// from the scheduler\n\tg.rc_loop_time = g.scheduler.loop_time_us;\n\n\t// run the low-level rate controllers that require only IMU data\n\t// (attitude and rate controllers)\n\tg.rc_controller->rate_controller_run();\n}", "CodeBleu_score": 24.51833608624393}, {"code": "void Copter::run_rate_controller(){\n\t\t// run the rate controller at the specified rate\n\tif (_rate_controller_loop_timer.expired()) {\n\t\t_rate_controller_loop_timer.start();\n\n\t\t// run the attitude controller\n\t\t_attitude_controller->rate_controller_run();\n\n\t\t// run the position controller\n\t\t_position_controller->rate_controller_run();\n\n\t\t// run the motor controller\n\t\t_motor_controller->rate_controller_run();\n\t}\n}", "CodeBleu_score": 28.88084549611594}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// exit if the old location does not match the next waypoint\n\tif (!old_loc.is_equal(mode_guided.get_destination())) {\n\t\treturn false;\n\t}\n\n\t// exit if the altitude frames of the old and new locations are not the same\n\tif (old_loc.get_alt_frame()!= new_loc.get_alt_frame()) {\n\t\treturn false;\n\t}\n\n\t// set the new location as the target\n\treturn mode_guided.set_destination(new_loc);\n}", "CodeBleu_score": 60.25246340175714}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\tif (old_loc.id == new_loc.id && old_loc.frame == new_loc.frame) {\n\t\treturn false;\n\t}\n\n\t// set new target location\n\tset_target_location(new_loc);\n\n\treturn true;\n}", "CodeBleu_score": 41.91685655215025}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\t\t// exit if vehicle is not in Guided mode or Auto-Guided mode\n\tif (!flightmode->in_guided_mode()) {\n\t\treturn false;\n\t}\n\n\t// check if old location matches the waypoint location\n\tif (old_loc!= mode_guided.get_destination()) {\n\t\treturn false;\n\t}\n\n\t// check if altitude frames are the same\n\tif (old_loc.alt_frame!= new_loc.alt_frame) {\n\t\treturn false;\n\t}\n\n\t// set new location as target\n\tmode_guided.set_destination(new_loc);\n\n\treturn true;\n}", "CodeBleu_score": 55.58180396192055}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AUX_SWITCH_HIGH) {\n\t\t// If the switch is in the HIGH position, attempt to set the mode.\n\t\tset_mode(mode);\n\t} else if (mode == get_mode() && get_mode()!= Mode::RTL) {\n\t\t// If the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch.\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 46.97350807181468}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (aux_switch_pos(ch_flag) == AUX_HIGH) {\n\t\t// if the switch is in the high position, attempt to set the mode\n\t\tif (!set_mode(mode)) {\n\t\t\t// if we failed to set the mode, reset the switch\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t} else if (mode == get_mode()) {\n\t\t// if we are in the given mode, reset the mode switch\n\t\trc().reset_mode_switch();\n\t}\n}", "CodeBleu_score": 48.93428650399089}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\t\tif (ch_flag == AUX_HIGH) {\n\t\tif (set_mode(mode) == true) {\n\t\t\t// mode change was successful\n\t\t\treturn;\n\t\t}\n\t} else if (ch_flag == AUX_LOW) {\n\t\tif (get_mode() == mode) {\n\t\t\t// mode change was unsuccessful, reset the switch\n\t\t\trc().reset_mode_switch(mode);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.588598428211185}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t\t// calculate trim values from control inputs\n\tfloat trim_roll = (g.rc_1.control_in - 1500) * g.rc_1.get_scaling() * DEG_TO_RAD;\n\tfloat trim_pitch = (g.rc_2.control_in - 1500) * g.rc_2.get_scaling() * DEG_TO_RAD;\n\n\t// add trim values to AHRS trim\n\tahrs.set_trim(trim_roll, trim_pitch, 0);\n\n\t// log event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send confirmation message\n\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Trim saved\"));\n}", "CodeBleu_score": 42.92784472079563}, {"code": "void Copter::save_trim(){\n\t\t// save trim values\n\tfloat roll_trim_rad = radians(_roll_trim);\n\tfloat pitch_trim_rad = radians(_pitch_trim);\n\tahrs.set_trim(roll_trim_rad, pitch_trim_rad);\n\n\t// log event\n\tLog_Write_Event(DATA_TRIM_SAVE, true);\n\n\t// send confirmation message\n\tgcs_send_text_P(SEVERITY_LOW, PSTR(\"Trim saved\"));\n}", "CodeBleu_score": 43.042365648542436}, {"code": "void Copter::save_trim(){\n\t\t// save trim values\n\tg.channel_roll->set_trim((g.channel_roll->radio_in - g.channel_roll->radio_trim) * g.channel_roll->angle_max / g.channel_roll->radio_max);\n\tg.channel_pitch->set_trim((g.channel_pitch->radio_in - g.channel_pitch->radio_trim) * g.channel_pitch->angle_max / g.channel_pitch->radio_max);\n\n\t// save trim values to EEPROM\n\tg.channel_roll->save_eeprom();\n\tg.channel_pitch->save_eeprom();\n\n\t// log event\n\tLog_Write_Event(DATA_TRIM_SAVE);\n\n\t// send confirmation message\n\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"Trim saved\"));\n}", "CodeBleu_score": 22.342521596337217}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat vx = _vel.x;\n\tfloat vy = _vel.y;\n\tfloat vz = _vel.z;\n\n\tfloat speed_squared = vx * vx + vy * vy + vz * vz;\n\n\tif (_pos.is_valid() && speed_squared > 0.001f) {\n\t\tfloat yaw = atan2f(vy, vx);\n\t\treturn yaw;\n\t}\n\n\treturn NAN;\n}", "CodeBleu_score": 41.649132301051104}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat speed_sq = _vel.length_squared();\n\tfloat yaw = 0.0f;\n\tif (_pos.is_finite() && speed_sq > sq(LOOK_AHEAD_MIN_SPEED)) {\n\t\tyaw = atan2f(_vel.y, _vel.x);\n\t}\n\n\treturn yaw;\n}", "CodeBleu_score": 31.47530838488758}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t\tfloat vx = _vel_sp.x;\n\tfloat vy = _vel_sp.y;\n\tfloat vz = _vel_sp.z;\n\tfloat speed_sq = vx * vx + vy * vy + vz * vz;\n\n\tif (_pos_sp.is_valid() && speed_sq > 0.01f) {\n\t\treturn math::constrain(math::atan2(vy, vx), -M_PI_2, M_PI_2);\n\n\t} else {\n\t\treturn NAN;\n\t}\n}", "CodeBleu_score": 42.01245989901662}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\t// perform checks\n\tif (method == AP_Arming::RUDDER) {\n\t\t// rudder arming is disabled or throttle is not zero\n\t\tif (g.rudder_arm == 0 ||!ap.throttle_zero()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// arming checks are disabled or watchdog was armed\n\tif (g.arming_check == 0 || ap.watchdog_armed) {\n\t\treturn true;\n\t}\n\t// perform parent checks\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 44.046170097667876}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER_DISABLED) {\n\t\t\treturn false;\n\t\t}\n\t\tif (g.arming_check == ARMING_CHECK_RUDDER_THROTTLE_DISABLED && g.rc_3.control_in == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (g.arming_check == ARMING_CHECK_DISABLED || watchdog_armed) {\n\t\treturn true;\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 48.255542882854606}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t\tif (method == AP_Arming::RUDDER) {\n\t\tif (g.arming_check & ARMING_CHECK_RUDDER) {\n\t\t\t// rudder arming is disabled\n\t\t\treturn false;\n\t\t}\n\t\tif (g.rc_3.control_in > 0) {\n\t\t\t// throttle is not zero\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (method == AP_Arming::WATCHDOG) {\n\t\tif (g.arming_check & ARMING_CHECK_WATCHDOG) {\n\t\t\t// watchdog arming is disabled\n\t\t\treturn false;\n\t\t}\n\t\tif (g.watchdog_armed) {\n\t\t\t// watchdog was armed\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 47.68439760701106}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t\tbool ret = false;\n\n\t// if already armed, return\n\tif(hal.util->get_soft_armed()) {\n\t\treturn true;\n\t}\n\n\t// if we're not in a state that allows arming, return\n\tif(!is_armed_state()) {\n\t\treturn false;\n\t}\n\n\t// if we're disarmed and the pilot is trying to arm, set the\n\t// throttle to the minimum\n\tif(method == AP_Arming::Method::Pilot &&!hal.util->get_soft_armed()) {\n\t\tset_throttle_takeoff();\n\t}\n\n\t// run arming checks\n\tif(do_arming_checks) {\n\t\tif(!run_arming_checks()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// if we're still here, we're armed\n\thal.util->set_soft_armed(true);\n\tchange_arm_state();\n\tset_delay_arming(true);\n\tnotify->send_text(AP_Notify::Text::Armed);\n\tret = true;\n\n\treturn ret;\n}", "CodeBleu_score": 48.28351819608812}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if HAL_QUADPLANE_ENABLED\n    if (!plane.quadplane.arm(method, do_arming_checks)) {\n        return false;\n    }\n#endif\n\n    // update the home location\n    if (method == AP_Arming::Method::Auto || method == AP_Arming::Method::RC) {\n        if (home_is_set == false) {\n            home.id = 0;\n            home.alt = current_loc.alt;\n            home.lng = current_loc.lng;\n            home.lat = current_loc.lat;\n            home_is_set = true;\n            ahrs.set_home(home);\n        }\n    }\n\n    // update the current location\n    current_loc.alt = home.alt;\n    current_loc.lng = home.lng;\n    current_loc.lat = home.lat;\n\n    // change the arm state\n    change_arm_state();\n\n    // set the delay arming flag\n    delay_arming = true;\n\n    // send status text\n    gcs_send_text_P(SEVERITY_LOW,PSTR(\"Armed\"));\n\n    return true;\n}", "CodeBleu_score": 53.518954766228724}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t#if!HAL_QUADPLANE_ENABLED\n    return false;\n#else\n    if (hal.util->get_soft_armed()) {\n        // already armed\n        return false;\n    }\n\n    // check for arming checks\n    if (do_arming_checks) {\n        if (!pass_arming_checks(method)) {\n            return false;\n        }\n    }\n\n    // set home location\n    if (!home.have_home()) {\n        home.set_home_to_current_location();\n    }\n    ahrs.set_home(home.get_lat(), home.get_lng());\n\n    // set current location\n    if (!ahrs.have_position()) {\n        ahrs.set_position(home.get_lat(), home.get_lng());\n    }\n\n    // set throttle to armed\n    plane.throttle_set_armed();\n\n    // update the arm state\n    change_arm_state();\n\n    // set delay arming flag\n    delay_arming_flag = true;\n\n    // send status text\n    gcs_send_text_P(SEVERITY_LOW, PSTR(\"Throttle armed\"));\n\n    // return success\n    return true;\n#endif\n}", "CodeBleu_score": 55.804405636555565}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (!sub.arming.armed()) {\n\t\treturn true;\n\t}\n\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tsub.notify.error(PSTR(\"No disarm button\"));\n\t\t}\n\t\treturn false;\n\t}\n\treturn sub.arming.pre_arm_checks(display_failure);\n}", "CodeBleu_score": 63.239585492618765}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\tif (!has_disarm_function()) {\n\t\tif (display_failure) {\n\t\t\tAP_Notify::error(\"No disarm button\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 68.10588427326798}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t#if AP_ARMED_SUB_ARMING == ENABLED\n    if (!sub.armed.get()) {\n        if (!has_disarm_function()) {\n            if (display_failure) {\n                AP_Notify::flags.arming_failure = true;\n            }\n            return false;\n        }\n    }\n#endif\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 56.3326561675354}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat yaw = ahrs.yaw;\n\tfloat ne_x = x * cos(yaw) - y * sin(yaw);\n\tfloat ne_y = x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 56.60082837050477}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 53.18204260260693}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t\tfloat ne_x, ne_y;\n\tne_x = x * cos(ahrs->yaw) - y * sin(ahrs->yaw);\n\tne_y = x * sin(ahrs->yaw) + y * cos(ahrs->yaw);\n\tx = ne_x;\n\ty = ne_y;\n}", "CodeBleu_score": 55.81599952250087}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 < -180 || packet.param4 > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param2 < 0 || packet.param2 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param3 < 0 || packet.param3 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param5 < 0 || packet.param5 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param6 < 0 || packet.param6 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\tif (packet.param7 < 0 || packet.param7 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t_yaw_heading = packet.param1;\n\t_yaw_heading_relative = packet.param2;\n\t_yaw_speed = packet.param3;\n\t_yaw_angle_absolute = packet.param4;\n\t_yaw_angle_relative = packet.param5;\n\t_yaw_angle_change = packet.param6;\n\t_yaw_direction = packet.param7;\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 44.357425372935985}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\t// Check if yaw angle is within acceptable range\n\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if param4 is within acceptable range\n\tif (packet.param4 < 0 || packet.param4 > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading using the provided parameters\n\tyaw_heading = packet.param1;\n\tyaw_heading_mode = packet.param4;\n\n\treturn MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 42.55557628122785}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t\tif (packet.param4 > 0) {\n\t\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t\tif (packet.param4 < 0 || packet.param4 > 360) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t\tyaw_heading = packet.param1;\n\t\tyaw_heading_tolerance = packet.param4;\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\tif (packet.param1 < 0 || packet.param1 > 360) {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t\tyaw_heading = packet.param1;\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n}", "CodeBleu_score": 48.798986654545615}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.150400996515202}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn high_latency_tgt_heading_;\n}", "CodeBleu_score": 6.16275310706722}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\t\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.150400996515202}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_enabled) {\n\t\tuint8_t data[8];\n\t\tdata[0] = (uint8_t)id;\n\t\tdata[1] = (uint8_t)(id >> 8);\n\t\tdata[2] = (uint8_t)(id >> 16);\n\t\tdata[3] = (uint8_t)(id >> 24);\n\t\tdata[4] = (uint8_t)value;\n\t\tdata[5] = (uint8_t)(value >> 8);\n\t\tdata[6] = (uint8_t)(value >> 16);\n\t\tdata[7] = (uint8_t)(value >> 24);\n\t\tLog_Write_Data(data, 8);\n\t}\n}", "CodeBleu_score": 32.3738638215762}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.id = id;\n\t\tpacket.value.i32 = value;\n\t\tpacket.time = time(NULL);\n\t\tLog_Write_Packet(packet);\n\t}\n}", "CodeBleu_score": 35.69531635671932}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\t\tif (logging_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.time = Time::Get_Time();\n\t\tpacket.data_id = id;\n\t\tpacket.value = value;\n\t\tlogger.Write_Critical_Block((uint8_t*)&packet, sizeof(packet));\n\t}\n}", "CodeBleu_score": 36.54697413655289}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 43.71443122701882}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set) {\n\t\treturn;\n\t}\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 43.71443122701882}, {"code": "void Sub::update_home_from_EKF(){\n\t\tif (home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (motors.armed()) {\n\t\tset_home_to_current_location_inflight();\n\t} else {\n\t\tset_home_to_current_location(false);\n\t}\n}", "CodeBleu_score": 44.18690302067394}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t\t// If motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n\tif (!motorsArmed()) {\n\t\t// Set throttle to zero\n\t\tsetThrottle(0.0);\n\t\t// Adjust spool state\n\t\tadjustSpoolState();\n\t\t// Relax attitude controllers\n\t\trelaxAttitudeControllers();\n\t\t// Exit\n\t\treturn;\n\t}\n\t// If motors are armed, set spool state to unlimited throttle, convert pilot inputs to desired body frame rates, run attitude controller with these rates, output pilot's throttle input without angle boost, and set the forward and lateral motor inputs based on pilot controls\n\telse {\n\t\t// Set spool state to unlimited throttle\n\t\tsetSpoolState(SpoolState::UNLIMITED_THROTTLE);\n\t\t// Convert pilot inputs to desired body frame rates\n\t\tdouble rollRate = convertPilotInputToDesiredRate(pilotRollInput, getRollRate());\n\t\tdouble pitchRate = convertPilotInputToDesiredRate(pilotPitchInput, getPitchRate());\n\t\tdouble yawRate = convertPilotInputToDesiredRate(pilotYawInput, getYawRate());\n\t\t// Run attitude controller with these rates\n\t\trunAttitudeController(rollRate, pitchRate, yawRate);\n\t\t// Output pilot's throttle input without angle boost\n\t\tsetThrottle(pilotThrottleInput);\n\t\t// Set the forward and lateral motor inputs based on pilot controls\n\t\tsetForwardMotorInput(pilotForwardInput);\n\t\tsetLateralMotorInput(pilotLateralInput);\n\t}\n}", "CodeBleu_score": 26.2691022744858}, {"code": "void ModeAcro::run(){\n\t\t// if motors are not armed, set throttle to zero, adjust spool state, relax attitude controllers, and exit\n\tif (!motors_armed) {\n\t\t// set throttle to zero\n\t\tthrottle_out = 0;\n\t\t// adjust spool state\n\t\tspool_state = SPOOL_STATE_UNLIMITED;\n\t\t// relax attitude controllers\n\t\tattitude_controller.relax();\n\t\t// exit\n\t\treturn;\n\t}\n\n\t// if armed, set spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run attitude controller with these rates\n\t// set spool state to unlimited throttle\n\tspool_state = SPOOL_STATE_UNLIMITED;\n\t// convert pilot inputs to desired body frame rates\n\tdesired_body_rates.x = (pilot_input.y - 0.5) * 2 * ACRO_RATE_MAX;\n\tdesired_body_rates.y = (pilot_input.x - 0.5) * 2 * ACRO_RATE_MAX;\n\tdesired_body_rates.z = (pilot_input.r - 0.5) * 2 * ACRO_RATE_MAX;\n\t// run attitude controller with these rates\n\tattitude_controller.run(desired_body_rates);\n\n\t// output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls\n\tthrottle_out = pilot_input.t;\n\tmotor_inputs.x = pilot_input.x;\n\tmotor_inputs.y = pilot_input.y;\n}", "CodeBleu_score": 34.32843414069182}, {"code": "void ModeAcro::run(){\n\t\t// If motors aren't armed, set throttle to zero and exit\n\tif (!motors.armed()) {\n\t\tmotors.setThrottle(0);\n\t\tmotors.setSpoolState(Motor::SpoolState::UNLIMITED_THROTTLE);\n\t\tattitudeController.relax();\n\t\treturn;\n\t}\n\n\t// If motors are armed, set spool state to unlimited throttle\n\tmotors.setSpoolState(Motor::SpoolState::UNLIMITED_THROTTLE);\n\n\t// Convert pilot inputs to desired body frame rates\n\tfloat rollRate = pilotInputs.roll * Config::get<float>(\"pilot_roll_rate_scale\");\n\tfloat pitchRate = pilotInputs.pitch * Config::get<float>(\"pilot_pitch_rate_scale\");\n\tfloat yawRate = pilotInputs.yaw * Config::get<float>(\"pilot_yaw_rate_scale\");\n\n\t// Run the attitude controller with these rates\n\tattitudeController.run(rollRate, pitchRate, yawRate);\n\n\t// Output pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls\n\tmotors.setThrottle(pilotInputs.throttle);\n\tmotors.setMotorInputs(pilotInputs.forward, pilotInputs.lateral);\n}", "CodeBleu_score": 43.57066002575507}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set position control mode\n\tset_mode(GUIDED);\n\n\t// set waypoint destination\n\t// get stopping point\n\tVector3f stopping_point;\n\tget_stopping_point(&stopping_point);\n\t// set waypoint destination\n\twp_nav->set_destination(stopping_point.x, stopping_point.y, stopping_point.z);\n\n\t// set initial yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 41.30171715714017}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n    set_mode(GUIDED);\n    // set the stopping point as the waypoint destination\n    wp_nav.set_destination(stopping_point);\n    // initialize yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 14.354539693821966}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t\t// set to position control mode\n\tset_mode(GUIDED);\n\n\t// set the stopping point as the waypoint destination\n\twp_nav.set_destination(stopping_point);\n\n\t// initialize the yaw using the default auto yaw mode\n\tset_auto_yaw_mode(get_default_auto_yaw_mode());\n}", "CodeBleu_score": 12.96984052003683}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// initialise vertical maximum speeds and acceleration using pilot-defined parameters\n\tsub.vel_control_max_vertical_speed = get_pilot_desired_velocity_z_max();\n\tsub.vel_control_max_vertical_acceleration = get_pilot_desired_velocity_z_max_change();\n\n\t// initialise vertical velocity controller\n\tsub.vel_control_vertical_velocity = 0;\n\tsub.vel_control_vertical_acceleration = 0;\n\tsub.vel_control_vertical_position = 0;\n\tsub.vel_control_vertical_velocity_target = 0;\n\tsub.vel_control_vertical_velocity_error = 0;\n\tsub.vel_control_vertical_position_error = 0;\n\tsub.vel_control_vertical_position_target = 0;\n\tsub.vel_control_vertical_position_error_sum = 0;\n\tsub.vel_control_vertical_position_error_last = 0;\n\tsub.vel_control_vertical_velocity_error_last = 0;\n\tsub.vel_control_vertical_velocity_error_sum = 0;\n\n\t// initialise horizontal velocity controller\n\tsub.vel_control_horizontal_velocity = 0;\n\tsub.vel_control_horizontal_velocity_target = 0;\n\tsub.vel_control_horizontal_velocity_error = 0;\n\tsub.vel_control_horizontal_velocity_error_sum = 0;\n\tsub.vel_control_horizontal_velocity_error_last = 0;\n\tsub.vel_control_horizontal_position = 0;\n\tsub.vel_control_horizontal_position_target = 0;\n\tsub.vel_control_horizontal_position_error = 0;\n\tsub.vel_control_horizontal_position_error_sum = 0;\n\tsub.vel_control_horizontal_position_error_last = 0;\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 24.92551000797027}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set the vertical max speeds and accelerations\n\tsub.guided_max_z_velocity = g.guided_max_z_velocity;\n\tsub.guided_max_climb_rate = g.guided_max_climb_rate;\n\tsub.guided_max_descent_rate = g.guided_max_descent_rate;\n\tsub.guided_max_vertical_acceleration = g.guided_max_vertical_acceleration;\n\n\t// initialize the vertical velocity controller\n\tsub.guided_vel_controller_z.set_max_speed(sub.guided_max_z_velocity);\n\tsub.guided_vel_controller_z.set_max_acceleration(sub.guided_max_vertical_acceleration);\n\tsub.guided_vel_controller_z.reset_I();\n\n\t// initialize the horizontal velocity controller\n\tsub.guided_vel_controller_xy.set_max_speed(g.guided_max_xy_velocity);\n\tsub.guided_vel_controller_xy.set_max_acceleration(g.guided_max_horizontal_acceleration);\n\tsub.guided_vel_controller_xy.reset_I();\n\n\t// set the yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 37.35802606205819}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t\t// set vertical maximum speed and acceleration using pilot-defined parameters\n\tsub.vel_control_max_vertical_speed = g.guided_vel_z_max;\n\tsub.vel_control_max_vertical_accel = g.guided_vel_z_accel;\n\n\t// initialize vertical velocity controller\n\tvel_controller_z.set_max_speed(sub.vel_control_max_vertical_speed);\n\tvel_controller_z.set_max_accel(sub.vel_control_max_vertical_accel);\n\tvel_controller_z.set_target(0.0f);\n\tvel_controller_z.reset_I();\n\n\t// initialize horizontal velocity controller\n\tvel_controller_xy.set_max_speed(g.guided_vel_xy_max);\n\tvel_controller_xy.set_max_accel(g.guided_vel_xy_accel);\n\tvel_controller_xy.set_target(0.0f);\n\tvel_controller_xy.reset_I();\n\n\t// set yaw control mode to AUTO_YAW_HOLD\n\tset_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 51.483979199756135}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\t\tif (time_since_last_heartbeat > (uint32_t)timeout) {\n\t\treturn true;\n\t}\n\tif (current_loc.lat == 0 && current_loc.lng == 0) {\n\t\treturn false;\n\t}\n\tif (wp_distance < 10) {\n\t\treturn true;\n\t}\n\tif (current_loc.lat == 0 && current_loc.lng == 0) {\n\t\treturn false;\n\t}\n\tif (abs(current_loc.alt - initial_state.alt) > max_climb_rate * 100 * dt) {\n\t\treturn true;\n\t}\n\tif (abs(current_loc.alt - initial_state.alt) > max_descent_rate * 100 * dt) {\n\t\treturn true;\n\t}\n\tif (abs(current_loc.lat - initial_state.lat) > max_xy_travel_distance * 100 * dt) {\n\t\treturn true;\n\t}\n\tif (abs(current_loc.lng - initial_state.lng) > max_xy_travel_distance * 100 * dt) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 45.93686912919621}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check if timeout has been exceeded\n\tif (guided_timeout_check()) {\n\t\treturn true;\n\t}\n\n\t// check if altitude is below minimum\n\tif (guided_altitude_check(guided_min_altitude)) {\n\t\treturn true;\n\t}\n\n\t// check if altitude is above maximum\n\tif (guided_altitude_check(guided_max_altitude)) {\n\t\treturn true;\n\t}\n\n\t// check if horizontal distance moved exceeds limit\n\tif (guided_distance_check()) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 16.970646932618212}, {"code": "bool ModeGuided::guided_limit_check(){\n\t\t// check if we have reached the timeout\n\tif (millis() - _last_update_time > _timeout) {\n\t\treturn true;\n\t}\n\n\t// check if we have reached the minimum altitude\n\tif (_current_alt < _min_altitude) {\n\t\treturn true;\n\t}\n\n\t// check if we have reached the maximum altitude\n\tif (_current_alt > _max_altitude) {\n\t\treturn true;\n\t}\n\n\t// check if we have reached the horizontal distance limit\n\tif (_current_distance > _max_distance) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 16.85492463729652}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t\tif (motor_test_req_timeout > 0) {\n\t\tmotor_test_req_timeout--;\n\t}\n\tif (motor_test_req_timeout == 0) {\n\t\tmotor_test_req_timeout = 0;\n\t\tmotor_test_pass = false;\n\t\tmotor_test_req = false;\n\t\tmotor_test_enabled = false;\n\t\tmotor_test_timeout = true;\n\t\tmotor_test_timeout_time = millis();\n\t\tmotor_test_timeout_time_prev = motor_test_timeout_time;\n\t\tSerial.println(\"Motor Test Timed Out\");\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 44.68367950152503}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Check if motor test requests are received at least every 2 Hz\n\tif (motor_test_request_timer.elapsed() > 1.0 / 2.0) {\n\t\t// Send timeout message\n\t\tROS_INFO(\"Motor test timeout.\");\n\t\tmotor_test_timeout_msg.data = true;\n\t\tmotor_test_timeout_pub.publish(motor_test_timeout_msg);\n\t\t// Set pass flag to false\n\t\tmotor_test_pass = false;\n\t\t// Disable motor test\n\t\tdisable_motor_test();\n\t\t// Disarm system\n\t\tdisarm_system();\n\t\t// Record failure time\n\t\tmotor_test_failure_time = ros::Time::now();\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 30.677947665741833}, {"code": "bool Sub::verify_motor_test(){\n\t\t// Check if the motor test request has been received at least every 2 Hz\n\tif (motor_test_request_timer.elapsed() > 500) {\n\t\t// Send timeout message\n\t\tsend_timeout_message(motor_test_timeout_message);\n\t\t// Set the pass flag to false\n\t\tpass = false;\n\t\t// Disable the motor test\n\t\tdisable_motor_test();\n\t\t// Disarm the system\n\t\tdisarm_system();\n\t\t// Record the failure time\n\t\trecord_failure_time();\n\t\t// Return false\n\t\treturn false;\n\t}\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 19.729987129933523}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat roll_target = 0.0;\n\tfloat pitch_target = 0.0;\n\tfloat roll_target_max = 0.0;\n\tfloat pitch_target_max = 0.0;\n\tfloat roll_target_min = 0.0;\n\tfloat pitch_target_min = 0.0;\n\n\t// Get roll and pitch targets from wp_nav\n\troll_target = (float) wp_nav.roll_target;\n\tpitch_target = (float) wp_nav.pitch_target;\n\n\t// Constrain roll and pitch targets within a maximum angle range\n\troll_target_max = (float) wp_nav.roll_target_max;\n\tpitch_target_max = (float) wp_nav.pitch_target_max;\n\troll_target_min = (float) wp_nav.roll_target_min;\n\tpitch_target_min = (float) wp_nav.pitch_target_min;\n\n\tif (roll_target > roll_target_max) {\n\t\troll_target = roll_target_max;\n\t} else if (roll_target < roll_target_min) {\n\t\troll_target = roll_target_min;\n\t}\n\n\tif (pitch_target > pitch_target_max) {\n\t\tpitch_target = pitch_target_max;\n\t} else if (pitch_target < pitch_target_min) {\n\t\tpitch_target = pitch_target_min;\n\t}\n\n\t// Normalize roll and pitch targets\n\troll_target = roll_target / 100.0;\n\tpitch_target = pitch_target / 100.0;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 38.497491284900924}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\tfloat max_angle = 1000; // 1000 = 10 degrees\n\n\t// constrain the roll and pitch targets\n\tfloat roll = constrain(wp_nav.roll, -max_angle, max_angle);\n\tfloat pitch = constrain(wp_nav.pitch, -max_angle, max_angle);\n\n\t// normalize the roll and pitch targets\n\troll = roll / max_angle;\n\tpitch = pitch / max_angle;\n\n\t// assign the normalized values to lateral_out and forward_out\n\tlateral_out = roll;\n\tforward_out = pitch;\n}", "CodeBleu_score": 38.884596288057}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t\t// Get the current roll and pitch targets from wp_nav in centidegrees.\n\tfloat roll_target = _wp_nav->get_roll_target();\n\tfloat pitch_target = _wp_nav->get_pitch_target();\n\n\t// Constrain the roll and pitch targets within the specified maximum angle range.\n\troll_target = math::constrain(roll_target, -_param_wp_nav_rp_max.get(), _param_wp_nav_rp_max.get());\n\tpitch_target = math::constrain(pitch_target, -_param_wp_nav_rp_max.get(), _param_wp_nav_rp_max.get());\n\n\t// Normalize the roll and pitch targets.\n\troll_target /= _param_wp_nav_rp_max.get();\n\tpitch_target /= _param_wp_nav_rp_max.get();\n\n\t// Assign the normalized roll and pitch targets to lateral_out and forward_out.\n\tlateral_out = roll_target;\n\tforward_out = pitch_target;\n}", "CodeBleu_score": 43.57642213249723}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\t\tif (barometer_health == 0) {\n\t\treturn;\n\t}\n\n\t// Read the barometer\n\tif (barometer->read() == 0) {\n\t\t// If the barometer is not healthy, return\n\t\tif (barometer_health == 1) {\n\t\t\treturn;\n\t\t}\n\t\tbarometer_health = 1;\n\t\treturn;\n\t}\n\tif (barometer_health == 1) {\n\t\tbarometer_health = 2;\n\t}\n\n\t// Update the barometer calibration\n\tif (barometer_calibration == 0) {\n\t\tbarometer_calibration = barometer->get_altitude();\n\t}\n\n\t// Update the barometer data\n\tbarometer_altitude = barometer->get_altitude() - barometer_calibration;\n\tbarometer_pressure = barometer->get_pressure();\n\tbarometer_temperature = barometer->get_temperature();\n\n\t// Update the depth sensor health\n\tif (barometer_altitude < 0) {\n\t\tdepth_sensor_health = 1;\n\t} else {\n\t\tdepth_sensor_health = 0;\n\t}\n}", "CodeBleu_score": 45.63321257963865}, {"code": "void Sub::read_barometer(){\n\t\t//read barometer data\n\t//if the altitude is above zero, update the barometer calibration\n\t//if a depth sensor is present, update the sensor health status based on the barometer's health\n\n\t//read barometer data\n\t//if the altitude is above zero, update the barometer calibration\n\t//if a depth sensor is present, update the sensor health status based on the barometer's health\n}", "CodeBleu_score": 2.7652140501199507}, {"code": "void Sub::read_barometer(){\n\t\tif (barometer.read()) {\n\t\tif (barometer.get_altitude() > 0) {\n\t\t\tbarometer.calibrate();\n\t\t}\n\t\tif (depth_sensor_present) {\n\t\t\tif (barometer.get_altitude() < 0) {\n\t\t\t\tsensor_health_status |= 0x01;\n\t\t\t} else {\n\t\t\t\tsensor_health_status &= 0xFE;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 57.05159788763696}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\t\t// check if we have an absolute position\n\tif (!ekf_position_absolute()) {\n\t\treturn false;\n\t}\n\n\t// check if we have a good absolute position\n\tif (ekf_position_absolute_ok()) {\n\t\treturn true;\n\t}\n\n\t// check if we have a predicted horizontal position\n\tif (ekf_position_predicted()) {\n\t\treturn true;\n\t}\n\n\t// check if we are in a mode that requires a good position\n\tif (ekf_mode_ok()) {\n\t\treturn true;\n\t}\n\n\t// otherwise we don't have a good position\n\treturn false;\n}", "CodeBleu_score": 13.730157523404113}, {"code": "bool Sub::ekf_position_ok(){\n\t\t// check if we have inertial navigation\n\tif (!_ekf->have_vertical_velocity() ||!_ekf->have_horizontal_velocity() ||!_ekf->have_position()) {\n\t\treturn false;\n\t}\n\n\t// if disarmed, we can accept a predicted position\n\tif (!_armed.armed) {\n\t\treturn true;\n\t}\n\n\t// if armed, we require a good absolute position\n\tif (!_ekf->get_ekf_pos_hgt_valid()) {\n\t\treturn false;\n\t}\n\n\t// if armed, we require the EKF not to be in constant position mode\n\tif (_ekf->get_in_constant_position_mode()) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 49.952799851811704}, {"code": "bool Sub::ekf_position_ok(){\n\t\tif (!_ekf_position_ok) {\n\t\treturn false;\n\t}\n\n\tif (!_ekf_initialized) {\n\t\treturn false;\n\t}\n\n\tif (!_armed.armed) {\n\t\t// if motors are disarmed, we accept predicted horizontal position\n\t\t// if the predicted position is more than 10m from the current position, we do not accept it\n\t\tif (fabsf(_local_pos.x - _pos_sp.x) > 10.0f ||\n\t\t    fabsf(_local_pos.y - _pos_sp.y) > 10.0f) {\n\t\t\treturn false;\n\t\t}\n\n\t} else {\n\t\t// if motors are armed, we require a good absolute position\n\t\t// and ensure the EKF is not in constant position mode\n\t\tif (_ekf_pos_horiz_accuracy > 1.0f ||\n\t\t    _ekf_pos_vert_accuracy > 1.0f ||\n\t\t    _ekf_const_pos_mode) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 28.4966777533171}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\tif (control_mode->get_mode()!= AP_MOTORS_STABILIZE && control_mode->get_mode()!= AP_MOTORS_ACRO) {\n\t\treturn true;\n\t}\n\n\tif (!super::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (!ahrs->is_healthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"EKF not healthy\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (ahrs->ekf_failsafe()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"EKF failsafe\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (!ahrs->get_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"position not valid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 50.297223434743685}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if we are not using position or velocity, we don't need to check the GPS\n\tif (!flags.use_position &&!flags.use_velocity) {\n\t\treturn true;\n\t}\n\n\t// call parent class's GPS checks\n\tif (!AP_Arming_Base::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check AHRS is healthy\n\tif (!ahrs.healthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"AHRS not healthy\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check EKF failsafe is not active\n\tif (ahrs.ekf_check_fail()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"EKF failsafe active\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check position estimate is valid\n\tif (!ahrs.position_ok()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_HIGH,PSTR(\"Position estimate invalid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// all checks passed\n\treturn true;\n}", "CodeBleu_score": 50.331195811139665}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t\t// if we are not using position or velocity control, no need to check\n\tif (control_mode == AP_CONTROL_NONE || control_mode == AP_CONTROL_MANUAL) {\n\t\treturn true;\n\t}\n\n\t// call parent class's checks\n\tif (!AP_Arming::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// check AHRS system is ready\n\tif (!ahrs.healthy()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"AHRS not ready\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check EKF failsafe is not active\n\tif (ahrs.ekf_check_fail()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"EKF failsafe\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// check position estimate is valid\n\tif (!ahrs.get_position_ok()) {\n\t\tif (display_failure) {\n\t\t\tgcs_send_text_P(SEVERITY_LOW,PSTR(\"position invalid\"));\n\t\t}\n\t\treturn false;\n\t}\n\n\t// all checks passed\n\treturn true;\n}", "CodeBleu_score": 51.93762718796147}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tif HAL_LOGGING_ENABLED\n    AP::logger().set_arming_method(method);\n#endif\n\n    // if we're already armed, do nothing\n    if (is_armed()) {\n        return true;\n    }\n\n    // check if we are allowed to arm\n    if (do_arming_checks &&!check_arming_requirements(method)) {\n        return false;\n    }\n\n    // set the armed flag\n    _armed.set_and_save(true);\n\n    // set the last armed time\n    _last_armed_ms.set_and_save(AP_HAL::millis());\n\n    // set the last disarmed time\n    _last_disarmed_ms.set_and_save(0);\n\n    // set the last arming method\n    _last_arming_method.set_and_save(method);\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // set the arm/disarm status text\n    _arming_status_text.set_and_save(g_arming_status_text_armed);\n\n    // set the arming failed flag\n    _arming_failed.set_and_save(false);\n\n    // send the armed status\n    notify_armed(true);\n\n    return true;\n}", "CodeBleu_score": 34.5419471111564}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t", "CodeBleu_score": 4.8659819959003165}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_retry_time = 0;\n\t\t} else {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_retry_time = time_now + 300000;\n\t\t}\n\t} else {\n\t\tif (time_now > charging_retry_time) {\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_retry_time = time_now + 300000;\n\t\t}\n\t}\n}", "CodeBleu_score": 29.973391414715035}, {"code": "void updateChargingEnabled(){\n\t\tif (charging_allowed) {\n\t\tif (checkShouldCharge()) {\n\t\t\tif (charging_enabled) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_disable_time = get_time();\n\t\t\t}\n\t\t} else {\n\t\t\tcharging_enabled = true;\n\t\t}\n\t} else {\n\t\tif (get_time() - charging_disable_time > 10000) {\n\t\t\tcharging_enabled = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.65861423433044}, {"code": "void updateChargingEnabled(){\n\t\tif(charging_allowed) {\n\t\tif(checkShouldCharge()) {\n\t\t\tdisableCharging();\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_start_time = 0;\n\t\t} else {\n\t\t\tenableCharging();\n\t\t\tcharging_enabled = true;\n\t\t\tcharging_start_time = get_time();\n\t\t}\n\t} else {\n\t\tif(get_time() - charging_start_time > 1000) {\n\t\t\tif(checkShouldCharge()) {\n\t\t\t\tdisableCharging();\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_start_time = 0;\n\t\t\t} else {\n\t\t\t\tenableCharging();\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_start_time = get_time();\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 42.322677883595404}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\t\tif(ros::isStarted() && size >= 4) {\n\t\tuint16_t crc = calculateCRC(message, size);\n\t\tpacketSerial.send(message, size);\n\t\tpacketSerial.send(&crc, 2);\n\t}\n}", "CodeBleu_score": 28.82465087849702}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isInitialized() && size >= 4) {\n\t\tuint16_t crc = calculateCRC(message, size);\n\t\tuint8_t *msg = (uint8_t *)message;\n\t\tmsg[size] = (uint8_t)crc;\n\t\tmsg[size+1] = (uint8_t)(crc >> 8);\n\t\tpacketSerial.send(msg, size+2);\n\t}\n}", "CodeBleu_score": 48.08889103780073}, {"code": "void sendMessage(void *message, size_t size){\n\t\tif (ros::isStarted() && size >= 4) {\n\t\tuint16_t crc = 0xFFFF;\n\t\tfor (size_t i = 0; i < size; i++) {\n\t\t\tuint8_t c = ((uint8_t *) message)[i];\n\t\t\tcrc = _crc_xmodem_update(crc, c);\n\t\t}\n\t\t((uint8_t *) message)[size++] = crc >> 8;\n\t\t((uint8_t *) message)[size++] = crc & 0xFF;\n\t\tpacketSerial.send((uint8_t *) message, size);\n\t}\n}", "CodeBleu_score": 56.61033052736536}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t", "CodeBleu_score": 2.1230943536500524}, {"code": "bool MP3Sound::begin(){\n\t\t//Serial.begin(9600);\n\tSerial.begin(115200);\n\tSerial.flush();\n\tdelay(100);\n\n\t//Serial.print(\"Initializing MP3 module...\n\");\n\tSerial.write(0x7E); //start byte\n\tSerial.write(0xFF); //version\n\tSerial.write(0x06); //length\n\tSerial.write(0x09); //command\n\tSerial.write(0x00); //feedback\n\tSerial.write(0x00); //dummy byte\n\tSerial.write(0x00); //dummy byte\n\tSerial.write(0x00); //checksum\n\tSerial.write(0xEF); //end byte\n\n\tdelay(100);\n\tSerial.flush();\n\n\t//Serial.print(\"Getting number of files...\n\");\n\tSerial.write(0x7E); //start byte\n\tSerial.write(0xFF); //version\n\tSerial.write(0x06); //length\n\tSerial.write(0x17); //command\n\tSerial.write(0x00); //feedback\n\tSerial.write(0x00); //dummy byte\n\tSerial.write(0x00); //dummy byte\n\tSerial.write(0x00); //checksum\n\tSerial.write(0xEF); //end byte\n\n\tdelay(100);\n\tSerial.flush();\n\n\t//Serial.print(\"Waiting for response...\n\");\n\twhile (Serial.available() < 10) {\n\t\t//wait\n\t}\n\n\t//Serial.print(\"Response received!\n\");\n\tbyte response[10];\n\tfor (int i = 0; i < 10; i++) {\n\t\tresponse[i] = Serial.read();\n\t}\n\n\tif (response[3] == 0x17) {\n\t\t//Serial.print(\"Number of files: \");\n\t\t//Serial.print(response[6]);\n\t\t//Serial.print(\"\n\");\n\t\tnumFiles = response[6];\n\t\treturn true;\n\t} else {\n\t\t//Serial.print(\"Response not received!\n\");\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 41.69429811044394}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\t\t// If there are no sounds, return 0\n\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\n\t// If an MP3 is playing, return the number of active sounds\n\tif (isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\n\t// Retrieve the last sound in the active sounds list\n\tSound *sound = activeSounds.back();\n\n\t// Remove the sound from the list\n\tactiveSounds.pop_back();\n\n\t// Play the sound\n\tplay(sound);\n\n\t// Return the updated number of active sounds\n\treturn activeSounds.size();\n}", "CodeBleu_score": 40.24664131408592}, {"code": "int MP3Sound::processSounds(){\n\t\t// If there are no active sounds or if an MP3 is currently playing, return the number of active sounds.\n\tif (activeSounds.size() == 0 || isPlaying) {\n\t\treturn activeSounds.size();\n\t}\n\n\t// Retrieve and play the last sound from the active sounds list, remove it from the list, and return the updated number of active sounds.\n\tint soundID = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaySound(soundID);\n\treturn activeSounds.size();\n}", "CodeBleu_score": 41.14865998183497}, {"code": "int MP3Sound::processSounds(){\n\t\tint numSounds = activeSounds.size();\n\tif (numSounds == 0) {\n\t\treturn 0;\n\t}\n\tif (numSounds == 1 && activeSounds[0]->isPlaying()) {\n\t\treturn 1;\n\t}\n\tif (numSounds > 1) {\n\t\tif (activeSounds[0]->isPlaying()) {\n\t\t\treturn numSounds;\n\t\t}\n\t\telse {\n\t\t\tactiveSounds[0]->play();\n\t\t\tactiveSounds.erase(activeSounds.begin());\n\t\t\treturn numSounds - 1;\n\t\t}\n\t}\n}", "CodeBleu_score": 41.04106268288235}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t", "CodeBleu_score": 6.48713104527464}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command: %d\n\", command);\n#endif\n  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (camera->memory_mapped_file)\n        wb_abstract_camera_cleanup_memory_mapped_file(camera);\n      wb_abstract_camera_setup_memory_mapped_file(camera, r);\n      return true;\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 39.54368091508355}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_handle_command: %d\n\", command);\n#endif\n\n  WbAbstractCamera *ac = (WbAbstractCamera *)d;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      // clean up any existing memory-mapped file\n      if (ac->mmf_file_name) {\n        wb_abstract_camera_close_memory_mapped_file(d);\n        free(ac->mmf_file_name);\n        ac->mmf_file_name = NULL;\n      }\n\n      // create a new memory-mapped file\n      char *file_name = wb_request_read_string(r);\n      int size = wb_request_read_int32(r);\n      wb_abstract_camera_create_memory_mapped_file(d, file_name, size);\n      free(file_name);\n      return true;\n    }\n    default:\n      return false;\n  }\n}", "CodeBleu_score": 49.346718337347895}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG\n  printf(\"wb_abstract_camera_get_height(%d)\n\", d->tag);\n#endif\n  if (d->type!= WB_NODE_ABSTRACT_CAMERA) {\n    fprintf(stderr, \"Error: %s(): invalid device type\n\", __FUNCTION__);\n    return -1;\n  }\n  WbAbstractCamera *ac = d->pdata;\n  pthread_mutex_lock(&ac->mutex);\n  int height = ac->height;\n  pthread_mutex_unlock(&ac->mutex);\n  return height;\n}", "CodeBleu_score": 40.60098319085681}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_get_height(%d)\n\", d->index);\n#endif\n  int height;\n\n  pthread_mutex_lock(&d->mutex);\n  if (d->data) {\n    height = ((WbCameraData *)d->data)->height;\n  } else {\n    height = -1;\n  }\n  pthread_mutex_unlock(&d->mutex);\n\n  return height;\n}", "CodeBleu_score": 39.24925510139704}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\t#ifdef DEBUG_CAMERA\n  printf(\"wb_abstract_camera_get_height(%d)\n\", d->tag);\n#endif\n  int height;\n\n  pthread_mutex_lock(&d->mutex);\n  if (d->data) {\n    height = ((WbAbstractCameraData *)d->data)->height;\n  } else {\n    height = -1;\n  }\n  pthread_mutex_unlock(&d->mutex);\n\n  return height;\n}", "CodeBleu_score": 39.382254806537674}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\n\", tag);\n#endif\n  int result;\n  pthread_mutex_lock(&mutex);\n  WbDevice *d = device_get(tag);\n  if (d!= NULL) {\n    if (d->pdata->type == WB_NODE_ACCELEROMETER) {\n      WbAccelerometer *accelerometer = d->pdata->pdata;\n      result = accelerometer->sampling_period;\n    } else {\n      fprintf(stderr, \"Error: %s() called with wrong device type.\n\", __FUNCTION__);\n      result = -1;\n    }\n  } else {\n    fprintf(stderr, \"Error: %s() called with invalid device tag.\n\", __FUNCTION__);\n    result = -1;\n  }\n  pthread_mutex_unlock(&mutex);\n  return result;\n}", "CodeBleu_score": 43.777342368987426}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG\n  printf(\"wb_accelerometer_get_sampling_period(%d)\n\", tag);\n#endif\n  int result;\n  WbDevice *device = get_device_from_tag(tag);\n  if (device) {\n    pthread_mutex_lock(&device->mutex);\n    if (device->type == WB_NODE_ACCELEROMETER) {\n      result = ((WbAccelerometer *)device->pdata)->sampling_period;\n    } else {\n      fprintf(stderr, \"Error: %s(): device tag %d does not refer to an accelerometer.\n\", __FUNCTION__, tag);\n      result = -1;\n    }\n    pthread_mutex_unlock(&device->mutex);\n  } else {\n    fprintf(stderr, \"Error: %s(): device tag %d does not refer to a valid device.\n\", __FUNCTION__, tag);\n    result = -1;\n  }\n  return result;\n}", "CodeBleu_score": 42.65012362269201}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\t#ifdef DEBUG_MODE\n  printf(\"wb_accelerometer_get_sampling_period(%d)\n\", tag);\n#endif\n  int result = 0;\n  pthread_mutex_lock(&mutex_accelerometer);\n  WbDevice *d = get_device(tag);\n  if (d) {\n    WbAccelerometer *a = d->pdata;\n    if (a)\n      result = a->sampling_period;\n    else\n      fprintf(stderr, \"Error: %s() called on a non accelerometer device tag.\n\", __FUNCTION__);\n  } else\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\n\", __FUNCTION__);\n  pthread_mutex_unlock(&mutex_accelerometer);\n  return result;\n}", "CodeBleu_score": 48.639807044202186}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar* degreesMinutesSeconds = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = string(degreesMinutesSeconds);\n\tfree(degreesMinutesSeconds);\n\treturn result;\n}", "CodeBleu_score": 46.43170281290807}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dmsString;\n\tdmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms(dmsString);\n\tfree(dmsString);\n\treturn dms;\n}", "CodeBleu_score": 44.00177861523308}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\t\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring result = string(dms);\n\tfree(dms);\n\treturn result;\n}", "CodeBleu_score": 43.64100316504131}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\t", "CodeBleu_score": 1.2608392870836123}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box->body, \"dxBox has no body\");\n\tdUASSERT (flags >= 0, \"Invalid flags\");\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\treturn dImmerseBoxInternal (box, fluidPlane, flags, &data);\n}", "CodeBleu_score": 50.01009729504905}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdUASSERT (box->body, \"dxBox has no body\");\n\tdUASSERT (flags >= 0 && flags < 32, \"invalid flags\");\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\treturn dBoxImmersion (&data);\n}", "CodeBleu_score": 50.215748467921294}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t\tdAASSERT (box);\n\tdAASSERT (fluidPlane);\n\tdAASSERT (flags >= 0);\n\tdAASSERT (flags < 32);\n\tdAASSERT (immersion);\n\n\tsBoxImmersionData data;\n\tdata.box = box;\n\tdata.fluidPlane = fluidPlane;\n\tdata.flags = flags;\n\tdata.immersion = immersion;\n\n\treturn dImmerse (box->geom.gflags, &data, &dImmerseBoxCallback);\n}", "CodeBleu_score": 43.77317094492425}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsBoxImmersionData data((dxBox*)o1, (dxCapsule*)o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 34.39601600145932}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t", "CodeBleu_score": 3.4828458572712746}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsBoxCapsuleImmersionData data(o1, o2, immersion, flags);\n\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 27.17834577281052}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\t", "CodeBleu_score": 7.098796311631135}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t", "CodeBleu_score": 8.378651108572473}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n\tsCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 25.230309501955507}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body && o2->body, \"Both objects must have a body\");\n\n\tsCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 27.983793016248182}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\t\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\tdUASSERT (o1->body, \"The first capsule has no body and hence cannot be tested for immersion into a fluid\");\n\tdUASSERT (o2->type == dTriMeshClass, \"The second object is not a trimesh\");\n\n\tsCapsuleTrimeshImmersionData data(o1, o2, flags, immersion);\n\treturn data.performImmersionChecking();\n}", "CodeBleu_score": 33.472755720068335}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\t\t// retrieve the sleep duration from the input\n\tint64_t duration_ms;\n\tif (!getInput(\"duration_ms\", duration_ms)) {\n\t\treturn SUCCESS;\n\t}\n\n\t// if the duration is missing or non-positive, return SUCCESS\n\tif (duration_ms <= 0) {\n\t\treturn SUCCESS;\n\t}\n\n\t// set the node status to RUNNING\n\tsetStatus(RUNNING);\n\n\t// start a timer and set a callback to emit a wake-up signal when the timer expires\n\ttimer_waiting_ = true;\n\ttimer_.start(duration_ms, [this]() {\n\t\tif (timer_waiting_) {\n\t\t\ttimer_waiting_ = false;\n\t\t\temitWakeUpSignal();\n\t\t}\n\t});\n\n\t// if the timer is aborted, ensure the timer_waiting_ flag is reset\n\ttimer_.onAborted([this]() {\n\t\tif (timer_waiting_) {\n\t\t\ttimer_waiting_ = false;\n\t\t}\n\t});\n\n\treturn RUNNING;\n}", "CodeBleu_score": 46.85211874237223}, {"code": "NodeStatus SleepNode::onStart(){\n\t\t// retrieve the sleep duration from the input\n\tdouble duration = input<double>(\"duration\");\n\tif (duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\t// start a timer\n\ttimer_ = std::make_unique<Timer>(duration, false);\n\ttimer_->start();\n\t// set a callback to emit a wake-up signal when the timer expires\n\ttimer_->setCallback(std::bind(&SleepNode::onWakeUp, this));\n\t// set the timer_waiting_ flag\n\ttimer_waiting_ = true;\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 40.47703695071093}, {"code": "NodeStatus SleepNode::onStart(){\n\t\tif (input_port_0_buffer_.size() == 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\tif (input_port_0_buffer_[0] <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\tstatus_ = NodeStatus::RUNNING;\n\ttimer_waiting_ = true;\n\ttimer_ = std::make_unique<Timer>(input_port_0_buffer_[0], [this]() {\n\t\ttimer_waiting_ = false;\n\t\temitWakeUpSignal();\n\t});\n\ttimer_->start();\n\treturn NodeStatus::RUNNING;\n}", "CodeBleu_score": 42.67764392725329}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\tif (blackboard->isEntryRegistered(key)) {\n\t\tblackboard->lock(key);\n\t\tif (blackboard->getSequenceID(key)!= sequenceID) {\n\t\t\tsequenceID = blackboard->getSequenceID(key);\n\t\t\tblackboard->unlock(key);\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t\tblackboard->unlock(key);\n\t}\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 31.26755033346196}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Retrieve the entry and lock its mutex.\n\tEntry* entry = blackboard->getEntry(entry_name);\n\tif (entry == NULL) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\tentry->lock();\n\n\t// Check if the sequence ID has changed.\n\tif (entry->getSequenceID()!= sequence_id) {\n\t\tsequence_id = entry->getSequenceID();\n\t\tentry->unlock();\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// The sequence ID hasn't changed.\n\tentry->unlock();\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 36.13476573986802}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\t\t// Check if the entry is found\n\tif (blackboard->isEntryFound(entryName)) {\n\t\t// Retrieve the entry\n\t\tEntry* entry = blackboard->getEntry(entryName);\n\n\t\t// Lock the entry's mutex\n\t\tentry->lock();\n\n\t\t// Check if the sequence ID has changed\n\t\tif (entry->getSequenceID()!= sequenceID) {\n\t\t\t// Update the stored sequence ID\n\t\t\tsequenceID = entry->getSequenceID();\n\n\t\t\t// Unlock the entry's mutex\n\t\t\tentry->unlock();\n\n\t\t\t// Return success\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\n\t\t// Unlock the entry's mutex\n\t\tentry->unlock();\n\t}\n\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 34.19129749163922}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\t\tsize_t threshold = this->successThreshold_;\n\tif (threshold < 0) {\n\t\tthreshold = this->children_.size() + threshold;\n\t\tif (threshold < 0) {\n\t\t\tthreshold = 0;\n\t\t}\n\t}\n\treturn threshold;\n}", "CodeBleu_score": 43.356183471362066}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_successThreshold < 0) {\n\t\treturn (size_t) (m_children.size() + m_successThreshold);\n\t}\n\treturn m_successThreshold;\n}", "CodeBleu_score": 47.39663009106254}, {"code": "size_t ParallelNode::successThreshold() const{\n\t\tif (m_successThreshold < 0) {\n\t\treturn static_cast<size_t>(m_successThreshold * -1) * m_children.size();\n\t}\n\treturn static_cast<size_t>(m_successThreshold);\n}", "CodeBleu_score": 49.871543261066044}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif (_p->heartbeat_time.time_since_epoch().count() == 0) {\n\t\t\t// no heartbeat received yet\n\t\t\tlk.unlock();\n\t\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\t\tcontinue;\n\t\t}\n\t\tauto now = std::chrono::system_clock::now();\n\t\tif (now - _p->heartbeat_time > std::chrono::seconds(2)) {\n\t\t\t// heartbeat timed out\n\t\t\t_p->heartbeat_time = std::chrono::system_clock::time_point();\n\t\t\t_p->enableAllHooks(false);\n\t\t} else {\n\t\t\t_p->enableAllHooks(true);\n\t\t}\n\t\tlk.unlock();\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t}\n}", "CodeBleu_score": 44.56475876765251}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tauto now = std::chrono::system_clock::now();\n\t\tstd::unique_lock<std::mutex> lk(_p->heartbeat_mutex);\n\t\tif (now - _p->last_heartbeat > _p->heartbeat_timeout) {\n\t\t\t_p->heartbeat_active = false;\n\t\t\tenableAllHooks(false);\n\t\t} else {\n\t\t\t_p->heartbeat_active = true;\n\t\t\tenableAllHooks(true);\n\t\t}\n\t}\n}", "CodeBleu_score": 49.56839713745939}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (_p->heartbeat_active) {\n\t\t\tif (std::chrono::steady_clock::now() - _p->last_heartbeat > std::chrono::seconds(1)) {\n\t\t\t\t_p->heartbeat_active = false;\n\t\t\t\tenableAllHooks(false);\n\t\t\t}\n\t\t} else {\n\t\t\tif (std::chrono::steady_clock::now() - _p->last_heartbeat <= std::chrono::seconds(1)) {\n\t\t\t\t_p->heartbeat_active = true;\n\t\t\t\tenableAllHooks(true);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 45.83032003050283}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Split the input string of blackboard names\n\tstd::vector<std::string> blackboard_names = splitString(bb_list, ',');\n\n\t// Initialize the JSON object\n\tjson dump;\n\n\t// Iterate through the blackboard names\n\tfor (const std::string& blackboard_name : blackboard_names) {\n\t\t// Find the corresponding subtree\n\t\tconst auto& subtree = m_blackboard->findSubtree(blackboard_name);\n\n\t\t// Check if the subtree is valid\n\t\tif (subtree.isValid()) {\n\t\t\t// Lock the subtree\n\t\t\tsubtree->lock();\n\n\t\t\t// Export the blackboard to JSON\n\t\t\tdump[blackboard_name] = subtree->to_json();\n\n\t\t\t// Unlock the subtree\n\t\t\tsubtree->unlock();\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\tstd::vector<uint8_t> messagepack_dump = json::to_msgpack(dump);\n\n\treturn messagepack_dump;\n}", "CodeBleu_score": 42.15821381870999}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\tstd::vector<uint8_t> dump;\n\tstd::vector<std::string> bb_names;\n\tboost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\tfor (const auto& bb_name : bb_names) {\n\t\tauto subtree = groot_tree->getSubTree(bb_name);\n\t\tif (subtree) {\n\t\t\tsubtree->lock();\n\t\t\tauto json = subtree->exportToJSON();\n\t\t\tsubtree->unlock();\n\t\t\tdump.insert(dump.end(), json.begin(), json.end());\n\t\t}\n\t}\n\treturn dump;\n}", "CodeBleu_score": 42.58685320933533}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t\t// Split the input string into a vector of strings using the ',' delimiter\n\tstd::vector<std::string> blackboard_names = splitString(bb_list, ',');\n\n\t// Initialize the JSON object\n\tjson json_dump;\n\n\t// Iterate through each blackboard name\n\tfor (const auto& blackboard_name : blackboard_names) {\n\t\t// Find the corresponding subtree\n\t\tauto subtree = m_blackboard->findSubtree(blackboard_name);\n\n\t\t// Lock the subtree\n\t\tif (subtree) {\n\t\t\t// Export the blackboard to JSON\n\t\t\tjson_dump[blackboard_name] = subtree->to_json();\n\t\t}\n\t}\n\n\t// Convert the JSON object to MessagePack format\n\tstd::vector<uint8_t> messagepack_dump;\n\tjson_dump.dump_binary(messagepack_dump);\n\n\t// Return the MessagePack dump\n\treturn messagepack_dump;\n}", "CodeBleu_score": 41.28012855588056}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tifdef GROOT_DEBUG\n  std::cout << \"Groot2Publisher::unlockBreakpoint(\" << pos << \", \" << node_uid << \", \" << result\n            << \", \" << remove << \")\" << std::endl;\n#endif\n\n  auto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n\n  std::unique_lock<std::mutex> lk(*hook->mutex);\n  if(hook->mode == Monitor::Hook::Mode::BREAKPOINT)\n  {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n  }\n  return true;\n}", "CodeBleu_score": 55.43851965177923}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto bk_it = hooks->find(node_uid);\n\tif (bk_it == hooks->end()) {\n\t\treturn false;\n\t}\n\tauto &hook = bk_it->second;\n\tstd::unique_lock<std::mutex> lk2(hook->mutex);\n\tif (hook->status!= HookStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = HookStatus::READY;\n\thook->result = result;\n\thook->remove = remove;\n\thook->cv.notify_all();\n\treturn true;\n}", "CodeBleu_score": 52.857063824725515}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hooks = pos == Position::PRE? &_p->pre_hooks : &_p->post_hooks;\n\tstd::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n\tauto bk_it = hooks->find(node_uid);\n\tif (bk_it == hooks->end()) {\n\t\treturn false;\n\t}\n\tauto &hook = bk_it->second;\n\tstd::unique_lock<std::mutex> hook_lk(hook->mutex);\n\tif (hook->status!= HookStatus::BREAKPOINT) {\n\t\treturn false;\n\t}\n\thook->status = HookStatus::READY;\n\thook->result = result;\n\thook->remove = remove;\n\thook->cv.notify_all();\n\treturn true;\n}", "CodeBleu_score": 52.94160533204955}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tauto tick_functor = [this]() {\n\t\t\ttry {\n\t\t\t\ttick();\n\t\t\t} catch (...) {\n\t\t\t\t// Catch all exceptions and store them\n\t\t\t\ttry {\n\t\t\t\t\tstd::rethrow_exception(std::current_exception());\n\t\t\t\t} catch (const std::exception& e) {\n\t\t\t\t\tLOG_ERROR << \"Exception in ThreadedAction: \" << e.what();\n\t\t\t\t} catch (...) {\n\t\t\t\t\tLOG_ERROR << \"Unknown exception in ThreadedAction\";\n\t\t\t\t}\n\t\t\t\t// Make sure to set the status to IDLE\n\t\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t\t}\n\t\t};\n\t\tthread_ = std::thread(tick_functor);\n\t}\n\n\t// Check if the thread is still running\n\tif (thread_.joinable()) {\n\t\tthread_.join();\n\t}\n\n\t// Check if the thread has thrown an exception\n\tif (thread_exception_) {\n\t\tstd::rethrow_exception(thread_exception_);\n\t}\n\n\t// Update the node status\n\tNodeStatus status = status();\n\tif (status!= prev_status) {\n\t\tsetStatus(status);\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 46.365743358309345}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tthread_ = std::thread(&ThreadedAction::tick, this);\n\t}\n\n\tif (thread_.joinable()) {\n\t\tthread_.join();\n\t}\n\n\tNodeStatus status = status();\n\tif (status!= prev_status) {\n\t\tsetStatus(status);\n\t}\n\n\tif (exception_) {\n\t\ttry {\n\t\t\tstd::rethrow_exception(exception_);\n\t\t} catch (const std::exception& e) {\n\t\t\tLOG_ERROR_STREAM(\"Exception in ThreadedAction: \" << e.what());\n\t\t\tsetStatus(NodeStatus::IDLE);\n\t\t}\n\t}\n\n\treturn status;\n}", "CodeBleu_score": 43.310078415853624}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n\tif (prev_status == NodeStatus::IDLE) {\n\t\tsetStatus(NodeStatus::RUNNING);\n\t\tprev_status = NodeStatus::RUNNING;\n\t}\n\n\thalt_requested_ = false;\n\n\ttry {\n\t\tstd::future<NodeStatus> status_future = std::async(std::launch::async, &BT::ThreadedAction::tick, this);\n\t\tNodeStatus status = status_future.get();\n\n\t\tif (status!= prev_status) {\n\t\t\tsetStatus(status);\n\t\t}\n\t} catch (const std::exception& e) {\n\t\tLOG_ERROR_STREAM(e.what());\n\t\tsetStatus(NodeStatus::IDLE);\n\t}\n\n\tif (stored_exception_) {\n\t\tstd::rethrow_exception(stored_exception_);\n\t}\n\n\treturn status();\n}", "CodeBleu_score": 43.44141375129442}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"========================================================================\n\";\n\tauto print_node = [&](const TreeNode* node) {\n\t\tfor (int i = 0; i < node->getDepth(); i++) {\n\t\t\tstream << \"  \";\n\t\t}\n\t\tstream << node->getName() << std::endl;\n\t\tif (node->isControlNode()) {\n\t\t\tfor (auto child : node->getChildren()) {\n\t\t\t\tprint_node(child);\n\t\t\t}\n\t\t} else if (node->isDecoratorNode()) {\n\t\t\tprint_node(node->getChild());\n\t\t}\n\t};\n\tprint_node(root_node);\n\tstream << \"========================================================================\n\";\n}", "CodeBleu_score": 34.37674734624076}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t\tstream << \"-----------------------------\" << std::endl;\n\tauto print = [&stream](const TreeNode* node, int depth) {\n\t\tif (node == nullptr) return;\n\t\tfor (int i = 0; i < depth; ++i) stream << \"  \";\n\t\tstream << node->getName() << std::endl;\n\t\tif (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n\t\t\tfor (const auto& child : control_node->getChildren()) {\n\t\t\t\tprint(child, depth + 1);\n\t\t\t}\n\t\t} else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n\t\t\tprint(decorator_node->getChild(), depth + 1);\n\t\t}\n\t};\n\tprint(root_node, 0);\n\tstream << \"-----------------------------\" << std::endl;\n}", "CodeBleu_score": 49.442053470462334}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\t", "CodeBleu_score": 3.8194029341999376}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.54280928346758}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t} else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.54280928346758}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\t\tif (!node) {\n\t\tthrow LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n\t}\n\n\tvisitor(node);\n\n\tif (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n\t\tfor (const auto& child : control->children()) {\n\t\t\tapplyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n\t\t}\n\t}\n\telse if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n\t\tapplyRecursiveVisitor(decorator->child(), visitor);\n\t}\n}", "CodeBleu_score": 90.51781904209018}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_ID)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"Trying to register a builder with an already registered ID\");\n\t}\n\n\tbuilders_[manifest.registration_ID] = builder;\n\tmanifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 42.38633322429642}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.find(manifest.registration_ID)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder: \"\n\t\t                            \"registration ID already exists\");\n\t}\n\tbuilders_[manifest.registration_ID] = builder;\n\tmanifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 43.29183157622661}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\t\tif (builders_.count(manifest.registration_ID)!= 0) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"Trying to register a new builder with an ID that is already registered\");\n\t}\n\tbuilders_[manifest.registration_ID] = builder;\n\tmanifests_[manifest.registration_ID] = manifest;\n}", "CodeBleu_score": 42.15471093719434}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tif defined(BT_DEBUG_LOG)\n  std::cout << \"Registering action: \" << ID << std::endl;\n#endif\n\n  auto builder = [tick_functor](TreeNodeConfig config) {\n    return std::make_unique<SimpleActionNode>(config, tick_functor);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.registration_ID = ID;\n  manifest.type = TreeNodeType::ACTION;\n  manifest.ports = std::move(ports);\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 53.76300380566653}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\t//  BehaviorTreeFactory::registerSimpleAction(const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor, PortsList ports)\n  auto builder = [tick_functor](const std::string& ID,\n                                const NodeConfig& config) -> Node::Ptr {\n    return std::make_unique<SimpleActionNode>(ID, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest(ID, \"SimpleActionNode\", ports);\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 63.576750536784324}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tifdef BT_DEBUG_MODE\n  if(ID.empty())\n  {\n    throw BehaviorTreeException(\"Empty ID\");\n  }\n#endif\n\n  auto builder = [tick_functor](const TreeNodeConfig& config) -> TreeNode::Ptr {\n    return std::make_unique<SimpleActionNode>(config.blackboard, tick_functor,\n                                              config.ports);\n  };\n\n  TreeNodeManifest manifest(ID, TreeNodeManifest::NodeType::ACTION, ports);\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 52.26786817080953}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetSubtrees().size());\n\tfor (const auto& subtree : tree.GetSubtrees()) {\n\t\tbackups.push_back(Blackboard::Create());\n\t\tbackups.back()->Clone(*subtree->GetBlackboard());\n\t}\n\treturn backups;\n}", "CodeBleu_score": 56.9229762829669}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.GetSubtrees().size());\n\tfor (const auto& subtree : tree.GetSubtrees()) {\n\t\tbackups.emplace_back(subtree->GetBlackboard()->Clone());\n\t}\n\treturn backups;\n}", "CodeBleu_score": 52.56494203138554}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\t\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees.size());\n\n\tfor (const auto& subtree : tree.subtrees) {\n\t\tBlackboard::Ptr backup = Blackboard::Create();\n\t\tbackup->Clone(*subtree->blackboard);\n\t\tbackups.push_back(backup);\n\t}\n\n\treturn backups;\n}", "CodeBleu_score": 56.972025252307304}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor.has_value()) {\n\t\ttry {\n\t\t\treturn executor.value()(env);\n\t\t} catch(RuntimeError& err) {\n\t\t\treturn nonstd::make_unexpected(err.what());\n\t\t}\n\t} else {\n\t\treturn executor;\n\t}\n}", "CodeBleu_score": 74.91777103134419}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor)\n\t{\n\t\treturn (*executor)(env);\n\t}\n\telse\n\t{\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 81.61885481789363}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\t\tauto executor = ParseScript(script);\n\tif(executor.has_value())\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn executor.value()(env);\n\t\t}\n\t\tcatch(RuntimeError& err)\n\t\t{\n\t\t\treturn nonstd::make_unexpected(err.what());\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}", "CodeBleu_score": 77.97057105545339}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (handle_!= nullptr) {\n\t\tthrow RuntimeError(\"Shared library already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle_ == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tpath_ = path;\n}", "CodeBleu_score": 46.61983151096919}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (handle) {\n\t\tthrow RuntimeError(\"Shared library already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tthis->path = path;\n}", "CodeBleu_score": 48.006566905066414}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\t\tstd::unique_lock<std::mutex> lock(mutex_);\n\tif (handle_!= nullptr) {\n\t\tthrow RuntimeError(\"Shared library is already loaded\");\n\t}\n\thandle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle_ == nullptr) {\n\t\tthrow RuntimeError(\"Failed to load shared library: \" + std::string(dlerror()));\n\t}\n\tpath_ = path;\n}", "CodeBleu_score": 49.732956354453506}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.length() < 3)\n\t\treturn false;\n\n\tauto stripped = str.strip();\n\tif (stripped.length() < 3)\n\t\treturn false;\n\n\tif (stripped[0]!= '{' || stripped[stripped.length() - 1]!= '}')\n\t\treturn false;\n\n\tif (stripped_pointer)\n\t\t*stripped_pointer = stripped.substr(1, stripped.length() - 2);\n\n\treturn true;\n}", "CodeBleu_score": 22.218068768756858}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.length() < 3) return false;\n\tstr = str.trim();\n\tif (str.startsWith(\"{\") && str.endsWith(\"}\")) {\n\t\tif (stripped_pointer!= nullptr) {\n\t\t\t*stripped_pointer = str.substr(1, str.length() - 2);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 18.626525063405577}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\t\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\n\tstr = str.trim_edges();\n\n\tif (str.starts_with('{') && str.ends_with('}')) {\n\t\tif (stripped_pointer) {\n\t\t\t*stripped_pointer = str.substr(1, str.length() - 2);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 21.84587529872248}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (unsigned int i = 0; i < line.num_steps_; ++i, ++line) {\n\t\tdouble point_cost = pointCost(line.x_, line.y_);\n\t\tif (point_cost < 0)\n\t\t\treturn point_cost;\n\t\tline_cost = std::max(line_cost, point_cost);\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 53.35226555001309}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (LineIterator it = line; it!= line.end(); ++it) {\n\t\tdouble point_cost = pointCost(it->x, it->y);\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\tif (point_cost > line_cost) {\n\t\t\tline_cost = point_cost;\n\t\t}\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 59.458036866408314}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\t\tdouble line_cost = 0.0;\n\tLineIterator line(costmap_, x0, y0, x1, y1);\n\tfor (LineIterator it = line; it!= line.end(); ++it) {\n\t\tdouble point_cost = pointCost(it.getX(), it.getY());\n\t\tif (point_cost < 0)\n\t\t\treturn point_cost;\n\t\tif (point_cost > line_cost)\n\t\t\tline_cost = point_cost;\n\t}\n\treturn line_cost;\n}", "CodeBleu_score": 64.06729236931471}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\t\tif (!path.empty()) {\n\t\tnav_msgs::Path gui_path;\n\t\tgui_path.poses.resize(path.size());\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\n\t\t// Extract the plan in world for visualization purposes\n\t\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\t\tgui_path.poses[i] = path[i];\n\t\t}\n\t\tpub.publish(gui_path);\n\t}\n}", "CodeBleu_score": 83.04198294017864}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (base_odom.twist.twist.angular.x <= rot_stopped_velocity && base_odom.twist.twist.angular.y <= rot_stopped_velocity && base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity && base_odom.twist.twist.linear.y <= trans_stopped_velocity && base_odom.twist.twist.linear.z <= trans_stopped_velocity);\n}", "CodeBleu_score": 49.798239171717356}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\treturn (base_odom.twist.twist.angular.x <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.angular.y <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.angular.z <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.y <= trans_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.z <= trans_stopped_velocity);\n}", "CodeBleu_score": 49.210375875729504}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t\tif (base_odom.twist.twist.angular.x <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.angular.y <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.angular.z <= rot_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.y <= trans_stopped_velocity &&\n\t\t\tbase_odom.twist.twist.linear.z <= trans_stopped_velocity) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 48.264297041215954}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif(restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tsetup_ = false;\n\t}\n\n\tif(!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tconfig_mutex_.lock();\n\tlimits_ = config;\n\tconfig_mutex_.unlock();\n}", "CodeBleu_score": 62.16922755189487}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t", "CodeBleu_score": 4.618232570056105}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\t\tif (setup_ && restore_defaults) {\n\t\tconfig = default_limits_;\n\t\tsetup_ = false;\n\t}\n\n\tif (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\n\tboost::mutex::scoped_lock l(configuration_mutex_);\n\tlimits_ = config;\n}", "CodeBleu_score": 75.33583218199658}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Get the cost of the cell\n\tunsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n\t// Check if the cell is an obstacle or has no information\n\tif (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n\t\t// Set the cell's target distance to the maximum obstacle cost and return false\n\t\tcheck_cell->target_distance = costmap_2d::LETHAL_OBSTACLE;\n\t\treturn false;\n\t}\n\t// If the cell is not an obstacle, calculate a new target distance and update the cell's target distance if the new distance is shorter\n\tdouble new_distance = current_cell->target_distance + sqrt(pow(current_cell->x - check_cell->x, 2) + pow(current_cell->y - check_cell->y, 2));\n\tif (new_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_distance;\n\t}\n\t// Return true\n\treturn true;\n}", "CodeBleu_score": 63.677352198455104}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t\t// Check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->getX(), check_cell->getY()) == costmap_2d::NO_INFORMATION || costmap.getCost(check_cell->getX(), check_cell->getY()) == costmap_2d::LETHAL_OBSTACLE) {\n\t\t// Set the target distance to the maximum obstacle cost and return false\n\t\tcheck_cell->setTargetDistance(costmap_2d::LETHAL_OBSTACLE);\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance\n\tdouble new_target_distance = current_cell->getTargetDistance() + current_cell->getCost();\n\n\t// Update the cell's target distance if the new distance is shorter\n\tif (new_target_distance < check_cell->getTargetDistance()) {\n\t\tcheck_cell->setTargetDistance(new_target_distance);\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 51.81685273221134}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t", "CodeBleu_score": 6.181338956123423}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//the trajectory must be legal...\n\tif (!traj.cost_ || traj.xv_ == 0.0 || traj.yv_ == 0.0) {\n\t\treturn -9.0;\n\t}\n\n\t//we want to scale the robot's footprint by a factor based on its velocity\n\tdouble scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n\t//we'll make sure that we update the world model with the most recent obstacle information\n\t//if the world model is a costmap model, we'll need to update it\n\tif (world_model_type_ == \"costmap\") {\n\t\tcostmap_model_->updateWithTrueObstacles(costmap_, robot_inflation_radius_);\n\t}\n\n\tdouble cost = 0.0;\n\t//we'll iterate through each point on the trajectory and add costs for that cell\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\t//check the legality of the point\n\t\tdouble footprint_cost = footprintCost(traj.xv_, traj.yv_, traj.thetap_, scale, footprint_spec_, costmap_, world_model_);\n\n\t\t//if the footprint hits an obstacle this will return -ve\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 53.58647714048872}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//the trajectory must be legal...\n\tif (!traj.legal_) {\n\t\treturn -1.0;\n\t}\n\n\tdouble cost = 0.0;\n\tdouble scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\tif (footprint_spec_.size() == 0) {\n\t\tROS_ERROR(\"No footprint points provided for costmap obstacle model\");\n\t\treturn -9.0;\n\t}\n\n\tfor (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n\t\tdouble px, py, pth;\n\t\ttraj.getPoint(i, px, py, pth);\n\t\tdouble footprint_cost = footprintCost(px, py, pth, scale, footprint_spec_, costmap_, world_model_);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost;\n\t\t} else {\n\t\t\tcost = std::max(cost, footprint_cost);\n\t\t}\n\t}\n\n\treturn cost;\n}", "CodeBleu_score": 75.82101021212118}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t", "CodeBleu_score": 2.4783660178912723}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t", "CodeBleu_score": 8.44058203738115}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"The obstacle cost function has not been initialized, please call initialize before using this planner\");\n\t\treturn -1.0;\n\t}\n\n\t//if we have no footprint... do nothing\n\tif (footprint_spec.size() < 3) {\n\t\treturn -1.0;\n\t}\n\n\t//build the oriented footprint\n\tstd::vector<geometry_msgs::Point> oriented_footprint = footprint_spec;\n\ttransformFootprint(x, y, th, oriented_footprint);\n\n\t//we need to loop through the points on the oriented footprint... we'll add them to\n\t//the cell cost if they are in range\n\tdouble footprint_cost = 0.0;\n\tdouble point_x;\n\tdouble point_y;\n\tfor (unsigned int i = 0; i < oriented_footprint.size(); ++i) {\n\t\t//check the point is inside the map\n\t\tif (costmap->worldToMap(oriented_footprint[i].x, oriented_footprint[i].y, point_x, point_y)) {\n\t\t\tdouble cost = world_model->footprintCost(point_x, point_y, oriented_footprint, costmap);\n\t\t\tif (cost < 0) {\n\t\t\t\treturn -6.0;\n\t\t\t}\n\t\t\tfootprint_cost += cost;\n\t\t}\n\t\telse {\n\t\t\treturn -7.0;\n\t\t}\n\t}\n\n\t//return the cost between 0 and max_obstacle_cost\n\tif (footprint_cost < 0) {\n\t\treturn 0.0;\n\t}\n\telse {\n\t\treturn std::min(footprint_cost, max_obstacle_cost_);\n\t}\n}", "CodeBleu_score": 52.801286941542756}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t\n//  ROS_INFO(\"ObstacleCostFunction::footprintCost\");\n\n  //check if the footprint is legal\n  if (!costmap->footprintCost(x, y, th, footprint_spec, inscribed_radius_, circumscribed_radius_)) {\n    return -1.0;\n  }\n\n  //check if the position is off the map\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -1.0;\n  }\n\n  //check if the position is in an obstacle\n  double cost = world_model->footprintCost(x, y, th, footprint_spec, costmap);\n\n  if (cost < 0) {\n    return -6.0;\n  }\n\n  return std::max(cost, costmap->getCost(mx, my));\n}", "CodeBleu_score": 42.48591199739991}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Setting new odometry topic to: %s\", odom_topic.c_str());\n  if (odom_topic!= odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_.shutdown();\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic_, 1,\n          boost::bind(&OdometryHelperRos::odomCallback, this, _1));\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 53.26417958200261}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_INFO_NAMED(\"dwa_local_planner\", \"Setting the odometry topic to: %s\", odom_topic.c_str());\n  if (odom_topic_!= odom_topic) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 48.684102553091805}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\t//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"Setting the odometry topic to: %s\", odom_topic.c_str());\n  if (odom_topic!= odom_topic_) {\n    if (!odom_topic_.empty()) {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Shutting down odometry subscription.\");\n      odom_sub_.shutdown();\n    }\n\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      ROS_INFO_NAMED(\"dwa_local_planner\", \"Subscribing to odometry topic %s\", odom_topic_.c_str());\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n  }\n}", "CodeBleu_score": 42.90145506795423}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat sq_dist = (pos - prev).squaredNorm();\n\tfloat yaw_diff = fabs(angles::shortest_angular_distance(tf::getYaw(prev.cast<double>()), tf::getYaw(pos.cast<double>())));\n\n\tif (sq_dist > oscillation_reset_dist_ || yaw_diff > oscillation_reset_angle_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 40.603704189394676}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat sq_dist = (pos - prev).squaredNorm();\n\tfloat angle = fabs(angles::shortest_angular_distance(tf2::getYaw(prev.cast<double>()), tf2::getYaw(pos.cast<double>())));\n\n\tif (sq_dist > sq_dist_threshold_ || angle > angle_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 35.021039753568964}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\t\tfloat dx = pos[0] - prev[0];\n\tfloat dy = pos[1] - prev[1];\n\tfloat dt = std::sqrt(dx * dx + dy * dy);\n\n\tif (dt > oscillation_reset_dist_) {\n\t\tresetOscillationFlags();\n\t}\n\n\tfloat dp = std::abs(tf2::getYaw(pos) - tf2::getYaw(prev));\n\tif (dp > oscillation_reset_angle_) {\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 63.353788064706926}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//if the point is outside the grid bounds, return\n\tif (gx >= width_ || gy >= height_)\n\t\treturn;\n\n\t//if the point is too close to its nearest neighbor, return\n\tif (nearestNeighborDistance(pt) < sq_min_separation_)\n\t\treturn;\n\n\t//calculate the grid index\n\tunsigned int grid_index = gy * width_ + gx;\n\n\t//insert the point into the cell\n\tgrid_[grid_index].push_back(pt);\n}", "CodeBleu_score": 69.3529859100518}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//check if the point is too close to its nearest neighbor\n\tdouble neighbor_sq_dist = nearestNeighborDistance(pt);\n\tif(neighbor_sq_dist < sq_min_separation_){\n\t  return;\n\t}\n\n\t//calculate the grid index\n\tunsigned int grid_index = gx + gy * width_;\n\n\t//insert the point into the grid\n\tgrid_[grid_index].push_back(pt);\n}", "CodeBleu_score": 62.626145005395}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t\t//get the grid coordinates of the point\n\tunsigned int gx, gy;\n\n\tgridCoords(pt, gx, gy);\n\n\t//check if the point is in bounds\n\tif(gx < width_ && gy < height_){\n\t\t//check if the point is too close to its nearest neighbor\n\t\tdouble neighbor_sq_dist = nearestNeighborDistance(pt);\n\t\tif(neighbor_sq_dist > sq_min_separation_){\n\t\t\t//calculate the grid index\n\t\t\tunsigned int index = gx + gy * width_;\n\n\t\t\t//insert the point into the grid\n\t\t\tgrid_[index].push_back(pt);\n\t\t}\n\t}\n}", "CodeBleu_score": 59.069141399959015}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tdouble target_vel = sample_target_vel[i];\n\t\tdouble current_vel = vel[i];\n\t\tdouble acclimit = acclimits[i];\n\t\tif (current_vel < target_vel) {\n\t\t\tnew_vel[i] = std::min(current_vel + acclimit * dt, target_vel);\n\t\t} else if (current_vel > target_vel) {\n\t\t\tnew_vel[i] = std::max(current_vel - acclimit * dt, target_vel);\n\t\t} else {\n\t\t\tnew_vel[i] = current_vel;\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 59.41712069754723}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n\t\t} else {\n\t\t\tnew_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 75.16793421237837}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\t\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tnew_vel(i) = std::min(sample_target_vel(i), vel(i) + acclimits(i)*dt);\n\t\t} else {\n\t\t\tnew_vel(i) = std::max(sample_target_vel(i), vel(i) - acclimits(i)*dt);\n\t\t}\n\t}\n\treturn new_vel;\n}", "CodeBleu_score": 55.871143302596934}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble point_cost = -1;\n\tint closest_x = -1;\n\tint closest_y = -1;\n\n\t//Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\tpoint_cost = pointCost(global_plan[i].x, global_plan[i].y); //Score the current point\n\n\t\tif (point_cost >= 0) { //If the point is valid\n\t\t\tclosest_x = global_plan[i].x;\n\t\t\tclosest_y = global_plan[i].y;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (closest_x == -1 || closest_y == -1) { //If no valid point is found\n\t\treturn DBL_MAX;\n\t}\n\n\t//Convert the goal cell coordinates to world coordinates\n\tdouble goal_x = closest_x * costmap_->getResolution() + costmap_->getOriginX();\n\tdouble goal_y = closest_y * costmap_->getResolution() + costmap_->getOriginY();\n\n\t//Calculate the heading to the goal point\n\tdouble goal_heading = atan2(goal_y - y, goal_x - x);\n\n\t//Return the absolute value of the shortest angular distance between the current heading and the goal heading\n\treturn fabs(angles::shortest_angular_distance(heading, goal_heading));\n}", "CodeBleu_score": 48.545559183734554}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x, goal_y, goal_heading;\n\tdouble min_dist = DBL_MAX;\n\tdouble heading_diff = DBL_MAX;\n\tint i;\n\n\t//Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (i = global_plan.size() - 1; i >= 0; i--) {\n\t\t//Calculate the distance to the current point\n\t\tdouble dist = hypot(global_plan[i].x - cell_x, global_plan[i].y - cell_y);\n\t\t//If the distance is less than the minimum distance and the line of sight is clear\n\t\tif (dist < min_dist && lineCost(cell_x, global_plan[i].x, cell_y, global_plan[i].y) == 0) {\n\t\t\t//Save the current point as the goal point\n\t\t\tgoal_x = global_plan[i].x;\n\t\t\tgoal_y = global_plan[i].y;\n\t\t\tmin_dist = dist;\n\t\t}\n\t}\n\n\t//If a valid point is found\n\tif (min_dist!= DBL_MAX) {\n\t\t//Convert the goal cell coordinates to world coordinates\n\t\tgoal_x = costmap->getOriginX() + costmap->getResolution() * goal_x;\n\t\tgoal_y = costmap->getOriginY() + costmap->getResolution() * goal_y;\n\t\t//Calculate the heading to the goal point\n\t\tgoal_heading = atan2(goal_y - y, goal_x - x);\n\t\t//Calculate the shortest angular distance between the current heading and the goal heading\n\t\theading_diff = angles::shortest_angular_distance(heading, goal_heading);\n\t\t//Return the absolute value of the heading difference\n\t\treturn fabs(heading_diff);\n\t}\n\n\t//If no valid point is found, return DBL_MAX\n\treturn DBL_MAX;\n}", "CodeBleu_score": 48.15903535118202}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t\tdouble goal_x, goal_y, goal_heading;\n\n\t//Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\tgoal_x = global_plan_[i].x;\n\t\tgoal_y = global_plan_[i].y;\n\n\t\t//Check if the point is in the line of sight of the robot's current cell\n\t\tif (lineCost(cell_x, goal_x, cell_y, goal_y) < 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//Convert the goal cell coordinates to world coordinates\n\tgoal_x = costmap_->getOriginX() + goal_x * costmap_->getResolution();\n\tgoal_y = costmap_->getOriginY() + goal_y * costmap_->getResolution();\n\n\t//Calculate the direction to the goal point\n\tgoal_heading = atan2(goal_y - y, goal_x - x);\n\n\t//Return the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n\treturn fabs(angles::shortest_angular_distance(heading, goal_heading));\n}", "CodeBleu_score": 55.010688539406}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//    ROS_DEBUG(\"Checking trajectory with vx, vy, vtheta samp: %.2f, %.2f, %.2f\",\n//              vx_samp, vy_samp, vtheta_samp);\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n      ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, cost);\n      return false;\n    }\n\n    return true;\n  }", "CodeBleu_score": 86.58428229036441}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//    ROS_INFO(\"checkTrajectory: x=%f, y=%f, theta=%f, vx=%f, vy=%f, vtheta=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    Trajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if (t.cost_ >= 0) {\n      return true;\n    } else {\n      ROS_WARN(\"Invalid Trajectory x=%f, y=%f, theta=%f, vx=%f, vy=%f, vtheta=%f, vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\", x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp, t.cost_);\n      return false;\n    }\n  }", "CodeBleu_score": 59.53551556876893}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t//  ROS_DEBUG(\"checkTrajectory: x: %.2f, y: %.2f, theta: %.2f, vx: %.2f, vy: %.2f, vtheta: %.2f, vx_samp: %.2f, vy_samp: %.2f, vtheta_samp: %.2f\",\n//            x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN(\"Invalid Trajectory %f, %f, %f (cost %f)\", vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }\n  return true;\n}", "CodeBleu_score": 82.5927008287203}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tf(!initialized_){\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif(global_costmap_ == NULL || local_costmap_ == NULL){\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not clear costmaps.\");\n\t\treturn;\n\t}\n\n\tif(invert_area_to_clear_){\n\t\tROS_WARN(\"Clearing inside an area is not supported. Clearing outside the area instead.\");\n\t}\n\n\tif(affected_maps_ == BOTH){\n\t\tdouble start_time = ros::Time::now().toSec();\n\t\tclear(global_costmap_);\n\t\tdouble end_time = ros::Time::now().toSec();\n\t\tROS_INFO(\"Global costmap cleared in %.2f seconds\", end_time - start_time);\n\n\t\tstart_time = ros::Time::now().toSec();\n\t\tclear(local_costmap_);\n\t\tend_time = ros::Time::now().toSec();\n\t\tROS_INFO(\"Local costmap cleared in %.2f seconds\", end_time - start_time);\n\t}\n\telse if(affected_maps_ == LOCAL){\n\t\tdouble start_time = ros::Time::now().toSec();\n\t\tclear(local_costmap_);\n\t\tdouble end_time = ros::Time::now().toSec();\n\t\tROS_INFO(\"Local costmap cleared in %.2f seconds\", end_time - start_time);\n\t}\n\telse if(affected_maps_ == GLOBAL){\n\t\tdouble start_time = ros::Time::now().toSec();\n\t\tclear(global_costmap_);\n\t\tdouble end_time = ros::Time::now().toSec();\n\t\tROS_INFO(\"Global costmap cleared in %.2f seconds\", end_time - start_time);\n\t}\n\n\tif(force_update_){\n\t\tglobal_costmap_->updateMap();\n\t\tlocal_costmap_->updateMap();\n\t}\n}", "CodeBleu_score": 56.67516810678788}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The global costmap passed to the ClearCostmapRecovery object cannot be NULL. Do not set the global_costmap_param parameter.\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local costmap passed to the ClearCostmapRecovery object cannot be NULL. Do not set the local_costmap_param parameter.\");\n\t\treturn;\n\t}\n\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside the area specified\");\n\t} else {\n\t\tROS_WARN(\"Clearing inside the area specified\");\n\t}\n\n\tros::Time start = ros::Time::now();\n\n\tif (affected_maps_ & CLEAR_GLOBAL_MAP) {\n\t\tclearMap(global_costmap_, global_costmap_->getRobotPose().getOrigin().x(), global_costmap_->getRobotPose().getOrigin().y());\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap(global_costmap_->getRobotPose().getOrigin().x(), global_costmap_->getRobotPose().getOrigin().y());\n\t\t}\n\t}\n\n\tros::Time end = ros::Time::now();\n\tdouble global_costmap_time = (end - start).toSec();\n\n\tstart = ros::Time::now();\n\n\tif (affected_maps_ & CLEAR_LOCAL_MAP) {\n\t\tclearMap(local_costmap_, local_costmap_->getRobotPose().getOrigin().x(), local_costmap_->getRobotPose().getOrigin().y());\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap(local_costmap_->getRobotPose().getOrigin().x(), local_costmap_->getRobotPose().getOrigin().y());\n\t\t}\n\t}\n\n\tend = ros::Time::now();\n\tdouble local_costmap_time = (end - start).toSec();\n\n\tROS_INFO(\"Clearing costmap took %f seconds\", global_costmap_time + local_costmap_time);\n}", "CodeBleu_score": 48.51729405913676}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tf (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Do not clear the costs without a costmap.\");\n\t\treturn;\n\t}\n\n\tros::Time start = ros::Time::now();\n\n\t// check if we want to clear the area outside the robot's footprint\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing outside the robot's footprint. This behavior is deprecated. Please change invert_area_to_clear to false and update the clear_costmap_recovery.cpp file\");\n\t}\n\n\t// clear the costmap\n\tclear(global_costmap_);\n\tclear(local_costmap_);\n\n\t// if we're supposed to force a re-plan, do so\n\tif (force_replan_) {\n\t\tROS_WARN(\"Forcing a replan because we just cleared the costmap\");\n\t\tplanner_costmap_ros_->updateMap();\n\t}\n\n\tros::Time end = ros::Time::now();\n\n\tlast_run_ = end;\n\tlast_distance_traveled_ = distance_traveled_;\n\tdistance_traveled_ = 0.0;\n\n\t// log some information\n\tdouble secs = (end - start).toSec();\n\tROS_INFO(\"Clearing/resetting costmaps took %.2f seconds\", secs);\n}", "CodeBleu_score": 47.60050814156024}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\t// initialize the object to collect the cells\n\tPolygonOutlineCells collector(polygon_cells);\n\n\t// iterate through the polygon vertices\n\tfor (size_t i = 0; i < polygon.size() - 1; ++i) {\n\t\t// collect the cells between the consecutive points\n\t\traytraceLine(polygon[i], polygon[i + 1], collector);\n\t}\n\n\t// if the polygon is not empty, close it by connecting the last point to the first\n\tif (!polygon.empty()) {\n\t\traytraceLine(polygon.back(), polygon.front(), collector);\n\t}\n}", "CodeBleu_score": 42.3293061404553}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells collector(polygon_cells);\n\tif (!polygon.empty()) {\n\t\tfor (unsigned int i = 1; i < polygon.size(); ++i) {\n\t\t\traytraceLine(polygon[i - 1], polygon[i], collector);\n\t\t}\n\t\traytraceLine(polygon.back(), polygon.front(), collector);\n\t}\n}", "CodeBleu_score": 39.13275690603697}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t\tPolygonOutlineCells poc(polygon_cells);\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation p1 = polygon[i];\n\t\tMapLocation p2 = polygon[(i + 1) % polygon.size()];\n\t\traytraceLine(p1, p2, poc);\n\t}\n}", "CodeBleu_score": 35.61714820828452}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\t//ROS_INFO(\"onNewSubscription\");\n\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.90268748571795}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\t\tprepareGrid();\n\tpub.publish(grid_);\n}", "CodeBleu_score": 93.91395417007593}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tunsigned char* char_map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.data.size(); i++) {\n\t\tgrid_.data[i] = translation_table_[char_map[i]];\n\t}\n}", "CodeBleu_score": 71.16992534228064}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\t// Lock the costmap\n\tcostmap_ros_->getCostmap().getMutex().lock();\n\n\t// Get the resolution\n\tdouble resolution = costmap_ros_->getCostmap().getResolution();\n\n\t// Set the grid's header, resolution, width, and height\n\tgrid_.header = costmap_ros_->getCostmap().getHeader();\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_ros_->getCostmap().getSizeInCellsX();\n\tgrid_.info.height = costmap_ros_->getCostmap().getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tdouble wx, wy;\n\tcostmap_ros_->getCostmap().mapToWorld(0, 0, wx, wy);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = wx;\n\tgrid_.info.origin.position.y = wy;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = wx;\n\torigin_y_ = wy;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = costmap_to_markers_translation_table_[costmap_ros_->getCostmap().getCharMap()[i]];\n\t}\n\n\t// Unlock the costmap\n\tcostmap_ros_->getCostmap().getMutex().unlock();\n}", "CodeBleu_score": 61.99776166118009}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\tdouble resolution = costmap_->getResolution();\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = frame_id_;\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\tgrid_.info.origin.position.x = costmap_->getOriginX();\n\tgrid_.info.origin.position.y = costmap_->getOriginY();\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\tunsigned char* char_map = costmap_->getCharMap();\n\tfor (unsigned int i = 0; i < grid_.data.size(); ++i) {\n\t\tgrid_.data[i] = char_map_to_grid_[char_map[i]];\n\t}\n}", "CodeBleu_score": 67.57678596599233}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n\t\treturn;\n\t}\n\n\tif (!new_config.footprint.empty()) {\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (costmap_2d::convertToPoints(new_config.footprint, footprint)) {\n\t\t\tsetUnpaddedRobotFootprint(footprint);\n\t\t\treturn;\n\t\t} else {\n\t\t\tROS_ERROR(\"Failed to parse footprint, using default\");\n\t\t}\n\t}\n\n\tstd::vector<geometry_msgs::Point> new_footprint;\n\tif (costmap_2d::makeFootprintFromRadius(new_config.robot_radius, new_footprint)) {\n\t\tsetUnpaddedRobotFootprint(new_footprint);\n\t} else {\n\t\tROS_ERROR(\"Failed to create footprint, using default\");\n\t}\n}", "CodeBleu_score": 68.06653829918199}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\tif (new_config.footprint!= old_config.footprint || new_config.robot_radius!= old_config.robot_radius) {\n\t\tstd::vector<geometry_msgs::Point> new_footprint;\n\t\tif (costmap_2d::convertFootprintMsgToPoints(new_config.footprint, new_footprint)) {\n\t\t\tsetUnpaddedRobotFootprint(new_footprint);\n\t\t} else {\n\t\t\tROS_ERROR(\"Failed to parse footprint string \\\"%s\\\"\", new_config.footprint.c_str());\n\t\t}\n\t}\n}", "CodeBleu_score": 48.760778189659646}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t\n//  if (new_config.footprint!= old_config.footprint || new_config.robot_radius!= old_config.robot_radius) {\n//    std::vector<geometry_msgs::Point> new_footprint;\n//    if (costmap_2d::convertFootprintFromString(new_config.footprint, new_footprint)) {\n//      setUnpaddedRobotFootprint(new_footprint);\n//    } else {\n//      ROS_ERROR(\"Failed to parse footprint, using default\");\n//      setUnpaddedRobotFootprint(costmap_2d::Costmap2DROS::getDefaultRobotFootprint());\n//    }\n//  }\n}", "CodeBleu_score": 4.80081231526899}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped new_pose;\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN(\"Failed to get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\n\t// if we have a new pose, we need to reconfigure the costmap\n\tif (new_pose.header.stamp!= last_pose_stamp_) {\n\t\t// reconfigure costmap\n\t\treconfigureCB(reconfigure_server_->getConfig(), false);\n\n\t\t// update the pose time stamp\n\t\tlast_pose_stamp_ = new_pose.header.stamp;\n\t}\n}", "CodeBleu_score": 64.65437734048449}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t", "CodeBleu_score": 9.193132898790823}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t\tgeometry_msgs::PoseStamped new_pose;\n\tif (!getRobotPose(new_pose)) {\n\t\tROS_WARN_THROTTLE(1.0, \"Could not get robot pose, cancelling reconfiguration\");\n\t\treturn;\n\t}\n\t// make sure that the new pose is valid\n\tif (new_pose.header.frame_id!= global_frame_) {\n\t\tROS_ERROR(\"Received pose in frame %s, expected frame %s\", new_pose.header.frame_id.c_str(), global_frame_.c_str());\n\t\treturn;\n\t}\n\t// check if we've moved\n\tif (new_pose.pose.position.x!= last_pose_.pose.position.x || new_pose.pose.position.y!= last_pose_.pose.position.y || new_pose.pose.orientation.z!= last_pose_.pose.orientation.z || new_pose.pose.orientation.w!= last_pose_.pose.orientation.w) {\n\t\t// update the copy of the pose\n\t\tlast_pose_ = new_pose;\n\t\t// store the time\n\t\tlast_valid_pose_ = ros::Time::now();\n\t\t// if we're stopped, we want to clear the costmap because we have no knowledge of where the robot is and\n\t\t// we don't want to route around obstacles that we don't know exist\n\t\tif (stopped_) {\n\t\t\tresetLayers();\n\t\t}\n\t\t// if we're not stopped, we want to make sure that the costmap is re-published now that we have a valid pose\n\t\telse {\n\t\t\treconfigureCB(config_, level_);\n\t\t}\n\t}\n}", "CodeBleu_score": 71.9450472462247}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t\tif (!stopped_) return;\n\n\t// Activate plugins\n\tfor (unsigned int i = 0; i < plugins_.size(); ++i) {\n\t\tplugins_[i]->activate();\n\t}\n\tstopped_ = false;\n\n\t// Start the map update loop\n\tstop_updates_ = false;\n\tmap_update_thread_ = boost::shared_ptr<boost::thread>(new boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_frequency_)));\n}", "CodeBleu_score": 34.6655574052922}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tROS_DEBUG(\"Starting costmap\");\n\t\t// activate plugins\n\t\tstd::vector<boost::shared_ptr<Layer> > *plugins = layered_costmap_->getPlugins();\n\t\tfor (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin!= plugins->end(); ++plugin) {\n\t\t\t(*plugin)->activate();\n\t\t}\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\n\t\t// wait for costmap to be ready\n\t\tros::Rate r(100.0);\n\t\twhile (!layered_costmap_->isCurrent() && ros::ok()) {\n\t\t\tROS_DEBUG(\"Waiting for costmap to be ready...\");\n\t\t\tr.sleep();\n\t\t}\n\n\t\t// start the map update loop\n\t\tmap_update_thread_ = boost::shared_ptr<boost::thread>(new boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, frequency_)));\n\t}\n}", "CodeBleu_score": 65.91341694799607}, {"code": "void Costmap2DROS::start(){\n\t\tif (stopped_) {\n\t\tfor (unsigned int i = 0; i < plugins_.size(); i++) {\n\t\t\tplugins_[i]->activate();\n\t\t}\n\t\tstopped_ = false;\n\t\tstop_updates_ = false;\n\n\t\twhile (!ros::ok() ||!layered_costmap_->isSizeLocked()\n\t\t\t\t||!layered_costmap_->isInitialized()) {\n\t\t\tif (!ros::ok()) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS: ROS is not ok.\");\n\t\t\t} else if (!layered_costmap_->isInitialized()) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS: Layered costmap is not initialized.\");\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Costmap2DROS: Layered costmap size is locked.\");\n\t\t\t}\n\t\t\tusleep(100000);\n\t\t}\n\t}\n}", "CodeBleu_score": 40.58016512882835}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0) {\n\t\tobservation_list_.clear();\n\t\tobservation_list_.push_back(observation_);\n\t} else {\n\t\tstd::list<Observation>::iterator it = observation_list_.begin();\n\t\twhile (it!= observation_list_.end()) {\n\t\t\tif (observation_.time_ - it->time_ > observation_keep_time_) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.6611500767067}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0) {\n\t\tobservation_list_.clear();\n\t\treturn;\n\t}\n\n\tdouble oldest_valid_time = ros::Time::now().toSec() - observation_keep_time_;\n\n\t// Remove stale observations\n\tObservationList::iterator it = observation_list_.begin();\n\twhile (it!= observation_list_.end()) {\n\t\tif (it->time_ < oldest_valid_time) {\n\t\t\tit = observation_list_.erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 33.71054297519225}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\t\tif (observation_keep_time_ == 0) {\n\t\tif (observation_list_.size() > 1) {\n\t\t\tobservation_list_.erase(observation_list_.begin() + 1, observation_list_.end());\n\t\t}\n\t} else {\n\t\tfor (auto it = observation_list_.begin(); it!= observation_list_.end();) {\n\t\t\tif (it->observation_time_ < ros::Time::now() - observation_keep_time_) {\n\t\t\t\tit = observation_list_.erase(it);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.667543978590516}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\t// If the start and end indices are the same, return\n\tif (start_index == end_index) {\n\t\treturn;\n\t}\n\n\t// Get the start and end poses\n\tgeometry_msgs::PoseStamped start_pose = path[start_index];\n\tgeometry_msgs::PoseStamped end_pose = path[end_index];\n\n\t// Get the start and end angles\n\tdouble start_angle = get_angle(&start_pose);\n\tdouble end_angle = get_angle(&end_pose);\n\n\t// Calculate the shortest angular distance\n\tdouble shortest_angular_distance = std::remainder(end_angle - start_angle, 2 * M_PI);\n\n\t// Determine the sign of the shortest angular distance\n\tint sign = (shortest_angular_distance > 0)? 1 : -1;\n\n\t// Calculate the incremental change in angle\n\tdouble delta_angle = shortest_angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tgeometry_msgs::PoseStamped* pose = &path[i];\n\t\tdouble angle = start_angle + sign * delta_angle * (i - start_index);\n\t\tset_angle(pose, angle);\n\t}\n}", "CodeBleu_score": 45.9796878531816}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tif (start_index == end_index) {\n\t\treturn;\n\t}\n\tdouble start_angle = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble angle_diff = angles::shortest_angular_distance(start_angle, end_angle);\n\tdouble angle_inc = angle_diff / (end_index - start_index);\n\tdouble angle = start_angle;\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tangle += angle_inc;\n\t\tset_angle(&path[i], angle);\n\t}\n}", "CodeBleu_score": 62.95691364447046}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t\tdouble start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\tdouble yaw_diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n\tdouble angle_inc = yaw_diff / (end_index - start_index);\n\tdouble angle = start_yaw;\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tangle += angle_inc;\n\t\tset_angle(&path[i], angle);\n\t}\n}", "CodeBleu_score": 67.8384524078159}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\tmakePlan(req.start, req.goal, resp.plan);\n\tresp.code = resp.plan.size() > 0? 1 : 0;\n\treturn true;\n}", "CodeBleu_score": 45.33600186517104}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t", "CodeBleu_score": 6.034762534938585}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\tmakePlan(req.start, req.goal, resp.plan);\n\tresp.code = resp.plan.size()? navfn::MakeNavPlan::Response::SUCCESS : navfn::MakeNavPlan::Response::OUT_OF_REACH;\n\treturn true;\n}", "CodeBleu_score": 46.87076183362375}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t//    ros::NodeHandle private_nh(\"~/\" + name);\n    ros::NodeHandle private_nh(\"~\");\n    private_nh.param(\"step_size\", step_size_, costmap_->getResolution());\n    private_nh.param(\"min_dist_from_robot\", min_dist_from_robot_, 0.10);\n    planner_window_x_ = costmap_->getSizeInMetersX();\n    planner_window_y_ = costmap_->getSizeInMetersY();\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}", "CodeBleu_score": 62.97588474075933}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t//    ROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap\");\n    cmap_ = cmap;\n    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\",\n            &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1,\n            boost::bind(&PlannerWithCostmap::goalCB, this, _1));\n}", "CodeBleu_score": 68.6583435603056}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\t\tROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap: Initializing\");\n\tprivate_nh_ = ros::NodeHandle(\"~/\" + name);\n\tmake_plan_srv_ = private_nh_.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub_ = private_nh_.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n\tROS_INFO(\"PlannerWithCostmap::PlannerWithCostmap: Initialized\");\n}", "CodeBleu_score": 56.429366390617574}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\t// If the world coordinates are within the bounds of the costmap's origin, calculate the map coordinates\n\tif (wx >= origin_x_ && wx <= origin_x_ + size_x_ * resolution_ && wy >= origin_y_ && wy <= origin_y_ + size_y_ * resolution_) {\n\t\tmx = (wx - origin_x_) / resolution_;\n\t\tmy = (wy - origin_y_) / resolution_;\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.43146035380125}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_ros_->getCostmap()->getOriginX(), origin_y = costmap_ros_->getCostmap()->getOriginY();\n\tdouble resolution = costmap_ros_->getCostmap()->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_ros_->getCostmap()->getSizeInCellsX() && my < costmap_ros_->getCostmap()->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 72.77413644026498}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\t\tdouble origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n\tdouble resolution = costmap_->getResolution();\n\n\tif (wx < origin_x || wy < origin_y)\n\t\treturn false;\n\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\n\tif (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n\t\treturn true;\n\n\treturn false;\n}", "CodeBleu_score": 83.87997991772444}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.52659093292189}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.52659093292189}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t\tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t//create a message for the plan\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\n\tif (!path.empty()) {\n\t\tgui_path.header.frame_id = path[0].header.frame_id;\n\t\tgui_path.header.stamp = path[0].header.stamp;\n\t}\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}", "CodeBleu_score": 85.52659093292189}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID g;\n\t// use the system time for the timestamp\n\tg.stamp = ros::Time::now();\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\t// publish the goal\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 59.27602824215851}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID g;\n\tg.stamp = ros::Time::now();\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 57.0670887834417}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\t\tactionlib_msgs::GoalID g;\n\t// use the system time for the goal id\n\tg.stamp = ros::Time::now();\n\n\tgoal_id_ = g.stamp;\n\n\tactionlib_msgs::GoalStatus gs;\n\tgs.goal_id = g;\n\tgs.status = actionlib_msgs::GoalStatus::PENDING;\n\tgs.text = \"Goal received by MoveBase\";\n\n\t// publish the goal status\n\tas_.publishGoalStatus(gs);\n\n\t// wrap the geometry_msgs::PoseStamped in the action message\n\t// and restamp it with the current time\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\t// publish the action goal\n\taction_goal_pub_.publish(action_goal);\n\n\t// we have a new goal\n\tnew_goal_ = true;\n}", "CodeBleu_score": 64.66606514605353}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (getSqDistance() > limited_distance_sq_) {\n\t\tROS_INFO(\"Robot has moved far enough, removing speed limit\");\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 57.57826574062987}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tif (getSqDistance() > sq_distance_limit_) {\n\t\tROS_DEBUG_NAMED(\"move_slow_and_clear\", \"Robot has moved %f meters. Stopping distance check timer.\", sqrt(getSqDistance()));\n\t\tdistance_check_timer_.stop();\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t\tremove_limit_thread_ = NULL;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t}\n}", "CodeBleu_score": 62.51237961114199}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\t\tdouble distance = getSqDistance();\n\tif (distance >= limited_distance_sq_) {\n\t\tROS_INFO(\"Robot has moved far enough to remove speed limit.\");\n\t\tif (remove_limit_thread_!= NULL) {\n\t\t\tremove_limit_thread_->join();\n\t\t\tdelete remove_limit_thread_;\n\t\t}\n\t\tremove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\tdistance_check_timer_.stop();\n\t}\n}", "CodeBleu_score": 73.63583259699081}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Got new pose\");\n\t// Get the current pose of the robot\n\trm::PoseStamped global_pose;\n\tgetRobotPose(global_pose);\n\n\t// Define the vector path\n\tstd::vector<rm::PoseStamped> path;\n\n\t// Generate a path from the current pose to the goal pose\n\tmakePlan(global_pose, *goal, path);\n}", "CodeBleu_score": 68.27698552092953}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\ttf::Stamped<tf::Pose> goal_tf;\n\ttf::poseStampedMsgToTF(*goal, goal_tf);\n\n\t//we want to publish the goal pose as a PoseStamped message\n\trm::PoseStamped goal_pose;\n\tgoal_pose.header.frame_id = goal->header.frame_id;\n\tgoal_pose.header.stamp = goal->header.stamp;\n\ttf::poseStampedTFToMsg(goal_tf, goal_pose);\n\n\t//we also want to check if the goal pose is in the global frame\n\tif(goal_pose.header.frame_id!= costmap_ros_->getGlobalFrameID()) {\n\t\tROS_ERROR(\"This planner as configured will only accept goals in the %s frame, but a goal was sent in the %s frame.\", costmap_ros_->getGlobalFrameID().c_str(), goal_pose.header.frame_id.c_str());\n\t\treturn;\n\t}\n\n\tROS_DEBUG(\"Got a new goal pose\");\n\n\t//update the copy for the costmap\n\tglobal_pose_ = goal_pose;\n\n\t//make sure to set the plan to be empty initially\n\tplan_.clear();\n\n\t//since this gets called on a new goal, we'll increment the robot's pose\n\tpose_count_++;\n\n\t//make sure to set the plan to be empty initially\n\tplan_.clear();\n\n\t//now, we'll try to plan to the desired goal\n\tstd::vector<rm::PoseStamped> global_plan;\n\tif(makePlan(global_pose_, goal_pose, global_plan) == true) {\n\t\t//a path was found, store it locally\n\t\tplan_ = global_plan;\n\t\t//publish the plan for visualization purposes\n\t\tpublishPlan(global_plan);\n\t} else {\n\t\tROS_WARN(\"Failed to find a plan to the goal pose\");\n\t}\n}", "CodeBleu_score": 41.657281993566976}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t\tROS_INFO(\"Got new pose\");\n\tgeometry_msgs::PoseStamped global_pose;\n\tif(!costmap_ros_->getRobotPose(global_pose)) {\n\t\tROS_ERROR(\"Unable to get starting pose of robot, unable to create global plan\");\n\t\treturn;\n\t}\n\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tif(makePlan(global_pose, *goal, plan)) {\n\t\t//publish the plan\n\t\tROS_INFO(\"Got plan with %d points\", (int)plan.size());\n\t\tplan_pub_.publish(plan);\n\t} else {\n\t\tROS_INFO(\"Failed to get a plan\");\n\t}\n}", "CodeBleu_score": 50.46040834839014}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\tparam_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 54.88228415128826}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\n\tif (param_set_client_.call(param_set_srv)) {\n\t\tROS_INFO(\"Gimbal Param Set: %s\", param_set_srv.response.success? \"Success\" : \"Failed\");\n\t} else {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t}\n}", "CodeBleu_score": 50.007733363223494}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\t\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 58.7743208729043}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}, {"code": "void CommunicationBridge::serverFun(){\n\t", "CodeBleu_score": 1.9967459379652532}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\tif (simulation_mode_) {\n\t\t// find the corresponding UAV by ID\n\t\tauto it = swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it!= swarm_control_simulation_.end()) {\n\t\t\t// publish the command to the matching UAV\n\t\t\tit->second->publishUAVCommand(uav_cmd);\n\t\t}\n\t} else {\n\t\t// publish the command to a single UAV using uav_basic_\n\t\tuav_basic_->publishUAVCommand(uav_cmd);\n\t}\n}", "CodeBleu_score": 39.01530270795952}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t", "CodeBleu_score": 2.601564811867212}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t\t// If not in simulation mode, send command to single UAV\n\tif (!simulation_mode_) {\n\t\tuav_basic_.sendCommand(uav_cmd);\n\t}\n\t// If in simulation mode, send command to UAV with matching ID\n\telse {\n\t\t// Find UAV with matching ID\n\t\tstd::map<int, UAV>::iterator it = swarm_control_simulation_.find(uav_cmd.id);\n\t\t// If UAV with matching ID exists, send command to it\n\t\tif (it!= swarm_control_simulation_.end()) {\n\t\t\tit->second.sendCommand(uav_cmd);\n\t\t}\n\t\t// If UAV with matching ID does not exist, print error\n\t\telse {\n\t\t\tROS_ERROR(\"UAV with ID %d not found in simulation mode\", uav_cmd.id);\n\t\t}\n\t}\n}", "CodeBleu_score": 37.86022385445567}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"shutdown now\");\n\t} else if (mode_selection.use_mode == CREATE_MODE) {\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETE_MODE) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == SET_MODE) {\n\t\tsetMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == GET_MODE) {\n\t\tgetMode();\n\t}\n}", "CodeBleu_score": 50.770888258242174}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == CREATE) {\n\t\tcreateMode(mode_selection);\n\t} else if (mode_selection.use_mode == DELETE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 60.13106077968521}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t\tif (mode_selection.mode == REBOOTNX) {\n\t\tsystem(\"reboot\");\n\t} else if (mode_selection.mode == EXITNX) {\n\t\tsystem(\"poweroff\");\n\t} else if (mode_selection.use_mode) {\n\t\tcreateMode(mode_selection);\n\t} else {\n\t\tdeleteMode(mode_selection);\n\t}\n}", "CodeBleu_score": 53.85932726389001}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\t// check if heartbeat is received\n\tif (heartbeat_count_ == last_heartbeat_count_) {\n\t\tif (heartbeat_counter_ > 10) {\n\t\t\tROS_ERROR_STREAM(\"No heartbeat received for \" << heartbeat_counter_ << \" seconds.\");\n\t\t\tif (vehicle_type_ == \"swarm\") {\n\t\t\t\tROS_ERROR_STREAM(\"Swarm is disconnected.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t} else if (vehicle_type_ == \"uav\") {\n\t\t\t\tROS_ERROR_STREAM(\"UAV is disconnected.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t} else if (vehicle_type_ == \"ugv\") {\n\t\t\t\tROS_ERROR_STREAM(\"UGV is disconnected.\");\n\t\t\t\tdisconnect_flag_ = true;\n\t\t\t}\n\t\t} else {\n\t\t\theartbeat_counter_++;\n\t\t}\n\t} else {\n\t\theartbeat_counter_ = 0;\n\t}\n\n\tlast_heartbeat_count_ = heartbeat_count_;\n}", "CodeBleu_score": 32.232712775502925}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (heartbeat_count == prev_heartbeat_count) {\n\t\t//ROS_ERROR(\"Heartbeat not received from %s\", heartbeat_topic.c_str());\n\t\tif (vehicle_type == \"swarm\") {\n\t\t\tif (vehicle_id == \"1\") {\n\t\t\t\tROS_ERROR(\"Heartbeat not received from %s\", heartbeat_topic.c_str());\n\t\t\t\tROS_ERROR(\"Disconnecting from swarm\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Heartbeat not received from %s\", heartbeat_topic.c_str());\n\t\t\t\tROS_ERROR(\"Disconnecting from swarm\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t} else if (vehicle_type == \"UAV\") {\n\t\t\tif (vehicle_id == \"1\") {\n\t\t\t\tROS_ERROR(\"Heartbeat not received from %s\", heartbeat_topic.c_str());\n\t\t\t\tROS_ERROR(\"Disconnecting from swarm\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t} else {\n\t\t\t\tROS_ERROR(\"Heartbeat not received from %s\", heartbeat_topic.c_str());\n\t\t\t\tROS_ERROR(\"Disconnecting from swarm\");\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t} else if (vehicle_type == \"UGV\") {\n\t\t\tROS_ERROR(\"Heartbeat not received from %s\", heartbeat_topic.c_str());\n\t\t\tROS_ERROR(\"Disconnecting from swarm\");\n\t\t\tdisconnect_flag = true;\n\t\t} else {\n\t\t\tROS_ERROR(\"Heartbeat not received from %s\", heartbeat_topic.c_str());\n\t\t\tROS_ERROR(\"Disconnecting from swarm\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t} else {\n\t\tprev_heartbeat_count = heartbeat_count;\n\t}\n}", "CodeBleu_score": 33.65734274930201}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t\tif (this->heartbeat_count == this->last_heartbeat_count) {\n\t\tthis->heartbeat_count = 0;\n\t\tthis->last_heartbeat_count = 0;\n\t\tthis->disconnect_flag = true;\n\n\t\tif (this->vehicle_type == VehicleType::SWARM) {\n\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting...\");\n\t\t}\n\t\telse if (this->vehicle_type == VehicleType::UAV) {\n\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting...\");\n\t\t}\n\t\telse if (this->vehicle_type == VehicleType::UGV) {\n\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting...\");\n\t\t}\n\t\telse {\n\t\t\tROS_ERROR(\"Heartbeat lost. Disconnecting...\");\n\t\t}\n\t}\n\telse {\n\t\tthis->last_heartbeat_count = this->heartbeat_count;\n\t}\n}", "CodeBleu_score": 21.180154425632043}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t", "CodeBleu_score": 1.2533532611694385}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\tpcl::PointCloud<pcl::PointXYZRGB> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\tpcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZRGB>(cloud));\n\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZRGB> octree(compression_resolution_);\n\toctree.setInputCloud(cloud_ptr);\n\toctree.defineBoundingBox();\n\toctree.addPointsFromInputCloud();\n\n\tstd::vector<char> compressed_data;\n\toctree.encodePointCloud(compressed_data);\n\n\tsensor_msgs::PointCloud2 msg_out;\n\tmsg_out.header = msg.header;\n\tmsg_out.height = 1;\n\tmsg_out.width = compressed_data.size();\n\tmsg_out.is_bigendian = false;\n\tmsg_out.is_dense = true;\n\tmsg_out.point_step = 1;\n\tmsg_out.row_step = compressed_data.size();\n\tmsg_out.data = compressed_data;\n\n\tsensor_msgs::PointField field;\n\tfield.name = \"rgb\";\n\tfield.datatype = 7;\n\tfield.offset = 0;\n\tfield.count = 1;\n\tfield.datatype = 7;\n\tmsg_out.fields.push_back(field);\n\n\treturn msg_out;\n}", "CodeBleu_score": 44.183008236152645}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// convert to pcl::PointCloud\n\tpcl::PCLPointCloud2 pcl_pc2;\n\tpcl_conversions::toPCL(msg,pcl_pc2);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr temp_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromPCLPointCloud2(pcl_pc2,*temp_cloud);\n\n\t// compress the point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree (compression_level_);\n\toctree.encodePointCloud (temp_cloud, *cloud_out);\n\n\t// convert to PointCloud2 message\n\tpcl::PCLPointCloud2 pcl_pc2_out;\n\tpcl::toPCLPointCloud2(*cloud_out,pcl_pc2_out);\n\tsensor_msgs::PointCloud2 msg_out;\n\tpcl_conversions::fromPCL(pcl_pc2_out,msg_out);\n\n\t// release memory\n\ttemp_cloud.reset();\n\tcloud_out.reset();\n\n\treturn msg_out;\n}", "CodeBleu_score": 34.96399078167853}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t\t// Create a container for the data.\n\tsensor_msgs::PointCloud2 output;\n\t// Create a PCLPointCloud2 object to store the compressed data.\n\tpcl::PCLPointCloud2 pcl_pc2;\n\t// Create a PCLPointCloud2 object to store the input data.\n\tpcl::PCLPointCloud2 cloud;\n\t// Convert the input message to a PCLPointCloud2 object.\n\tpcl_conversions::toPCL(msg, cloud);\n\t// Compress the point cloud using an octree compression technique.\n\tpcl::io::octree::OctreePointCloudCompression<pcl::PCLPointCloud2> octree(compression_level_);\n\toctree.encodePointCloud(cloud, pcl_pc2);\n\t// Convert the compressed data back to a PointCloud2 message.\n\tpcl_conversions::fromPCL(pcl_pc2, output);\n\t// Release dynamically allocated memory.\n\tpcl_pc2.data.clear();\n\tcloud.data.clear();\n\t// Return the compressed PointCloud2 message.\n\treturn output;\n}", "CodeBleu_score": 23.827129961768666}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tif (multi_uav_state_.size() == 0) {\n\t\tmulti_uav_state_.push_back(uav_state);\n\t} else {\n\t\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 63.533725942609045}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\tint i;\n\tfor (i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_.at(i).uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_.at(i) = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 51.547479047720834}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t\t//std::cout << \"SwarmControl::updateAllUAVState\" << std::endl;\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\treturn;\n\t\t}\n\t}\n\t//std::cout << \"SwarmControl::updateAllUAVState - Adding new UAV\" << std::endl;\n\tmulti_uav_state_.push_back(uav_state);\n}", "CodeBleu_score": 56.928816593785605}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState msg;\n\tmsg.header.stamp = ros::Time::now();\n\tmsg.ugv_count = 0;\n\tfor(int i=0; i<m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state_msg;\n\t\tugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n\t\tugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n\t\tugv_state_msg.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n\t\tmsg.ugv_state.push_back(ugv_state_msg);\n\t\tmsg.ugv_count++;\n\t}\n\tall_ugv_state_pub.publish(msg);\n}", "CodeBleu_score": 41.780882307955046}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t", "CodeBleu_score": 1.0347223857878618}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t\tMultiUGVState multi_ugv_state;\n\tmulti_ugv_state.header.stamp = ros::Time::now();\n\tmulti_ugv_state.header.frame_id = \"ugv_state\";\n\tmulti_ugv_state.ugv_count = 0;\n\n\tfor(int i=0; i<m_multi_ugv_state.ugv_count; i++) {\n\t\tUGVState ugv_state;\n\t\tugv_state.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n\t\tugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n\t\tugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n\t\tmulti_ugv_state.ugv_state.push_back(ugv_state);\n\t\tmulti_ugv_state.ugv_count++;\n\t}\n\n\tall_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 43.25067073823968}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\tcost = 0;\n\tgradient.setZero();\n\tdouble clearance = 0.5;\n\tdouble weight = 1;\n\tdouble distance;\n\tdouble distance_error;\n\tdouble d_distance_error;\n\tEigen::Vector3d pos;\n\tEigen::Vector3d d_pos;\n\tEigen::Vector3d d_distance;\n\tEigen::Vector3d d_distance_error;\n\tEigen::Vector3d d_cost;\n\tfor (int i = 0; i < n_control_points_; i++) {\n\t\tpos = q.block<3, 1>(3 * i, 0);\n\t\td_pos = gradient.block<3, 1>(3 * i, 0);\n\t\tfor (int j = 0; j < n_moving_objects_; j++) {\n\t\t\tdistance = (pos - moving_objects_[j]).norm();\n\t\t\tif (distance < clearance) {\n\t\t\t\tdistance_error = distance - clearance;\n\t\t\t\td_distance = (pos - moving_objects_[j]) / distance;\n\t\t\t\td_distance_error = d_distance;\n\t\t\t\td_cost = weight * d_distance_error;\n\t\t\t\tcost += weight * distance_error * distance_error;\n\t\t\t\tgradient.block<3, 1>(3 * i, 0) += d_cost;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.14109751303904}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t//cout << \"calcMovingObjCost\" << endl;\n\tdouble cost_temp = 0;\n\tEigen::MatrixXd gradient_temp = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\tdouble dist_temp;\n\tEigen::Vector3d dist_vec;\n\tEigen::Vector3d obj_pos;\n\tEigen::Vector3d ctrl_pt;\n\tdouble clearance;\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\tctrl_pt = q.col(i);\n\t\tfor (int j = 0; j < moving_objs.size(); j++) {\n\t\t\tobj_pos = moving_objs[j].getPos();\n\t\t\tdist_vec = obj_pos - ctrl_pt;\n\t\t\tdist_temp = dist_vec.norm();\n\t\t\tclearance = moving_objs[j].getClearance();\n\t\t\tif (dist_temp < clearance) {\n\t\t\t\tcost_temp += pow(clearance - dist_temp, 2);\n\t\t\t\tgradient_temp.col(i) += 2 * (clearance - dist_temp) * dist_vec / dist_temp;\n\t\t\t}\n\t\t}\n\t}\n\tcost += cost_temp;\n\tgradient += gradient_temp;\n}", "CodeBleu_score": 38.84079132124075}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 3.554566006852088}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// initialize cost and gradient\n\tcost = 0;\n\tgradient.setZero();\n\n\t// iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// get reference point\n\t\tEigen::Vector3d ref = _ref_points.col(i);\n\n\t\t// compute positional error\n\t\tEigen::Vector3d pos_error = q.col(i) - ref;\n\n\t\t// compute velocity vector\n\t\tEigen::Vector3d vel;\n\t\tif (i == 0) {\n\t\t\tvel = q.col(i + 1) - q.col(i);\n\t\t} else if (i == q.cols() - 1) {\n\t\t\tvel = q.col(i) - q.col(i - 1);\n\t\t} else {\n\t\t\tvel = (q.col(i + 1) - q.col(i - 1)) / 2;\n\t\t}\n\n\t\t// compute cost and gradient\n\t\tdouble a = pos_error.dot(vel);\n\t\tdouble b = pos_error.cross(vel).norm();\n\t\tcost += a * a / _a2 + b * b / _b2;\n\n\t\t// compute derivatives\n\t\tEigen::Vector3d da = 2 * a / _a2 * pos_error;\n\t\tEigen::Vector3d db = 2 * b / _b2 * pos_error.cross(vel) / b;\n\t\tEigen::Vector3d dg = da + db;\n\n\t\t// update gradient\n\t\tgradient.col(i) = dg;\n\t}\n}", "CodeBleu_score": 37.764539312973234}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t\t// Compute the B-spline trajectory\n\tEigen::MatrixXd T = calcBsplineTrajectory(q);\n\t// Initialize the cost to zero\n\tcost = 0;\n\t// Iterate through the control points of the trajectory\n\tfor (int i = 0; i < num_control_points; i++) {\n\t\t// Compute the positional error relative to reference points\n\t\tEigen::Vector3d error = T.col(i) - reference_points.col(i);\n\t\t// Compute the velocity vector\n\t\tEigen::Vector3d velocity = Eigen::Vector3d(0, 0, 0);\n\t\tif (i > 0) {\n\t\t\tvelocity = (T.col(i) - T.col(i - 1)) / dt;\n\t\t}\n\t\t// Update the cost function\n\t\tcost += a2 * error.squaredNorm() + b2 * velocity.squaredNorm();\n\t\t// Compute the derivatives of the cost function with respect to the control point\n\t\tEigen::MatrixXd dC_dq = 2 * a2 * error * T.col(i).transpose() + 2 * b2 * velocity * velocity.transpose();\n\t\t// Update the gradient for the control point\n\t\tgradient.block<3, 3>(i * 3, 0) += dC_dq;\n\t}\n}", "CodeBleu_score": 27.467649795827466}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t", "CodeBleu_score": 2.753685590973287}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getDerivativeControlPoints();\n\tctp = getDerivativeControlPoints(ctp);\n\tctp = getDerivativeControlPoints(ctp);\n\tEigen::VectorXd knot = getKnot();\n\tdouble jerk = 0;\n\tfor (int i = 0; i < ctp.cols(); i++) {\n\t\tfor (int j = 0; j < ctp.rows(); j++) {\n\t\t\tjerk += ctp(j, i) * (knot(i + 1) - knot(i));\n\t\t}\n\t}\n\treturn jerk;\n}", "CodeBleu_score": 51.167774420634636}, {"code": "double UniformBspline::getJerk(){\n\t", "CodeBleu_score": 1.1628100042452454}, {"code": "double UniformBspline::getJerk(){\n\t\tEigen::MatrixXd ctp = getDerivativeControlPoints();\n\tUniformBspline derivative(ctp, p_ - 1, interval_);\n\tEigen::VectorXd knot = derivative.getKnot();\n\tEigen::MatrixXd jerk_ctp = derivative.getDerivativeControlPoints();\n\tUniformBspline jerk(jerk_ctp, p_ - 2, interval_);\n\tEigen::VectorXd jerk_knot = jerk.getKnot();\n\tdouble jerk_val = 0.0;\n\tfor (int i = 0; i < jerk_ctp.cols(); i++) {\n\t\tfor (int j = 0; j < jerk_ctp.rows(); j++) {\n\t\t\tjerk_val += jerk_ctp(j, i) * jerk_ctp(j, i) * (jerk_knot(i + 1) - jerk_knot(i));\n\t\t}\n\t}\n\treturn jerk_val;\n}", "CodeBleu_score": 53.874875589211534}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}", "CodeBleu_score": 74.49740701774701}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.71884142349269}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_) * depth / fx_;\n\tpos(1) = (v - cy_) * depth / fy_;\n\tpos(2) = depth;\n\tpos(3) = 1.0;\n\treturn pos;\n}", "CodeBleu_score": 75.71884142349269}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tstd::string droneID = extractDroneIDFromChildFrameID(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"Failed to extract drone ID from child_frame_id of odometry message: %s\", e.what());\n\t}\n}", "CodeBleu_score": 45.20434943769607}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\tint droneID = extractDroneID(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t} catch (std::exception& e) {\n\t\tROS_ERROR(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 45.836048368020144}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\t\ttry {\n\t\trcvDroneOdomCallbackBase(odom, extractDroneID(odom.child_frame_id));\n\t} catch (std::exception &e) {\n\t\tROS_ERROR(\"%s\", e.what());\n\t}\n}", "CodeBleu_score": 34.26262265941947}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t", "CodeBleu_score": 3.1161603120218353}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the pose of the drone in the camera frame\n\tEigen::Vector3d drone_pose = getDronePose(drone_id);\n\tEigen::Vector3d drone_pose_cam = cam_frame_transform_ * drone_pose;\n\n\t// Check for the presence of the drone in the camera frame\n\tif (drone_pose_cam(2) > 0) {\n\t\t// Compute the pose error between the camera and world coordinates\n\t\tEigen::Vector3d pose_error = cam_frame_transform_.inverse() * drone_pose;\n\n\t\t// Update the debug result\n\t\tdebug_result_.drone_id = drone_id;\n\t\tdebug_result_.true_pixel = true_pixel;\n\t\tdebug_result_.found = true;\n\t\tdebug_result_.pose_error = pose_error;\n\n\t\t// Publish the pose error\n\t\tpose_error_pub_.publish(pose_error);\n\t} else {\n\t\t// Update the debug result to indicate failure\n\t\tdebug_result_.drone_id = drone_id;\n\t\tdebug_result_.true_pixel = true_pixel;\n\t\tdebug_result_.found = false;\n\t\tdebug_result_.pose_error.setZero();\n\t}\n\n\t// Publish the debug result\n\tdebug_result_pub_.publish(debug_result_);\n}", "CodeBleu_score": 44.40489386362214}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t\t// Get the drone pose\n\tEigen::Vector3d drone_pose;\n\tif (getDronePose(drone_id, drone_pose)) {\n\t\t// Get the drone pose in the camera frame\n\t\tEigen::Vector3d drone_pose_cam = m_cam_pose.inverse() * drone_pose;\n\t\t// Get the drone position in the camera frame\n\t\tEigen::Vector2d drone_pos_cam(drone_pose_cam(0), drone_pose_cam(1));\n\t\t// Get the drone position in the image frame\n\t\tEigen::Vector2d drone_pos_img = m_cam_intrinsics.inverse() * drone_pos_cam;\n\t\t// Get the drone position in the image frame as an integer\n\t\tEigen::Vector2i drone_pos_img_int(round(drone_pos_img(0)), round(drone_pos_img(1)));\n\n\t\t// Compute the pose error\n\t\tEigen::Vector2d pose_error = true_pixel.cast<double>() - drone_pos_img;\n\n\t\t// Update the debug result\n\t\tm_debug_result.drone_id = drone_id;\n\t\tm_debug_result.drone_pos_img = drone_pos_img_int;\n\t\tm_debug_result.pose_error = pose_error;\n\t\tm_debug_result.success = true;\n\n\t\t// Publish the pose error\n\t\tm_pose_error_pub.publish(m_debug_result);\n\t}\n\telse {\n\t\t// Update the debug result\n\t\tm_debug_result.drone_id = drone_id;\n\t\tm_debug_result.drone_pos_img = Eigen::Vector2i::Zero();\n\t\tm_debug_result.pose_error = Eigen::Vector2d::Zero();\n\t\tm_debug_result.success = false;\n\n\t\t// Publish the pose error\n\t\tm_pose_error_pub.publish(m_debug_result);\n\t}\n}", "CodeBleu_score": 35.330895623963016}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\t\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}", "CodeBleu_score": 84.72259716802478}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert the start and end points to grid indices\n\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Check if the start or end point is inside an obstacle\n\tif (IsPointInObstacle(start_pt) || IsPointInObstacle(end_pt)) {\n\t\t// Adjust the start and end points until they are no longer inside an obstacle\n\t\tVector3i start_idx_adjusted = start_idx;\n\t\tVector3i end_idx_adjusted = end_idx;\n\t\tif (!AdjustStartEndPoints(start_idx, end_idx, start_idx_adjusted, end_idx_adjusted)) {\n\t\t\treturn false;\n\t\t}\n\t\tstart_idx = start_idx_adjusted;\n\t\tend_idx = end_idx_adjusted;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 36.53735324709435}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// Convert start and end points to indices\n\tif (!ConvertPointToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertPointToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Adjust start and end points if they are inside obstacles\n\tif (IsPointInObstacle(start_pt)) {\n\t\tif (!AdjustPointToNotBeInObstacle(start_pt, end_pt)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!ConvertPointToIndex(start_pt, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (IsPointInObstacle(end_pt)) {\n\t\tif (!AdjustPointToNotBeInObstacle(end_pt, start_pt)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!ConvertPointToIndex(end_pt, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 38.89822501782879}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t\t// convert start and end points to indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// check if start or end point is inside an obstacle\n\tif (IsPointInObstacle(start_pt) || IsPointInObstacle(end_pt)) {\n\t\t// adjust start and end points iteratively until they are no longer inside an obstacle\n\t\tVector3i start_idx_adj = start_idx;\n\t\tVector3i end_idx_adj = end_idx;\n\t\tVector3i start_idx_diff = start_idx_adj - end_idx_adj;\n\t\tVector3i end_idx_diff = end_idx_adj - start_idx_adj;\n\t\tVector3d start_pt_adj = start_pt;\n\t\tVector3d end_pt_adj = end_pt;\n\t\tVector3d start_pt_diff = start_pt_adj - end_pt_adj;\n\t\tVector3d end_pt_diff = end_pt_adj - start_pt_adj;\n\t\twhile (IsPointInObstacle(start_pt_adj) || IsPointInObstacle(end_pt_adj)) {\n\t\t\t// adjust start point\n\t\t\tif (IsPointInObstacle(start_pt_adj)) {\n\t\t\t\t// move start point away from end point\n\t\t\t\tstart_idx_adj = start_idx_adj - start_idx_diff;\n\t\t\t\tstart_pt_adj = start_pt_adj - start_pt_diff;\n\t\t\t}\n\t\t\t// adjust end point\n\t\t\tif (IsPointInObstacle(end_pt_adj)) {\n\t\t\t\t// move end point away from start point\n\t\t\t\tend_idx_adj = end_idx_adj - end_idx_diff;\n\t\t\t\tend_pt_adj = end_pt_adj - end_pt_diff;\n\t\t\t}\n\t\t}\n\t\t// update start and end indices\n\t\tstart_idx = start_idx_adj;\n\t\tend_idx = end_idx_adj;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 39.677501465020335}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = world2grid(min_pos);\n\tEigen::Vector3i max_id = world2grid(max_pos);\n\n\t// Reset occupancy buffer\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Reset distance buffer\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\tdistance_buffer_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.93682731517473}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = posToId(min_pos);\n\tEigen::Vector3i max_id = posToId(max_pos);\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\toccupancy_buffer_inflate_(x, y, z) = 0;\n\t\t\t\tdistance_buffer_(x, y, z) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.9755216424397}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t\tEigen::Vector3i min_id = world2grid(min_pos);\n\tEigen::Vector3i max_id = world2grid(max_pos);\n\n\tfor (int i = min_id.x(); i <= max_id.x(); i++) {\n\t\tfor (int j = min_id.y(); j <= max_id.y(); j++) {\n\t\t\tfor (int k = min_id.z(); k <= max_id.z(); k++) {\n\t\t\t\toccupancy_buffer_inflate_(i, j, k) = 0;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 38.79586177522082}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tEigen::Vector3d max_scale(1.0, 1.0, 1.0);\n\tEigen::Vector3d min_scale(1.0, 1.0, 1.0);\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (diff[i] > 0) {\n\t\t\tmax_scale[i] = (map_max[i] - camera_pt[i]) / diff[i];\n\t\t} else {\n\t\t\tmin_scale[i] = (map_min[i] - camera_pt[i]) / diff[i];\n\t\t}\n\t}\n\tdouble scale = 1.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (max_scale[i] < scale) {\n\t\t\tscale = max_scale[i];\n\t\t}\n\t\tif (min_scale[i] > scale) {\n\t\t\tscale = min_scale[i];\n\t\t}\n\t}\n\treturn camera_pt + scale * diff;\n}", "CodeBleu_score": 47.43282294699427}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_x = diff.x() / (max_x_ - camera_pt.x());\n\tdouble min_x = diff.x() / (min_x_ - camera_pt.x());\n\tdouble max_y = diff.y() / (max_y_ - camera_pt.y());\n\tdouble min_y = diff.y() / (min_y_ - camera_pt.y());\n\tdouble max_z = diff.z() / (max_z_ - camera_pt.z());\n\tdouble min_z = diff.z() / (min_z_ - camera_pt.z());\n\tdouble x_factor = 1.0, y_factor = 1.0, z_factor = 1.0;\n\tif (min_x > 0.0 && min_x < 1.0) {\n\t\tx_factor = min_x;\n\t} else if (max_x > 0.0 && max_x < 1.0) {\n\t\tx_factor = max_x;\n\t}\n\tif (min_y > 0.0 && min_y < 1.0) {\n\t\ty_factor = min_y;\n\t} else if (max_y > 0.0 && max_y < 1.0) {\n\t\ty_factor = max_y;\n\t}\n\tif (min_z > 0.0 && min_z < 1.0) {\n\t\tz_factor = min_z;\n\t} else if (max_z > 0.0 && max_z < 1.0) {\n\t\tz_factor = max_z;\n\t}\n\tEigen::Vector3d adjusted_pt = camera_pt + (diff * std::min(std::min(x_factor, y_factor), z_factor));\n\treturn adjusted_pt;\n}", "CodeBleu_score": 41.671164565054895}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\t", "CodeBleu_score": 4.826190268379092}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t", "CodeBleu_score": 3.305901240966732}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\t// Update the last occupancy update time\n\tlast_occupancy_update_time_ = ros::Time::now();\n\n\t// If an update is needed, process the depth image\n\tif (need_update_occupancy_) {\n\t\tneed_update_occupancy_ = false;\n\n\t\t// Get the depth image\n\t\tcv::Mat depth_image;\n\t\tif (!getDepthImage(depth_image)) {\n\t\t\t// If the depth image is not available, set the timeout flag\n\t\t\tdepth_timeout_ = true;\n\t\t\treturn;\n\t\t}\n\n\t\t// If the local map has been updated, clear and inflate the local map\n\t\tif (local_map_updated_) {\n\t\t\tlocal_map_updated_ = false;\n\t\t\tlocal_map_.clear();\n\t\t\tlocal_map_.inflate();\n\t\t}\n\n\t\t// Project the depth image into points\n\t\tstd::vector<cv::Point3f> points;\n\t\tprojectDepthImage(depth_image, points);\n\n\t\t// Process the points with raycasting\n\t\tprocessPoints(points);\n\n\t\t// If the local map has been updated, clear and inflate the local map\n\t\tif (local_map_updated_) {\n\t\t\tlocal_map_updated_ = false;\n\t\t\tlocal_map_.clear();\n\t\t\tlocal_map_.inflate();\n\t\t}\n\t}\n\n\t// If the odometry is not available, set the timeout flag\n\tif (!odometry_available_) {\n\t\todometry_timeout_ = true;\n\t}\n}", "CodeBleu_score": 33.95524117401397}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t\tif (depth_image_sub_.getNumPublishers() == 0) {\n\t\treturn;\n\t}\n\n\tlast_occupancy_update_time_ = ros::Time::now();\n\n\tif (!occupancy_grid_update_needed_) {\n\t\treturn;\n\t}\n\n\toccupancy_grid_update_needed_ = false;\n\n\t// Clear the local map.\n\tlocal_map_.clear();\n\n\t// Inflates the local map.\n\tlocal_map_.inflate();\n\n\t// Raycast the depth image.\n\traycastDepthImage();\n\n\t// Update the occupancy grid.\n\tupdateOccupancyGrid();\n\n\t// Publish the local map.\n\tpublishLocalMap();\n}", "CodeBleu_score": 25.112446810559486}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure_total(0.f);\n\n\tfor (unsigned i = 0; i < image_fns.size(); ++i) {\n\t\tMat3b img = imread(image_fns[i], 1);\n\t\tif (img.empty()) {\n\t\t\tcout << \"Error reading image: \" << image_fns[i] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n\t\tfmeasure_total += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\n\treturn fmeasure_total / float(image_fns.size());\n}", "CodeBleu_score": 58.37194965394099}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure(0.f);\n\tint num_images = image_fns.size();\n\tfor (int i = 0; i < num_images; i++) {\n\t\tMat3b img = imread(image_fns[i]);\n\t\tvector<Ellipse> gt_ellipses;\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\t\t_load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\t\tfmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\treturn fmeasure / num_images;\n}", "CodeBleu_score": 60.73216436816568}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\toat fmeasure = 0.f;\n\tunsigned n = image_fns.size();\n\tfor (unsigned i = 0; i < n; ++i)\n\t{\n\t\tstring img_fn = image_fns[i];\n\t\tstring gt_fn = gt_fns[i];\n\t\tstring dt_fn = dt_fns[i];\n\n\t\tMat3b img = imread(img_fn, IMREAD_COLOR);\n\t\tif (img.empty())\n\t\t{\n\t\t\tcout << \"Error reading image: \" << img_fn << endl;\n\t\t\treturn 0.f;\n\t\t}\n\n\t\tvector<Ellipse> gt_ellipses;\n\t\t_load_ellipse_GT(gt_fn, gt_ellipses, gt_angle_radians);\n\n\t\tvector<Ellipse> dt_ellipses;\n\t\t_load_ellipse_DT(dt_fn, dt_ellipses, gt_angle_radians);\n\n\t\tfmeasure += _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n\t}\n\tfmeasure /= float(n);\n\treturn fmeasure;\n}", "CodeBleu_score": 51.267787681850166}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_a = atan2(y, x - foci[0]);\n\tfloat angle_b = atan2(y, x - foci[1]);\n\tfloat angle_diff = angle_diff_signed(angle_a, angle_b);\n\treturn angle_diff + M_PI_2;\n}", "CodeBleu_score": 25.611069312341613}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat a, b, c, d, e, f;\n\tfloat a1, a2, a3, a4, a5, a6, a7, a8;\n\tfloat angle1, angle2, angle_diff;\n\n\ta = foci[0];\n\tb = foci[1];\n\tc = foci[2];\n\td = foci[3];\n\n\te = x - a;\n\tf = y - b;\n\n\ta1 = (e * e) + (f * f);\n\ta2 = sqrt(a1);\n\ta3 = a2 * a2;\n\ta4 = a1 * a3;\n\ta5 = a4 * a1;\n\ta6 = a5 * a1;\n\ta7 = a6 * a1;\n\ta8 = a7 * a1;\n\n\tangle1 = atan2(f, e);\n\tangle2 = atan2(d - b, c - a);\n\n\tangle_diff = angle_diff_signed(angle1, angle2);\n\n\treturn angle_diff;\n}", "CodeBleu_score": 36.16855101570933}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\t\tfloat angle_a, angle_b, normal_angle;\n\n\tif (foci!= NULL) {\n\t\tangle_a = atan2(y, x - foci[0]);\n\t\tangle_b = atan2(y, x - foci[1]);\n\t\tnormal_angle = angle_diff_signed(angle_a, angle_b);\n\t} else {\n\t\tnormal_angle = atan2(y, x);\n\t}\n\n\treturn normal_angle;\n}", "CodeBleu_score": 34.40275112154148}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tint i;\n\tdouble min_x, max_x, min_y, max_y;\n\tdouble integral_above, integral_below;\n\n\tmin_x = max_x = vp1[start].x;\n\tmin_y = max_y = vp1[start].y;\n\n\tfor (i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\n\tintegral_above = integral_below = 0;\n\n\tfor (i = start; i <= end; i++) {\n\t\tif (vp1[i].x >= min_x && vp1[i].x <= max_x && vp1[i].y >= min_y && vp1[i].y <= max_y) {\n\t\t\tintegral_above += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\t\tintegral_below += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n\t\t}\n\t}\n\n\tif (integral_above < integral_below)\n\t\treturn false;\n\telse\n\t\treturn true;\n}", "CodeBleu_score": 37.91238588546224}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t\tdouble min_x, max_x, min_y, max_y;\n\tdouble integral_above = 0;\n\tdouble integral_below = 0;\n\n\t// calculate min and max x and y coordinates\n\tmin_x = max_x = vp1[start].x;\n\tmin_y = max_y = vp1[start].y;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\n\t// compute integral above and below polygon\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x >= min_x && vp1[i].x <= max_x && vp1[i].y >= min_y && vp1[i].y <= max_y) {\n\t\t\tintegral_above += (vp1[i].x - min_x) * (max_y - vp1[i].y);\n\t\t\tintegral_below += (vp1[i].x - min_x) * (vp1[i].y - min_y);\n\t\t}\n\t}\n\n\tif (integral_above < integral_below) return false;\n\treturn true;\n}", "CodeBleu_score": 40.85480848374004}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\t", "CodeBleu_score": 2.764264785048207}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t", "CodeBleu_score": 3.2076906242185066}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\t\tellipse_det.num_det = msg->num_det;\n\tfor (int i = 0; i < msg->num_det; i++) {\n\t\tif (msg->detection_infos[i].name == \"T\") {\n\t\t\tellipse_det.num_regain++;\n\t\t\tellipse_det.num_lost = 0;\n\t\t} else {\n\t\t\tellipse_det.num_regain = 0;\n\t\t\tellipse_det.num_lost++;\n\t\t}\n\t\tif (ellipse_det.num_lost >= VISION_THRES) {\n\t\t\tellipse_det.is_detected = false;\n\t\t}\n\t\tif (ellipse_det.num_regain >= VISION_THRES) {\n\t\t\tellipse_det.is_detected = true;\n\t\t}\n\t\tellipse_det.ellipse_det_info[i] = msg->detection_infos[i];\n\t\tellipse_det.ellipse_det_info[i].ellipse.center.x = msg->detection_infos[i].ellipse.center.x;\n\t\tellipse_det.ellipse_det_info[i].ellipse.center.y = msg->detection_infos[i].ellipse.center.y;\n\t\tellipse_det.ellipse_det_info[i].ellipse.center.z = msg->detection_infos[i].ellipse.center.z;\n\t\tellipse_det.ellipse_det_info[i].ellipse.size.x = msg->detection_infos[i].ellipse.size.x;\n\t\tellipse_det.ellipse_det_info[i].ellipse.size.y = msg->detection_infos[i].ellipse.size.y;\n\t\tellipse_det.ellipse_det_info[i].ellipse.size.z = msg->detection_infos[i].ellipse.size.z;\n\t\tellipse_det.ellipse_det_info[i].ellipse.angle = msg->detection_infos[i].ellipse.angle;\n\t}\n}", "CodeBleu_score": 30.62329782994162}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tbool safe = true;\n\tif (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n\t\tsafe = false;\n\t}\n\treturn safe;\n}", "CodeBleu_score": 58.50207032561233}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\t// check whether the current position is safe\n\treturn Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.63250389573369}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\t\tEigen::Vector3d check_pos = cur_pos;\n\tcheck_pos(2) = 0;\n\tif (Occupy_map_ptr->check_safety(check_pos, safe_distance)) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 50.24946090149645}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tpath_nodes_.push_back(end_node);\n\tNodePtr current_node = end_node;\n\twhile (current_node->parent_node_!= nullptr) {\n\t\tcurrent_node = current_node->parent_node_;\n\t\tpath_nodes_.push_back(current_node);\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 60.81613477273007}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 53.941987291368946}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent;\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 53.941987291368946}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\tif (sim_mode) {\n\t\tif (sqrt(pow(odom->pose.pose.position.x, 2) + pow(odom->pose.pose.position.y, 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t} else {\n\t\tget_nei_state[id] = true;\n\t}\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id][3] = odom->pose.pose.position.z;\n}", "CodeBleu_score": 56.460799503712465}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t// ROS_INFO(\"nei_odom_cb\");\n\t// ROS_INFO(\"id: %d\", id);\n\n\tif (id < 0 || id >= (int)state_nei.size()) {\n\t\tROS_ERROR(\"nei_odom_cb: id out of range\");\n\t\treturn;\n\t}\n\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\n\tif (simulation_mode) {\n\t\tif (hypot(state_nei[id].x, state_nei[id].y) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t} else {\n\t\tget_nei_state[id] = true;\n\t}\n}", "CodeBleu_score": 51.99174588407519}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t\t//ROS_INFO(\"nei_odom_cb\");\n\tif(simulation_mode) {\n\t\tdouble dist = sqrt(pow(odom->pose.pose.position.x - start_pos.x, 2) + pow(odom->pose.pose.position.y - start_pos.y, 2));\n\t\tif(dist > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n\tstate_nei[id][0] = odom->pose.pose.position.x;\n\tstate_nei[id][1] = odom->pose.pose.position.y;\n\tstate_nei[id][2] = tf::getYaw(odom->pose.pose.orientation);\n\tstate_nei[id][3] = odom->pose.pose.position.z;\n}", "CodeBleu_score": 56.49221390394473}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\tif (!odom_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\tupdate_count = 0;\n\t\t// Update the Astar map\n\t\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\t\tpcl::fromROSMsg(*msg, cloud);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_ptr(new pcl::PointCloud<pcl::PointXYZ>());\n\t\tpcl::VoxelGrid<pcl::PointXYZ> sor;\n\t\tsor.setInputCloud(cloud_ptr);\n\t\tsor.setLeafSize(0.02f, 0.02f, 0.02f);\n\t\tsor.filter(*cloud_filtered_ptr);\n\t\tfor (int i = 0; i < cloud_filtered_ptr->size(); i++) {\n\t\t\tint x = (cloud_filtered_ptr->points[i].x - map_origin_x) / map_resolution;\n\t\t\tint y = (cloud_filtered_ptr->points[i].y - map_origin_y) / map_resolution;\n\t\t\tif (x >= 0 && x < map_width && y >= 0 && y < map_height) {\n\t\t\t\tmap[x][y] = 1;\n\t\t\t}\n\t\t}\n\t\t// Update the Astar map\n\t\tastar.setMap(map, map_width, map_height, map_resolution, map_origin_x, map_origin_y);\n\t}\n}", "CodeBleu_score": 52.85176351030496}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 5.371612362555575}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\n\tif (odom_ready == false) {\n\t\treturn;\n\t}\n\n\tsensor_ready = true;\n\tupdate_counter++;\n\n\tif (update_counter == 5) {\n\t\tupdate_counter = 0;\n\t\tupdateMap(msg);\n\t}\n}", "CodeBleu_score": 46.45509256692157}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, global_pcl);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr global_pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>(global_pcl));\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr inflated_pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>());\n\t\tpcl::PointCloud<pcl::PointXYZ> inflated_pcl;\n\t\tpcl::VoxelGrid<pcl::PointXYZ> vg;\n\t\tvg.setInputCloud(global_pcl_ptr);\n\t\tvg.setLeafSize(0.05f, 0.05f, 0.05f);\n\t\tvg.filter(*inflated_pcl_ptr);\n\t\tpcl::copyPointCloud(*inflated_pcl_ptr, inflated_pcl);\n\t\tfor (int i = 0; i < inflated_pcl.points.size(); i++) {\n\t\t\tmap_update(inflated_pcl.points[i].x, inflated_pcl.points[i].y, inflated_pcl.points[i].z);\n\t\t}\n\t}\n}", "CodeBleu_score": 44.36554048891722}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif(!get_gpcl) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tpcl::copyPointCloud(*gpcl, *gpcl_inf);\n\t\tinflation_gpcl();\n\t}\n}", "CodeBleu_score": 49.79356269509741}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\t\tif (get_gpcl) {\n\t\tpcl::fromROSMsg(*global_point, gpcl);\n\t\tpcl::copyPointCloud(gpcl, gpcl_inflated);\n\t\tget_gpcl = false;\n\t\tinflate_pcl(gpcl_inflated);\n\t}\n}", "CodeBleu_score": 41.56987648631328}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert laser scan to point cloud\n\tsensor_msgs::PointCloud2 laser_cloud;\n\ttry {\n\t\tprojector_.transformLaserScanToPointCloud(\"base_link\", *local_point, laser_cloud, tfListener_);\n\t} catch (tf::TransformException & e) {\n\t\tROS_ERROR(\"Unable to transform laser scan into base_link: %s\", e.what());\n\t\treturn;\n\t}\n\n\t// Convert point cloud to pcl data\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(laser_cloud, cloud);\n\n\t// Merge cloud with current map\n\tif (simulation_mode_) {\n\t\t// In simulation mode, we just add the cloud to the current map\n\t\t*map_ += cloud;\n\t} else {\n\t\t// In real mode, we need to merge the cloud with the current map\n\t\t// using the provided odometry information\n\t\tEigen::Affine3d odom_trans;\n\t\ttf::transformTFToEigen(odom.pose.pose, odom_trans);\n\t\tpcl::transformPointCloud(cloud, cloud, odom_trans);\n\t\t*map_ += cloud;\n\t}\n\n\t// Publish the map\n\tmap_publisher_.publish(map_);\n}", "CodeBleu_score": 43.249215562378474}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Convert the laser scan to a PointCloud2 format and convert it to a pcl::PointCloud\n\tsensor_msgs::PointCloud2 local_cloud;\n\tprojector_.transformLaserScanToPointCloud(laser_frame_, *local_point, local_cloud, tfListener_);\n\tpcl::PointCloud<pcl::PointXYZ> local_pcl;\n\tpcl::fromROSMsg(local_cloud, local_pcl);\n\n\t// Merge the local map with the provided odometry data\n\tif (!simulation_mode_) {\n\t\tpcl::transformPointCloud(local_pcl, local_pcl, odom.pose.pose);\n\t}\n\n\t// Update the occupancy map\n\tmap_update(local_pcl);\n}", "CodeBleu_score": 45.12736915903278}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t\t// Project laser scan into a PointCloud2 format\n\tsensor_msgs::PointCloud2 local_cloud;\n\tprojector_.projectLaser(*local_point, local_cloud);\n\n\t// Convert the PointCloud2 format to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> local_pcl;\n\tpcl::fromROSMsg(local_cloud, local_pcl);\n\n\t// Convert the odometry data to a tf::Transform\n\ttf::Transform odom_tf;\n\ttf::poseMsgToTF(odom.pose.pose, odom_tf);\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (!simulation_mode_) {\n\t\t// Transform the local map into the global frame\n\t\tpcl::PointCloud<pcl::PointXYZ> local_pcl_transformed;\n\t\tpcl::transformPointCloud(local_pcl, local_pcl_transformed, odom_tf);\n\n\t\t// Merge the transformed local map with the global map\n\t\tglobal_map_ += local_pcl_transformed;\n\t}\n\n\t// Convert the global map to a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ> global_pcl;\n\tif (simulation_mode_) {\n\t\tglobal_pcl = local_pcl;\n\t}\n\telse {\n\t\tglobal_pcl = global_map_;\n\t}\n\tsensor_msgs::PointCloud2 global_cloud;\n\tpcl::toROSMsg(global_pcl, global_cloud);\n\n\t// Publish the global map\n\tglobal_cloud.header.frame_id = map_frame_;\n\tglobal_cloud.header.stamp = ros::Time::now();\n\tglobal_cloud_pub_.publish(global_cloud);\n}", "CodeBleu_score": 44.8009449142443}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t", "CodeBleu_score": 6.653409987869169}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_map(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr pcl_map_inflate(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl_map->header.frame_id = \"world\";\n\tpcl_map_inflate->header.frame_id = \"world\";\n\tpcl_map->header.stamp = ros::Time::now();\n\tpcl_map_inflate->header.stamp = ros::Time::now();\n\n\tfor (int i = 0; i < map_size_x; i++) {\n\t\tfor (int j = 0; j < map_size_y; j++) {\n\t\t\tif (map[i][j] == 1) {\n\t\t\t\tpcl::PointXYZ p;\n\t\t\t\tp.x = i;\n\t\t\t\tp.y = j;\n\t\t\t\tp.z = 0;\n\t\t\t\tpcl_map->push_back(p);\n\t\t\t}\n\t\t\tif (map_inflate[i][j] == 1) {\n\t\t\t\tpcl::PointXYZ p;\n\t\t\t\tp.x = i;\n\t\t\t\tp.y = j;\n\t\t\t\tp.z = 0;\n\t\t\t\tpcl_map_inflate->push_back(p);\n\t\t\t}\n\t\t}\n\t}\n\n\tglobal_pcl_pub.publish(pcl_map);\n\tinflate_pcl_pub.publish(pcl_map_inflate);\n}", "CodeBleu_score": 46.462800324184514}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t", "CodeBleu_score": 8.100328403968353}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t", "CodeBleu_score": 5.583872204671806}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\t// If foot contact publishing is enabled and the robot is not in Gazebo, create a ContactsStamped message.\n\tif (publish_foot_contacts_ &&!gazebo_simulation_) {\n\t\t// Populate the message with the current gait phase of each leg.\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfoot_contacts_msg_.contacts[i].state = foot_contacts[i];\n\t\t}\n\t\t// Publish the message.\n\t\tfoot_contacts_publisher_.publish(foot_contacts_msg_);\n\t}\n}", "CodeBleu_score": 45.46852794091324}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t\tif (publish_foot_contacts_ &&!is_gazebo_) {\n\t\t// Create a ContactsStamped message\n\t\tsensor_msgs::ContactsStamped contacts_msg;\n\t\tcontacts_msg.header.stamp = ros::Time::now();\n\t\tcontacts_msg.header.frame_id = \"world\";\n\t\tcontacts_msg.contacts.resize(4);\n\n\t\t// Populate the message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcontacts_msg.contacts[i].header.stamp = contacts_msg.header.stamp;\n\t\t\tcontacts_msg.contacts[i].header.frame_id = \"world\";\n\t\t\tcontacts_msg.contacts[i].name = foot_names_[i];\n\t\t\tcontacts_msg.contacts[i].states.resize(1);\n\t\t\tcontacts_msg.contacts[i].states[0].state = foot_contacts[i];\n\t\t\tcontacts_msg.contacts[i].states[0].name = \"contact\";\n\t\t}\n\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_.publish(contacts_msg);\n\t}\n}", "CodeBleu_score": 58.83288227592096}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t", "CodeBleu_score": 3.1254227762308044}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\t", "CodeBleu_score": 0.0}, {"code": "def joints_cmd_callback(self, joints){\n\t\t// TODO: uncomment the following line when the minimal joints message is available\n\t// self.joints_pub.publish(joints)\n\n\t// create a joint trajectory message\n\ttraj = JointTrajectory()\n\ttraj.header.stamp = rospy.Time.now()\n\ttraj.joint_names = self.joint_names\n\n\tpoint = JointTrajectoryPoint()\n\tpoint.positions = joints.position[0:12]\n\tpoint.time_from_start = rospy.Duration(self.duration)\n\ttraj.points.append(point)\n\n\tself.traj_pub.publish(traj)\n}", "CodeBleu_score": 38.00523854339987}, {"code": "def joints_cmd_callback(self, joints){\n\t\tdef joints_msg = new JointState()\n\tjoints_msg.header.stamp = rospy.Time.now()\n\tjoints_msg.name = Arrays.copyOfRange(self.joints_names, 0, 12)\n\tjoints_msg.position = Arrays.copyOfRange(joints.position, 0, 12)\n\tself.joints_pub.publish(joints_msg)\n\tdef joint_trajectory_msg = new JointTrajectory()\n\tjoint_trajectory_msg.header.stamp = rospy.Time.now()\n\tjoint_trajectory_msg.joint_names = Arrays.copyOfRange(self.joints_names, 0, 12)\n\tdef point = new JointTrajectoryPoint()\n\tpoint.positions = Arrays.copyOfRange(joints.position, 0, 12)\n\tpoint.velocities = Arrays.copyOfRange(joints.velocity, 0, 12)\n\tpoint.accelerations = Arrays.copyOfRange(joints.effort, 0, 12)\n\tpoint.time_from_start = new Duration(self.trajectory_duration)\n\tjoint_trajectory_msg.points.add(point)\n\tself.joints_trajectory_pub.publish(joint_trajectory_msg)\n}", "CodeBleu_score": 47.00767599284448}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contact_states_.left = false;\n\tfoot_contact_states_.right = false;\n\n\tfor (int i = 0; i < _msg->contact_size(); ++i) {\n\t\tconst auto &contact = _msg->contact(i);\n\n\t\tstd::string collision1(contact.collision1());\n\t\tstd::string collision2(contact.collision2());\n\n\t\tif (collision1.find(\"left_foot\")!= std::string::npos) {\n\t\t\tfoot_contact_states_.left = true;\n\t\t}\n\t\telse if (collision2.find(\"left_foot\")!= std::string::npos) {\n\t\t\tfoot_contact_states_.left = true;\n\t\t}\n\t\telse if (collision1.find(\"right_foot\")!= std::string::npos) {\n\t\t\tfoot_contact_states_.right = true;\n\t\t}\n\t\telse if (collision2.find(\"right_foot\")!= std::string::npos) {\n\t\t\tfoot_contact_states_.right = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.15317950769683}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfoot_contact_states_.clear();\n\tfoot_contact_states_.push_back(false);\n\tfoot_contact_states_.push_back(false);\n\tfoot_contact_states_.push_back(false);\n\tfoot_contact_states_.push_back(false);\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::string link1 = _msg->contact(i).collision1();\n\t\tstd::string link2 = _msg->contact(i).collision2();\n\t\tif (link1.find(\"l_foot\")!= std::string::npos || link2.find(\"l_foot\")!= std::string::npos) {\n\t\t\tfoot_contact_states_[0] = true;\n\t\t}\n\t\tif (link1.find(\"r_foot\")!= std::string::npos || link2.find(\"r_foot\")!= std::string::npos) {\n\t\t\tfoot_contact_states_[1] = true;\n\t\t}\n\t\tif (link1.find(\"l_hand\")!= std::string::npos || link2.find(\"l_hand\")!= std::string::npos) {\n\t\t\tfoot_contact_states_[2] = true;\n\t\t}\n\t\tif (link1.find(\"r_hand\")!= std::string::npos || link2.find(\"r_hand\")!= std::string::npos) {\n\t\t\tfoot_contact_states_[3] = true;\n\t\t}\n\t}\n}", "CodeBleu_score": 40.60755870532931}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t\tfootContactState_.leftFootContact = false;\n\tfootContactState_.rightFootContact = false;\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\tstd::vector<std::string> collision = split(_msg->contact(i).collision1(), \"::\");\n\t\tif (collision.size() > 1) {\n\t\t\tif (collision[1] == \"left_sole\") {\n\t\t\t\tfootContactState_.leftFootContact = true;\n\t\t\t} else if (collision[1] == \"right_sole\") {\n\t\t\t\tfootContactState_.rightFootContact = true;\n\t\t\t}\n\t\t}\n\t\tcollision = split(_msg->contact(i).collision2(), \"::\");\n\t\tif (collision.size() > 1) {\n\t\t\tif (collision[1] == \"left_sole\") {\n\t\t\t\tfootContactState_.leftFootContact = true;\n\t\t\t} else if (collision[1] == \"right_sole\") {\n\t\t\t\tfootContactState_.rightFootContact = true;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 39.29806194610246}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kRotorCount);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis.\n  Eigen::Vector3d thrust_B = vehicle_parameters_.mass_ * acceleration;\n  double thrust = thrust_B.dot(Eigen::Vector3d::UnitZ());\n\n  // Combine thrust and angular acceleration.\n  Eigen::Vector3d acc_B = thrust_B + vehicle_parameters_.inertia_ * angular_acceleration;\n\n  // Transform acceleration to rotor velocities.\n  Eigen::VectorXd rotor_velocities_tmp = rotor_velocity_matrix_ * acc_B;\n\n  // Ensure non-negative velocities.\n  for (int i = 0; i < kRotorCount; ++i) {\n    if (rotor_velocities_tmp[i] < 0) {\n      rotor_velocities_tmp[i] = 0;\n    }\n  }\n\n  // Take square root.\n  *rotor_velocities = rotor_velocities_tmp.cwiseSqrt();\n}", "CodeBleu_score": 55.56213851086043}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// Check if the controller is active.\n\tif (!controller_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Compute the desired acceleration and angular acceleration.\n\tEigen::Vector3d acceleration;\n\tComputeDesiredAcceleration(&acceleration);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n\t// Project thrust onto the body z-axis.\n\tEigen::Vector3d thrust_W = vehicle_parameters_.mass_ * acceleration;\n\tEigen::Vector3d thrust_B = odometry_.orientation.toRotationMatrix().transpose() * thrust_W;\n\tthrust_B[2] = std::max(thrust_B[2], 0.0);\n\n\t// Combine thrust and angular acceleration.\n\tEigen::Vector3d acceleration_B;\n\tacceleration_B << angular_acceleration, thrust_B[2];\n\n\t// Compute the rotor velocities.\n\t*rotor_velocities = rotor_velocity_matrix_ * acceleration_B;\n\t*rotor_velocities = rotor_velocities->cwiseSqrt();\n}", "CodeBleu_score": 51.38022463141879}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t//  assert(rotor_velocities);\n//  assert(rotor_velocities->size() == kRotorCount);\n\n  if (!controller_active_ ||!is_initialized_ ||!is_flying_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kRotorCount);\n    return;\n  }\n\n  // Calculate the desired acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z-axis.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d thrust_W = vehicle_parameters_.mass_ * (acceleration + vehicle_parameters_.gravity_ * Eigen::Vector3d::UnitZ());\n  Eigen::Vector3d thrust_I = R_W_I.transpose() * thrust_W;\n\n  // Combine thrust and angular acceleration.\n  Eigen::Vector3d thrust_and_angular_acceleration;\n  thrust_and_angular_acceleration << thrust_I, angular_acceleration;\n\n  // Calculate rotor velocities.\n  *rotor_velocities = rotor_configuration_.rotor_direction_ * rotor_configuration_.rotor_velocity_constant_\n                       * thrust_and_angular_acceleration;\n\n  // Ensure non-negative values.\n  for (int i = 0; i < kRotorCount; ++i) {\n    if ((*rotor_velocities)(i) < 0.0) {\n      *rotor_velocities = Eigen::VectorXd::Zero(kRotorCount);\n      return;\n    }\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_configuration_.rotor_direction_ * rotor_configuration_.rotor_velocity_constant_\n                       * thrust_and_angular_acceleration.cwiseSqrt();\n}", "CodeBleu_score": 52.74035992708672}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position error\n\tEigen::Vector3d position_error = command_trajectory_.pose().translation() - odometry_.pose().translation();\n\n\t// Compute the velocity error\n\tEigen::Vector3d velocity_error = command_trajectory_.velocity() - odometry_.velocity();\n\n\t// Transform the velocity error to the world frame\n\tEigen::Vector3d velocity_error_world = odometry_.pose().rotation() * velocity_error;\n\n\t// Compute the desired acceleration\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_world;\n\n\t// Adjust for vehicle mass, gravity, and commanded acceleration\n\t*acceleration += Eigen::Vector3d(0, 0, -gravity_ * mass_);\n\t*acceleration += command_trajectory_.acceleration();\n}", "CodeBleu_score": 38.3040211627094}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position error.\n\tEigen::Vector3d position_error = command_trajectory_.position() - odometry_.position();\n\n\t// Compute the velocity error.\n\tEigen::Vector3d velocity_error = command_trajectory_.velocity() - odometry_.velocity();\n\n\t// Transform the velocity error to the world frame.\n\tEigen::Vector3d velocity_error_world = odometry_.orientation().inverse() * velocity_error;\n\n\t// Compute the desired acceleration.\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_world;\n\n\t// Adjust for vehicle mass, gravity, and commanded acceleration.\n\t*acceleration -= odometry_.orientation().inverse() * (gravity_ * Eigen::Vector3d::UnitZ() + odometry_.acceleration());\n}", "CodeBleu_score": 37.36927420281494}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t\t// Compute the position and velocity errors.\n\tEigen::Vector3d position_error = command_trajectory_.EvaluatePoint(current_time_) - current_pose_.translation();\n\tEigen::Vector3d velocity_error = command_trajectory_.EvaluateDerivative(current_time_, 1) - current_velocity_;\n\n\t// Transform the vehicle's velocity to the world frame.\n\tEigen::Vector3d velocity_world = current_pose_.rotation() * current_velocity_;\n\n\t// Compute the desired acceleration.\n\t*acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error + mass_ * gravity_ * Eigen::Vector3d::UnitZ() + command_trajectory_.EvaluateDerivative(current_time_, 2);\n}", "CodeBleu_score": 37.893627875708304}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\tassert(rotor_velocities->size() == 4);\n\n\tEigen::Vector3d angular_acceleration(Eigen::Vector3d::Zero());\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\tEigen::Vector4d angular_acceleration_thrust_reference(Eigen::Vector4d::Zero());\n\tangular_acceleration_thrust_reference.head<3>() = angular_acceleration;\n\tangular_acceleration_thrust_reference[3] = control_attitude_thrust_reference_(3);\n\n\tEigen::Matrix<double, 4, 4> rotor_matrix;\n\trotor_matrix << 0.0, 1.0, 1.0, 0.0,\n\t\t\t\t\t 1.0, 0.0, 0.0, 1.0,\n\t\t\t\t\t 1.0, 1.0, 0.0, 0.0,\n\t\t\t\t\t 0.0, 0.0, 1.0, 1.0;\n\n\tEigen::Vector4d rotor_velocities_vector = rotor_matrix * angular_acceleration_thrust_reference;\n\n\tfor (int i = 0; i < rotor_velocities_vector.size(); i++) {\n\t\tif (rotor_velocities_vector[i] < 1.0) {\n\t\t\trotor_velocities_vector[i] = 1.0;\n\t\t}\n\t\trotor_velocities_vector[i] = sqrt(rotor_velocities_vector[i]);\n\t}\n\n\t*rotor_velocities = rotor_velocities_vector;\n}", "CodeBleu_score": 46.649366608513276}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\t// get desired angular acceleration\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\t// combine desired angular acceleration and thrust reference into a single vector\n\tEigen::VectorXd desired_acceleration_thrust(4);\n\tdesired_acceleration_thrust << angular_acceleration, control_attitude_thrust_reference_(3);\n\n\t// calculate rotor velocities\n\t*rotor_velocities = rotors_matrix_ * desired_acceleration_thrust;\n\n\t// ensure rotor velocities are at least one\n\t*rotor_velocities = (*rotor_velocities).cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->size()));\n\n\t// take the square root of each component\n\t*rotor_velocities = (*rotor_velocities).cwiseSqrt();\n}", "CodeBleu_score": 53.14540495045335}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\t\tassert(rotor_velocities);\n\n\tEigen::Vector3d angular_acceleration;\n\tComputeDesiredAngularAcc(&angular_acceleration);\n\n\tEigen::Vector4d desired_acc;\n\tdesired_acc << angular_acceleration(0), angular_acceleration(1), angular_acceleration(2), control_attitude_thrust_reference_(3);\n\n\tEigen::Matrix4d rotor_velocities_mat = Eigen::Matrix4d::Zero();\n\trotor_velocities_mat.block(0, 0, 3, 3) = inertia_.inverse();\n\trotor_velocities_mat.block(0, 3, 3, 1) = -1 * inertia_.inverse() * moment_of_inertia_offset_;\n\trotor_velocities_mat.block(3, 0, 1, 3) = moment_of_inertia_offset_.transpose() * inertia_.inverse();\n\trotor_velocities_mat(3, 3) = -1 * moment_of_inertia_offset_.transpose() * inertia_.inverse() * moment_of_inertia_offset_;\n\n\tEigen::Vector4d rotor_velocities_vec = rotor_velocities_mat * desired_acc;\n\n\trotor_velocities_vec = rotor_velocities_vec.cwiseMax(Eigen::Vector4d::Constant(1));\n\trotor_velocities_vec = rotor_velocities_vec.cwiseSqrt();\n\n\t*rotor_velocities = rotor_velocities_vec;\n}", "CodeBleu_score": 47.53206018071418}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = self.time[start_index:end_index]\n    sliced_object.data = self.data[start_index:end_index]\n    sliced_object.metadata = self.metadata\n    return sliced_object", "CodeBleu_score": 31.991831031811046}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_object = copy.deepcopy(self)\n    for attr in copied_object.__dict__:\n        if isinstance(copied_object.__dict__[attr], np.ndarray):\n            copied_object.__dict__[attr] = copied_object.__dict__[attr][start_index:end_index]\n    return copied_object\n\n", "CodeBleu_score": 34.73411475304863}, {"code": "def slice(self, start_time, end_time)\n\t\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = sliced_object.time[start_index:end_index]\n    sliced_object.data = sliced_object.data[start_index:end_index]\n    sliced_object.error = sliced_object.error[start_index:end_index]\n    sliced_object.flag = sliced_object.flag[start_index:end_index]\n    return sliced_object\n\n", "CodeBleu_score": 27.435275449413766}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    # Extract the position and rotation\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert the rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion(\n        [rotation.x, rotation.y, rotation.z, rotation.w]\n    )\n    # Create a Point object\n    point = Point(position.x, position.y, position.z, euler[2])\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or (\n        self.last_point.x!= point.x\n        or self.last_point.y!= point.y\n        or self.last_point.yaw!= point.yaw\n    ):\n        # Append the new point, yaw, and corresponding times\n        self.append_point(point)\n        self.yaw = numpy.append(self.yaw, point.yaw)\n        self.append_times(msg_time, bag_time)\n        # Update the last_point variable\n        self.last_point = point\n\n", "CodeBleu_score": 29.955452854472313}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    self.append_point(waypoint_msg.pose.position)\n    self.yaw = numpy.append(self.yaw, tf.transformations.euler_from_quaternion(\n        [waypoint_msg.pose.orientation.x, waypoint_msg.pose.orientation.y, waypoint_msg.pose.orientation.z, waypoint_msg.pose.orientation.w])[2])\n    self.append_times(msg_time, bag_time)\n    if self.is_different(waypoint_msg.pose.position, self.yaw[-1]):\n        self.x = numpy.append(self.x, waypoint_msg.pose.position.x)\n        self.y = numpy.append(self.y, waypoint_msg.pose.position.y)\n        self.z = numpy.append(self.z, waypoint_msg.pose.position.z)\n        self.yaw = numpy.append(self.yaw, tf.transformations.euler_from_quaternion(\n            [waypoint_msg.pose.orientation.x, waypoint_msg.pose.orientation.y, waypoint_msg.pose.orientation.z, waypoint_msg.pose.orientation.w])[2])\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 28.18942747645889}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\t\n    self.append_point(waypoint_msg.pose.position)\n    self.append_times(msg_time, bag_time)\n\n    # Get the yaw from the quaternion\n    quaternion = (\n        waypoint_msg.pose.orientation.x,\n        waypoint_msg.pose.orientation.y,\n        waypoint_msg.pose.orientation.z,\n        waypoint_msg.pose.orientation.w,\n    )\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    yaw = euler[2]\n\n    # Check if the current waypoint is different from the last one\n    if (\n        self.x[-1]!= waypoint_msg.pose.position.x\n        or self.y[-1]!= waypoint_msg.pose.position.y\n        or self.yaw[-1]!= yaw\n    ):\n        # Append the yaw and the time\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.yaw_time = numpy.append(self.yaw_time, msg_time)\n\n        # Create a Point object\n        point = Point(\n            waypoint_msg.pose.position.x,\n            waypoint_msg.pose.position.y,\n            waypoint_msg.pose.position.z,\n            yaw,\n        )\n\n        # Append the point to the list\n        self.points.append(point)\n", "CodeBleu_score": 26.13550551001871}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == '/imu/data':\n        self.imu_linear_accel_x.append_data(msg.linear_acceleration.x, bag_time)\n        self.imu_linear_accel_y.append_data(msg.linear_acceleration.y, bag_time)\n        self.imu_linear_accel_z.append_data(msg.linear_acceleration.z, bag_time)\n    elif topic == '/imu/data_raw':\n        self.imu_linear_accel_x.append_data(msg.linear_acceleration.x, bag_time)\n        self.imu_linear_accel_y.append_data(msg.linear_acceleration.y, bag_time)\n        self.imu_linear_accel_z.append_data(msg.linear_acceleration.z, bag_time)\n    elif topic == '/imu_filtered':\n        self.imu_linear_accel_x.append_data(msg.linear_acceleration.x, bag_time)\n        self.imu_linear_accel_y.append_data(msg.linear_acceleration.y, bag_time)\n        self.imu_linear_accel_z.append_data(msg.linear_acceleration.z, bag_time)\n\n", "CodeBleu_score": 23.89835816891277}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_linear_acceleration_x.append_times(msg.linear_acceleration.x, bag_time)\n        self.imu_linear_acceleration_y.append_times(msg.linear_acceleration.y, bag_time)\n        self.imu_linear_acceleration_z.append_times(msg.linear_acceleration.z, bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.imu_raw_linear_acceleration_x.append_times(msg.linear_acceleration.x, bag_time)\n        self.imu_raw_linear_acceleration_y.append_times(msg.linear_acceleration.y, bag_time)\n        self.imu_raw_linear_acceleration_z.append_times(msg.linear_acceleration.z, bag_time)\n    elif topic == \"/imu/mag\":\n        self.imu_mag_x.append_times(msg.magnetic_field.x, bag_time)\n        self.imu_mag_y.append_times(msg.magnetic_field.y, bag_time)\n        self.imu_mag_z.append_times(msg.magnetic_field.z, bag_time)\n    elif topic == \"/imu/mag_raw\":\n        self.imu_raw_mag_x.append_times(msg.magnetic_field.x, bag_time)\n        self.imu_raw_mag_y.append_times(msg.magnetic_field.y, bag_time)\n        self.imu_raw_mag_z.append_times(msg.magnetic_field.z, bag_time)\n    elif topic == \"/imu/temp\":\n        self.imu_temp.append_times(msg.temperature, bag_time)\n\n", "CodeBleu_score": 21.12029350557984}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\t\n    if topic == \"/imu/data\":\n        self.imu_linear_acceleration.append_x(msg.linear_acceleration.x, bag_time)\n        self.imu_linear_acceleration.append_y(msg.linear_acceleration.y, bag_time)\n        self.imu_linear_acceleration.append_z(msg.linear_acceleration.z, bag_time)\n        self.imu_linear_acceleration.append_times(msg.header.stamp.to_sec(), bag_time)\n    elif topic == \"/imu/data_raw\":\n        self.imu_linear_acceleration_raw.append_x(msg.linear_acceleration.x, bag_time)\n        self.imu_linear_acceleration_raw.append_y(msg.linear_acceleration.y, bag_time)\n        self.imu_linear_acceleration_raw.append_z(msg.linear_acceleration.z, bag_time)\n        self.imu_linear_acceleration_raw.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 28.36508324248132}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.save_plots:\n        plot_suffix = plot_suffix if plot_suffix is not None else ''\n        filename = f'{self.plot_prefix}_{plot_suffix}.png'\n        plt.figure(figsize=(10, 6))\n        plt.title('Accelerations')\n        for i, (name, data) in enumerate(self.accelerations.items()):\n            plt.subplot(3, 1, i + 1)\n            plt.plot(data['x'], label='x')\n            plt.plot(data['y'], label='y')\n            plt.plot(data['z'], label='z')\n            plt.ylabel(name)\n            plt.legend()\n        plt.xlabel('Time (s)')\n        plt.tight_layout()\n        plt.savefig(filename)\n        plt.close()\n\n", "CodeBleu_score": 37.24572049430573}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    # Create a figure with a title\n    fig, ax = plt.subplots()\n    fig.suptitle('Accelerations')\n\n    # Create a subplot for accelerations\n    ax.plot(self.time, self.accelerations[:, 0], label='x')\n    ax.plot(self.time, self.accelerations[:, 1], label='y')\n    ax.plot(self.time, self.accelerations[:, 2], label='z')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, save the plot as a PNG file\n    if self.save_plots:\n        filename = f'accelerations{plot_suffix}.png'\n        plt.savefig(os.path.join(self.save_plots_dir, filename))\n\n    # Show the plot\n    plt.show()\n\n", "CodeBleu_score": 28.45824823051661}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        plot_filename = self.plot_prefix + \"_accelerations\" + plot_suffix + \".png\"\n        print(\"Saving plot to\", plot_filename)\n        plt.savefig(plot_filename)\n    else:\n        plt.show()\n\n", "CodeBleu_score": 19.336850892998335}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    if len(pose_indeces) < 2:\n        print(\"Error: compare_positions requires at least two pose indices to perform comparisons.\")\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            compare_two_xyz(self.get_pose_position(pose_indeces[i]), self.get_pose_position(pose_indeces[j]))\n\n", "CodeBleu_score": 43.22560401519058}, {"code": "def compare_positions(self, pose_indeces)\n\t\n    # TODO(ff): Implement some position comparison\n    pass\n\n", "CodeBleu_score": 2.8645833333333344}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if time >= start_time and time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 36.88690027153799}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 35.848869058795394}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\t\n    collision_times = []\n    for time in self.wrench:\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n\n", "CodeBleu_score": 32.146680046322444}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\t\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.7731933299838}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t\tif (data == nullptr) {\n\t\treturn;\n\t}\n\tconst float multiplier = this->GetMultiplier(width, height);\n\tEigen::Map<Eigen::VectorXf> data_map(data, width * height);\n\tconst float rms_noise = this->GetRMSNoise(width, height);\n\tEigen::VectorXf noise_values = this->GetNoiseValues(width, height, rms_noise);\n\tfor (uint32_t i = 0; i < width * height; i++) {\n\t\tif (this->InRange(data_map[i])) {\n\t\t\tdata_map[i] += noise_values[i] * multiplier;\n\t\t} else {\n\t\t\tdata_map[i] = this->bad_point;\n\t\t}\n\t}\n}", "CodeBleu_score": 48.672303116138046}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t#ifdef USE_OPENMP\n#pragma omp parallel for\n#endif\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (data[i] == 0.0f) {\n      continue;\n    }\n    float depth = data[i] * 0.001f;\n    if (!InRange(depth)) {\n      data[i] = 0.0f;\n      continue;\n    }\n    float noise = this->noise_multiplier * this->rms_noise *\n                  this->distribution(this->generator);\n    data[i] += noise;\n  }\n}", "CodeBleu_score": 31.745446699803313}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\t#ifdef _DEBUG\n  if (data == nullptr) {\n    return;\n  }\n#endif\n  // Calculate multiplier based on camera parameters\n  const float multiplier = 1.0f / this->depth_scale;\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n  // Compute RMS noise\n  const float rms_noise = this->GetRmsNoise(width, height);\n  // Compute noise values\n  const float noise_value = rms_noise * multiplier;\n  // For each pixel, add noise if in range, otherwise set to bad point value\n  for (uint32_t i = 0; i < width * height; ++i) {\n    const float depth = data_vec[i];\n    if (this->InRange(depth)) {\n      data_vec[i] += noise_value;\n    } else {\n      data_vec[i] = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 52.52145990803194}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time and convert it to ROS time\n\tgazebo::common::Time current_sim_time = world_->GetSimTime();\n\tros::Time current_ros_time(current_sim_time.sec, current_sim_time.nsec);\n\n\t// Write the trajectory message to the bag file using the specified namespace and waypoint topic\n\twaypoint_bag_.write(waypoint_topic_ns_, current_ros_time, *trajectory_msg);\n}", "CodeBleu_score": 50.94615916436385}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t\t// Get the current simulation time and convert it to ROS time\n\tros::Time ros_time = ros::Time::now();\n\n\t// Write the trajectory message to the bag file using the specified namespace and waypoint topic\n\tif (trajectory_msg->header.frame_id == \"world\") {\n\t\twaypoint_bag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n\t}\n}", "CodeBleu_score": 39.634460151431064}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t//  ROS_INFO(\"WaypointCallback\");\n  if (trajectory_msg->header.stamp.sec == 0 &&\n      trajectory_msg->header.stamp.nsec == 0) {\n    ROS_ERROR(\"WaypointCallback: trajectory_msg->header.stamp is zero!\");\n    return;\n  }\n\n  // Convert Gazebo time to ROS time.\n  ros::Time ros_time;\n  ros_time.sec = trajectory_msg->header.stamp.sec;\n  ros_time.nsec = trajectory_msg->header.stamp.nsec;\n\n  // Write the trajectory message to the bag file.\n  bag_.write(waypoint_topic_, ros_time, *trajectory_msg);\n}", "CodeBleu_score": 35.90572222270507}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// convert simulation time to ROS time\n\tros::Time t = ros::Time(now.sec, now.nsec);\n\n\t// prepare message\n\tmav_msgs::Actuators msg;\n\tmsg.angular_velocities.resize(motor_joint_names_.size());\n\n\t// iterate through the motor joints\n\tfor (int i = 0; i < motor_joint_names_.size(); i++) {\n\t\t// calculate slowed-down rotational velocities\n\t\tdouble velocity = motor_joint_controllers_[i]->GetVelocity(0);\n\t\tvelocity = velocity * motor_velocity_slowdown_factors_[i];\n\n\t\t// assign to message\n\t\tmsg.angular_velocities[i] = velocity;\n\t}\n\n\t// set message timestamp\n\tmsg.header.stamp = t;\n\n\t// write to bag file\n\tmotor_velocity_bag_file_.write(motor_velocity_bag_namespace_ + \"/motor_velocity\", t, msg);\n}", "CodeBleu_score": 52.58975076457325}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\tros::Time t = ros::Time(now.sec, now.nsec);\n\n\t// Create a message for the actuator velocities\n\tmav_msgs::ActuatorsPtr actuator_velocities_msg(new mav_msgs::Actuators);\n\n\t// Iterate through the motor joints\n\tfor (unsigned int i = 0; i < motor_joints_.size(); i++) {\n\t\t// Get the current joint's rotational velocity\n\t\tdouble joint_velocity = motor_joints_[i]->GetVelocity(0);\n\n\t\t// Calculate the slowed-down rotational velocity\n\t\tdouble slowed_down_joint_velocity = joint_velocity / motor_velocity_slowdown_factor_;\n\n\t\t// Assign the slowed-down rotational velocity to the message\n\t\tactuator_velocities_msg->angular_velocities.push_back(slowed_down_joint_velocity);\n\t}\n\n\t// Set the message timestamp\n\tactuator_velocities_msg->header.stamp = t;\n\n\t// Write the message to the bag file\n\tmotor_velocity_bag_.write(motor_velocity_topic_, actuator_velocities_msg);\n}", "CodeBleu_score": 45.17436146217947}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t\t// Convert simulation time to ROS time\n\tros::Time t(now.sec, now.nsec);\n\n\t// Prepare message for actuator velocities\n\tmav_msgs::Actuators msg;\n\tmsg.angular_velocities.resize(num_motors_);\n\n\t// Iterate through motor joints\n\tfor (int i = 0; i < num_motors_; i++) {\n\t\t// Calculate slowed-down rotational velocities\n\t\tdouble rot_vel = motor_joint_ptrs_[i]->GetVelocity(0);\n\t\tdouble vel = rot_vel * rotor_speed_ratio_;\n\n\t\t// Assign to message\n\t\tmsg.angular_velocities[i] = vel;\n\t}\n\n\t// Set message timestamp\n\tmsg.header.stamp = t;\n\n\t// Write data to bag file\n\tmotor_vel_bag_.write(motor_vel_topic_, msg);\n}", "CodeBleu_score": 40.07832054903301}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called\"\n        << std::endl;\n#endif\n  // Set control surface angles from normalized roll, pitch, and yaw rate\n  // inputs\n  control_surfaces_.aileron_angle = NormalizedInputToAngle(\n      control_surfaces_.aileron, roll_pitch_yawrate_thrust_msg->roll_input);\n  control_surfaces_.elevator_angle = NormalizedInputToAngle(\n      control_surfaces_.elevator, roll_pitch_yawrate_thrust_msg->pitch_input);\n  control_surfaces_.rudder_angle = NormalizedInputToAngle(\n      control_surfaces_.rudder, roll_pitch_yawrate_thrust_msg->yaw_rate_input);\n\n  // Set throttle from thrust input\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust_input;\n}", "CodeBleu_score": 44.750568076051565}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#if GAZEBO_FW_DYNAMICS_PLUGIN_DEBUG\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called.\n\";\n#endif\n  // Set the control surface angles from the normalized input values.\n  control_surface_angles_.aileron = NormalizedInputToAngle(\n      control_surfaces_.aileron, roll_pitch_yawrate_thrust_msg->roll);\n  control_surface_angles_.elevator = NormalizedInputToAngle(\n      control_surfaces_.elevator, roll_pitch_yawrate_thrust_msg->pitch);\n  control_surface_angles_.rudder = NormalizedInputToAngle(\n      control_surfaces_.rudder, roll_pitch_yawrate_thrust_msg->yaw_rate);\n  // Set the throttle value.\n  throttle_ = roll_pitch_yawrate_thrust_msg->thrust;\n}", "CodeBleu_score": 41.8816219073475}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t#ifdef DEBUG_PRINT\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called\"\n        << std::endl;\n#endif\n  // Convert normalized input to control surface angles.\n  double aileron_angle =\n      NormalizedInputToAngle(control_surfaces_.aileron,\n                             roll_pitch_yawrate_thrust_msg->roll);\n  double elevator_angle =\n      NormalizedInputToAngle(control_surfaces_.elevator,\n                             roll_pitch_yawrate_thrust_msg->pitch);\n  double rudder_angle =\n      NormalizedInputToAngle(control_surfaces_.rudder,\n                             roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set control surface angles.\n  control_surface_joint_controller_->SetJointPositions(\n      aileron_angle, elevator_angle, rudder_angle);\n\n  // Set throttle.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n  if (throttle < 0.0) {\n    throttle = 0.0;\n  } else if (throttle > 1.0) {\n    throttle = 1.0;\n  }\n  throttle_joint_controller_->SetJointPosition(throttle);\n}", "CodeBleu_score": 37.55571680936441}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tfdef __MACH__\n  // OSX does not have a timespec, so we have to use timeval\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n#else\n  struct timespec timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_nsec = (_timeoutMs % 1000) * 1000000;\n#endif\n\n  // Check for new data\n  int pret = poll(&fd_, 1, _timeoutMs);\n  if (pret < 0) {\n    if (errno!= EINTR) {\n      PX4_ERR(\"poll error %d, %s\", errno, strerror(errno));\n    }\n    return;\n  }\n\n  if (pret == 0) {\n    return;\n  }\n\n  // Receive data\n  uint8_t buf[1024];\n  ssize_t len = read(fd_.fd, buf, sizeof(buf));\n  if (len <= 0) {\n    if (errno!= EAGAIN && errno!= EWOULDBLOCK) {\n      PX4_ERR(\"read error %d, %s\", errno, strerror(errno));\n    }\n    return;\n  }\n\n  // Parse buffer\n  mavlink_message_t message;\n  mavlink_status_t status;\n\n  for (unsigned i = 0; i < (unsigned)len; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &message, &status)) {\n      if (serial_enabled_) {\n        // Forward message to serial port\n        send_mavlink_message(&message, 0);\n      }\n      handle_message(&message);\n    }\n  }\n}", "CodeBleu_score": 55.34981043918739}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t", "CodeBleu_score": 1.42558760589385}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tf GAZEBO_MAJOR_VERSION >= 9\n  if (this->new_data_) {\n    this->new_data_ = false;\n    return;\n  }\n#endif\n\n  // Poll for new data\n  struct timeval tv;\n  tv.tv_sec = 0;\n  tv.tv_usec = _timeoutMs * 1000;\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(this->fd_, &readfds);\n  int ret = select(this->fd_ + 1, &readfds, NULL, NULL, &tv);\n  if (ret < 0) {\n    gzerr << \"select failed, errno=\" << errno << \"\n\";\n    return;\n  } else if (ret == 0) {\n    // timeout\n    return;\n  }\n\n  // Receive data\n  uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n  ssize_t len = recvfrom(\n      this->fd_, buf, MAVLINK_MAX_PACKET_LEN, 0, NULL, NULL);\n  if (len <= 0) {\n    gzerr << \"recvfrom failed, errno=\" << errno << \"\n\";\n    return;\n  }\n\n  // Parse buffer\n  mavlink_message_t message;\n  mavlink_status_t status;\n\n  for (unsigned i = 0; i < len; ++i) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &message, &status)) {\n      if (serial_enabled_) {\n        // Forward message to serial port\n        uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n        int packetlen = mavlink_msg_to_send_buffer(buffer, &message);\n\n        ssize_t len = write(this->serial_fd_, buffer, packetlen);\n        if (len <= 0) {\n          gzerr << \"Failed sending mavlink message\n\";\n        }\n      }\n\n      // Handle message\n      handle_message(&message);\n    }\n  }\n}", "CodeBleu_score": 52.44284828523465}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::unique_lock<boost::mutex> lock(this->serial_mutex);\n\n\tif (this->serial_open) {\n\t\tthis->io_service.stop();\n\t\tthis->serial_open = false;\n\t\tthis->serial_port.close();\n\n\t\tif (this->io_thread.joinable()) {\n\t\t\tthis->io_thread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 28.26373643973852}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tif (this->isOpen()) {\n\t\tthis->io_service.stop();\n\t\tthis->serial_device.close();\n\t\tif (this->io_thread.joinable()) {\n\t\t\tthis->io_thread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 31.64721938272843}, {"code": "void GazeboMavlinkInterface::close() {\n\t\tboost::unique_lock<boost::mutex> lock(this->io_service_mutex);\n\tif (this->is_open) {\n\t\tthis->is_open = false;\n\t\tthis->io_service.stop();\n\t\tthis->serial_device->close();\n\t\tif (this->io_thread.joinable()) {\n\t\t\tthis->io_thread.join();\n\t\t}\n\t}\n}", "CodeBleu_score": 28.701185902843783}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d pos,\n\tignition::math::Vector3d pos1,\n\tignition::math::Vector3d pos2,\n\tignition::math::Vector3d val1,\n\tignition::math::Vector3d val2\n}", "CodeBleu_score": 15.578636935879}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\tignition::math::Vector3d position,\n\tignition::math::Vector3d position1,\n\tignition::math::Vector3d position2,\n\tignition::math::Vector3d value1,\n\tignition::math::Vector3d value2\n}", "CodeBleu_score": 16.89248882253368}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\t\t(ignition::math::Vector3d pos, ignition::math::Vector3d p1, ignition::math::Vector3d p2, ignition::math::Vector3d v1, ignition::math::Vector3d v2) {\n\t\tignition::math::Vector3d result;\n\t\tdouble alpha = (pos.X() - p1.X()) / (p2.X() - p1.X());\n\t\tresult.X(v1.X() + alpha * (v2.X() - v1.X()));\n\t\tresult.Y(v1.Y() + alpha * (v2.Y() - v1.Y()));\n\t\tresult.Z(v1.Z() + alpha * (v2.Z() - v1.Z()));\n\t\treturn result;\n\t}\n}", "CodeBleu_score": 30.9312814258718}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\t\tif (_time < 0.0)\n\t\t_time = 0.0;\n\telse if (_time > m_length)\n\t\t_time = m_length;\n\n\tif (m_time!= _time) {\n\t\tm_time = _time;\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 29.55577508203256}, {"code": "void Animation::SetTime(double _time){\n\t\tif (m_time!= _time) {\n\t\tm_time = _time;\n\t\tif (m_loop) {\n\t\t\twhile (m_time > m_length) {\n\t\t\t\tm_time -= m_length;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (m_time > m_length) {\n\t\t\t\tm_time = m_length;\n\t\t\t}\n\t\t\telse if (m_time < 0) {\n\t\t\t\tm_time = 0;\n\t\t\t}\n\t\t}\n\t\tUpdate();\n\t}\n}", "CodeBleu_score": 35.78731627685998}, {"code": "void Animation::SetTime(double _time){\n\t\tif (_time!= m_time) {\n\t\tm_time = _time;\n\t\tm_dirty = true;\n\n\t\tif (m_loop) {\n\t\t\tif (m_time >= m_length) {\n\t\t\t\tm_time = fmod(m_time, m_length);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (m_time < 0.0) {\n\t\t\t\tm_time = 0.0;\n\t\t\t}\n\t\t\telse if (m_time >= m_length) {\n\t\t\t\tm_time = m_length;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.390621607858606}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_local_position.x, y=self.current_local_position.y, z=self.current_local_position.z, yaw=self.current_local_position.yaw)\n    self.send_target_pose(target_raw_pose)\n    print(\"Vehicle type: %s, Vehicle ID: %s, Flight Mode: %s\" % (self.vehicle_type, self.vehicle_id, self.flight_mode))\n", "CodeBleu_score": 58.159183608537155}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_raw_pose = self.construct_target(x=self.current_position.x_val, y=self.current_position.y_val, z=self.current_position.z_val, yaw=self.current_yaw)\n    print(\"Vehicle Type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + str(self.flight_mode))\n", "CodeBleu_score": 63.09810241368179}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_local_position.x, y=self.current_local_position.y, z=self.current_local_position.z, yaw=self.current_attitude.yaw)\n    self.set_target_pose(target_raw_pose)\n    print(\"Vehicle Type: \" + self.vehicle_type + \"", "CodeBleu_score": 61.16520063006896}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = 'HOVER'\n            self.flight_mode_service(custom_mode='HOVER')\n            self.flight_mode = 'MANUAL'\n            self.flight_mode_service(custom_mode='MANUAL')\n            self.flight_mode = 'STABILIZE'\n            self.flight_mode_service(custom_mode='STABILIZE')\n            self.flight_mode = 'GUIDED'\n            self.flight_mode_service(custom_mode='GUIDED')\n            self.flight_mode = 'AUTO'\n            self.flight_mode_service(custom_mode='AUTO')\n            self.flight_mode = 'RTL'\n            self.flight_mode_service(custom_mode='RTL')\n            self.flight_mode = 'LOITER'\n            self.flight_mode_service(custom_mode='LOITER')\n            self.flight_mode = 'LAND'\n            self.flight_mode_service(custom_mode='LAND')\n            self.flight_mode = 'TAKEOFF'\n            self.flight_mode_service(custom_mode='TAKEOFF')\n            self.flight_mode = 'POSCTL'\n            self.flight_mode_service(custom_mode='POSCTL')\n            self.flight_mode = 'OFFBOARD'\n            self.flight_mode_service(custom_mode='OFFBOARD')\n            self.flight_mode = 'ACRO'\n            self.flight_mode_service(custom_mode='ACRO')\n            self.flight_mode = 'RATTITUDE'\n            self.flight_mode_service(custom_mode='RATTITUDE')\n            self.flight_mode = 'ALTCTL'\n            self.flight_mode_service(custom_mode='ALTCTL')\n            self.flight_mode = 'POSHOLD'\n            self.flight_mode_service(custom_mode='POSHOLD')\n            self.flight_mode = 'BRAKE'\n            self.flight_mode_service(custom_mode='BRAKE')\n            self.flight_mode = 'CIRCLE'\n            self.flight_mode_service(custom_mode='CIRCLE')\n            self.flight_mode = 'FOLLOWME'\n            self.flight_mode_service", "CodeBleu_score": 22.79487982767801}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\": switched to \"+self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 56.41954220713012}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        # Switch to the flight mode\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return False\n", "CodeBleu_score": 56.52084896846332}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, vel_type='enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 68.17044711515099}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 67.37959509180317}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z, yaw_rate=msg.angular.z)\n", "CodeBleu_score": 67.37959509180317}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= \"HOVER\":\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover()\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 71.09215828623712}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if self.flight_mode!= 'HOVER':\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.coordinate_frame = 1\n            self.motion_type = 0\n            self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                       z=self.current_position.z, yaw=self.current_yaw)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.coordinate_frame = 1\n            self.motion_type = 0\n            self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                       z=self.current_position.z, yaw=self.current_yaw)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    else:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.coordinate_frame = 1\n            self.motion_type = 0\n            self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                       z=self.current_position.z, yaw=self.current_yaw)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.coordinate_frame = 1\n            self.motion_type = 0\n            self.target_motion = self.construct_target(x", "CodeBleu_score": 61.452419915552234}, {"code": "def hover_state_transition(self, x, y, z, w)\n\t\n    if (abs(x) > 0.02) or (abs(y) > 0.02) or (abs(z) > 0.02) or (abs(w) > 0.005):\n        self.hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    elif self.flight_mode!= \"HOVER\" and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.flight_mode = \"HOVER\"\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 32.18669593054404}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw_pitch_roll[0]\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw_pitch_roll[0]\n\n", "CodeBleu_score": 26.04957448605886}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n\t\n    if isinstance(q, Quaternion):\n        return q.yaw()\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw()\n\n", "CodeBleu_score": 19.828110469756748}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_local_position.pose.position.x, y=self.current_local_position.pose.position.y, z=self.current_local_position.pose.position.z, yaw=self.current_local_position.pose.orientation.z)\n    self.set_target_raw_pose(target_raw_pose)\n    print(\"Vehicle Type: \" + str(self.vehicle_type))\n    print(\"Vehicle ID: \" + str(self.vehicle_id))\n    print(\"Flight Mode: \" + str(self.flight_mode))\n\n", "CodeBleu_score": 41.035360352747986}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_LOCAL_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_local_position[0], y=self.current_local_position[1], z=self.current_local_position[2], yaw=self.current_local_position[3])\n    self.set_target_raw_pose(target_raw_pose)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n", "CodeBleu_score": 37.33137327205113}, {"code": "def hover(self)\n\t\n    self.coordinate_frame = PositionTarget.FRAME_BODY_NED\n    self.motion_type = 0\n    target_raw_pose = self.construct_target(x=self.current_local_position.pose.position.x, y=self.current_local_position.pose.position.y, z=self.current_local_position.pose.position.z, yaw=self.current_local_position.pose.orientation.yaw)\n    self.set_target_pose(target_raw_pose)\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.vehicle.mode.name)\n\n", "CodeBleu_score": 40.6826602364713}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + \"Failed to change flight mode: \" + str(e))\n            return False\n\n", "CodeBleu_score": 65.76074263230792}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(self.vehicle_type + '_' + self.vehicle_id + \": Flight mode switch failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 58.02683929618089}, {"code": "def flight_mode_switch(self)\n\t\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Service call failed: %s\" % e)\n            return False\n\n", "CodeBleu_score": 51.80122864183332}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n\t\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.position.z = self.takeoff_height\n            self.takeoff_target_pose.position.y = self.takeoff_target_pose.position.y + self.takeoff_bias_y\n            self.takeoff_target_pose.position.x = self.takeoff_target_pose.position.x + self.takeoff_bias_x\n        if self.gcs_command == \"hover\":\n            self.hover_target_pose = self.local_pose\n            self.hover_target_pose.position.z = self.hover_height\n            self.hover_target_pose.position.y = self.hover_target_pose.position.y + self.hover_bias_y\n            self.hover_target_pose.position.x = self.hover_target_pose.position.x + self.hover_bias_x\n        self.global_pose = self.local_pose\n        self.global_pose.position.x = self.local_pose.position.x + self.global_bias_x\n        self.global_pose.position.y = self.local_pose.position.y + self.global_bias_y\n        self.global_pose.position.z = self.local_pose.position.z + self.global_bias_z\n        self.global_pose.orientation = self.local_pose.orientation\n\n", "CodeBleu_score": 20.24789489256536}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.position.z = self.local_pose.pose.position.z + self.takeoff_bias\n        elif self.gcs_command == 'hover':\n            self.hover_target_pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.position.z = self.local_pose.pose.position.z + self.hover_bias\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.global_pose_bias[i][0]\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.global_pose_bias[i][1]\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.global_pose_bias[i][2]\n        self.global_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.global_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.global_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.global_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n\n", "CodeBleu_score": 22.034135999431147}, {"code": "def local_pose_callback(self, msg, i)\n\t\n    if msg.id == self.id:\n        self.local_pose = msg\n        self.local_pose.header.stamp = rospy.Time.now()\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose.position.x = self.local_pose.pose.position.x\n            self.takeoff_target_pose.position.y = self.local_pose.pose.position.y\n            self.takeoff_target_pose.position.z = self.local_pose.pose.position.z + self.takeoff_height\n            self.takeoff_target_pose.header.stamp = rospy.Time.now()\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose.position.x = self.local_pose.pose.position.x\n            self.hover_target_pose.position.y = self.local_pose.pose.position.y\n            self.hover_target_pose.position.z = self.local_pose.pose.position.z\n            self.hover_target_pose.header.stamp = rospy.Time.now()\n        self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.gps_bias.x\n        self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.gps_bias.y\n        self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.gps_bias.z\n        self.global_pose.header.stamp = rospy.Time.now()\n        self.global_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n        self.global_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n        self.global_pose.pose.orientation.z = self.local_pose.pose.orientation.z\n        self.global_pose.pose.orientation.w = self.local_pose.pose.orientation.w\n\n", "CodeBleu_score": 19.980112347927516}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\t\n    if self.vehicle.location.global_relative_frame.alt > 0.2 and self.vehicle.armed:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.95685276863904}, {"code": "def takeoff_detection(self)\n\t\n    if self.vehicle.armed and self.vehicle.location.global_relative_frame.alt > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 55.337351953608874}, {"code": "def takeoff_detection(self)\n\t\n    if self.vehicle.location.global_relative_frame.alt > 0.2 and self.vehicle.armed:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.95685276863904}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    orig_formation_list = []\n    change_formation_list = []\n    for i in range(len(orig_formation)):\n        orig_formation_list.append(orig_formation[i].get_position())\n    for i in range(len(change_formation)):\n        change_formation_list.append(change_formation[i].get_position())\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distance = np.linalg.norm(np.array(orig_formation_list[i]) - np.array(change_formation_list[j]))\n            distance_matrix[i, j] = int(50 - distance)\n    return distance_matrix\n\n", "CodeBleu_score": 22.49995136774887}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # build graph\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = 50 - np.linalg.norm(orig_formation[i] - change_formation[j])\n    dist_matrix = dist_matrix.astype(int)\n    return dist_matrix\n\n", "CodeBleu_score": 26.32512447150983}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t\n    # Initialize distance matrix\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Calculate pairwise distances between UAVs in the original and changed formations\n    for i, uav in enumerate(orig_formation):\n        for j, uav_ in enumerate(change_formation):\n            distance = np.linalg.norm(np.array(uav) - np.array(uav_))\n            distance_matrix[i, j] = int(50 - distance)\n    return distance_matrix\n\n", "CodeBleu_score": 24.962506462813195}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}, {"code": "def find_path(self, i)\n\t\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.33029434665332}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\t\n    self.match_right = [-1] * self.num_right\n    for i in range(self.num_left):\n        self.label_left[i] = 0\n        self.label_right[i] = max(self.adj_matrix[i])\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n        self.slack_right[i] = self.label_right[i]\n    for i in range(self.num_left):\n        while True:\n            self.visit_left[i] = True\n            j = 0\n            while j < self.num_right:\n                if self.visit_right[j]:\n                    j += 1\n                    continue\n                gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n                if gap == 0:\n                    self.visit_right[j] = True\n                    if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                        self.match_right[j] = i\n                        break\n                    else:\n                        j += 1\n                else:\n                    self.slack_right[j] = min(self.slack_right[j], gap)\n                    j += 1\n            if self.match_right[j]!= -1:\n                break\n            delta = self.INF\n            for j in range(self.num_right):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for j in range(self.num_left):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n            for j in range(self.num_right):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n            if self.match_right[j] == -1:\n                self.match_right[j] = i\n                break\n    return self.match_right\n", "CodeBleu_score": 28.4601286872729}, {"code": "def KM(self)\n\t\n    self.match_right = [-1] * len(self.adj_matrix[0])\n    for i in range(len(self.adj_matrix)):\n        self.label_left[i] = max(self.adj_matrix[i])\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n        self.slack_right[i] = INF\n    for i in range(len(self.adj_matrix)):\n        while True:\n            self.visit_left[i] = True\n            j = 0\n            while j < len(self.adj_matrix[0]):\n                if self.visit_right[j]:\n                    j += 1\n                    continue\n                gap = self.label_left[i] + self.label_right[j] - self.adj_matrix[i][j]\n                if gap == 0:\n                    self.visit_right[j] = True\n                    if self.match_right[j] == -1:\n                        break\n                    else:\n                        i = self.match_right[j]\n                        self.visit_left[i] = False\n                else:\n                    self.slack_right[j] = min(self.slack_right[j], gap)\n                j += 1\n            if j < len(self.adj_matrix[0]):\n                break\n            delta = INF\n            for j in range(len(self.adj_matrix[0])):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for j in range(len(self.adj_matrix[0])):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n            for j in range(len(self.adj_matrix[0])):\n                self.visit_left[j] = False\n                self.visit_right[j] = False\n    return self.match_right\n\n", "CodeBleu_score": 30.184842839601984}, {"code": "def KM(self)\n\t\n    for i in range(self.n_uavs):\n        self.slack_right = [sys.maxsize] * self.n_targets\n        self.visit_left = [False] * self.n_uavs\n        self.visit_right = [False] * self.n_targets\n        while True:\n            if self.find_path(i):\n                break\n            delta = sys.maxsize\n            for j in range(self.n_targets):\n                if not self.visit_right[j]:\n                    delta = min(delta, self.slack_right[j])\n            for j in range(self.n_uavs):\n                if self.visit_left[j]:\n                    self.label_left[j] -= delta\n            for j in range(self.n_targets):\n                if self.visit_right[j]:\n                    self.label_right[j] += delta\n                else:\n                    self.slack_right[j] -= delta\n    return self.match_right", "CodeBleu_score": 38.732147710625796}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\t\n    # convert image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # create a mask for yellow color using specified lower and upper HSV bounds\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n\t\n    # Convert image to HSV color space\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Create a mask for yellow color\n    lower_yellow = np.array([15, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 27.085328208956632}, {"code": "def yellow_dectection(image)\n\t\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    return cv2.bitwise_and(image, image, mask=mask)\n\n", "CodeBleu_score": 27.779830147695577}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\t", "CodeBleu_score": 0.5893535280724209}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tint id;\n\tStandaloneTagDescriptionContainer* descriptionContainer;\n\tbool printWarning;\n}", "CodeBleu_score": 0.8848862003960891}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\t\tint id;\n\tStandaloneTagDescriptionContainer* descriptionContainer;\n\tbool printWarning;\n}", "CodeBleu_score": 0.8848862003960891}]}
