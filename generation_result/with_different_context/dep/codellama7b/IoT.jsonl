{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tuint16_t len;\n\n\t/* Search for the next descriptor */\n\twhile (desc != NULL) {\n\t\t/* Check if this descriptor is the one we are looking for */\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\t/* Return the descriptor */\n\t\t\treturn desc;\n\t\t}\n\n\t\t/* Get the length of the current descriptor */\n\t\tlen = desc->bLength;\n\n\t\t/* Move to the next descriptor */\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc\n\t\t\t\t+ len);\n\t}\n\n\t/* No descriptor of the specified type was found */\n\treturn NULL;\n}", "CodeBleu_score": 35.549370388243105}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\tuint8_t *desc_ptr = (uint8_t *) desc;\n\n\twhile (desc_ptr < (uint8_t *) UDC_DESC_STORAGE_END) {\n\t\tif (desc_ptr[1] == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (desc_ptr[2] == desc_id) {\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\t\t}\n\t\tdesc_ptr += desc_ptr[0];\n\t}\n\treturn NULL;\n}", "CodeBleu_score": 34.165215030654046}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id){\n\twhile (desc->bDescriptorType != desc_id) {\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc +\n\t\t\t\tdesc->bLength);\n\t\tif (desc->bDescriptorType == 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn desc;\n}", "CodeBleu_score": 33.29056247925629}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t *desc = (uint8_t *)&usb_configuration_descriptor;\n\tuint8_t desc_len = usb_configuration_descriptor.bLength;\n\tuint8_t desc_type = desc[1];\n\tuint8_t desc_index = 0;\n\tuint8_t desc_num = 0;\n\tuint8_t desc_iface_num = 0;\n\tuint8_t desc_setting_num = 0;\n\tuint8_t desc_end = 0;\n\tuint8_t desc_len_total = 0;\n\tuint8_t desc_len_current = 0;\n\tuint8_t desc_len_next = 0;\n\tuint8_t desc_len_next_total = 0;\n\tuint8_t desc_len_next_remain = 0;\n\tuint8_t desc_len_next_total_remain = 0;\n\tuint8_t desc_len_next_remain_total = 0;\n\tuint8_t desc_len_next_remain_total_remain = 0;\n\tuint8_t desc_len_next_remain_total_remain_total = 0;\n\n\tif (usb_configuration_descriptor.bLength == 0) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= USB_NUM_INTERFACES) {\n\t\treturn false;\n\t}\n\n\twhile (desc_len_total < desc_len) {\n\t\tdesc_len_current = desc[desc_index];\n\t\tdesc_type = desc[desc_index + 1];\n\t\tdesc_len_total += desc_len_current;\n\t\tdesc_index += desc_len_current;\n\n\t\tif (desc_type == USB_DESC_TYPE_INTERFACE) {\n\t\t\tdesc_iface_num = desc[desc_index + 2];\n\t\t\tdesc_setting_num = desc[desc_index + 3];\n\n\t\t\tif (desc_iface_num == iface_num && desc_setting_num", "CodeBleu_score": 30.865049159598385}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tif (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n    if (iface_num >= udc_config.num_of_ifaces) {\n        return false;\n    }\n    for (uint8_t i = 0; i < udc_config.iface_descs[iface_num].num_of_alt_settings; i++) {\n        if (udc_config.iface_descs[iface_num].alt_settings[i].setting_num == setting_num) {\n            return true;\n        }\n    }\n    return false;\n}", "CodeBleu_score": 32.30986513639677}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num){\n\tuint8_t i;\n\tuint8_t *p;\n\n\tif (udc_state != UDC_STATE_CONFIGURED)\n\t\treturn false;\n\n\tif (iface_num >= udc_config.bNumInterfaces)\n\t\treturn false;\n\n\tp = udc_config.desc;\n\tfor (i = 0; i < udc_config.wTotalLength; i++) {\n\t\tif (p[0] == 0x04) {\n\t\t\tif (p[2] == iface_num) {\n\t\t\t\tif (p[3] == setting_num)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n\treturn false;\n}", "CodeBleu_score": 26.585509226586808}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void){\n\tuint8_t ep_num = udc_req.wIndex & 0x0F;\n\tuint8_t *payload = udc_req.payload;\n\n\tif (udc_req.wLength != 2) {\n\t\treturn false;\n\t}\n\n\tif (ep_num == 0) {\n\t\t*payload = udc_ep0_halted ? 0x01 : 0x00;\n\t} else {\n\t\t*payload = udc_ep_halted(ep_num) ? 0x01 : 0x00;\n\t}\n\n\tudc_req_setup_response(2);\n\treturn true;\n}", "CodeBleu_score": 22.26085806982506}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tuint8_t ep_num;\n\n    /* Get the endpoint number */\n    ep_num = (uint8_t)((uint8_t)udc_ctrl_req.setup.wIndex & 0x0F);\n\n    /* Check if the request length matches the size of the endpoint status variable */\n    if (udc_ctrl_req.setup.wLength != 2) {\n        return false;\n    }\n\n    /* Determine the status of the specified endpoint */\n    if (udc_ep_is_halted(ep_num)) {\n        udc_ctrl_req.payload[0] = 1;\n    } else {\n        udc_ctrl_req.payload[0] = 0;\n    }\n\n    /* Set the response payload with the endpoint status */\n    udc_ctrl_req.payload[1] = 0;\n    udc_ctrl_req.payload_len = 2;\n\n    /* Set the response payload with the endpoint status */\n    udc_ctrl_req.payload[1] = 0;\n    udc_ctrl_req.payload_len = 2;\n\n    return true;\n}", "CodeBleu_score": 28.850264153611803}, {"code": "static bool udc_req_std_ep_get_status(void){\n\tuint8_t ep_num = udc_req.wIndex & 0x0F;\n\tuint8_t ep_status = 0;\n\n\tif (udc_req.wLength != 2) {\n\t\treturn false;\n\t}\n\n\tif (udc_ep_is_stalled(ep_num)) {\n\t\tep_status |= 1;\n\t}\n\n\tudc_ep_set_payload_size(ep_num, 2);\n\tudc_ep_write_payload(ep_num, &ep_status, 2);\n\treturn true;\n}", "CodeBleu_score": 29.85955749152211}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void){\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (udc_setup.wIndex >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to default setting\n\tif (!udc_update_iface_desc(udc_setup.wIndex, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update interface descriptor to current setting\n\tif (!udc_update_iface_desc(udc_setup.wIndex, udc_setup.wValue)) {\n\t\treturn false;\n\t}\n\n\t// Forward setup request to the corresponding UDI\n\treturn udc_udi_setup();\n}", "CodeBleu_score": 47.645089443960686}, {"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\tbool retval;\n\n\tiface_num = udc_ctrl_request.wIndex & 0xFF;\n\tsetting_num = udc_ctrl_request.wValue & 0xFF;\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tretval = udc_update_iface_desc(iface_num, 0);\n\tif (retval) {\n\t\t// Update the interface descriptor to the current alternate setting\n\t\tretval = udc_update_iface_desc(iface_num, setting_num);\n\t}\n\n\tif (retval) {\n\t\t// Forward the SETUP request to the corresponding UDI handler\n\t\tretval = udc_udi_setup_request();\n\t}\n\n\treturn retval;\n}", "CodeBleu_score": 63.805492284378374}, {"code": "static bool udc_req_iface(void){\n\tuint8_t iface_num;\n\tuint8_t setting_num;\n\n\tiface_num = udc_req.wIndex;\n\tsetting_num = udc_req.wValue;\n\n\t// Check if the device is in a configured state\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\t// Check if the requested interface number is valid\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the default setting\n\tif (false == udc_update_iface_desc(iface_num, 0)) {\n\t\treturn false;\n\t}\n\n\t// Update the interface descriptor to the current alternate setting\n\tif (false == udc_update_iface_desc(iface_num, setting_num)) {\n\t\treturn false;\n\t}\n\n\t// Forward the SETUP request to the corresponding UDI handler\n\treturn udc_udi_setup_request();\n}", "CodeBleu_score": 61.81100272016038}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void){\n\tuint8_t i;\n\n  // Initialize the structure with the default values\n  udi_msc_cbw.signature = UDI_MSC_CBW_SIGNATURE;\n  udi_msc_cbw.tag = 0;\n  udi_msc_cbw.data_length = 0;\n  udi_msc_cbw.flags = 0;\n  udi_msc_cbw.lun = 0;\n\n  // Initialize the structure with the default values\n  udi_msc_csw.signature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw.tag = 0;\n  udi_msc_csw.data_residue = 0;\n  udi_msc_csw.status = UDI_MSC_CSW_COMMAND_PASSED;\n\n  // Initialize the structure with the default values\n  udi_msc_cbw_fail.signature = UDI_MSC_CBW_SIGNATURE;\n  udi_msc_cbw_fail.tag = 0;\n  udi_msc_cbw_fail.data_length = 0;\n  udi_msc_cbw_fail.flags = 0;\n  udi_msc_cbw_fail.lun = 0;\n\n  // Initialize the structure with the default values\n  udi_msc_csw_fail.signature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw_fail.tag = 0;\n  udi_msc_csw_fail.data_residue = 0;\n  udi_msc_csw_fail.status = UDI_MSC_CSW_COMMAND_FAILED;\n\n  // Initialize the structure with the default values\n  udi_msc_csw_fail_timeout.signature = UDI_MSC_CSW_SIGNATURE;\n  udi_msc_csw_fail_timeout.tag = 0;", "CodeBleu_score": 33.555802212038714}, {"code": "bool udi_msc_enable(void){\n\tuint8_t i;\n  uint8_t nb_lun;\n\n  // Initialize the number of LUNs\n  nb_lun = 0;\n\n  // Initialize the LUNs\n  for (i = 0; i < UDI_MSC_LUN_QTY; i++) {\n    // Check if LUN is available\n    if (udi_msc_lun_is_available(i)) {\n      // Initialize LUN\n      udi_msc_lun[i].is_read_only = false;\n      udi_msc_lun[i].is_write_protected = false;\n      udi_msc_lun[i].is_removable = true;\n      udi_msc_lun[i].is_ready = true;\n      udi_msc_lun[i].is_initialized = false;\n      udi_msc_lun[i].is_inquiry_loaded = false;\n      udi_msc_lun[i].is_unit_attention = false;\n      udi_msc_lun[i].is_test_unit_ready = false;\n      udi_msc_lun[i].is_prevent_allow_medium_removal = false;\n      udi_msc_lun[i].is_read_capacity_10 = false;\n      udi_msc_lun[i].is_read_capacity_16 = false;\n      udi_msc_lun[i].is_mode_sense_6 = false;\n      udi_msc_lun[i].is_mode_sense_10 = false;\n      udi_msc_lun[i].is_request_sense = false;\n      udi_msc_lun[i].is_format_unit = false;\n      udi_msc_lun[i].is_read_10 = false;\n      udi_msc_lun[i].is_write_10 = false;\n      udi_msc_lun[i].is_verify_10 =", "CodeBleu_score": 29.028056552058796}, {"code": "bool udi_msc_enable(void){\n\t// Initialize the number of LUNs\n  udi_msc_nb_lun = 0;\n\n  // Check if the external enable function is defined\n  if (udi_msc_enable_ext) {\n    // Call the external enable function\n    if (!udi_msc_enable_ext()) {\n      return false;\n    }\n  }\n\n  // Check if there is at least one LUN available\n  if (udi_msc_nb_lun == 0) {\n    return false;\n  }\n\n  // Unload the medium on each LUN\n  udi_msc_unload_medium();\n\n  // Register buffer and callback on IN endpoint\n  if (!udd_ep_run(UDI_MSC_EP_IN, true,\n          (uint8_t *) & udi_msc_csw,\n          sizeof(udi_msc_csw),\n          udi_msc_csw_received)) {\n    // IN endpoint not available (halted), then wait a clear of halt.\n    udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_enable);\n  }\n\n  // Register buffer and callback on OUT endpoint\n  if (!udd_ep_run(UDI_MSC_EP_OUT, true,\n          (uint8_t *) & udi_msc_cbw,\n          sizeof(udi_msc_cbw),\n          udi_msc_cbw_received)) {\n    // OUT endpoint not available (halted), then wait a clear of halt.\n    udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_enable);\n  }\n\n  // Wait a CBW reception\n  udi_msc_cbw_wait();\n\n  return true;\n}", "CodeBleu_score": 46.611270840908695}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t(void)nb_sent;\n  (void)ep;\n  if (UDD_EP_TRANSFER_OK != status) {\n    // If the transfer is not successful, then STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n    udi_msc_csw.bCSWStatus = USB_CSW_STATUS_PHASE_ERROR;\n  } else {\n    // If the transfer is successful, then update sense data\n    udi_msc_sense_pass();\n    // Decrease the data residue in the Command Status Wrapper (CSW)\n    udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n    // Process the updated CSW\n    udi_msc_csw_process();\n  }\n}", "CodeBleu_score": 62.758420816136876}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t(void)ep;\n  (void)nb_sent;\n  switch (status) {\n  case UDD_EP_TRANSFER_OK:\n    // Data successfully sent\n    udi_msc_sense_pass();\n    udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n    udi_msc_csw_process();\n    break;\n  case UDD_EP_TRANSFER_ABORT:\n    // Data transfer aborted\n    udi_msc_sense_pass();\n    udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n    udi_msc_csw_process();\n    break;\n  case UDD_EP_TRANSFER_STALL:\n    // Stall on IN endpoint\n    udi_msc_sense_pass();\n    udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n    udi_msc_csw_process();\n    break;\n  case UDD_EP_TRANSFER_ERROR:\n    // Error on IN endpoint\n    udi_msc_sense_pass();\n    udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n    udi_msc_csw_process();\n    break;\n  default:\n    // Unknown status\n    udi_msc_csw.bCSWStatus = USB_CSW_STATUS_FAIL;\n    udi_msc_csw.dCSWDataResidue = 0;\n    udi_msc_csw_send();\n    break;\n  }\n}", "CodeBleu_score": 45.36610440984926}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep){\n\t(void) status;\n  (void) nb_sent;\n  (void) ep;\n\n  // Check if the transfer is successful\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Check if a MSC setup reset is required\n    if (UDD_EP_TRANSFER_ABORT != status) {\n      // Set the MSC setup reset flag\n      udi_msc_setup_reset = true;\n    }\n    return;\n  }\n  // Update sense data\n  udi_msc_update_sense();\n  // Decrease the data residue in the Command Status Wrapper (CSW)\n  udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n  // Process the updated CSW\n  udi_msc_csw_process();\n}", "CodeBleu_score": 61.423716914659565}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void){\n\t// Check if CSW is ready to be sent\n  if (udi_msc_cbw.dCBWDataTransferLength != 0) {\n    // Data residue is not zero\n    // then stall endpoint according to the direction of the CBW\n    if (udi_msc_cbw.bmCBWFlags & 0x80) {\n      // Device-to-host\n      udd_ep_stall(UDI_MSC_EP_IN);\n    } else {\n      // Host-to-device\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    }\n  }\n  // Prepare the CSW\n  udi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n  udi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASSED;\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 57.579023685404174}, {"code": "static void udi_msc_csw_process(void){\n\t// Check if the data residue is zero\n  if (udi_msc_csw.dCSWDataResidue != 0) {\n    // Data residue is not zero\n    // then stall the endpoint on which the CBW was received\n    if (udi_msc_cbw.bmCBWFlags & 0x80) {\n      // The CBW was received on the IN endpoint\n      // then stall the OUT endpoint\n      udd_ep_stall(UDI_MSC_EP_OUT);\n    } else {\n      // The CBW was received on the OUT endpoint\n      // then stall the IN endpoint\n      udd_ep_stall(UDI_MSC_EP_IN);\n    }\n  }\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 28.66881970300308}, {"code": "static void udi_msc_csw_process(void){\n\t// Check if there is a non-zero data residue\n  if (udi_msc_cbw.dCBWDataTransferLength != 0) {\n    // Stall the next request on the appropriate endpoint\n    if (udi_msc_cbw.bmCBWFlags & 0x80) {\n      // Stall IN endpoint\n      udd_ep_abort(UDI_MSC_EP_IN);\n    } else {\n      // Stall OUT endpoint\n      udd_ep_abort(UDI_MSC_EP_OUT);\n    }\n  }\n  // Prepare the CSW\n  udi_msc_csw.dCSWSignature = UDI_MSC_DCSWSIGNATURE;\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue =\n      udi_msc_cbw.dCBWDataTransferLength;\n  udi_msc_csw.bCSWStatus = UDI_MSC_CSW_COMMAND_PASSED;\n  // Send CSW\n  udi_msc_csw_send();\n}", "CodeBleu_score": 58.43611314682657}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n    /*\n     * Cancel any scheduled resets.\n     */\n    cancelReset(port);\n  } else {\n    /*\n     * If the DTR signal is disabled, schedule a reset.\n     */\n    if (USB_CDC_DTR_RATE_1200 == usb_cdc_dtr_rate[port]) {\n      /*\n       * Schedule a reset.\n       */\n      scheduleReset(port);\n    }\n  }\n}", "CodeBleu_score": 30.342103514725082}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (port == 0) {\n\t\tif (b_enable) {\n\t\t\t// DTR enabled\n\t\t\t// Cancel any pending resets\n\t\t\tcancelReset();\n\t\t} else {\n\t\t\t// DTR disabled\n\t\t\t// Schedule a reset\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}", "CodeBleu_score": 23.746191436637794}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable){\n\tif (b_enable) {\n        // Cancel any pending reset\n        cancelReset(port);\n    } else {\n        // Schedule a reset if the baud rate is 1200\n        if (usb_port_state[port].baud_rate == 1200) {\n            scheduleReset(port);\n        }\n    }\n}", "CodeBleu_score": 31.333964154860226}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void){\n\t/* Check the request type */\n\tif (usb_request_type == USB_REQUEST_TYPE_VENDOR) {\n\n\t\t/* Check the request index */\n\t\tswitch (usb_request_index) {\n\n\t\t\t/* Request index 0x04: Microsoft-compatible ID descriptor */\n\t\t\tcase 0x04:\n\n\t\t\t\t/* Set up the pointer and size */\n\t\t\t\tusb_request_payload_ptr = (uint8_t *)&usb_microsoft_compatible_id_descriptor;\n\t\t\t\tusb_request_payload_size = sizeof(usb_microsoft_compatible_id_descriptor);\n\n\t\t\t\t/* Return true to indicate that the request is processed */\n\t\t\t\treturn true;\n\n\t\t\t\t/* Request index 0x05: Extended properties descriptor */\n\t\t\tcase 0x05:\n\n\t\t\t\t/* Set up the pointer and size */\n\t\t\t\tusb_request_payload_ptr = (uint8_t *)&usb_extended_properties_descriptor;\n\t\t\t\tusb_request_payload_size = sizeof(usb_extended_properties_descriptor);\n\n\t\t\t\t/* Return true to indicate that the request is processed */\n\t\t\t\treturn true;\n\n\t\t\t\t/* Request index 0x06: Microsoft OS feature descriptor */\n\t\t\tcase 0x06:\n\n\t\t\t\t/* Set up the pointer and size */\n\t\t\t\tusb_request_payload_ptr = (uint8_t *)&usb_microsoft_os_feature_descriptor;\n\t\t\t\tusb_request_payload_size = sizeof(usb_microsoft_os_feature_descriptor);\n\n\t\t\t\t/* Return true to indicate that the request is processed */\n\t\t\t\treturn true;\n\n\t\t\t\t/* Request index 0x07: Microsoft OS feature compatibility ID descriptor */\n\t\t\tcase 0x07:\n\n\t\t\t\t/* Set up the pointer and size */\n\t\t\t\tusb_request_payload_ptr = (uint8_t *)&usb_microsoft_os_feature_compatibility_", "CodeBleu_score": 22.55552788533822}, {"code": "bool usb_task_other_requests(void){\n\tuint8_t *request = (uint8_t *)&usb_control_request;\n\n    if (request[0] == 0x04) {\n        if (request[1] == 0x00) {\n            usb_control_request.wLength = 0x12;\n            usb_control_request.wValue = 0x0000;\n            usb_control_request.wIndex = 0x0000;\n            usb_control_request.bRequest = 0x00;\n            usb_control_request.bmRequestType = 0x80;\n            usb_control_request.bRequest = 0x04;\n            return true;\n        } else if (request[1] == 0x01) {\n            usb_control_request.wLength = 0x12;\n            usb_control_request.wValue = 0x0000;\n            usb_control_request.wIndex = 0x0000;\n            usb_control_request.bRequest = 0x00;\n            usb_control_request.bmRequestType = 0x80;\n            usb_control_request.bRequest = 0x04;\n            return true;\n        } else if (request[1] == 0x02) {\n            usb_control_request.wLength = 0x08;\n            usb_control_request.wValue = 0x0000;\n            usb_control_request.wIndex = 0x0000;\n            usb_control_request.bRequest = 0x00;\n            usb_control_request.bmRequestType = 0x80;\n            usb_control_request.bRequest = 0x04;\n            return true;\n        } else if (request[1] == 0x03) {\n            usb_control_request.wLength = 0x12;\n            usb_control_request.wValue = 0x0000;\n            usb_control_request.wIndex =", "CodeBleu_score": 21.559260186966455}, {"code": "bool usb_task_other_requests(void){\n\t// Check for a vendor-specific request\n  if ((usb_setup_packet.bmRequestType & USB_REQUEST_TYPE_TYPE_MASK) == USB_REQUEST_TYPE_TYPE_VENDOR) {\n    // Check for a request index of 0x04\n    if (usb_setup_packet.bRequest == 0x04) {\n      // Check for a GET request\n      if ((usb_setup_packet.bmRequestType & USB_REQUEST_TYPE_DIR_MASK) == USB_REQUEST_TYPE_DIR_IN) {\n        // Set the pointer and size for the Microsoft compatible ID descriptor\n        usb_setup_packet.wLength = sizeof(usb_microsoft_compatible_id_descriptor);\n        usb_setup_packet.wValue = (usb_setup_packet.wValue & 0xFF00) >> 8;\n        usb_setup_packet.wValue |= (uint16_t)((uint16_t)usb_microsoft_compatible_id_descriptor.bFirstInterfaceNumber << 8);\n        usb_setup_packet.wValue |= (uint16_t)usb_microsoft_compatible_id_descriptor.bReserved;\n        usb_setup_packet.wIndex = 0;\n        usb_setup_packet.wIndex |= (uint16_t)usb_microsoft_compatible_id_descriptor.CompatibleID[0] << 8;\n        usb_setup_packet.wIndex |= (uint16_t)usb_microsoft_compatible_id_descriptor.CompatibleID[1];\n        usb_setup_packet.wIndex |= (uint16_t)usb_microsoft_compatible_id_descriptor.SubCompatibleID[0] << 8;\n        usb_setup_packet.wIndex |= (uint16_t)usb_microsoft_compatible_id_descriptor.SubCompatibleID[1];\n        usb_setup_packet.wIndex |= (uint16_t)usb_microsoft_compatible_id_descriptor.SubCompatibleID[2] << 8;", "CodeBleu_score": 30.776178630823857}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tif (nbyte == 0) {\n\t\treturn;\n\t}\n\n\tSPI_Send_Byte(0);\n\tfor (uint16_t i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = SPI_Rec_Byte();\n\t}\n\tbuf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 49.29028458668211}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n    uint8_t dummy;\n    if (nbyte == 0) {\n        return;\n    }\n    for (i = 0; i < nbyte - 1; i++) {\n        dummy = SPI_SendByte(0x00);\n        buf[i] = SPI_RecByte();\n    }\n    dummy = SPI_SendByte(0x00);\n    buf[nbyte - 1] = SPI_RecByte();\n}", "CodeBleu_score": 49.68892241160589}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte){\n\tuint16_t i;\n\tuint8_t dummy;\n\n\tif (nbyte == 0) return;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tdummy = 0x00;\n\t\tspiSend(dummy);\n\t\tbuf[i] = spiRec();\n\t}\n\tdummy = 0x00;\n\tspiSend(dummy);\n\tbuf[i] = spiRec();\n}", "CodeBleu_score": 46.93524005585805}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n    uint32_t *vector_table = (uint32_t *)SCB->VTOR;\n    uint32_t *vector_table_end = vector_table + 32;\n    uint32_t *vector_table_entry = &vector_table[irq];\n\n    // disable global interrupts\n    __disable_irq();\n\n    // retrieve current handler\n    oldHandler = (pfnISR_Handler)vector_table_entry[1];\n\n    // replace current handler with new handler\n    vector_table_entry[1] = (uint32_t)newHandler;\n\n    // enable global interrupts\n    __enable_irq();\n\n    // return old handler\n    return oldHandler;\n}", "CodeBleu_score": 46.12297889512877}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n    uint32_t *p_vect = (uint32_t *)0xE000E100;\n    p_vect += irq;\n\n    __disable_irq();\n    oldHandler = (pfnISR_Handler) (*p_vect);\n    *p_vect = (uint32_t) newHandler;\n    __enable_irq();\n\n    return oldHandler;\n}", "CodeBleu_score": 47.56808794818066}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler){\n\tpfnISR_Handler oldHandler;\n\tuint32_t *vectors;\n\tuint32_t *vectors_end;\n\tuint32_t *vector_table;\n\tuint32_t *vector_table_end;\n\n\t/* Get the address of the relocated interrupt vector table */\n\tvectors = (uint32_t *)SCB->VTOR;\n\t/* Get the end of the relocated interrupt vector table */\n\tvectors_end = vectors + 16;\n\t/* Get the address of the interrupt vector table */\n\tvector_table = (uint32_t *)0x0;\n\t/* Get the end of the interrupt vector table */\n\tvector_table_end = vector_table + 16;\n\n\t/* Disable global interrupts */\n\t__disable_irq();\n\t/* Get the original handler */\n\toldHandler = vectors[irq];\n\t/* Install the new handler */\n\tvectors[irq] = (uint32_t)newHandler;\n\t/* Enable global interrupts */\n\t__enable_irq();\n\n\t/* If the new handler is not in the interrupt vector table, then restore the original handler */\n\tif (newHandler < vector_table || newHandler >= vector_table_end) {\n\t\t/* Disable global interrupts */\n\t\t__disable_irq();\n\t\t/* Restore the original handler */\n\t\tvectors[irq] = (uint32_t)oldHandler;\n\t\t/* Enable global interrupts */\n\t\t__enable_irq();\n\t}\n\n\t/* Return the original handler */\n\treturn oldHandler;\n}", "CodeBleu_score": 45.71673214899184}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek(){\n\tif (usb_serial_enabled && usb_configuration && usb_serial_available()) {\n    int c = usb_serial_getchar();\n    if (c >= 0) {\n      if (emergency_parser_enabled) {\n        if (emergency_parser_state == EP_IDLE) {\n          if (c == START_CHAR) {\n            emergency_parser_state = EP_START_CHAR;\n          }\n        }\n        else if (emergency_parser_state == EP_START_CHAR) {\n          if (c == START_CHAR) {\n            emergency_parser_state = EP_START_CHAR;\n          }\n          else if (c == END_CHAR) {\n            emergency_parser_state = EP_END_CHAR;\n          }\n          else {\n            emergency_parser_state = EP_IDLE;\n            emergency_parser_index = 0;\n            emergency_parser_buffer[0] = c;\n          }\n        }\n        else if (emergency_parser_state == EP_END_CHAR) {\n          if (c == END_CHAR) {\n            emergency_parser_state = EP_IDLE;\n            emergency_parser_index = 0;\n            emergency_parser_buffer[0] = c;\n          }\n          else {\n            emergency_parser_state = EP_IDLE;\n            emergency_parser_index = 0;\n          }\n        }\n        else {\n          if (emergency_parser_index < sizeof(emergency_parser_buffer)) {\n            emergency_parser_buffer[emergency_parser_index] = c;\n            emergency_parser_index++;\n          }\n          else {\n            emergency_parser_state = EP_IDLE;\n            emergency_parser_index = 0;\n          }\n        }\n        if (emergency_parser_state == EP_IDLE) {\n          if (emergency_parser_index > 0) {\n            if (emergency_parser_buffer[0] == START_CHAR) {\n              if (emergency_parser_index == 1) {\n                emergency_parser_buffer", "CodeBleu_score": 34.21293642636419}, {"code": "int MarlinSerialUSB::peek(){\n\tif (enabled && !(usb_configuration && (USB_BUS_SENSE & _BV(USB_BUS_SENSE_PIN)))) {\n    if (rx_buffer_head != rx_buffer_tail) {\n      return rx_buffer[rx_buffer_tail];\n    }\n    return -1;\n  }\n  return -1;\n}", "CodeBleu_score": 19.64058870846507}, {"code": "int MarlinSerialUSB::peek(){\n\tif (usb_serial_enabled && usb_serial_configured && !usb_serial_suspended) {\n    if (usb_serial_rx_available()) {\n      return usb_serial_rx_getchar();\n    }\n    else {\n      return -1;\n    }\n  }\n  else {\n    return -1;\n  }\n}", "CodeBleu_score": 14.676476834630915}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read(){\n\tif (rx_buffer_head != rx_buffer_tail) {\n    uint8_t c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n    return c;\n  }\n  if (!is_usb_enabled || !is_usb_configured) return -1;\n  if (!is_usb_open) return -1;\n  if (!is_usb_rx_enabled) return -1;\n  if (usb_available() < 1) return -1;\n  uint8_t c = usb_read();\n  if (emergency_parser_enabled) emergency_parser_rx(c);\n  return c;\n}", "CodeBleu_score": 36.29017389949701}, {"code": "int MarlinSerialUSB::read(){\n\tif (rx_buffer_head != rx_buffer_tail) {\n    // Return the character in the circular buffer\n    uint8_t c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n    return c;\n  }\n  if (!usb_configuration) return -1;\n  if (!(USB_DeviceState[0] == DEVICE_STATE_Configured)) return -1;\n  if (!(Endpoint_IsINReady())) return -1;\n  uint8_t c = Endpoint_Read_8();\n  if (emergency_parser_enabled) emergency_parser_rx_byte(c);\n  return c;\n}", "CodeBleu_score": 36.610147065096456}, {"code": "int MarlinSerialUSB::read(){\n\tif (rx_buffer_head != rx_buffer_tail) {\n    uint8_t c = rx_buffer[rx_buffer_tail++];\n    rx_buffer_tail &= BUFFER_MASK;\n    return c;\n  }\n  if (!is_usb_enabled() || !is_usb_configured()) return -1;\n  if (usb_available() <= 0) return -1;\n  uint8_t c = usb_serial_getchar();\n  if (emergency_parser_enabled) {\n    emergency_parser_state = emergency_parser_state_machine[emergency_parser_state](c);\n  }\n  return c;\n}", "CodeBleu_score": 43.89703171413571}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available(){\n\tif (usb_available()) {\n    return usb_available();\n  }\n  else {\n    return 0;\n  }\n}", "CodeBleu_score": 33.102958520368}, {"code": "int MarlinSerialUSB::available(){\n\tint retVal = 0;\n\n  if (usb_serial_available()) {\n    retVal = usb_serial_available();\n  }\n  else {\n    retVal = -1;\n  }\n\n  return retVal;\n}", "CodeBleu_score": 43.23408626052267}, {"code": "int MarlinSerialUSB::available(){\n\tif (rx_buffer_head != rx_buffer_tail) {\n    return rx_buffer_head - rx_buffer_tail;\n  }\n  if (rx_enabled) {\n    return 0;\n  }\n  return -1;\n}", "CodeBleu_score": 29.35377168110598}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t b;\n  for (uint16_t i = 0; i < size; i++) {\n    b = ee_Read(pos, writing);\n    if (value) *value++ = b;\n    pos++;\n    if (crc) *crc = crc16(*crc, &b, 1);\n  }\n  return false;\n}", "CodeBleu_score": 55.19454781826337}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t data;\n  while (size--) {\n    if (writing) {\n      data = ee_Read(pos);\n      *value++ = data;\n      crc16(crc, &data, 1);\n    }\n    else {\n      data = ee_Read(pos, true);\n      crc16(crc, &data, 1);\n    }\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 53.9690261923816}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/){\n\tuint8_t data;\n  for (size_t i = 0; i < size; i++) {\n    data = ee_Read(pos, !writing);\n    if (writing)\n      *value++ = data;\n    crc16(crc, &data, 1);\n    pos++;\n  }\n  return false;\n}", "CodeBleu_score": 55.19425680557271}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (pin >= MAX_PWM_IOPIN) return; // Not a hardware PWM pin!\n  uint16_t v = constrain(value, 0, 255);\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid < 0) return; // No channel available\n  ledcWrite(cid, v);\n}", "CodeBleu_score": 29.342588858184072}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (pin >= MAX_PWM_IOPIN) return; // Not a hardware PWM pin!\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) ledcWrite(cid, value);\n}", "CodeBleu_score": 25.513046836638143}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/){\n\tif (pin >= MAX_PWM_IOPIN) return; // Not a hardware PWM pin!\n  int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid < 0) return; // No PWM available\n  ledcWrite(cid, value);\n}", "CodeBleu_score": 26.123186527936245}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_LENGTH == SERVO_COUNT, \"Servo delay array length must match the number of servos\");\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 51.627175341472054}, {"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_LENGTH == NUM_SERVOS, \"Servo::move: SERVO_DELAY_LENGTH must be equal to NUM_SERVOS\");\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 52.13343357940248}, {"code": "void Servo::move(const int value){\n\tstatic_assert(SERVO_DELAY_LENGTH == NUM_SERVOS, \"SERVO_DELAY_LENGTH must equal NUM_SERVOS\");\n  if (channel >= 0) {\n    write(value);\n    safe_delay(SERVO_DELAY_LENGTH[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n  }\n}", "CodeBleu_score": 51.215537711154056}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample(){\n\t// Update the PWM states for each pin\n\tfor (uint8_t i = 0; i < I2S_PIN_COUNT; i++) {\n\t\t// Check if the pin has active PWM\n\t\tif (pwm_states[i].duty_cycle != 0) {\n\t\t\t// Decrement the PWM tick count\n\t\t\tpwm_states[i].tick_count--;\n\n\t\t\t// If the PWM tick count reaches zero, toggle the pin state and set the tick count for the next transition\n\t\t\tif (pwm_states[i].tick_count == 0) {\n\t\t\t\t// Toggle the pin state\n\t\t\t\tif (pwm_states[i].pin_state == LOW) {\n\t\t\t\t\tpwm_states[i].pin_state = HIGH;\n\t\t\t\t} else {\n\t\t\t\t\tpwm_states[i].pin_state = LOW;\n\t\t\t\t}\n\t\t\t\t// Set the tick count for the next transition\n\t\t\t\tpwm_states[i].tick_count = pwm_states[i].duty_cycle;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write the updated port data to the DMA buffer\n\tfor (uint8_t i = 0; i < I2S_PIN_COUNT; i++) {\n\t\t// Set the pin state\n\t\tif (pwm_states[i].pin_state == LOW) {\n\t\t\t// Set the pin low\n\t\t\tPORTB &= ~(1 << i);\n\t\t} else {\n\t\t\t// Set the pin high\n\t\t\tPORTB |= (1 << i);\n\t\t}\n\t\t// Store the port data in the DMA buffer\n\t\tdma_buffer[dma_buffer_position++] = PINB;\n\t\t// Reset the position if the end of the buffer is reached\n\t\tif (dma_buffer_position == DMA_BUFFER_SIZE) {\n\t\t\tdma_buffer_position = 0;", "CodeBleu_score": 34.252826766134035}, {"code": "void i2s_push_sample(){\n\t// Get the current time\n    unsigned long time = micros();\n\n    // Iterate through all pins\n    for (int i = 0; i < NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (pwm_states[i].duty_cycle > 0) {\n            // Check if the current time has passed the next transition time\n            if (time >= pwm_states[i].next_transition_time) {\n                // Toggle the pin state\n                pwm_states[i].pin_state = !pwm_states[i].pin_state;\n\n                // Set the next transition time\n                pwm_states[i].next_transition_time = time + 1000000 / pwm_states[i].frequency;\n            }\n        }\n\n        // Write the pin state to the DMA buffer\n        dma_buffer[dma_buffer_pos] = pwm_states[i].pin_state;\n\n        // Increment the buffer position\n        dma_buffer_pos++;\n\n        // Wrap around the buffer position\n        if (dma_buffer_pos >= BUFFER_SIZE) {\n            dma_buffer_pos = 0;\n        }\n    }\n}", "CodeBleu_score": 31.903398144166072}, {"code": "void i2s_push_sample(){\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (i2s_pwm_duty_cycle[i] > 0) {\n\t\t\tif (i2s_pwm_tick_count[i] == 0) {\n\t\t\t\tif (i2s_pwm_state[i] == 0) {\n\t\t\t\t\ti2s_pwm_state[i] = 1;\n\t\t\t\t\ti2s_pwm_tick_count[i] = i2s_pwm_duty_cycle[i];\n\t\t\t\t} else {\n\t\t\t\t\ti2s_pwm_state[i] = 0;\n\t\t\t\t\ti2s_pwm_tick_count[i] = i2s_pwm_duty_cycle[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ti2s_pwm_tick_count[i]--;\n\t\t\t}\n\t\t}\n\t\ti2s_dma_buffer[i2s_dma_buffer_position] = i2s_pwm_state[i];\n\t\ti2s_dma_buffer_position++;\n\t}\n\tif (i2s_dma_buffer_position == I2S_DMA_BUFFER_SIZE) {\n\t\ti2s_dma_buffer_position = 0;\n\t\tHAL_I2S_Transmit_DMA(&hi2s, (uint16_t*) i2s_dma_buffer, I2S_DMA_BUFFER_SIZE);\n\t}\n}", "CodeBleu_score": 37.09515588357777}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t timer_count;\n\n    if (timer_num >= TIMER_NUM) {\n        return 0;\n    }\n\n    if (timer_num == TIMER_0) {\n        timer_count = (hal_timer_t)TIMER0->CNT;\n    } else if (timer_num == TIMER_1) {\n        timer_count = (hal_timer_t)TIMER1->CNT;\n    } else if (timer_num == TIMER_2) {\n        timer_count = (hal_timer_t)TIMER2->CNT;\n    } else if (timer_num == TIMER_3) {\n        timer_count = (hal_timer_t)TIMER3->CNT;\n    } else if (timer_num == TIMER_4) {\n        timer_count = (hal_timer_t)TIMER4->CNT;\n    } else if (timer_num == TIMER_5) {\n        timer_count = (hal_timer_t)TIMER5->CNT;\n    } else {\n        timer_count = 0;\n    }\n\n    return timer_count;\n}", "CodeBleu_score": 29.345875070573648}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\tuint32_t timer_base_address = 0;\n\n\tif (timer_num >= HAL_TIMER_NUM_MAX) {\n\t\treturn 0;\n\t}\n\n\tif (timer_num == HAL_TIMER_0) {\n\t\ttimer_base_address = TIMER0_BASE_ADDRESS;\n\t} else if (timer_num == HAL_TIMER_1) {\n\t\ttimer_base_address = TIMER1_BASE_ADDRESS;\n\t} else if (timer_num == HAL_TIMER_2) {\n\t\ttimer_base_address = TIMER2_BASE_ADDRESS;\n\t} else if (timer_num == HAL_TIMER_3) {\n\t\ttimer_base_address = TIMER3_BASE_ADDRESS;\n\t}\n\n\treturn *((volatile uint32_t *)(timer_base_address + TIMER_REG_COUNT));\n}", "CodeBleu_score": 25.381982169894968}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num){\n\thal_timer_t timer_count;\n\n    switch (timer_num) {\n        case HAL_TIMER_0:\n            timer_count = TIMER0->CNT;\n            break;\n        case HAL_TIMER_1:\n            timer_count = TIMER1->CNT;\n            break;\n        case HAL_TIMER_2:\n            timer_count = TIMER2->CNT;\n            break;\n        case HAL_TIMER_3:\n            timer_count = TIMER3->CNT;\n            break;\n        case HAL_TIMER_4:\n            timer_count = TIMER4->CNT;\n            break;\n        case HAL_TIMER_5:\n            timer_count = TIMER5->CNT;\n            break;\n        case HAL_TIMER_6:\n            timer_count = TIMER6->CNT;\n            break;\n        case HAL_TIMER_7:\n            timer_count = TIMER7->CNT;\n            break;\n        case HAL_TIMER_8:\n            timer_count = TIMER8->CNT;\n            break;\n        case HAL_TIMER_9:\n            timer_count = TIMER9->CNT;\n            break;\n        case HAL_TIMER_10:\n            timer_count = TIMER10->CNT;\n            break;\n        case HAL_TIMER_11:\n            timer_count = TIMER11->CNT;\n            break;\n        case HAL_TIMER_12:\n            timer_count = TIMER12->CNT;\n            break;\n        case HAL_TIMER_13:\n            timer_count = TIMER13->CNT;\n            break;\n        case HAL_TIMER_14:\n            timer_count = TIMER14->CNT;\n            break;\n        case HAL_TIMER_15:\n            timer_count = TIMER15->CNT;\n            break;", "CodeBleu_score": 26.139143745681732}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (size == 0) return true;\n  if (writing) {\n    for (size_t i = 0; i < size; i++) {\n      value[i] = eeprom_read_byte((uint8_t *)pos++);\n      *crc = (uint16_t)(*crc ^ (uint16_t)value[i]);\n    }\n  }\n  else {\n    for (size_t i = 0; i < size; i++) {\n      *crc = (uint16_t)(*crc ^ (uint16_t)eeprom_read_byte((uint8_t *)pos++));\n    }\n  }\n  return false;\n}", "CodeBleu_score": 57.598478164772146}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tfor (uint16_t i = 0; i < size; i++) {\n    if (writing) *value++ = eeprom_read_byte((uint8_t *)pos++);\n    crc16(crc, (uint8_t *)pos - 1, 1);\n  }\n  return false;\n}", "CodeBleu_score": 53.649357122763554}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/){\n\tif (eeprom_read_block(value, (const void*)pos, size) != 0) return false;\n  if (writing) {\n    crc16(crc, value, size);\n    for (size_t i = 0; i < size; i++)\n      *value++ = eeprom_read_byte((const uint8_t*)pos++);\n  }\n  else\n    pos += size;\n  return true;\n}", "CodeBleu_score": 55.47948582183424}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (SDIO_Handle == NULL || src == NULL) {\n\t\tprintf(\"SDIO_WriteBlock: Invalid SDIO handle or source pointer.\n\");\n\t\treturn false;\n\t}\n\n\tbool success = false;\n\tuint8_t retry = 0;\n\twhile (retry < MAX_SDIO_RETRIES) {\n\t\tHAL_SD_ErrorTypeDef error = HAL_SD_WriteBlock(SDIO_Handle, (uint32_t *) src, block, 512);\n\t\tif (error == HAL_SD_ERROR_NONE) {\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tprintf(\"SDIO_WriteBlock: Write error.\n\");\n\t\t\tprintf(\"SDIO_WriteBlock: Error code: %d\n\", error);\n\t\t\tretry++;\n\t\t}\n\t}\n\n\treturn success;\n}", "CodeBleu_score": 45.82103873490399}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (sdio == NULL || src == NULL) {\n        return false;\n    }\n\n    for (int i = 0; i < SDIO_RETRY_COUNT; i++) {\n        if (sdio_write_block(sdio, block, src, 512) == 0) {\n            return true;\n        }\n    }\n\n    printf(\"SD card write failed.\n\");\n    return false;\n}", "CodeBleu_score": 31.366591150550448}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src){\n\tif (sdio == NULL || src == NULL) {\n        return false;\n    }\n    bool result = false;\n    for (int i = 0; i < SDIO_RETRIES; i++) {\n        if (sdio->writeBlock(block, src)) {\n            result = true;\n            break;\n        }\n    }\n    if (!result) {\n        Serial.println(\"Failed to write block\");\n    }\n    return result;\n}", "CodeBleu_score": 34.915759320104165}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_CHANNEL_0:\n      TIMER_0->CTRL = TIMER_CTRL_ENABLE | TIMER_CTRL_PRESCALE(TIMER_PRESCALE) | TIMER_CTRL_FREQ(frequency);\n      NVIC_SetPriority(TIMER0_IRQn, TIMER_0_IRQ_PRIORITY);\n      NVIC_EnableIRQ(TIMER0_IRQn);\n      break;\n    case TIMER_CHANNEL_1:\n      TIMER_1->CTRL = TIMER_CTRL_ENABLE | TIMER_CTRL_PRESCALE(TIMER_PRESCALE) | TIMER_CTRL_FREQ(frequency);\n      NVIC_SetPriority(TIMER1_IRQn, TIMER_1_IRQ_PRIORITY);\n      NVIC_EnableIRQ(TIMER1_IRQn);\n      break;\n    case TIMER_CHANNEL_2:\n      TIMER_2->CTRL = TIMER_CTRL_ENABLE | TIMER_CTRL_PRESCALE(TIMER_PRESCALE) | TIMER_CTRL_FREQ(frequency);\n      NVIC_SetPriority(TIMER2_IRQn, TIMER_2_IRQ_PRIORITY);\n      NVIC_EnableIRQ(TIMER2_IRQn);\n      break;\n    case TIMER_CHANNEL_3:\n      TIMER_3->CTRL = TIMER_CTRL_ENABLE | TIMER_CTRL_PRESCALE(TIMER_PRESCALE) | TIMER_CTRL_FREQ(frequency);\n      NVIC_SetPriority(TIMER3_IRQn, TIMER_3_IRQ_PRIORITY);\n      NVIC_EnableIRQ(TIMER3_IRQn);\n      break;", "CodeBleu_score": 31.604059229278835}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tswitch (timer_num) {\n    case TIMER_CH_TEMP:\n      // Configure timer for temperature measurement\n      // Timer is clocked by F_CPU / 256 / prescaler\n      // With default settings the timer is clocked by F_CPU / 256 / 256 = 122.07 Hz\n      // To get a frequency of 1 Hz we need to divide the timer by 122.07\n      // To get a frequency of 10 Hz we need to divide the timer by 122.07 / 10 = 12.207 Hz\n      // To get a frequency of 100 Hz we need to divide the timer by 122.07 / 100 = 1.2207 Hz\n      OCR1A = (F_CPU / 256 / frequency) - 1;\n      TCCR1B |= (1 << CS12) | (1 << CS11);\n      TIMSK1 |= (1 << OCIE1A);\n      break;\n    case TIMER_CH_STEP:\n      // Configure timer for stepper control\n      // Timer is clocked by F_CPU / 64 / prescaler\n      // With default settings the timer is clocked by F_CPU / 64 / 64 = 15625 Hz\n      // To get a frequency of 1 Hz we need to divide the timer by 15625\n      // To get a frequency of 10 Hz we need to divide the timer by 15625 / 10 = 1562.5 Hz\n      // To get a frequency of 100 Hz we need to divide the timer by 15625 / 100 = 15.625 Hz\n      OCR1A = (F_CPU / 64 / frequency) - 1;\n      TCCR1B |= (1 << CS12) | (1 << CS10);\n      TIMSK1 |= (1 << OCIE1A", "CodeBleu_score": 21.02612150371237}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency){\n\tif (timer_num == TIMER_CHANNEL_TEMPERATURE) {\n\t\t// Configure timer for temperature measurement\n\t\tHAL_timer_set_prescaler(timer_num, frequency);\n\t\tHAL_timer_set_callback_priority(timer_num, TIMER_CALLBACK_PRIORITY_TEMPERATURE);\n\t}\n\telse if (timer_num == TIMER_CHANNEL_STEP) {\n\t\t// Configure timer for stepper\n\t\tHAL_timer_set_prescaler(timer_num, frequency);\n\t\tHAL_timer_set_callback_priority(timer_num, TIMER_CALLBACK_PRIORITY_STEP);\n\t}\n\telse {\n\t\t// Invalid timer channel\n\t\tassert(false);\n\t}\n}", "CodeBleu_score": 43.003736884462576}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start(){\n\tbool success = false;\n  uint32_t file_size;\n  int file_handle;\n  uint8_t *buffer_ptr;\n  uint32_t buffer_size;\n  uint32_t bytes_read;\n  uint32_t bytes_to_read;\n  uint32_t bytes_to_write;\n  uint32_t bytes_written;\n\n  if (eeprom_file_name != NULL) {\n    if ((file_handle = open(eeprom_file_name, O_RDWR)) != -1) {\n      if ((file_size = lseek(file_handle, 0, SEEK_END)) != -1) {\n        if (file_size > 0) {\n          if (file_size > eeprom_size) {\n            file_size = eeprom_size;\n          }\n          if ((buffer_ptr = (uint8_t *)malloc(file_size)) != NULL) {\n            if ((buffer_size = read(file_handle, buffer_ptr, file_size)) == file_size) {\n              success = true;\n              if (file_size < eeprom_size) {\n                bytes_to_write = eeprom_size - file_size;\n                bytes_written = 0;\n                while (bytes_written < bytes_to_write) {\n                  bytes_to_write = bytes_to_write - bytes_written;\n                  bytes_to_write = bytes_to_write > EEPROM_WRITE_SIZE ? EEPROM_WRITE_SIZE : bytes_to_write;\n                  bytes_written = bytes_written + bytes_to_write;\n                  bytes_to_write = bytes_to_write > EEPROM_ERASE_SIZE ? EEPROM_ERASE_SIZE : bytes_to_write;\n                  bytes_written = bytes_written + bytes_to_write;\n                }\n              }\n            }\n            else {\n              success = false;\n            }\n            free(buffer_ptr);\n          }\n          else {\n            success = false;\n          }\n        }\n        else {\n          success =", "CodeBleu_score": 39.20650919551273}, {"code": "bool PersistentStore::access_start(){\n\t// Open the file\n  int fd = open(filename, O_RDWR);\n  if (fd < 0) {\n    // File does not exist\n    return false;\n  }\n\n  // Get file size\n  struct stat statbuf;\n  fstat(fd, &statbuf);\n  size_t filesize = statbuf.st_size;\n\n  // Read the file into the buffer\n  if (filesize > EEPROM_SIZE) {\n    // File is too big\n    close(fd);\n    return false;\n  }\n  if (filesize < EEPROM_SIZE) {\n    // File is too small, fill the rest with 0xFF\n    memset(buffer, 0xFF, EEPROM_SIZE);\n    filesize = EEPROM_SIZE;\n  }\n  ssize_t bytesread = read(fd, buffer, filesize);\n  if (bytesread < 0) {\n    // Read error\n    close(fd);\n    return false;\n  }\n  if ((size_t)bytesread < filesize) {\n    // Read error\n    close(fd);\n    return false;\n  }\n\n  // Close the file\n  close(fd);\n\n  // File is OK\n  return true;\n}", "CodeBleu_score": 41.068010745682514}, {"code": "bool PersistentStore::access_start(){\n\tif (!SD.exists(filename)) {\n    return false;\n  }\n  file = SD.open(filename, FILE_READ);\n  if (!file) {\n    return false;\n  }\n  file_size = file.size();\n  if (file_size > EEPROM_SIZE) {\n    file_size = EEPROM_SIZE;\n  }\n  file.read(buffer, file_size);\n  file.close();\n  return true;\n}", "CodeBleu_score": 31.329596641506125}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t r = 0;\n\tfor (uint8_t i = 0; i < 8; i++) {\n\t\tHAL_SPI_STM32_SetClockLow();\n\t\tHAL_SPI_STM32_WriteMosi(b & 0x80);\n\t\tHAL_SPI_STM32_SetClockHigh();\n\t\tr = (r << 1) | HAL_SPI_STM32_ReadMiso();\n\t\tb = b << 1;\n\t}\n\tHAL_SPI_STM32_SetClockLow();\n\tHAL_SPI_STM32_WriteMosi(0);\n\tHAL_SPI_STM32_SetClockHigh();\n\tHAL_SPI_STM32_ReadMiso();\n\tHAL_SPI_STM32_SetClockLow();\n\tHAL_SPI_STM32_WriteMosi(0);\n\tHAL_SPI_STM32_SetClockHigh();\n\tHAL_SPI_STM32_ReadMiso();\n\treturn r;\n}", "CodeBleu_score": 38.47027800751087}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t i;\n    uint8_t r;\n\n    // SPIx_SS_LOW\n    SPIx_SS_LOW();\n\n    // SPIx_MOSI_HIGH\n    SPIx_MOSI_HIGH();\n\n    // SPIx_SCK_LOW\n    SPIx_SCK_LOW();\n\n    // SPIx_MOSI_LOW\n    SPIx_MOSI_LOW();\n\n    // SPIx_SCK_HIGH\n    SPIx_SCK_HIGH();\n\n    // SPIx_MOSI_HIGH\n    SPIx_MOSI_HIGH();\n\n    // SPIx_SCK_LOW\n    SPIx_SCK_LOW();\n\n    // SPIx_MOSI_LOW\n    SPIx_MOSI_LOW();\n\n    // SPIx_SCK_HIGH\n    SPIx_SCK_HIGH();\n\n    // SPIx_MOSI_HIGH\n    SPIx_MOSI_HIGH();\n\n    // SPIx_SCK_LOW\n    SPIx_SCK_LOW();\n\n    // SPIx_MOSI_LOW\n    SPIx_MOSI_LOW();\n\n    // SPIx_SCK_HIGH\n    SPIx_SCK_HIGH();\n\n    // SPIx_MOSI_HIGH\n    SPIx_MOSI_HIGH();\n\n    // SPIx_SCK_LOW\n    SPIx_SCK_LOW();\n\n    // SPIx_MOSI_LOW\n    SPIx_MOSI_LOW();\n\n    // SPIx_SCK_HIGH\n    SPIx_SCK_HIGH();\n\n    // SPIx_MOSI_HIGH\n    SPIx_MOSI_HIGH();\n\n    // SPIx_SCK_LOW\n    SPIx_SCK_LOW();\n\n    // SPIx_", "CodeBleu_score": 33.91413987999457}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b){\n\tuint8_t c = 0;\n\tuint8_t i;\n\tfor (i = 0; i < 8; i++) {\n\t\tSPI_SCK_LOW;\n\t\tSPI_MOSI_WRITE(b & 0x80);\n\t\tSPI_SCK_HIGH;\n\t\tSPI_MISO_READ(c);\n\t\tb <<= 1;\n\t\tc >>= 1;\n\t}\n\tSPI_SCK_LOW;\n\tSPI_MOSI_WRITE(b & 0x80);\n\tSPI_SCK_HIGH;\n\tSPI_MISO_READ(c);\n\tb <<= 1;\n\tc >>= 1;\n\tHAL_SPI_STM32_Delay_1();\n\treturn c;\n}", "CodeBleu_score": 45.63883198114391}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    if (NewState != DISABLE) {\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 83.79020628658785}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 84.07596204999733}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState){\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}", "CodeBleu_score": 46.64045728127212}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c;\n  if (obj->rx_buff.head == obj->rx_buff.tail) {\n    // Buffer is full: discard byte\n    obj->rx_buff.head = (obj->rx_buff.head + 1) & (SERIAL_RX_BUFFER_SIZE - 1);\n    obj->rx_buff.buffer[obj->rx_buff.head] = 0;\n  }\n  else {\n    // Buffer is not full: read byte and store it\n    c = obj->serial->RX_BUFFER;\n    obj->rx_buff.buffer[obj->rx_buff.head] = c;\n    obj->rx_buff.head = (obj->rx_buff.head + 1) & (SERIAL_RX_BUFFER_SIZE - 1);\n    if (obj->parity_enable) {\n      obj->parity_error = (obj->parity_error | c) & (c ^ obj->parity);\n    }\n  }\n}", "CodeBleu_score": 39.969037866389904}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = obj->serial->RXDATA;\n\n  if (rx_buffer_head != rx_buffer_tail) {\n    rx_buffer[rx_buffer_head] = c;\n    rx_buffer_head = (rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n\n  // If the emergency parser is enabled, give it the received byte\n  if (emergency_parser_enabled) {\n    emergency_parser_rx_byte(c);\n  }\n\n  // If the RX interrupt is enabled, give it the received byte\n  if (rx_interrupt_enabled) {\n    rx_callback(c);\n  }\n}", "CodeBleu_score": 37.02964925871157}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj){\n\tuint8_t c = obj->serial->RX_COMPLETE_IRQ_VECTOR;\n\n  if (!(obj->serial->STATUS & SERIAL_RX_COMPLETE_IRQ_MASK)) return;\n\n  if (obj->serial->STATUS & SERIAL_RX_OVERFLOW_IRQ_MASK) {\n    obj->serial->STATUS = SERIAL_RX_OVERFLOW_IRQ_MASK;\n    if (rx_overrun_errors < (0xFF - 1)) rx_overrun_errors++;\n  }\n\n  if (obj->serial->STATUS & SERIAL_RX_FRAMING_IRQ_MASK) {\n    obj->serial->STATUS = SERIAL_RX_FRAMING_IRQ_MASK;\n    if (rx_framing_errors < (0xFF - 1)) rx_framing_errors++;\n  }\n\n  if (obj->serial->STATUS & SERIAL_RX_PARITY_IRQ_MASK) {\n    obj->serial->STATUS = SERIAL_RX_PARITY_IRQ_MASK;\n    if (rx_parity_errors < (0xFF - 1)) rx_parity_errors++;\n  }\n\n  if (obj->serial->STATUS & SERIAL_RX_DONE_IRQ_MASK) {\n    obj->serial->STATUS = SERIAL_RX_DONE_IRQ_MASK;\n    if (rx_crc_errors < (0xFF - 1)) rx_crc_errors++;\n  }\n\n  if (rx_buffer_head == rx_buffer_tail) {\n    // Buffer overflow\n    rx_buffer_overflow_errors++;\n    rx_buffer_head = rx_buffer_tail = 0;\n  }\n  else {\n    rx_buffer[rx_buffer_head] = c;\n    rx_buffer_head = (rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  }\n\n  if (rx_buffer_head == rx_buffer_tail) {\n    //", "CodeBleu_score": 31.93942656624974}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n    if (!step_timer_initialized) {\n      step_timer_initialized = true;\n      NVIC_EnableIRQ(TIMER0_IRQn);\n    }\n    if (!step_timer_has_interrupt) {\n      step_timer_has_interrupt = true;\n      NVIC_SetVector(TIMER0_IRQn, (uint32_t)Step_Handler);\n    }\n  }\n  else if (timer_num == MF_TIMER_TEMP) {\n    if (!temp_timer_initialized) {\n      temp_timer_initialized = true;\n      NVIC_EnableIRQ(TIMER1_IRQn);\n    }\n    if (!temp_timer_has_interrupt) {\n      temp_timer_has_interrupt = true;\n      NVIC_SetVector(TIMER1_IRQn, (uint32_t)Temp_Handler);\n    }\n  }\n}", "CodeBleu_score": 30.310734146264117}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n        if (!(TIFR1 & (1 << TOV1))) {\n            TIMSK1 |= (1 << TOIE1);\n            TIFR1 |= (1 << TOV1);\n        }\n    }\n    else if (timer_num == MF_TIMER_TEMP) {\n        if (!(TIFR2 & (1 << TOV2))) {\n            TIMSK2 |= (1 << TOIE2);\n            TIFR2 |= (1 << TOV2);\n        }\n    }\n}", "CodeBleu_score": 27.143135585786016}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num){\n\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (step_timer_enabled == false) {\n\t\t\tstep_timer_enabled = true;\n\t\t\tstep_timer_interrupt_enabled = true;\n\t\t\tattachInterrupt(digitalPinToInterrupt(STEP_TIMER_INT), Step_Handler, CHANGE);\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (temp_timer_enabled == false) {\n\t\t\ttemp_timer_enabled = true;\n\t\t\ttemp_timer_interrupt_enabled = true;\n\t\t\tattachInterrupt(digitalPinToInterrupt(TEMP_TIMER_INT), Temp_Handler, CHANGE);\n\t\t}\n\t}\n}", "CodeBleu_score": 29.79141989981875}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\tvar (\n\t\thash, pow, sq uint32\n\t\thashSep, powSep uint32\n\t)\n\tif len(sep) < 5 {\n\t\thash, pow = HashStrRev(sep)\n\t\thashSep = hash\n\t\tpowSep = pow\n\t} else {\n\t\thash, pow = HashStrRev(sep[:5])\n\t\thashSep, powSep = HashStrRev(sep)\n\t}\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif hash == hashSep {\n\t\t\tfor j := 0; j < len(sep); j++ {\n\t\t\t\tif s[i+j] != sep[j] {\n\t\t\t\t\tgoto next\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i\n\t\t}\n\tnext:\n\t\tif i >= 5 {\n\t\t\thash = (hash - uint32(s[i-5])*pow + uint32(s[i+len(sep)-1])*powSep) % PrimeRK\n\t\t} else {\n\t\t\thash = (hash - uint32(s[i-5])*pow + uint32(s[i+len(sep)-1])*powSep) % PrimeRK\n\t\t\tif i >= 1 {\n\t\t\t\thash = (hash - uint32(s[i-1])*powSep + uint32(s[i+len(sep)-1])*pow) % PrimeRK\n\t\t\t} else {\n\t\t\t\thash = (hash - uint32(s[i-1])*powSep + uint32(s[i+len(sep)-1])*pow) % PrimeRK\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 34.30094372729326}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\tvar hash, pow, sq, sepHash, sepPow, sepSq uint32\n\tif len(sep) == 0 {\n\t\treturn -1\n\t}\n\tif len(s) == 0 {\n\t\treturn -1\n\t}\n\thash, pow = HashStrRev(sep)\n\tsepHash, sepPow = HashStrRev(s[:len(sep)])\n\tif hash == sepHash && s[:len(sep)] == sep {\n\t\treturn 0\n\t}\n\tsq = pow\n\tfor i := len(sep); i < len(s); i++ {\n\t\thash = hash*PrimeRK + uint32(s[i]) - sepPow*uint32(s[i-len(sep)])\n\t\tif hash == sepHash && s[i-len(sep)+1:i+1] == sep {\n\t\t\treturn i - len(sep) + 1\n\t\t}\n\t\tif i >= len(sep) {\n\t\t\tsepHash = sepHash*PrimeRK + uint32(s[i-len(sep)]) - sepPow*uint32(s[i-len(sep)-1])\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 37.531907206628425}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int{\n\thashS, pow := HashStrRev[T](s)\n\thashSep, _ := HashStrRev[T](sep)\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tif hashS[i] == hashSep && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t\tif i > 0 {\n\t\t\thashS = (hashS - uint32(s[i-1])*pow) * PrimeRK\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 33.251873043810434}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush(){\n\tusbcdc.waitTxc = false\n\tif usbcdc.txb_cnt > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txb_ptr, usbcdc.txb_cnt)\n\t\tusbcdc.txb_cnt = 0\n\t\tusbcdc.txb_ptr = 0\n\t}\n}", "CodeBleu_score": 25.314396025950746}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tusbcdc.usb.USB_EP_REG[usbcdc.tx_ep].USB_EP_TX_STATUS = 0x00000000\n\tusbcdc.usb.USB_EP_REG[usbcdc.tx_ep].USB_EP_TX_CNT = 0\n\tusbcdc.usb.USB_EP_REG[usbcdc.tx_ep].USB_EP_TX_CNT = uint32(usbcdc.tx_buffer_ptr)\n\tusbcdc.usb.USB_EP_REG[usbcdc.tx_ep].USB_EP_TX_ADDR = uint32(uintptr(unsafe.Pointer(&usbcdc.tx_buffer[0])))\n\tusbcdc.usb.USB_EP_REG[usbcdc.tx_ep].USB_EP_TX_STATUS = 0x00000002\n\tusbcdc.waitTxc = true\n\tusbcdc.usb.USB_EP_REG[usbcdc.tx_ep].USB_EP_TX_STATUS = 0x00000000\n}", "CodeBleu_score": 13.544726753336214}, {"code": "func (usbcdc *USBCDC) Flush(){\n\tusbcdc.waitTxc = false\n\tif usbcdc.txb.Get() != 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txb.Get(), usbcdc.txb.Get())\n\t}\n}", "CodeBleu_score": 27.623042589617498}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.clearIntFlag()\n\ti2c.setStart()\n\ti2c.waitForStart()\n\ti2c.write(address<<1 | uint8(write))\n\ti2c.waitForStop()\n}", "CodeBleu_score": 23.646812676821238}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\ti2c.I2C_CR = (i2c.I2C_CR & 0xFFFFFFF8) | 0x00000001 // Clear interrupt flag\n\ti2c.I2C_CR = (i2c.I2C_CR & 0xFFFFFFF8) | 0x00000002 // Start condition\n\tfor {\n\t\tif i2c.I2C_SR&0x00000001 != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tif write {\n\t\ti2c.I2C_DR = address<<1 | 0x00000001 // Write address\n\t} else {\n\t\ti2c.I2C_DR = address<<1 | 0x00000002 // Read address\n\t}\n\tfor {\n\t\tif i2c.I2C_SR&0x00000001 != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}", "CodeBleu_score": 28.049456861132438}, {"code": "func (i2c *I2C) start(address uint8, write bool){\n\t// Clear interrupt flag\n\ti2c.Control.ClearInterruptFlag()\n\n\t// Set start condition\n\ti2c.Control.SetStartCondition()\n\n\t// Wait for start condition to be transmitted\n\tfor !i2c.Control.GetStartCondition() {\n\t}\n\n\t// Send address\n\ti2c.Address.SetAddress(address, write)\n\n\t// Wait for address to be transmitted\n\tfor !i2c.Control.GetAddressSent() {\n\t}\n}", "CodeBleu_score": 29.46455381574432}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif len < 1 {\n\t\treturn errors.New(\"length must be greater than 0\")\n\t}\n\tif start < 0 || start >= f.size {\n\t\treturn errors.New(\"start address must be in range\")\n\t}\n\tif start+len > f.size {\n\t\treturn errors.New(\"length is too long\")\n\t}\n\t// calculate the start address\n\tstartAddress := uint32(start) * f.blockSize\n\t// set the flash to erase mode\n\tf.writeRegister(0x05, 0x00)\n\t// erase blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// erase the block\n\t\tf.writeRegister(0x00, startAddress)\n\t\t// wait for flash to be ready\n\t\tfor f.readRegister(0x07) != 0 {\n\t\t}\n\t\t// increment the start address\n\t\tstartAddress += f.blockSize\n\t}\n\t// set the flash to read mode\n\tf.writeRegister(0x05, 0x01)\n\treturn nil\n}", "CodeBleu_score": 31.655642949833883}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\t// Calculate the start address of the first block to be erased\n\tstartAddress := f.baseAddress + (start * f.blockSize)\n\n\t// Configure the flash for erasing\n\tf.configure(true)\n\n\t// Erase the blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// Erase the block\n\t\tf.eraseBlock(startAddress)\n\n\t\t// Wait for the flash to be ready\n\t\tf.waitForFlashReady()\n\n\t\t// Increment the start address\n\t\tstartAddress += f.blockSize\n\t}\n\n\t// Set the flash to read mode\n\tf.configure(false)\n\n\treturn nil\n}", "CodeBleu_score": 27.641550876550298}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error{\n\tif start < 0 || start >= f.BlockCount {\n\t\treturn errors.New(\"Start block number out of range\")\n\t}\n\tif len < 0 {\n\t\treturn errors.New(\"Invalid length\")\n\t}\n\tif start+len > f.BlockCount {\n\t\treturn errors.New(\"End block number out of range\")\n\t}\n\tif len == 0 {\n\t\treturn nil\n\t}\n\t// Calculate start address\n\tstartAddr := uint32(start) * uint32(f.BlockSize)\n\t// Wait for any ongoing flash operations to complete\n\tf.waitForFlashReady()\n\t// Configure flash for erasing\n\tf.flash.CR.Store(f.flash.CR.Load() | flash.CR_PER)\n\t// Erase blocks\n\tfor i := int64(0); i < len; i++ {\n\t\t// Set address\n\t\tf.flash.AR.Store(startAddr + uint32(i)*f.BlockSize)\n\t\t// Set page erase bit\n\t\tf.flash.CR.Store(f.flash.CR.Load() | flash.CR_STRT)\n\t\t// Wait until page erase operation completes\n\t\tf.waitForFlashReady()\n\t}\n\t// Set flash back to read mode\n\tf.flash.CR.Store(f.flash.CR.Load() &^ flash.CR_PER)\n\t// Wait until flash is no longer busy\n\tf.waitForFlashReady()\n\t// Return nil\n\treturn nil\n}", "CodeBleu_score": 35.64655544615521}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || off+int64(len(p)) > f.size {\n\t\treturn 0, errors.New(\"WriteAt: offset is out of bounds\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\t// Calculate the start address and pad the data to the write block size\n\tstartAddr := int(off) &^ (f.writeBlockSize - 1)\n\tdata := make([]byte, f.writeBlockSize)\n\tcopy(data, p)\n\t// Write the data in blocks\n\tvar bytesWritten int\n\tfor i := 0; i < len(data); i += f.writeBlockSize {\n\t\t// Enable write mode\n\t\tf.setWriteMode()\n\t\t// Write the data in blocks\n\t\tf.writeBlock(startAddr, data[i:i+f.writeBlockSize])\n\t\t// Wait for the flash memory to be ready\n\t\tf.waitForReady()\n\t\t// Increment the number of bytes written\n\t\tbytesWritten += f.writeBlockSize\n\t\t// Disable write mode\n\t\tf.setReadMode()\n\t}\n\treturn bytesWritten, nil\n}", "CodeBleu_score": 27.12181605570291}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\tif off < 0 || off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"WriteAt: offset out of bounds\")\n\t}\n\n\t// Calculate start address and pad to write block size\n\tstartAddr := off / int64(f.blockSize)\n\tstartAddr *= int64(f.blockSize)\n\tpadding := int(off) - int(startAddr)\n\tp = append(make([]byte, padding), p...)\n\n\t// Enable write mode\n\tf.enableWriteMode()\n\n\t// Write data in blocks\n\tfor len(p) > 0 {\n\t\t// Calculate number of bytes to write\n\t\tn := len(p)\n\t\tif n > f.blockSize {\n\t\t\tn = f.blockSize\n\t\t}\n\n\t\t// Write data\n\t\terr = f.writeBlock(p[:n], startAddr)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\n\t\t// Update offset and byte slice\n\t\tp = p[n:]\n\t\tstartAddr += int64(n)\n\t}\n\n\t// Disable write mode\n\tf.disableWriteMode()\n\n\t// Return number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 31.223279439759548}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error){\n\t// Check if the write operation exceeds the flash memory bounds\n\tif off < 0 || off+int64(len(p)) > f.Size() {\n\t\treturn 0, errors.New(\"WriteAt: offset exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing\n\taddr := f.startAddr + off\n\n\t// Pad the byte slice to fit the write block size\n\tpad := f.writeBlockSize - (len(p) % f.writeBlockSize)\n\tif pad != f.writeBlockSize {\n\t\tp = append(p, make([]byte, pad)...)\n\t}\n\n\t// Enable write mode on the flash memory controller\n\tf.enableWriteMode()\n\n\t// Write the data in blocks\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\t// Write the data in a block\n\t\tif err := f.writeBlock(addr, p[i:i+f.writeBlockSize]); err != nil {\n\t\t\treturn i, err\n\t\t}\n\n\t\t// Wait for the flash memory to be ready\n\t\tif err := f.waitReady(); err != nil {\n\t\t\treturn i, err\n\t\t}\n\n\t\t// Increment the address\n\t\taddr += f.writeBlockSize\n\t}\n\n\t// Return the number of bytes written\n\treturn len(p), nil\n}", "CodeBleu_score": 31.18308765554303}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor\n\tdupFD, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"Error duplicating file descriptor: \" + err.Error(), err\n\t}\n\n\t// Open the directory\n\tdir, err := syscall.Fdopendir(dupFD)\n\tif err != nil {\n\t\t// Close the duplicated file descriptor\n\t\tsyscall.Close(dupFD)\n\n\t\t// Return the error\n\t\treturn 0, \"Error opening directory: \" + err.Error(), err\n\t}\n\n\t// Return the directory pointer\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 48.30078860441345}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"Dup\", err\n\t}\n\n\t// Open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// If we got an error, close the duplicated file descriptor and return the error.\n\t\t_ = syscall.Close(dupFd)\n\t\treturn 0, \"Fdopendir\", err\n\t}\n\n\t// If we got this far, we succeeded.\n\treturn uintptr(dir), \"\", nil\n}", "CodeBleu_score": 55.978159869584275}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error){\n\t// Duplicate the provided file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, err.Error(), err\n\t}\n\t// Attempt to open the directory using the duplicated file descriptor.\n\tdirPtr, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// If the error is \"syscall.EINTR\", then attempt to open the directory again.\n\t\tif err == syscall.EINTR {\n\t\t\treturn darwinOpenDir(fd)\n\t\t}\n\t\t// Close the duplicated file descriptor.\n\t\tsyscall.Close(dupFd)\n\t\t// Return the error.\n\t\treturn 0, err.Error(), err\n\t}\n\t// Close the duplicated file descriptor.\n\tsyscall.Close(dupFd)\n\t// Return the directory pointer.\n\treturn uintptr(dirPtr), \"\", nil\n}", "CodeBleu_score": 53.24848044581969}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response){\n\tuint32_t freeSpace = 0;\n    uint32_t totalSize = 0;\n    uint32_t usedSize = 0;\n    esp_partition_iterator_t iterator = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_APP_OTA_0, NULL);\n    if (iterator == NULL) {\n        return 0;\n    }\n    const esp_partition_t *partition = esp_partition_get(iterator);\n    if (partition == NULL) {\n        return 0;\n    }\n    if (partition->size == 0) {\n        return 0;\n    }\n    if (esp_ota_get_partition_description(partition, NULL, &freeSpace, &totalSize) != ESP_OK) {\n        return 0;\n    }\n    if (response == SKETCH_SIZE_FREE) {\n        return freeSpace;\n    }\n    usedSize = totalSize - freeSpace;\n    return usedSize;\n}", "CodeBleu_score": 40.69917569702648}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tif (response == true) {\n    return ESP.getFreeSketchSpace();\n  } else {\n    return ESP.getSketchSize();\n  }\n}", "CodeBleu_score": 15.52231960328746}, {"code": "static uint32_t sketchSize(sketchSize_t response){\n\tuint32_t freeSpace = 0;\n  uint32_t sketchSize = 0;\n  esp_partition_t *partition = esp_ota_get_running_partition();\n  if (partition == NULL) {\n    return 0;\n  }\n  if (partition->type == ESP_PARTITION_TYPE_APP) {\n    if (response) {\n      freeSpace = esp_partition_get_free_size(partition);\n      return freeSpace;\n    }\n    else {\n      sketchSize = esp_ota_get_app_size();\n      return sketchSize;\n    }\n  }\n  return 0;\n}", "CodeBleu_score": 43.12810327127548}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tuint32_t i;\n  size_t data_sectors = 0;\n  size_t total_sectors = 0;\n  bool ret = false;\n  if (msc_disk_sectors == 0) {\n    msc_disk_sectors = msc_update_get_required_disk_sectors();\n  }\n  if (msc_disk_sectors > 0) {\n    if (msc_disk_sectors > 0xFF4) {\n      log_d(\"USING FAT16\");\n      mcs_is_fat16 = true;\n    } else {\n      log_d(\"USING FAT12\");\n      mcs_is_fat16 = false;\n    }\n    if (msc_disk_sectors > 0xFF4) {\n      msc_table_sectors = fat_sectors_per_alloc_table(msc_disk_sectors - msc_table_sectors, true);\n    } else {\n      msc_table_sectors = fat_sectors_per_alloc_table(msc_disk_sectors - msc_table_sectors, false);\n    }\n    data_sectors = msc_disk_sectors - msc_table_sectors - 2;\n    log_d(\"FAT sector size: %u\", DISK_SECTOR_SIZE);\n    log_d(\"FAT data sectors: %u\", data_sectors);\n    log_d(\"FAT table sectors: %u\", msc_table_sectors);\n    log_d(\"FAT total sectors: %u (%uKB)\", msc_disk_sectors, (msc_disk_sectors * DISK_SECTOR_SIZE) / 1024);\n    if (msc_disk_sectors > 0xFF4) {\n      msc_disk_sectors = msc_disk_sectors - msc_table_sectors;\n    }\n    msc_disk = malloc(msc_disk_sectors * DISK_SECTOR_SIZE);\n    if (msc_disk", "CodeBleu_score": 30.6950910399731}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tif (msc_disk_sectors == 0) {\n    msc_disk_sectors = msc_update_get_required_disk_sectors();\n  }\n  if (msc_disk_sectors == 0) {\n    log_e(\"Invalid disk size\");\n    return false;\n  }\n  if (msc_disk_sectors > 0xFF4) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sectors > msc_disk_sectors_max) {\n    log_e(\"Disk size too large\");\n    return false;\n  }\n  if (msc_disk_sect", "CodeBleu_score": 19.532617056447133}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number){\n\tsize_t total_sectors = msc_update_get_required_disk_sectors();\n  if (total_sectors > 0) {\n    msc_disk = (msc_disk_t *)calloc(1, sizeof(msc_disk_t));\n    if (msc_disk) {\n      msc_disk->data = (uint8_t *)calloc(total_sectors, DISK_SECTOR_SIZE);\n      if (msc_disk->data) {\n        msc_disk->total_sectors = total_sectors;\n        msc_disk->serial_number = serial_number;\n        msc_disk->volume_label = volume_label;\n        msc_disk->fat_type = mcs_is_fat16 ? 16 : 12;\n        msc_disk->fat_sectors = msc_table_sectors;\n        msc_disk->root_dir_sectors = 0;\n        msc_disk->data_sectors = msc_disk->total_sectors - msc_disk->fat_sectors - msc_disk->root_dir_sectors;\n        if (msc_disk->data_sectors > 0) {\n          msc_disk->data_cluster_count = msc_disk->data_sectors / msc_disk->fat_type;\n          msc_disk->data_cluster_size = msc_disk->fat_type == 16 ? 2 : 1;\n          msc_disk->data_cluster_mask = msc_disk->data_cluster_size == 1 ? 0xFFF : 0xFFF;\n          msc_disk->data_cluster_shift = msc_disk->data_cluster_size == 1 ? 12 : 12;\n          msc_disk->data_cluster_sectors = msc_disk->data_cluster_count * msc_disk->data_cluster_size;\n          msc_disk->data_cluster_offset = msc_disk->fat_sectors;\n          msc_disk->data_cluster_offset += msc", "CodeBleu_score": 25.281366572919605}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err;\n    size_t block_size = esp_partition_get_size(partition);\n    size_t aligned_offset = offset & ~(block_size - 1);\n    size_t block_offset = offset - aligned_offset;\n    size_t block_size_to_write = size + block_offset;\n    size_t block_count = block_size_to_write / block_size;\n    if (block_size_to_write % block_size) {\n        block_count++;\n    }\n    if (block_offset) {\n        err = esp_partition_erase_range(partition, aligned_offset, block_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase partition %d at offset 0x%x (%d): 0x%x\", partition->address, aligned_offset, block_size, err);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, block_offset, data, block_size_to_write);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write to partition %d at offset 0x%x (%d): 0x%x\", partition->address, aligned_offset, block_size, err);\n        return err;\n    }\n    return ESP_OK;\n}", "CodeBleu_score": 50.13277011716411}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tesp_err_t err = ESP_OK;\n\tuint32_t sector_size = 4096;\n\tuint32_t aligned_offset = offset & (sector_size - 1);\n\tif (aligned_offset != 0) {\n\t\t// The offset is not aligned with the flash sector size, so erase the corresponding sector\n\t\terr = esp_partition_erase_range(partition, offset - aligned_offset, sector_size);\n\t\tif (err != ESP_OK) {\n\t\t\t// Failed to erase the sector, log an error message and return the error code\n\t\t\tESP_LOGE(TAG, \"Failed to erase the sector at offset %d\", offset);\n\t\t\treturn err;\n\t\t}\n\t}\n\t// Write the data to the specified offset\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\t// Failed to write the data, log an error message and return the error code\n\t\tESP_LOGE(TAG, \"Failed to write data to the partition\");\n\t\treturn err;\n\t}\n\treturn ESP_OK;\n}", "CodeBleu_score": 59.64900068271135}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size){\n\tif (offset % MSC_FLASH_SECTOR_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Offset is not aligned with the flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tif (size % MSC_FLASH_SECTOR_SIZE != 0) {\n\t\tESP_LOGE(TAG, \"Size is not aligned with the flash sector size\");\n\t\treturn ESP_ERR_INVALID_ARG;\n\t}\n\tesp_err_t err = ESP_OK;\n\tif (offset % MSC_FLASH_SECTOR_SIZE != 0) {\n\t\terr = esp_partition_erase_range(partition, offset, MSC_FLASH_SECTOR_SIZE);\n\t\tif (err != ESP_OK) {\n\t\t\tESP_LOGE(TAG, \"Failed to erase flash sector\");\n\t\t\treturn err;\n\t\t}\n\t}\n\terr = esp_partition_write(partition, offset, data, size);\n\tif (err != ESP_OK) {\n\t\tESP_LOGE(TAG, \"Failed to write data to flash\");\n\t\treturn err;\n\t}\n\treturn err;\n}", "CodeBleu_score": 57.524044018611974}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i = 0;\n  size_t j = 0;\n  while (in[i] && j < maxlen) {\n    if (in[i] >= 'a' && in[i] <= 'f')\n      out[j++] = (in[i] - ((uint8_t)'a' - 0xa));\n    else if (in[i] >= 'A' && in[i] <= 'F')\n      out[j++] = (in[i] - ((uint8_t)'A' - 0xA));\n    else if (in[i] >= '0' && in[i] <= '9')\n      out[j++] = (in[i] - (uint8_t)'0');\n    else if (in[i] == ' ')\n      ; // skip spaces\n    else\n      break; // invalid character\n    i++;\n  }\n  return j;\n}", "CodeBleu_score": 40.257476214872135}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i, j;\n  uint8_t c;\n  for (i = 0, j = 0; i < strlen(in) && j < maxlen; i++) {\n    c = in[i];\n    if (c >= 'a' && c <= 'f')   out[j++] = (c - ((uint8_t)'a' - 0xa));\n    else if (c >= 'A' && c <= 'F') out[j++] = (c - ((uint8_t)'A' - 0xA));\n    else if (c >= '0' && c <= '9') out[j++] = (c - (uint8_t)'0');\n    else if (c == ' ' || c == '\\t' || c == '\n' || c == '\\r') continue;\n    else break;\n  }\n  return j;\n}", "CodeBleu_score": 35.04527414096721}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in){\n\tsize_t i = 0;\n  size_t j = 0;\n\n  while (i < maxlen && in[j] != '\\0') {\n    uint8_t c = in[j];\n    if (c >= 'a' && c <= 'f') {\n      out[i] = (c - ((uint8_t)'a' - 0xa));\n    } else if (c >= 'A' && c <= 'F') {\n      out[i] = (c - ((uint8_t)'A' - 0xA));\n    } else if (c >= '0' && c <= '9') {\n      out[i] = (c - (uint8_t)'0');\n    } else {\n      break;\n    }\n    i++;\n    j++;\n  }\n  return i;\n}", "CodeBleu_score": 41.36750298442087}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void){\n\tif (tx_ring_buffer == NULL || tx_ring_buffer_lock == NULL) {\n\t\treturn 0;\n\t}\n\n\tint result = 0;\n\tif (xSemaphoreTake(tx_ring_buffer_lock, portMAX_DELAY) == pdTRUE) {\n\t\tresult = tx_ring_buffer->available();\n\t\txSemaphoreGive(tx_ring_buffer_lock);\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 61.19753982051904}, {"code": "int HWCDC::availableForWrite(void){\n\tif (tx_buffer == NULL) {\n    return 0;\n  }\n\n  if (tx_buffer_lock == NULL) {\n    return 0;\n  }\n\n  if (xSemaphoreTake(tx_buffer_lock, portMAX_DELAY) == pdTRUE) {\n    int free = tx_buffer->free();\n    xSemaphoreGive(tx_buffer_lock);\n    return free;\n  } else {\n    return 0;\n  }\n}", "CodeBleu_score": 62.13872881239488}, {"code": "int HWCDC::availableForWrite(void){\n\tif (!tx_ring_buffer || !tx_ring_buffer_lock) {\n\t\treturn 0;\n\t}\n\n\tif (xSemaphoreTake(tx_ring_buffer_lock, TX_BUFFER_LOCK_TIMEOUT) != pdTRUE) {\n\t\treturn 0;\n\t}\n\n\tint free_space = tx_ring_buffer_size - tx_ring_buffer_head - tx_ring_buffer_tail;\n\n\txSemaphoreGive(tx_ring_buffer_lock);\n\n\treturn free_space;\n}", "CodeBleu_score": 43.207601219277436}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t// Lock the serial mutex\n  xSemaphoreTake(_serialMutex, portMAX_DELAY);\n\n  // Assign the provided callback function to \"_onReceiveCB\"\n  _onReceiveCB = function;\n\n  // Configure the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  if (onlyOnTimeout) {\n    _rxTimeout = 0;\n  } else if (_rxTimeout == 0) {\n    _rxTimeout = 1;\n  }\n\n  // If the callback is not NULL, it sets the FIFO full threshold and creates an event task if it does not already exist\n  if (_onReceiveCB != NULL) {\n    // Set the FIFO full threshold\n    _uart_dev->conf1.rx_flow_thrhd = 1;\n    // Create an event task if it does not already exist\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n\n  // Unlock the serial mutex\n  xSemaphoreGive(_serialMutex);\n}", "CodeBleu_score": 53.59721121740147}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t// Lock the serial mutex\n  xSemaphoreTake(_serialMutex, portMAX_DELAY);\n\n  // Assign the callback function\n  _onReceiveCB = function;\n\n  // Configure the receive timeout behavior\n  if (onlyOnTimeout) {\n    _rxTimeout = false;\n  } else {\n    _rxTimeout = true;\n  }\n\n  // If the callback function is not NULL, set the FIFO full threshold and create an event task if it does not already exist\n  if (_onReceiveCB != NULL) {\n    _uart->setRxFifoFullThreshold(ARDUINO_SERIAL_RX_FIFO_FULL_THRESHOLD);\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n\n  // Unlock the serial mutex\n  xSemaphoreGive(_serialMutex);\n}", "CodeBleu_score": 53.965421949099834}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout){\n\t// Lock the serial mutex\n  xSemaphoreTake(_mutex, portMAX_DELAY);\n\n  // Assign the provided callback function to \"_onReceiveCB\"\n  _onReceiveCB = function;\n\n  // Configure the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values\n  if (onlyOnTimeout) {\n    _rxTimeout = false;\n  } else if (!_rxTimeout) {\n    _rxTimeout = true;\n  }\n\n  // If the callback is not NULL, it sets the FIFO full threshold and creates an event task if it does not already exist\n  if (_onReceiveCB != NULL) {\n    // Set the FIFO full threshold\n    _setRxFifoFullThreshold();\n\n    // Create an event task if it does not already exist\n    if (_eventTask == NULL) {\n      _createEventTask();\n    }\n  }\n\n  // Unlock the serial mutex\n  xSemaphoreGive(_mutex);\n}", "CodeBleu_score": 53.05450813208308}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    buffer[index++] = (char)c;\n  }\n  buffer[index] = 0;  // null terminate\n  return index;\n}", "CodeBleu_score": 85.6511151645276}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tsize_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0) {\n      break;\n    } else if (c == terminator) {\n      buffer[index++] = terminator;\n      break;\n    } else {\n      buffer[index++] = c;\n    }\n  }\n  return index;\n}", "CodeBleu_score": 67.26346108539573}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length){\n\tif (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    buffer[index++] = (char)c;\n  }\n  buffer[index] = 0;\n  return index;\n}", "CodeBleu_score": 83.83796708290612}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\tlog_v(\"tone: pin=%d, freq=%d, duration=%d\", pin, frequency, duration);\n  if (pin >= TONE_PIN_COUNT) {\n    log_e(\"Invalid pin number\");\n    return;\n  }\n  if (_tone_pins[pin] != -1) {\n    log_e(\"Pin already in use\");\n    return;\n  }\n  tone_init();\n  tone_msg_t msg = {\n    .pin = pin,\n    .frequency = frequency,\n    .duration = duration\n  };\n  if (xQueueSend(_tone_queue, &msg, 0) != pdPASS) {\n    log_e(\"Could not send tone message\");\n    return;\n  }\n  _tone_pins[pin] = 1;\n}", "CodeBleu_score": 58.928552523262645}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t// Check if the pin is available\n  if (_tone_pins[pin] == 0) {\n    // Pin is available, so initialize the tone\n    log_v(\"Tone on pin %d, frequency %d, duration %d\", pin, frequency, duration);\n    _tone_pins[pin] = 1;\n    tone_msg_t msg = {\n      .pin = pin,\n      .frequency = frequency,\n      .duration = duration\n    };\n    xQueueSend(_tone_queue, &msg, portMAX_DELAY);\n  } else {\n    // Pin is in use, so log an error message\n    log_e(\"Pin %d is already in use, please stop the current tone on this pin first\", pin);\n  }\n}", "CodeBleu_score": 56.39986080902803}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration){\n\t// Log the pin, frequency, and duration\n  log_v(\"tone: pin: %d, frequency: %d, duration: %d\", pin, frequency, duration);\n\n  // Check if the pin is available\n  if (is_pin_available(pin)) {\n    // If the pin is available, initialize the tone and send a start command\n    log_v(\"tone: pin available\");\n    if (tone_init()) {\n      // If tone init is successful, send a start command\n      tone_msg_t tone_msg;\n      tone_msg.pin = pin;\n      tone_msg.frequency = frequency;\n      tone_msg.duration = duration;\n      tone_msg.command = TONE_START;\n      if (xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY) == pdTRUE) {\n        log_v(\"tone: start command sent\");\n      } else {\n        log_e(\"tone: start command not sent\");\n      }\n    } else {\n      // If tone init is not successful, log an error message\n      log_e(\"tone: tone init not successful\");\n    }\n  } else {\n    // If the pin is not available, log an error message instructing to stop the current tone on the pin first\n    log_e(\"tone: pin in use\");\n  }\n}", "CodeBleu_score": 50.876613022572826}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (enabled) {\n        if (!_started) {\n            _webUSB = enabled;\n            return true;\n        }\n        if (_webUSB == enabled)\n            return false;\n        if (_webUSB) {\n            _webUSB = false;\n            _webUSB_enabled = false;\n            _webUSB_enabled_version = 0;\n            _webUSB_enabled_version_index = 0;\n        }\n        else {\n            _webUSB = true;\n            if (_webUSB_enabled_version == 0) {\n                _webUSB_enabled_version = _usb_version;\n                _webUSB_enabled_version_index = _usb_version_index;\n            }\n        }\n        return false;\n    }\n    if (!_started) {\n        _webUSB = enabled;\n        return true;\n    }\n    if (_webUSB == enabled)\n        return false;\n    _webUSB = enabled;\n    return false;\n}", "CodeBleu_score": 47.63171506347098}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (usbStarted) {\n    if (enabled) {\n      if (usbVersion >= 0x0210) {\n        webUSBEnabled = enabled;\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      webUSBEnabled = enabled;\n      return false;\n    }\n  } else {\n    webUSBEnabled = enabled;\n    return true;\n  }\n}", "CodeBleu_score": 35.73420200424946}, {"code": "bool ESPUSB::webUSB(bool enabled){\n\tif (!_started) {\n    _webUSB = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (_usbVersion < 0x0210) {\n      return true;\n    }\n    _webUSB = true;\n  } else {\n    _webUSB = false;\n  }\n  return false;\n}", "CodeBleu_score": 47.01977016585555}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX(){\n\tuint8_t *p;\n\tuint32_t i, len;\n\n\tlen = CDC_read(rxBuffer, USBCDC_RX_BUFFER_SIZE);\n\tif (len == 0) {\n\t\treturn;\n\t}\n\tp = rxBuffer;\n\tfor (i = 0; i < len; i++) {\n\t\tif (rxQueue.put(p[i]) != 0) {\n\t\t\tlogError(USBCDC_ERROR_RX_OVERFLOW, len - i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpostReceiveEvent(len);\n}", "CodeBleu_score": 17.8281105490297}, {"code": "void USBCDC::_onRX(){\n\tuint8_t rx_buffer[64];\n\tuint16_t rx_length;\n\tuint8_t i;\n\tuint8_t overflow_count = 0;\n\n\t// read data from the USB buffer into a local buffer\n\trx_length = _device->read(rx_buffer, 64);\n\n\t// send each byte to the receive queue\n\tfor (i = 0; i < rx_length; i++) {\n\t\tif (!_rx_queue.push(rx_buffer[i])) {\n\t\t\toverflow_count++;\n\t\t\t_overflow_event.post(overflow_count);\n\t\t\tLOG_ERROR((\"USBCDC\", \"RX overflow, dropped %d bytes\", overflow_count));\n\t\t}\n\t}\n\n\t// post a receive event\n\t_rx_event.post(rx_length);\n}", "CodeBleu_score": 20.191992973666473}, {"code": "void USBCDC::_onRX(){\n\tuint8_t buffer[USB_CDC_RX_BUFFER_SIZE];\n  uint8_t bytesRead = 0;\n  uint8_t bytesToRead = 0;\n  uint8_t bytesToSend = 0;\n  uint8_t bytesToDrop = 0;\n  uint8_t bytesToSendNow = 0;\n  uint8_t bytesToSendNext = 0;\n  uint8_t bytesToDropNext = 0;\n  uint8_t bytesToDropNow = 0;\n  uint8_t bytesToDropNextNext = 0;\n  uint8_t bytesToDropNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext = 0;\n  uint8_t bytesToDropNextNextNextNextNextNextNextNextNextNextNextNextNextNextNext", "CodeBleu_score": 6.092970383035165}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Parse the robot name from the URL.\n\trobotName := req.URL.Query().Get(\":robot\")\n\n\t// Check if the robot exists.\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\t// If the robot does not exist, return a 404.\n\t\tif err == database.ErrRobotNotFound {\n\t\t\thttp.Error(res, \"no robot with that name\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\t// If there was an error, return a 500.\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Get the devices associated with the robot.\n\tdevices, err := a.db.GetDevicesByRobot(robot.Name)\n\tif err != nil {\n\t\t// If there was an error, return a 500.\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Convert the devices to JSON.\n\tdevicesJSON, err := json.Marshal(devices)\n\tif err != nil {\n\t\t// If there was an error, return a 500.\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(devicesJSON)\n}", "CodeBleu_score": 37.804398155290315}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL.\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Check if the robot exists.\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\t// If the robot does not exist, return a JSON response with an error message.\n\t\ta.writeJSONError(res, req, http.StatusNotFound, \"No robot found with name \"+robotName)\n\t\treturn\n\t}\n\n\t// Gather the devices associated with the robot into a slice.\n\tdevices, err := a.db.GetDevicesByRobot(robot.ID)\n\tif err != nil {\n\t\t// If an error occurs while gathering the devices, return a JSON response with an error message.\n\t\ta.writeJSONError(res, req, http.StatusInternalServerError, \"Failed to retrieve devices for robot \"+robotName)\n\t\treturn\n\t}\n\n\t// Write a JSON response with the devices.\n\ta.writeJSON(res, req, http.StatusOK, devices)\n}", "CodeBleu_score": 35.337107737463654}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request){\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Check if the robot exists\n\tif _, ok := a.robots[robotName]; !ok {\n\t\thttp.Error(res, \"No robot with that name found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the devices for the robot\n\tdevices := a.robots[robotName].devices\n\tdeviceJSON := make([]DeviceJSON, len(devices))\n\tfor i, device := range devices {\n\t\tdeviceJSON[i] = DeviceJSON{\n\t\t\tDevice: device.Name,\n\t\t\tType:   device.Type,\n\t\t}\n\t}\n\n\t// Send the JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(deviceJSON)\n}", "CodeBleu_score": 41.56801687739251}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Extract the robot name from the request URL.\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Check if the robot exists.\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with that name was found.\"))\n\t\treturn\n\t}\n\n\t// If the robot exists, iterate through its connections and write them to the HTTP response.\n\tconnections := make([]map[string]interface{}, len(robot.Connections))\n\tfor i, connection := range robot.Connections {\n\t\tconnections[i] = connection.ToJSON()\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(connectionsToJSON(connections)))\n}", "CodeBleu_score": 42.62555827440758}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL.\n\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Check if the robot exists.\n\trobot, ok := a.robots[name]\n\tif !ok {\n\t\t// The robot does not exist.\n\t\thttp.Error(res, \"No robot with the specified name was found.\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Create a new array to store the connections.\n\tconnections := make([]string, 0)\n\n\t// Iterate through the connections of the robot.\n\tfor conn := range robot.connections {\n\t\t// Convert the connection to JSON format and add it to the array.\n\t\tconnections = append(connections, conn.String())\n\t}\n\n\t// Convert the array to JSON format and write it to the HTTP response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write([]byte(\"[\" + strings.Join(connections, \",\") + \"]\"))\n}", "CodeBleu_score": 43.46532728088675}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Parse the request URL to extract the robot name.\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Check if the robot exists.\n\tif _, ok := a.robots[robotName]; !ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response.\n\t\thttp.Error(res, \"No robot with name \"+robotName+\" found.\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// If the robot exists, iterate through its connections and write them to the HTTP response.\n\tconnections := []map[string]interface{}{}\n\tfor _, connection := range a.robots[robotName].connections {\n\t\tconnections = append(connections, map[string]interface{}{\n\t\t\t\"name\": connection.name,\n\t\t\t\"type\": connection.type_,\n\t\t})\n\t}\n\n\t// Convert the connections to JSON format and write them to the HTTP response.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 46.769916093218356}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name and device name from the URL parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot and device names are valid\n\tif robotName == \"\" || deviceName == \"\" {\n\t\ta.writeError(res, req, http.StatusBadRequest, \"invalid robot and/or device name\")\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tdevice, err := a.robotDeviceExists(robotName, deviceName)\n\tif err != nil {\n\t\ta.writeError(res, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// Check if the command is valid\n\tcommand := req.URL.Query().Get(\"command\")\n\tif command == \"\" {\n\t\ta.writeError(res, req, http.StatusBadRequest, \"invalid command\")\n\t\treturn\n\t}\n\n\t// Check if the command is a valid method of the device\n\t_, err = device.Commander().Get(command)\n\tif err != nil {\n\t\ta.writeError(res, req, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\n\t// Execute the command\n\terr = device.Commander().Call(command)\n\tif err != nil {\n\t\ta.writeError(res, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// Write the response\n\ta.writeResponse(res, req, http.StatusOK, \"command executed\")\n}", "CodeBleu_score": 48.06738022933688}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name and device name from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot and device names are not empty.\n\tif robotName == \"\" || deviceName == \"\" {\n\t\ta.writeError(res, req, http.StatusBadRequest, \"robot and device names must be specified\")\n\t\treturn\n\t}\n\n\t// Get the robot and device from the database.\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\ta.writeError(res, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\tdevice, err := a.db.GetDevice(robotName, deviceName)\n\tif err != nil {\n\t\ta.writeError(res, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif device == nil {\n\t\ta.writeError(res, req, http.StatusBadRequest, \"device does not exist\")\n\t\treturn\n\t}\n\n\t// Get the command from the URL query parameters.\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t// Check if the command is not empty.\n\tif command == \"\" {\n\t\ta.writeError(res, req, http.StatusBadRequest, \"command must be specified\")\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\terr = a.gobot.ExecuteDeviceCommand(robot, device, command)\n\tif err != nil {\n\t\ta.writeError(res, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// Write the response.\n\ta.writeResponse(res, req, http.StatusOK, \"success\")\n}", "CodeBleu_score": 47.0223241357912}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request){\n\t// Parse the URL parameters\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\tdeviceName := vars[\"deviceName\"]\n\tcommand := vars[\"command\"]\n\n\t// Check if the device exists\n\tif a.RobotDeviceExists(robotName, deviceName) {\n\t\t// Retrieve the device\n\t\tdevice := a.RobotDeviceMap[robotName][deviceName]\n\n\t\t// Execute the command on the device\n\t\tif err := device.ExecuteCommand(command); err != nil {\n\t\t\t// Write an error message as a JSON response\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(err.Error()))\n\t\t} else {\n\t\t\t// Write a success message as a JSON response\n\t\t\tres.WriteHeader(http.StatusOK)\n\t\t\tres.Write([]byte(\"Command executed successfully\"))\n\t\t}\n\t} else {\n\t\t// Write an error message as a JSON response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"Device not found\"))\n\t}\n}", "CodeBleu_score": 36.902220441309034}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If everything is OK, call the next handler\n\t\tr.Header.Del(\"Authorization\")\n\t\tr.Header.Del(\"WWW-Authenticate\")\n\t\tr.RemoteAddr = \"127.0.0.1\"\n\t\tr.RequestURI = \"\"\n\t\tr.URL = &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   \"localhost\",\n\t\t}\n\t\tr.Proto = \"HTTP/1.1\"\n\t\tr.ProtoMajor = 1\n\t\tr.ProtoMinor = 1\n\t\tr.Header.Set(\"X-Forwarded-For\", \"127.0.0.1\")\n\t\tr.Header.Set(\"X-Forwarded-Host\", \"localhost\")\n\t\tr.Header.Set(\"X-Forwarded-Proto\", \"http\")\n\t\tr.Header.Set(\"X-Real-IP\", \"127.0.0.1\")\n\t\tr.Header.Set(\"X-Scheme\", \"http\")\n\t\tr.Header.Set(\"X-Forwarded-Server\", \"localhost\")\n\t\tr.Header.Set(\"X-Forwarded-Port\", \"80\")\n\t\tr.Header.Set(\"X-Forwarded-Prefix\", \"\")\n\t\tr.Header.Set(\"X-Forwarded-Ssl\", \"off\")\n\t\tr.Header.Set(\"X-Original-Url\", r.URL.String())\n\t\tr.Header.Set(\"X-Url-Scheme\", \"http\")\n\t\tr.Header.Set(\"X-Forwarded-", "CodeBleu_score": 45.47854197843499}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tif !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// authentication succeeded\n\t}\n}", "CodeBleu_score": 51.146402856718446}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// Proceed to the next handler\n\t\tnext := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tfmt.Fprintln(w, \"Welcome!\")\n\t\t})\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 49.9289754344681}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t// Lock the sensor to prevent other threads from reading it\n\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\t// Check if the connection supports analog reading\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, errors.New(\"connection does not support analog reading\")\n\t}\n\n\t// Retrieve the raw sensor value\n\trawValue, err := a.connection.ReadAnalog(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tvar scaledValue float64\n\tswitch a.scale {\n\tcase 1:\n\t\tscaledValue = float64(rawValue)\n\tcase 2:\n\t\tscaledValue = float64(rawValue) / 100\n\tcase 4:\n\t\tscaledValue = float64(rawValue) / 10000\n\tcase 8:\n\t\tscaledValue = float64(rawValue) / 1000000\n\tdefault:\n\t\treturn 0, 0, errors.New(\"invalid analog scale\")\n\t}\n\n\t// Update the last read values\n\ta.lastReadRawValue = rawValue\n\ta.lastReadScaledValue = scaledValue\n\n\t// Return the raw and scaled values\n\treturn rawValue, scaledValue, nil\n}", "CodeBleu_score": 48.847048827091236}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\t// Lock the sensor for reading\n\ta.lock()\n\tdefer a.unlock()\n\n\t// Check if the connection supports analog reading\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, fmt.Errorf(\"analog sensor %s does not support analog reading\", a.name)\n\t}\n\n\t// Retrieve the raw sensor value\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\t// Scale the raw value according to the sensor's configuration\n\tscaled := float64(raw) * a.scaleFactor\n\n\t// Update the last read values\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\n\t// Return the raw and scaled values\n\treturn raw, scaled, nil\n}", "CodeBleu_score": 47.94761508489204}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\tif a.connection.IsAnalogReadSupported() {\n\t\ta.connection.Lock()\n\t\tdefer a.connection.Unlock()\n\t\trawValue, err := a.connection.AnalogRead(a.pin)\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\t\tscaledValue := a.scale(rawValue)\n\t\ta.lastRead = time.Now()\n\t\treturn rawValue, scaledValue, nil\n\t}\n\treturn 0, 0, errors.New(\"analog read not supported\")\n}", "CodeBleu_score": 48.116032147428996}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t// Initialize the driver.\n\ts := &GroveSoundSensorDriver{\n\t\tname:      \"GroveSoundSensor\",\n\t\tanalogSensor: &AnalogSensorDriver{\n\t\t\treader: a,\n\t\t\tpin:    pin,\n\t\t\tvalue:  0,\n\t\t},\n\t\tthreshold: 0.5,\n\t}\n\n\t// Check for optional parameters.\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase string:\n\t\t\ts.name = opt.(string)\n\t\tcase float64:\n\t\t\ts.threshold = opt.(float64)\n\t\t}\n\t}\n\n\t// Initialize the driver.\n\ts.analogSensor.Init()\n\n\treturn s\n}", "CodeBleu_score": 34.58463087862342}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\tvar options = make(map[string]interface{})\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase map[string]interface{}:\n\t\t\tfor k, v := range opt.(map[string]interface{}) {\n\t\t\t\toptions[k] = v\n\t\t\t}\n\t\t}\n\t}\n\tsensor := NewAnalogSensorDriver(a, pin, options)\n\tsensor.SetName(options[\"name\"])\n\tsensor.SetUnit(options[\"unit\"])\n\tsensor.SetDriverType(\"GroveSoundSensor\")\n\tsensor.SetMinRange(options[\"minRange\"])\n\tsensor.SetMaxRange(options[\"maxRange\"])\n\treturn &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: sensor,\n\t}\n}", "CodeBleu_score": 32.84647415708813}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver{\n\t// Create a new driver instance and assign default values to its fields.\n\tg := &GroveSoundSensorDriver{\n\t\tname:    \"GroveSoundSensorDriver\",\n\t\tpin:     pin,\n\t\tenabled: true,\n\t}\n\n\t// Overwrite default values with any provided options.\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase string:\n\t\t\tg.name = opt.(string)\n\t\t}\n\t}\n\n\t// Create a new AnalogSensorDriver with the provided AnalogReader and pin.\n\tg.asd = NewAnalogSensorDriver(a, pin)\n\n\treturn g\n}", "CodeBleu_score": 37.116760502769196}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error{\n\t// Reset the MFRC522 device\n\td.writeByte(CommandReg, CommandSoftReset)\n\n\t// Wait for the command to complete\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// Check if the command has completed successfully\n\tif d.readByte(CommandReg) != CommandSoftReset {\n\t\treturn errors.New(\"Soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 27.032182788861945}, {"code": "func (d *MFRC522Common) softReset() error{\n\t// Write soft reset command to the command register\n\td.setBitMask(d.commandReg, softReset)\n\n\t// Wait for 1 ms\n\ttime.Sleep(1 * time.Millisecond)\n\n\t// Check if the power down bit is cleared\n\tif d.getBitMask(d.commandReg, softReset) != 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 32.39071549573688}, {"code": "func (d *MFRC522Common) softReset() error{\n\td.writeRegister(MFRC522CommandReg, MFRC522SoftReset)\n\ttime.Sleep(20 * time.Microsecond)\n\tstatus := d.readRegister(MFRC522CommandReg)\n\tif status&MFRC522POWERDOWN != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 31.02787249636695}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Read the FIFO level\n\tfifoLevel, err := d.readRegister(MFRC522_FIFO_LEVEL_REG)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check if there are any bytes available\n\tif fifoLevel == 0 {\n\t\treturn 0, errors.New(\"No bytes available in FIFO\")\n\t}\n\n\t// Check if there are enough bytes available to read\n\tif fifoLevel < uint8(len(backData)) {\n\t\treturn 0, errors.New(\"Not enough bytes available in FIFO\")\n\t}\n\n\t// Read the bytes from FIFO\n\terr = d.readRegisterSlice(MFRC522_FIFO_DATA_REG, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Read the control register to get the last bits\n\tcontrol, err := d.readRegister(MFRC522_CONTROL_REG)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn control, nil\n}", "CodeBleu_score": 49.023727559206456}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\t// Check buffer overflow\n\tif len(backData) > 32 {\n\t\treturn 0, errors.New(\"readFifo: buffer overflow\")\n\t}\n\n\t// Check the number of bytes in the FIFO\n\tstatus, err := d.readRegister(FIFODataReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// FIFO empty, nothing to do\n\tif status == 0x00 {\n\t\treturn status, nil\n\t}\n\n\t// FIFO underflow, this should never happen\n\tif status&0x7F == 0x01 {\n\t\treturn 0, errors.New(\"readFifo: FIFO underflow error\")\n\t}\n\n\t// FIFO contains data to read\n\tif status&0x7F > len(backData) {\n\t\treturn 0, errors.New(\"readFifo: FIFO overrun error\")\n\t}\n\n\t// Read bytes from FIFO\n\tfor i := 0; i < int(status&0x7F); i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read last bits\n\tstatus, err = d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn status, nil\n}", "CodeBleu_score": 52.02666873163311}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error){\n\tif len(backData) == 0 {\n\t\treturn 0, errors.New(\"readFifo: backData must not be empty\")\n\t}\n\t// Check buffer overflow\n\tif (d.status2 & 0x08) != 0 {\n\t\treturn 0, errors.New(\"readFifo: FIFO buffer overflow\")\n\t}\n\t// Check buffer underflow\n\tif (d.status2 & 0x04) != 0 {\n\t\treturn 0, errors.New(\"readFifo: FIFO buffer underflow\")\n\t}\n\t// Check FIFO empty\n\tif (d.status2 & 0x02) != 0 {\n\t\treturn 0, errors.New(\"readFifo: FIFO empty\")\n\t}\n\t// Check FIFO full\n\tif (d.status2 & 0x01) != 0 {\n\t\treturn 0, errors.New(\"readFifo: FIFO full\")\n\t}\n\t// Read FIFO count\n\tfifoCount := d.fifoCount\n\tif fifoCount > uint8(len(backData)) {\n\t\treturn 0, errors.New(\"readFifo: FIFO count too large\")\n\t}\n\t// Read data from FIFO\n\tfor i := uint8(0); i < fifoCount; i++ {\n\t\tbackData[i] = d.spiRead(uint8(0x00))\n\t}\n\t// Read control register\n\treturn d.spiRead(uint8(0x00)), nil\n}", "CodeBleu_score": 36.36468050681324}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error{\n\tif d.debug {\n\t\td.debugLog(\"Halting communication with PICC\")\n\t}\n\t// Create halt command\n\tcmd := []byte{piccHaltCommand}\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(cmd)\n\t// Append CRC_A to command\n\tcmd = append(cmd, crc)\n\t// Send command\n\t_, err := d.transceive(cmd, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check for error response\n\tif d.lastResponse[0] != piccErrorResponse {\n\t\treturn errors.New(\"Error while halting communication\")\n\t}\n\treturn nil\n}", "CodeBleu_score": 35.201363449595796}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t// Log debug message\n\tif d.debug {\n\t\tlog.Println(\"Halting communication.\")\n\t}\n\n\t// Create halt command\n\tcommand := []byte{commands.Halt}\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(command)\n\n\t// Append CRC_A to command\n\tcommand = append(command, crc)\n\n\t// Send command\n\t_, err := d.sendCommand(command, commands.Halt)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Return nil if successful\n\treturn nil\n}", "CodeBleu_score": 31.52085497626189}, {"code": "func (d *MFRC522Common) piccHalt() error{\n\t// Log message\n\tif d.debug {\n\t\td.debugLog.Println(\"Halting PICC\")\n\t}\n\n\t// Build command\n\tcommand := []byte{piccHaltCommand}\n\n\t// Calculate CRC_A\n\tcrc := d.calculateCRC(command)\n\n\t// Build command with CRC\n\thaltCommand := []byte{piccHaltCommand, crc[0], crc[1]}\n\n\t// Send command\n\t_, err := d.transceive(haltCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check response\n\tresponse, err := d.transceive([]byte{})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(response) != 2 || response[0] != piccErrorResponse || response[1] != piccCollisionError {\n\t\treturn errors.New(\"Halting failed\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.45512321246746}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\tvar buffer []byte\n\t// Create command buffer\n\tbuffer = make([]byte, 18)\n\t// Set command header\n\tbuffer[0] = MF1_REQIDL\n\tbuffer[1] = MF1_REQALL\n\tbuffer[2] = 0x20\n\tbuffer[3] = block\n\t// Calculate CRC_A\n\tbuffer[4] = 0x00\n\tbuffer[5] = 0x00\n\t// Calculate CRC_A\n\tcrc := d.piccCalcCRC(buffer[0:6])\n\tbuffer[6] = crc[0]\n\tbuffer[7] = crc[1]\n\t// Transmit the READ command (header+block+CRC) - 8 bits in one go\n\tstatus := d.MFRC522Transceive(buffer)\n\tif status != MI_OK {\n\t\treturn nil, fmt.Errorf(\"Error while reading data from card. Status: %d\", status)\n\t}\n\t// Copy the 4 data bytes to the result buffer\n\tbuffer = buffer[9:13]\n\treturn buffer, nil\n}", "CodeBleu_score": 25.945362333998418}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Build command buffer\n\tbuffer := []byte{PICC_CMD_MF_READ, block}\n\t// Calculate CRC_A\n\tcrc := d.crcCalculate(buffer)\n\tbuffer = append(buffer, crc)\n\n\t// Send the read command\n\tstatus := d.command(PICC_CMD_MF_READ, buffer)\n\tif status != STATUS_OK {\n\t\treturn nil, errors.New(\"Error: MIFARE read command failed\")\n\t}\n\n\t// Read the response, 16 bytes\n\tresponse, err := d.readData(16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Verify block read\n\tif response[0] != PICC_CMD_MF_READ {\n\t\treturn nil, errors.New(\"Error: MIFARE read data failed\")\n\t}\n\n\t// Copy block data\n\tdata := make([]byte, 16)\n\tcopy(data, response[1:17])\n\n\treturn data, nil\n}", "CodeBleu_score": 45.28460933354448}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error){\n\t// Sanity check\n\tif block > 0xff {\n\t\treturn nil, errors.New(\"Block number out of range\")\n\t}\n\n\t// Build command\n\tpiccCmd := []byte{MF1_REQIDL, MF1_REQIDL, MF1_REQALL, 0, 0, 0}\n\tpiccCmd[4] = block\n\n\t// Calculate CRC_A\n\tcrc := crc.New(0x63, 0x31, 0xff)\n\tcrc.Write(piccCmd)\n\tpiccCmd[len(piccCmd)-2] = byte(crc.Sum16())\n\tpiccCmd[len(piccCmd)-1] = byte(crc.Sum16() >> 8)\n\n\t// Send the command and receive the response\n\tpiccResponse, err := d.MifareCommandInOut(piccCmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check response\n\tif piccResponse[0] != MF_ACK {\n\t\treturn nil, errors.New(\"Response not recognized\")\n\t}\n\n\t// Copy block data\n\tdata := make([]byte, 16)\n\tcopy(data, piccResponse[1:17])\n\n\treturn data, nil\n}", "CodeBleu_score": 40.02904019237856}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\t// Sanity check\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"piccRequest: The answer buffer has not enough space to store the returned data from the PICC\")\n\t}\n\n\t// Clear the two bits in the collision register\n\td.clearColl()\n\n\t// Set the request mode\n\td.setBitMask(d.regTxControl, 0x07<<4, reqMode<<4)\n\n\t// Set the transmission type to 7 bits\n\tif reqMode == reqA {\n\t\td.setBitMask(d.regTxControl, 0x01<<0, 0x01<<0)\n\t}\n\n\t// Send the command\n\terr := d.transceive(request, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check the error bits\n\terrRegValue := d.getStatus()\n\tif errRegValue&(1<<0) != 0 {\n\t\treturn errors.New(\"piccRequest: Timeout in communication\")\n\t}\n\tif errRegValue&(1<<2) != 0 {\n\t\treturn errors.New(\"piccRequest: Parity error\")\n\t}\n\tif errRegValue&(1<<4) != 0 {\n\t\treturn errors.New(\"piccRequest: CRC error\")\n\t}\n\tif errRegValue&(1<<3) != 0 {\n\t\treturn errors.New(\"piccRequest: Collision error\")\n\t}\n\n\t// Everything seems to be fine\n\treturn nil\n}", "CodeBleu_score": 54.05713413656852}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"piccRequest: not enough space in answer buffer\")\n\t}\n\td.clearBitMask(d.collReg, 0x80) // Clear the collision bit in the collision register\n\tif reqMode == reqA {\n\t\td.setBitMask(d.txControlReg, 0x04) // Set the transmission mode to use only 7 bits of the last byte\n\t} else {\n\t\td.clearBitMask(d.txControlReg, 0x04) // Set the transmission mode to use 8 bits of the last byte\n\t}\n\td.clearBitMask(d.txControlReg, 0x08) // Clear the no-CRC bit in the transmission control register\n\td.clearBitMask(d.txControlReg, 0x10) // Clear the last bit of the transmission control register\n\td.clearBitMask(d.txControlReg, 0x02) // Clear the transmission control register bit 0 (MFCrypto1On)\n\td.setBitMask(d.txControlReg, 0x01)   // Set the transmission control register bit 0 (MFCrypto1On)\n\td.clearBitMask(d.rxControlReg, 0x03) // Clear the buffer bits (RxIRq and IdleIrq) in the receiver control register\n\td.clearBitMask(d.rxControlReg, 0x04) // Clear the CRC bits (IRqPin and CRC16) in the receiver control register\n\td.setBitMask(d.rxControlReg, 0x01)   // Set the buffer bit (RxIRq) in the receiver control register\n\td.clearBitMask(d.commandReg, 0x80)   // Clear the command register bit 7 (Memory access)\n\td.writeData(reqMode)                 // Write the request command in the command register\n\td.writeData(answer[0])               // Write the request command in the command register\n\td.writeData(answer[1])               // Write the request command in the command register\n\td.clearBitMask(d.bitFram", "CodeBleu_score": 29.425297537666793}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error{\n\tif len(answer) < 2 {\n\t\treturn ErrBufferTooSmall\n\t}\n\n\t// Clear the two bits in the CollisionReg register that must be cleared in any case.\n\td.clearCollReg()\n\n\t// Set the request mode in the FIFO.\n\td.writeFifo(reqMode)\n\n\t// Set the transmission type to 7 bits.\n\tif reqMode == reqA {\n\t\td.writeReg(CommIEnReg, 0x87)\n\t}\n\n\t// Execute the command.\n\terr := d.transceive(answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check the error register for any errors.\n\terrRegVal := d.readReg(ErrorReg)\n\tif errRegVal&0x1B != 0 {\n\t\treturn fmt.Errorf(\"piccRequest: Error register not empty: 0x%02X\", errRegVal)\n\t}\n\n\t// Copy the 4 bytes from the FIFO into the answer buffer.\n\tcopy(answer, d.readFifo(4))\n\n\treturn nil\n}", "CodeBleu_score": 53.13623257449387}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn errors.New(\"stepPin not initialized\")\n\t}\n\n\tif d.directionPin == nil {\n\t\treturn errors.New(\"directionPin not initialized\")\n\t}\n\n\tif d.stepNumber >= d.stepsPerRevolution {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber < d.stepsPerRevolution && d.stepNumber >= 0 {\n\t\tif d.direction == 1 {\n\t\t\td.stepNumber++\n\t\t} else {\n\t\t\td.stepNumber--\n\t\t}\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber >= d.stepsPerRevolution {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber >= d.stepsPerRevolution {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber >= d.stepsPerRevolution {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber >= d.stepsPerRevolution {\n\t\td.stepNumber = d.stepsPerRevolution - 1\n\t}\n\n\tif d.stepNumber < 0 {\n\t\td.stepNumber = 0\n\t}\n\n\tif d.stepNumber >= d.stepsPerRevolution {\n\t\td.stepNumber = d.stepsPerRevolution - 1", "CodeBleu_score": 35.175739649357574}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\tvar err error\n\tif d.stepPin != nil {\n\t\terr = d.stepPin.Write(gpio.Low)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Millisecond * time.Duration(d.delay))\n\t\terr = d.stepPin.Write(gpio.High)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.direction == DirectionCW {\n\t\t\td.stepNumber++\n\t\t} else {\n\t\t\td.stepNumber--\n\t\t}\n\t} else {\n\t\terr = d.stepPin1.Write(gpio.Low)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Millisecond * time.Duration(d.delay))\n\t\terr = d.stepPin1.Write(gpio.High)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.direction == DirectionCW {\n\t\t\td.stepNumber1++\n\t\t} else {\n\t\t\td.stepNumber1--\n\t\t}\n\t\terr = d.stepPin2.Write(gpio.Low)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Millisecond * time.Duration(d.delay))\n\t\terr = d.stepPin2.Write(gpio.High)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.direction == DirectionCW {\n\t\t\td.stepNumber2++\n\t\t} else {\n\t\t\td.stepNumber2--\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.33617011059308}, {"code": "func (d *EasyDriver) onePinStepping() error{\n\tif d.stepPin == nil {\n\t\treturn errors.New(\"step pin not set\")\n\t}\n\tif d.dirPin == nil {\n\t\treturn errors.New(\"direction pin not set\")\n\t}\n\tif d.enablePin == nil {\n\t\treturn errors.New(\"enable pin not set\")\n\t}\n\tif d.valueMutex == nil {\n\t\treturn errors.New(\"value mutex not set\")\n\t}\n\tif d.delayMutex == nil {\n\t\treturn errors.New(\"delay mutex not set\")\n\t}\n\tif d.delay == nil {\n\t\treturn errors.New(\"delay not set\")\n\t}\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\td.delayMutex.Lock()\n\tdefer d.delayMutex.Unlock()\n\tif err := d.stepPin.Write(gpio.High); err != nil {\n\t\treturn err\n\t}\n\tif err := d.delay.Delay(d.delayTime); err != nil {\n\t\treturn err\n\t}\n\tif err := d.stepPin.Write(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\tif err := d.delay.Delay(d.delayTime); err != nil {\n\t\treturn err\n\t}\n\tif d.direction {\n\t\td.stepNumber++\n\t\tif d.stepNumber >= d.stepsPerRev {\n\t\t\td.stepNumber = 0\n\t\t}\n\t} else {\n\t\td.stepNumber--\n\t\tif d.stepNumber < 0 {\n\t\t\td.stepNumber = d.stepsPerRev - 1\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 52.273735882505136}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.distanceMonitorRunning = true\n\td.distanceMonitorStopChannel = make(chan bool)\n\td.distanceMonitorWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 35.445345163093776}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopDistanceMonitorChan = make(chan struct{})\n\td.distanceMonitorWg.Add(1)\n\n\tgo func() {\n\t\tdefer d.distanceMonitorWg.Done()\n\n\t\tticker := time.NewTicker(d.distanceMonitorInterval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distanceMonitorChan <- distance\n\t\t\t\t}\n\t\t\tcase <-d.stopDistanceMonitorChan:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\n\treturn nil\n}", "CodeBleu_score": 45.54049550390124}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error{\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"Distance monitor is already running\")\n\t}\n\td.stopDistanceMonitorChan = make(chan struct{})\n\td.distanceMonitorWaitGroup = &sync.WaitGroup{}\n\td.distanceMonitorWaitGroup.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}", "CodeBleu_score": 33.746890529665684}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTime time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestampExt uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else {\n\t\t\td.ch <- time.Since(startTime)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.36891967577657}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar startTime time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestampExt uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(startTime)\n\t\t\td.ch <- duration\n\t\t\tstartTime = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 40.20067804751461}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32){\n\tvar start time.Time\n\treturn func(pin int, duration time.Duration, edge string, timestamp uint32, timestamp_ms uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\td.ch <- time.Since(start).Nanoseconds() / 1e6\n\t\t\tstart = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 39.475955011449734}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error{\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\td.trigPin.Low()\n\ttime.Sleep(2 * time.Microsecond)\n\td.trigPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigPin.Low()\n\t// Wait for the sensor to measure the distance\n\tfor {\n\t\tif d.echoPin.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(d.startTime) > d.timeout {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t}\n\t// Wait for the sensor to stop measuring the distance\n\tfor {\n\t\tif d.echoPin.Read() == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(d.startTime) > d.timeout {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t}\n\t// Get the time it took for the echo to return\n\tduration := time.Since(d.startTime)\n\t// Store the measured time in microseconds\n\td.measuredTime = duration.Microseconds()\n\treturn nil\n}", "CodeBleu_score": 48.04025940339021}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\t// Lock the mutex\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\td.trig.Low()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trig.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trig.Low()\n\n\t// Wait for the echo to be high or for the timeout to occur\n\ttimeout := time.After(50 * time.Millisecond)\n\tfor d.echo.Read() == gpio.Low {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout\")\n\t\tdefault:\n\t\t\ttime.Sleep(10 * time.Microsecond)\n\t\t}\n\t}\n\n\t// Wait for the echo to be low or for the timeout to occur\n\ttimeout = time.After(50 * time.Millisecond)\n\tfor d.echo.Read() == gpio.High {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout\")\n\t\tdefault:\n\t\t\ttime.Sleep(10 * time.Microsecond)\n\t\t}\n\t}\n\n\t// Store the measured time\n\treturn nil\n}", "CodeBleu_score": 48.41133189072798}, {"code": "func (d *HCSR04Driver) measureDistance() error{\n\tif err := d.lock(); err != nil {\n\t\treturn err\n\t}\n\tdefer d.unlock()\n\n\t// Trigger the sensor\n\td.gpio.Out(gpio.High)\n\ttime.Sleep(time.Microsecond)\n\td.gpio.Out(gpio.Low)\n\n\t// Wait for the echo signal to be received\n\td.echo.In(gpio.PullUp, gpio.FallingEdge)\n\tif err := d.echo.WaitForEdge(-1); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo signal to be lost\n\td.echo.In(gpio.PullUp, gpio.RisingEdge)\n\tif err := d.echo.WaitForEdge(-1); err != nil {\n\t\treturn err\n\t}\n\n\t// Get the duration of the echo signal\n\tif d.duration, err = d.echo.WaitForEdge(time.Microsecond); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 51.46195966193229}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n\tif self.authentication_token:\n        return self.authentication_token\n\n    if self.refresh_token:\n        try:\n            self.authentication_token = self.fetch_authentication_token_using_refresh_token()\n        except HTTPClientError as exc:\n            raise AccountError(exc) from exc\n        return self.authentication_token\n\n    try:\n        self.authentication_token = self.fetch_authentication_token_using_client_credentials()\n    except HTTPClientError as exc:\n        raise AccountError(exc) from exc\n    return self.authentication_token\n\n", "CodeBleu_score": 17.72433335304683}, {"code": "def fetch_authentication_token(self)\n\tif 'ACCESS_TOKEN' in os.environ:\n        self.access_token = os.environ['ACCESS_TOKEN']\n        self.refresh_token = os.environ['REFRESH_TOKEN']\n        self.token_expiration = datetime.datetime.fromtimestamp(int(os.environ['TOKEN_EXPIRATION']))\n        return self.access_token\n    if self.access_token and self.refresh_token and self.token_expiration and self.token_expiration > datetime.datetime.now():\n        return self.access_token\n    if self.refresh_token:\n        try:\n            response = self.fetch_json_data(self.refresh_url, {\n                'grant_type': 'refresh_token',\n                'refresh_token': self.refresh_token\n            }, method='POST')\n            self.access_token = response['access_token']\n            self.refresh_token = response['refresh_token']\n            self.token_expiration = datetime.datetime.now() + datetime.timedelta(seconds=response['expires_in'])\n            self.save_state()\n            return self.access_token\n        except AccountError:\n            pass\n    raise AccountNotAuthorized('No valid authentication token available.')\n\n", "CodeBleu_score": 36.73639845484408}, {"code": "def fetch_authentication_token(self)\n\tif self.access_token and self.expiration_time:\n        if datetime.datetime.now() < self.expiration_time:\n            return self.access_token\n        elif self.refresh_token:\n            self.fetch_access_token()\n            return self.access_token\n        else:\n            raise AccountNotAuthorized(\"No access token or refresh token available.\")\n    elif self.access_token:\n        if self.refresh_token:\n            self.fetch_access_token()\n            return self.access_token\n        else:\n            raise AccountNotAuthorized(\"No access token or refresh token available.\")\n    elif self.refresh_token:\n        self.fetch_access_token()\n        return self.access_token\n    else:\n        raise AccountNotAuthorized(\"No access token or refresh token available.\")\n\n", "CodeBleu_score": 27.06304938419927}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n\tself.refresh_token = self.session.cookies.get(\"refresh_token\")\n    self.session.cookies.clear()\n    try:\n        self.fetch_json_data(\"/v1/logout\", method=\"POST\", params={\"refresh_token\": self.refresh_token})\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 41.86935738919581}, {"code": "def logout(self)\n\tself.delete_session()\n\n    try:\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            params={\"refresh_token\": self.refresh_token},\n        )\n    except AccountError:\n        pass\n\n    return True\n\n", "CodeBleu_score": 44.81571194765165}, {"code": "def logout(self)\n\tif self.session:\n        self.session.cookies.clear_session_cookies()\n    try:\n        self.fetch_json_data(\n            \"/v1/logout\",\n            method=\"POST\",\n            headers={\"Authorization\": f\"Bearer {self.session.cookies.get('refresh_token')}\"},\n        )\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 35.62911890958463}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n\tpackages = []\n    for package in self.pm.list_packages():\n        if self.pm.is_optional(package):\n            continue\n        info = self.pm.get_package_info(package)\n        if info.get('external_url'):\n            packages.append((package, info['version'], info['external_url']))\n        else:\n            packages.append((package, info['version']))\n    return packages\n\n", "CodeBleu_score": 29.522692017638203}, {"code": "def dump_used_packages(self)\n\tused_packages = []\n    for package in self.pm.list_packages():\n        if self.pm.is_optional(package):\n            continue\n        if self.pm.is_external(package):\n            source_url = self.pm.get_source_url(package)\n            if source_url:\n                used_packages.append((package, source_url))\n            else:\n                used_packages.append(package)\n        else:\n            used_packages.append(package)\n    return used_packages\n\n", "CodeBleu_score": 28.891051814765785}, {"code": "def dump_used_packages(self)\n\tpackages = []\n    for pkg in self.pm.iter_packages():\n        if pkg.is_optional:\n            continue\n        pkg_data = {\n            'name': pkg.name,\n            'version': pkg.version,\n            'url': pkg.url,\n        }\n        packages.append(pkg_data)\n    return packages\n\n", "CodeBleu_score": 28.182167934869774}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif targets is None:\n        targets = []\n    if not isinstance(targets, list):\n        targets = [targets]\n    if not isinstance(env, str):\n        raise TypeError(\"env must be a string\")\n    if not isinstance(targets, list):\n        raise TypeError(\"targets must be a list\")\n    if not isinstance(autoinstall, bool):\n        raise TypeError(\"autoinstall must be a boolean\")\n    # Get the platform specification for the environment.\n    platform = cls.get_platform(env)\n    if not platform:\n        raise exception.UndefinedEnvPlatformError(env)\n    # Create a new instance of the class with the platform specification.\n    instance = cls(platform)\n    # Set the project environment.\n    instance.set_env(env)\n    # Configure the project packages for the given environment and targets.\n    instance.configure(targets, autoinstall)\n    # Return the configured instance.\n    return instance\n\n", "CodeBleu_score": 33.08519980299714}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not targets:\n        targets = []\n    if not isinstance(targets, list):\n        targets = [targets]\n    if not isinstance(env, str):\n        raise TypeError(\"Expected str, got %s\" % type(env))\n    if not isinstance(targets, list):\n        raise TypeError(\"Expected list, got %s\" % type(targets))\n    if not isinstance(autoinstall, bool):\n        raise TypeError(\"Expected bool, got %s\" % type(autoinstall))\n    if not env:\n        raise exception.UndefinedEnvPlatformError()\n    if not cls.env_platforms:\n        raise exception.UndefinedEnvPlatformError()\n    if not cls.env_platforms.get(env):\n        raise exception.UndefinedEnvPlatformError()\n    platform_spec = cls.env_platforms.get(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    instance.set_project_env(env)\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 36.38737372345833}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\tif not issubclass(cls, ProjectEnv):\n        raise TypeError(\"cls must be a subclass of ProjectEnv\")\n\n    project = cls.project\n    if not project:\n        raise TypeError(\"cls must be a subclass of ProjectEnv with project attribute set\")\n\n    if env not in project.envs:\n        raise exception.UndefinedEnvPlatformError(env)\n\n    env_spec = project.envs[env]\n\n    if targets is None:\n        targets = env_spec.default_targets\n\n    env_obj = cls(\n        project,\n        env,\n        autoinstall=autoinstall,\n        platform_spec=env_spec.platform_spec,\n        platform_name=env_spec.platform_name,\n        platform_version=env_spec.platform_version,\n        platform_requires=env_spec.platform_requires,\n        platform_options=env_spec.platform_options,\n        platform_packages=env_spec.platform_packages,\n        platform_commands=env_spec.platform_commands,\n        platform_scripts=env_spec.platform_scripts,\n        platform_files=env_spec.platform_files,\n        platform_links=env_spec.platform_links,\n        platform_templates=env_spec.platform_templates,\n        platform_settings=env_spec.platform_settings,\n        platform_overrides=env_spec.platform_overrides,\n        platform_extras=env_spec.platform_extras,\n        platform_dependencies=env_spec.platform_dependencies,\n        platform_build_dependencies=env_spec.platform_build_dependencies,\n        platform_build_requires=env_spec.platform_build_requires,\n        platform_build_options=env_spec.platform_build_options,\n        platform_build_scripts=env_spec.platform_build_scripts,\n        platform_build_files=env_spec.platform_build_files,\n        platform_build_links=env_spec.platform_build_links,\n        platform_build_templates=env_spec.platform_build_templates,\n        platform_build_settings=env_spec.platform_build_settings,", "CodeBleu_score": 21.61526540282924}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(AXP192_ADDRESS);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_ADDRESS, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}", "CodeBleu_score": 63.06459076699385}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(AXP192_ADDR);\n    Wire.write(Addr);\n    Wire.endTransmission();\n    Wire.requestFrom(AXP192_ADDR, Size);\n    for (uint8_t i = 0; i < Size; i++) {\n        Buff[i] = Wire.read();\n    }\n}", "CodeBleu_score": 64.93596698640988}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff){\n\tWire.beginTransmission(AXP192_ADD);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(AXP192_ADD, Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire.read();\n  }\n}", "CodeBleu_score": 74.83005335460652}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tif (time_in_us == 0) {\n        SetSleep();\n    } else {\n        uint8_t buf = Read8bit(0x31);\n        buf         = (1 << 2) | buf;\n        Write1Byte(0x31, buf);\n        Write1Byte(0x90, 0x00);\n        Write1Byte(0x12, 0x09);\n        Write1Byte(0x13, 0x00);\n        Write1Byte(0x14, 0x00);\n        Write1Byte(0x15, 0x00);\n        Write1Byte(0x16, 0x00);\n        Write1Byte(0x17, 0x00);\n        Write1Byte(0x18, 0x00);\n        Write1Byte(0x19, 0x00);\n        Write1Byte(0x1A, 0x00);\n        Write1Byte(0x1B, 0x00);\n        Write1Byte(0x1C, 0x00);\n        Write1Byte(0x1D, 0x00);\n        Write1Byte(0x1E, 0x00);\n        Write1Byte(0x1F, 0x00);\n        Write1Byte(0x20, 0x00);\n        Write1Byte(0x21, 0x00);\n        Write1Byte(0x22, 0x00);\n        Write1Byte(0x23, 0x00);\n        Write1Byte(0x24, 0x00);\n        Write1Byte(0x25, 0x00);\n        Write1Byte(0x26, 0x00);\n        Write1Byte(0x27, 0x00);\n        Write1Byte(0x28, 0x00);\n        Write1Byte(0x29, 0x00);\n        Write1Byte(0x2A, 0x00);", "CodeBleu_score": 25.12268114256534}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\tSetSleep();\n    if (time_in_us > 0) {\n        Write1Byte(0x32, (time_in_us & 0xFF));\n        Write1Byte(0x33, (time_in_us >> 8));\n        Write1Byte(0x34, (time_in_us >> 16));\n        Write1Byte(0x35, (time_in_us >> 24));\n        Write1Byte(0x36, (time_in_us >> 32));\n        Write1Byte(0x37, (time_in_us >> 40));\n        Write1Byte(0x38, (time_in_us >> 48));\n        Write1Byte(0x39, (time_in_us >> 56));\n        Write1Byte(0x28, 0x01);  // Enable timer wakeup source\n    } else {\n        Write1Byte(0x28, 0x00);  // Disable timer wakeup source\n    }\n    Write1Byte(0x29, 0x01);  // Enable deep sleep\n}", "CodeBleu_score": 50.66783397779553}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us){\n\t// SetSleep();\n    if (time_in_us) {\n        uint64_t t = time_in_us / 256;\n        Write1Byte(0x32, t >> 8);\n        Write1Byte(0x33, t & 0xFF);\n        Write1Byte(0x34, 0xFF);\n        Write1Byte(0x35, 0xFF);\n        Write1Byte(0x36, 0xFF);\n        Write1Byte(0x37, 0xFF);\n        Write1Byte(0x38, 0xFF);\n        Write1Byte(0x39, 0xFF);\n        Write1Byte(0x3A, 0xFF);\n        Write1Byte(0x3B, 0xFF);\n        Write1Byte(0x3C, 0xFF);\n        Write1Byte(0x3D, 0xFF);\n        Write1Byte(0x3E, 0xFF);\n        Write1Byte(0x3F, 0xFF);\n        Write1Byte(0x40, 0xFF);\n        Write1Byte(0x41, 0xFF);\n        Write1Byte(0x42, 0xFF);\n        Write1Byte(0x43, 0xFF);\n        Write1Byte(0x44, 0xFF);\n        Write1Byte(0x45, 0xFF);\n        Write1Byte(0x46, 0xFF);\n        Write1Byte(0x47, 0xFF);\n        Write1Byte(0x48, 0xFF);\n        Write1Byte(0x49, 0xFF);\n        Write1Byte(0x4A, 0xFF);\n        Write1Byte(0x4B, 0xFF);\n        Write1Byte(0x4C, 0xFF);\n        Write1Byte(0x4D, 0xFF);\n        Write1Byte(0x4E, 0xFF);\n        Write1Byte(0x4", "CodeBleu_score": 22.378435022598165}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color){\n\tuint16_t y = tft.getCursorY();\n  uint16_t x = tft.getCursorX();\n  uint16_t height = tft.fontHeight();\n  uint16_t width = tft.fontWidth();\n  uint16_t tteBar = tft.getCursorY() + height;\n  uint16_t tte = tft.height() - height - tft.getCursorY();\n  uint16_t tte_start = tft.height() - height - tft.getCursorY();\n  uint16_t tte_end = tft.getCursorY();\n  if (tteBar >= tte_end) {\n    tte = tte_start;\n    tteBar = tte_end;\n  }\n  if (y >= tteBar) {\n    y = tte;\n  }\n  tft.setCursor(x, y);\n  tft.fillRect(x, y, width, height, color);\n  tft.setCursor(x, y + height);\n  scrollAddress(y + height);\n  return y;\n}", "CodeBleu_score": 34.895953764849985}, {"code": "int Display::scroll_line(uint32_t color){\n\tint16_t y_prev = y_top;\n  uint16_t y_new = y_top + text_height;\n  if (y_new >= tft.height() - bottom_area) {\n    y_new = y_top - text_height;\n    if (y_new < top_area) {\n      y_new = tft.height() - bottom_area;\n      scrollAddress(vsp);\n      vsp = 0;\n    }\n  }\n  tft.fillRect(0, y_top, tft.width(), text_height, color);\n  y_top = y_new;\n  scrollAddress(vsp);\n  return y_prev;\n}", "CodeBleu_score": 28.36447810948809}, {"code": "int Display::scroll_line(uint32_t color){\n\tint y0 = _y0;\n  int y1 = _y0 + _height;\n  int y2 = _y0 + _height + _height;\n  int y3 = _y0 + _height + _height + _height;\n  int y4 = _y0 + _height + _height + _height + _height;\n  int y5 = _y0 + _height + _height + _height + _height + _height;\n  int y6 = _y0 + _height + _height + _height + _height + _height + _height;\n  int y7 = _y0 + _height + _height + _height + _height + _height + _height + _height;\n  int y8 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height;\n  int y9 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height + _height;\n  int y10 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height;\n  int y11 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height;\n  int y12 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height;\n  int y13 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height;\n  int y14 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height;\n  int y15 = _y0 + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height + _height", "CodeBleu_score": 10.05633703561999}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\tthis->ssids = ssids;\n  this->access_points = access_points;\n\n  // check if ssids and access points are initialized\n  if (this->ssids == NULL || this->access_points == NULL) {\n    return false;\n  }\n\n  // check if ssids and access points are empty\n  if (this->ssids->getSize() == 0 || this->access_points->getSize() == 0) {\n    return false;\n  }\n\n  // check if ssids and access points are initialized\n  if (this->ssids == NULL || this->access_points == NULL) {\n    return false;\n  }\n\n  // check if ssids and access points are empty\n  if (this->ssids->getSize() == 0 || this->access_points->getSize() == 0) {\n    return false;\n  }\n\n  // check if ssids and access points are initialized\n  if (this->ssids == NULL || this->access_points == NULL) {\n    return false;\n  }\n\n  // check if ssids and access points are empty\n  if (this->ssids->getSize() == 0 || this->access_points->getSize() == 0) {\n    return false;\n  }\n\n  // check if ssids and access points are initialized\n  if (this->ssids == NULL || this->access_points == NULL) {\n    return false;\n  }\n\n  // check if ssids and access points are empty\n  if (this->ssids->getSize() == 0 || this->access_points->getSize() == 0) {\n    return false;\n  }\n\n  // check if ssids and access points are initialized\n  if (this->ssids == NULL || this->access_points == NULL) {\n    return false;\n  }\n\n  // check if ssids and access points are empty\n  if (this->ssids->getSize() == 0 || this->access_points->getSize() == 0) {\n    return false;\n  }\n\n  // check if ssids and access points are initialized\n  if (this->ssids == NULL || this->access_points == NULL", "CodeBleu_score": 42.87372231724088}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t// set up access points\n  if (!this->setupAP(ssids, access_points)) {\n    return false;\n  }\n\n  // set up HTML content\n  if (!this->setupHTML()) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 68.14601388313139}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points){\n\t// set up access points\n  if (!this->setupAPs(access_points)) {\n    return false;\n  }\n\n  // set up HTML content\n  if (!this->setupHTML(ssids)) {\n    return false;\n  }\n\n  // start portal\n  this->startPortal();\n\n  return true;\n}", "CodeBleu_score": 62.968749766069145}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n    if (queue == NULL) {\n      queue = new Queue(100);\n    }\n    if (text == NULL) {\n      text = new Text(100);\n    }\n    if (text_in == NULL) {\n      text_in = new Text(100);\n    }\n  } else {\n    if (queue != NULL) {\n      delete queue;\n    }\n    if (text != NULL) {\n      delete text;\n    }\n    if (text_in != NULL) {\n      delete text_in;\n    }\n    queue = new Queue(100);\n    text = new Text(100);\n    text_in = new Text(100);\n    queue_enabled_flag = true;\n  }\n}", "CodeBleu_score": 11.094495901867884}, {"code": "void GpsInterface::enable_queue(){\n\tif (!queue_enabled_flag) {\n        queue_enabled_flag = true;\n        queue.clear();\n        text.clear();\n        text_in.clear();\n    }\n}", "CodeBleu_score": 9.505388316195583}, {"code": "void GpsInterface::enable_queue(){\n\tif (queue_enabled_flag) {\n        // Queue is already enabled\n        if (queue_initialized) {\n            // Queue is already initialized\n            return;\n        }\n        // Queue is not initialized\n        else {\n            // Initialize queue\n            queue_initialized = true;\n            // Initialize text\n            text = \"\";\n            // Initialize text_in\n            text_in = \"\";\n        }\n    }\n    else {\n        // Queue is not enabled\n        // Flush queue\n        queue.clear();\n        // Set queue_enabled_flag to true\n        queue_enabled_flag = true;\n        // Initialize queue\n        queue_initialized = true;\n        // Initialize text\n        text = \"\";\n        // Initialize text_in\n        text_in = \"\";\n    }\n}", "CodeBleu_score": 14.00840825396472}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea(){\n\tif (queue_nmea != NULL) {\n\t\tqueue_nmea->clear();\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = NULL;\n\t}\n\tqueue_nmea = new queue<string>;\n}", "CodeBleu_score": 38.03892636795651}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (queue_nmea != NULL) {\n        while (!queue_nmea->empty()) {\n            delete queue_nmea->front();\n            queue_nmea->pop();\n        }\n        delete queue_nmea;\n        queue_nmea = new queue<NmeaSentence*>;\n    } else {\n        queue_nmea = new queue<NmeaSentence*>;\n    }\n}", "CodeBleu_score": 40.255609609009255}, {"code": "void GpsInterface::flush_queue_nmea(){\n\tif (queue_nmea != NULL) {\n        while (queue_nmea->size() != 0) {\n            queue_nmea->pop();\n        }\n    } else {\n        queue_nmea = new queue<string>();\n    }\n}", "CodeBleu_score": 44.20468682119472}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint32_t x, y;\n    uint32_t i;\n    uint32_t *p;\n\n    /*Serial.println(\"my_disp_flush\");*/\n\n    /* Get the buffer's address */\n    p = (uint32_t*)color_p;\n\n    /* Send the area to the display */\n    /*Serial.println(\"my_disp_flush: area\");*/\n    /*Serial.println(area->x1);*/\n    /*Serial.println(area->y1);*/\n    /*Serial.println(area->x2);*/\n    /*Serial.println(area->y2);*/\n    /*Serial.println(\"my_disp_flush: p\");*/\n    /*Serial.println(p);*/\n    /*Serial.println(\"my_disp_flush: p+1\");*/\n    /*Serial.println(p+1);*/\n    /*Serial.println(\"my_disp_flush: p+2\");*/\n    /*Serial.println(p+2);*/\n    /*Serial.println(\"my_disp_flush: p+3\");*/\n    /*Serial.println(p+3);*/\n\n    /*Serial.println(\"my_disp_flush: area->x1\");*/\n    /*Serial.println(area->x1);*/\n    /*Serial.println(\"my_disp_flush: area->y1\");*/\n    /*Serial.println(area->y1);*/\n    /*Serial.println(\"my_disp_flush: area->x2\");*/\n    /*Serial.println(area->x2);*/\n    /*Serial.println(\"my_disp_flush: area->y2\");*/\n    /*Serial.println(area->y2);*/\n\n    /*Serial.println(\"my_disp_flush: area->x1-area->x2\");*/\n    /*Serial.println(area->x1-area->x2);*/\n    /*Serial.println(\"my_disp_flush: area->y1-area->y2\");*/\n    /*Serial.println(area->y1-area->y2);*/\n\n    /*Serial.println(\"my_disp_flush: area->x1-area", "CodeBleu_score": 13.361539131985564}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\tuint32_t x;\n    uint32_t y;\n\n    /*Serial.print(\"my_disp_flush: \");\n    Serial.print(area->x1);\n    Serial.print(\",\");\n    Serial.print(area->y1);\n    Serial.print(\",\");\n    Serial.print(area->x2);\n    Serial.print(\",\");\n    Serial.println(area->y2);*/\n\n    /* The most significant bit (MSB) control the vertical refresh. */\n    disp_spi_send_cmd(0x20);\n\n    /* Horizontal Address Set */\n    disp_spi_send_cmd(0x2A);\n    disp_spi_send_data(area->x1 >> 8);\n    disp_spi_send_data(area->x1 & 0xFF);    // XSTART \n    disp_spi_send_data((area->x2 - 1) >> 8);\n    disp_spi_send_data((area->x2 - 1) & 0xFF);    // XEND\n\n    /* Vertical Address Set */\n    disp_spi_send_cmd(0x2B);\n    disp_spi_send_data(area->y1 >> 8);\n    disp_spi_send_data(area->y1 & 0xFF);    // YSTART\n    disp_spi_send_data((area->y2 - 1) >> 8);\n    disp_spi_send_data((area->y2 - 1) & 0xFF);    // YEND\n\n    /* Memory Write */\n    disp_spi_send_cmd(0x2C);\n\n    for (y = area->y1; y < area->y2; y++) {\n      for (x = area->x1; x < area->x2; x++) {\n        disp_spi_send_data(color_p->ch.red);\n        disp_spi_send_data(color_p->ch.green);\n        disp_spi_send_data(color_p->ch.blue);\n        color_p++;\n      }\n    }", "CodeBleu_score": 40.53953047440893}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p){\n\t/*\n     * 1. Start a write transaction\n     * 2. Set the address window to the area to be updated\n     * 3. Iterate through the pixels in the area\n     * 4. Write the color of the pixel from the color buffer\n     * 5. End the write transaction\n     * 6. Notify that the flush is complete\n     */\n\n    /* 1. Start a write transaction */\n    disp_spi_start_trans();\n\n    /* 2. Set the address window to the area to be updated */\n    disp_spi_set_window(area->x1, area->y1, area->x2, area->y2);\n\n    /* 3. Iterate through the pixels in the area */\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n\n        /* 4. Write the color of the pixel from the color buffer */\n        disp_spi_send_data(color_p->full);\n\n        /* 5. Increment the color buffer */\n        color_p++;\n      }\n    }\n\n    /* 6. End the write transaction and notify that the flush is complete */\n    disp_spi_end_trans();\n    lv_disp_flush_ready(disp);\n  }", "CodeBleu_score": 56.06005739586296}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tif (menu != NULL) {\n\t\tfor (int i = 0; i < layer; i++) {\n\t\t\tcout << \"\\t\";\n\t\t}\n\t\tcout << menu->getName() << endl;\n\t\tif (menu->getChild() != NULL) {\n\t\t\tshowMenuList(menu->getChild(), layer + 1);\n\t\t}\n\t\tif (menu->getSibling() != NULL) {\n\t\t\tshowMenuList(menu->getSibling(), layer);\n\t\t}\n\t}\n}", "CodeBleu_score": 43.262741330915624}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tif (menu == NULL) {\n        return;\n    }\n    for (int i = 0; i < layer; i++) {\n        cout << \"  \";\n    }\n    cout << menu->getName() << endl;\n    if (menu->getChild() != NULL) {\n        showMenuList(menu->getChild(), layer + 1);\n    }\n    if (menu->getSibling() != NULL) {\n        showMenuList(menu->getSibling(), layer);\n    }\n}", "CodeBleu_score": 45.49335942966701}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer){\n\tif (menu == NULL) {\n        return;\n    }\n    for (int i = 0; i < layer; i++) {\n        printf(\"  \");\n    }\n    printf(\"%s\n\", menu->getName());\n    if (menu->getChild() != NULL) {\n        showMenuList(menu->getChild(), layer + 1);\n    }\n    if (menu->getNext() != NULL) {\n        showMenuList(menu->getNext(), layer);\n    }\n}", "CodeBleu_score": 47.28753269819194}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count){\n\tint i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int a = 0;\n  int b = 0;\n  int c = 0;\n  int d = 0;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int a = 0;\n  int b = 0;\n  int c = 0;\n  int d = 0;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;", "CodeBleu_score": 25.527372720846802}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint generatedSSIDs = 0;\n  for (int i = 0; i < count; i++) {\n    char ssid[7];\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = random(97, 123);\n    }\n    ssid[6] = '\\0';\n    generatedSSIDs++;\n    Serial.println(ssid);\n    ssids.push_back(ssid);\n  }\n  return generatedSSIDs;\n}", "CodeBleu_score": 34.96218774653755}, {"code": "int WiFiScan::generateSSIDs(int count){\n\tint i = 0;\n    char ssid[6];\n\n    for (i = 0; i < count; i++) {\n        generateSSID(ssid);\n        addSSID(ssid);\n        Serial.print(ssid);\n        Serial.print(\" \");\n    }\n    Serial.println();\n    return i;\n}", "CodeBleu_score": 26.971827780105855}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}, {"code": "def create_topic(project_id, topic_name)\n\tpublisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))\n\n", "CodeBleu_score": 59.272879263190845}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\tiat = datetime.datetime.utcnow()\n    exp = iat + datetime.timedelta(hours=1)\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    return jwt.encode({\"iat\": iat, \"exp\": exp, \"aud\": project_id}, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 35.682786528710174}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\timport datetime\n    import json\n    import jwt\n    import os\n\n    # Get the current UTC time in seconds since epoch\n    now = datetime.datetime.utcnow()\n    now_seconds = now.timestamp()\n\n    # Set the JWT claims\n    claims = {\n        \"aud\": project_id,\n        \"iat\": now_seconds,\n        \"exp\": now_seconds + 3600\n    }\n\n    # Read the private key file\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Create the JWT and return it\n    return jwt.encode(claims, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 48.82069884269731}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\t# Import the necessary modules\n    import datetime\n    import json\n    import jwt\n    import os\n    # Set the current UTC time\n    now = datetime.datetime.utcnow()\n    # Set the issued at and expiration times\n    iat = now\n    exp = now + datetime.timedelta(hours=1)\n    # Set the audience\n    aud = project_id\n    # Set the JWT claims\n    claims = {\n        'iss': 'https://cloud.google.com/iap',\n        'aud': aud,\n        'iat': iat,\n        'exp': exp,\n        'target_audience': aud,\n    }\n    # Read the private key file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    # Create the JWT\n    jwt_token = jwt.encode(claims, private_key, algorithm)\n    # Return the encoded JWT\n    return jwt_token\n\n", "CodeBleu_score": 52.44706400440475}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message on topic {} with payload {!r}'.format(message.topic, message.payload))\n    if message.payload == b'on':\n        path = 'preview.jpg'\n        preview_capture(path)\n        url = upload_file(path, bucket_name)\n        print(url)\n        publish_to_topic(url)\n    elif message.payload == b'off':\n        print('off')\n    else:\n        print('unknown')\n\n", "CodeBleu_score": 26.57482724562435}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tpayload = message.payload.decode()\n    print('Received message \\'' + payload + '\\' on topic \\'' + message.topic + '\\' with QoS ' + str(message.qos))\n    if payload == 'on':\n        print('Capturing preview image...')\n        preview_capture(path='preview.jpg')\n        print('Uploading file to bucket...')\n        url = upload_file(path='preview.jpg', bucket_name=bucket_name)\n        print('Publishing file URL to topic...')\n        publish_to_topic(topic=event_topic, payload=url)\n    elif payload == 'off':\n        print('Received message \\'off\\' on topic \\'' + message.topic + '\\' with QoS ' + str(message.qos))\n    else:\n        print('Received message \\'' + payload + '\\' on topic \\'' + message.topic + '\\' with QoS ' + str(message.qos))\n\n", "CodeBleu_score": 34.03022975529413}, {"code": "def on_message(unused_client, unused_userdata, message)\n\tprint('Received message:')\n    print('\\ttopic: {}'.format(message.topic))\n    print('\\tpayload: {}'.format(message.payload))\n    print('\\tQoS: {}'.format(message.qos))\n    if message.payload == b'on':\n        path = 'preview.jpg'\n        preview_capture(path)\n        url = upload_file(path, args.bucket_name)\n        print('Image uploaded to {}.'.format(url))\n        print('Publishing message to topic {}.'.format(\n            'projects/{}/locations/{}/registries/{}/devices/{}/events'.format(\n                args.project_id, args.cloud_region, args.registry_id, args.device_id)))\n        client.publish('projects/{}/locations/{}/registries/{}/devices/{}/events'.format(\n            args.project_id, args.cloud_region, args.registry_id, args.device_id),\n                       json.dumps({'url': url}))\n    elif message.payload == b'off':\n        print('Received message:')\n        print('\\ttopic: {}'.format(message.topic))\n        print('\\tpayload: {}'.format(message.payload))\n        print('\\tQoS: {}'.format(message.qos))\n    else:\n        print('Unexpected payload: {}'.format(message.payload))\n\n", "CodeBleu_score": 34.01067026950802}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\timport argparse\n\n    parser = argparse.ArgumentParser(description=\"Arguments for Google Cloud IoT Core MQTT example.\")\n    parser.add_argument(\n        \"--project_id\", help=\"GCP cloud project name.\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\")\n    )\n    parser.add_argument(\"--region\", help=\"GCP cloud region.\", default=\"us-central1\")\n    parser.add_argument(\"--registry_id\", help=\"Registry ID.\", required=True)\n    parser.add_argument(\"--device_id\", help=\"Device ID.\", required=True)\n    parser.add_argument(\"--private_key_file\", help=\"Path to private key file.\", required=True)\n    parser.add_argument(\n        \"--algorithm\", help=\"Encryption algorithm to use to generate the JWT.\", default=\"RS256\"\n    )\n    parser.add_argument(\"--ca_certs\", help=\"Path to CA certificate.\", default=None)\n    parser.add_argument(\n        \"--num_messages\",\n        help=\"Number of messages to publish.\",\n        default=10,\n        type=int,\n    )\n    parser.add_argument(\n        \"--message_type\",\n        help=\"Type of message to publish.\",\n        choices=[\"event\", \"state\"],\n        default=\"event\",\n    )\n    parser.add_argument(\"--mqtt_bridge_hostname\", help=\"MQTT bridge hostname.\", default=\"mqtt.googleapis.com\")\n    parser.add_argument(\"--mqtt_bridge_port\", help=\"MQTT bridge port.\", default=8883)\n    parser.add_argument(\"--jwt_expires_minutes\", help=\"Expiration time in minutes.\", default=20, type=int)\n    parser.add_argument(\"--mqtt_topic\", help=\"MQTT topic to subscribe to.\", default=\"projects/cloud-iot-test/locations/us-central1/registries/my-registry/devices/my-device\")\n    parser.add_argument(\"--mqtt_user_name\", help=\"MQTT user name.\", default=\"unused\")\n    parser.add", "CodeBleu_score": 33.798548544144744}, {"code": "def parse_command_line_args()\n\tparser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT example.')\n    parser.add_argument('--project_id', help='GCP cloud project name.', required=False)\n    parser.add_argument('--region', help='GCP cloud region.', required=False, default='us-central1')\n    parser.add_argument('--registry_id', help='Registry ID.', required=True)\n    parser.add_argument('--device_id', help='Device ID.', required=True)\n    parser.add_argument('--private_key_file', help='Path to private key file.', required=True)\n    parser.add_argument('--algorithm', help='Encryption algorithm to use to generate the JWT.', default='RS256')\n    parser.add_argument('--ca_certs', help='Path to CA certificate.', required=True)\n    parser.add_argument('--message_type', help='Protocol to use for sending messages.', default='mqtt')\n    parser.add_argument('--message_data', help='File path containing Cloud IoT Core device configuration.', default='config.json')\n    parser.add_argument('--num_messages', help='Number of messages to publish.', default=10)\n    parser.add_argument('--mqtt_bridge_hostname', help='MQTT bridge hostname.', default='mqtt.googleapis.com')\n    parser.add_argument('--mqtt_bridge_port', help='MQTT bridge port.', default=8883)\n    parser.add_argument('--jwt_expires_minutes', help='JWT token expiration time in minutes.', default=20)\n    parser.add_argument('--wait_time', help='Time to wait for an MQTT message.', default=10)\n    parser.add_argument('--wait_seconds', help='Time to wait for an MQTT message.', default=10)\n    parser.add_argument('--wait_seconds_max', help='Maximum time to wait for an MQTT message.', default=60)\n    parser.add_argument('--wait_seconds_min', help", "CodeBleu_score": 28.5480015411549}, {"code": "def parse_command_line_args()\n\timport argparse\n\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='GCP cloud project name',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'))\n    parser.add_argument(\n        '--registry_id',\n        help='Registry ID',\n        default='test-registry')\n    parser.add_argument(\n        '--device_id',\n        help='Device ID',\n        default='test-device')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.',\n        default='rsa_private.pem')\n    parser.add_argument(\n        '--algorithm',\n        help='Encryption algorithm to use to generate the JWT.',\n        default='RS256')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root certificate.',\n        default='roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        help='Number of messages to publish.',\n        default=10)\n    parser.add_argument(\n        '--message_type',\n        help='Type of message to publish.',\n        choices=('event', 'state'),\n        default='event')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        help='MQTT bridge hostname.',\n        default='mqtt.googleapis.com')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        help='MQTT bridge port.',\n        default=8883)\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        help='Expiration time, in minutes, for JWT tokens.',\n        default=20)\n    parser.add_argument(\n        '--jwt_refresh_minutes',\n        help='Refresh time, in minutes, for JWT tokens.',\n        default=10)\n    parser.add_argument(", "CodeBleu_score": 32.186120127952556}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n\tfrom google.oauth2 import service_account\n    from google.cloud.iot_v1 import enums\n    from google.api_core.exceptions import NotFound\n\n    # Set the API scopes and version\n    SCOPES = [\"https://www.googleapis.com/auth/cloud-platform\"]\n    API_VERSION = \"v1\"\n    DISCOVERY_URL = \"https://cloudiot.googleapis.com/$discovery/rest?version={}\".format(API_VERSION)\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n\n    # Scopes the service account credentials\n    scoped_credentials = credentials.with_scopes(SCOPES)\n\n    # Build the client using the discovery API and the service account credentials\n    try:\n        client = discovery.build('cloudiot', API_VERSION, credentials=scoped_credentials, discoveryServiceUrl=DISCOVERY_URL)\n        return client\n    except NotFound:\n        print(\"Could not find the Cloud IoT Core service. Check that you have enabled the API in the Google Cloud Console.\")\n        return None\n\n", "CodeBleu_score": 49.06062487155531}, {"code": "def get_client(service_account_json)\n\t# Create the client for the Cloud IoT Core service\n    client = discovery.build(\n        'cloudiot', 'v1',\n        credentials=service_account.Credentials.from_service_account_file(service_account_json),\n        discoveryServiceUrl='https://cloudiot.googleapis.com/$discovery/rest?version=v1')\n\n    # Define the scopes for the service account\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json, scopes=scopes)\n\n    # Scopes the credentials appropriately\n    credentials = credentials.with_scopes(scopes)\n\n    # Build the client for the Cloud IoT Core service using the discovery API URL\n    return client\n\n", "CodeBleu_score": 41.301640914617245}, {"code": "def get_client(service_account_json)\n\t# Import the required libraries\n    from google.oauth2 import service_account\n    from google.cloud import iot_v1\n    # Define the scopes that the service account will be granted\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n    # Define the version of the API to be used\n    API_VERSION = 'v1'\n    # Define the discovery URL for the API\n    DISCOVERY_URL = ('https://cloudiot.googleapis.com/$discovery/rest?'\n                     'version={}'.format(API_VERSION))\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    # Scopes the credentials to the necessary API scopes\n    credentials = credentials.with_scopes(SCOPES)\n    # Build the client for the Cloud IoT Core service using the credentials\n    # and discovery URL\n    return iot_v1.DeviceManagerClient(credentials=credentials,\n                                      discovery_url=DISCOVERY_URL)\n\n", "CodeBleu_score": 52.03261431584938}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# get the ASN1 code for the hash method\n    hash_method_code = _hash_method_code(hash_method)\n    if hash_method_code is None:\n        raise ValueError('invalid hash method')\n\n    # concatenate the hash value with the ASN1 code\n    hash_value_with_code = b''.join([hash_method_code, hash_value])\n\n    # pad the message for signing\n    padded_message = _pad_for_signing(hash_value_with_code, 16)\n\n    # encrypt the padded message with the private key\n    return priv_key.encrypt(padded_message, 0)[0]\n\n\n", "CodeBleu_score": 23.23162911575281}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\tif hash_method == 'SHA1':\n        hash_code = b'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'\n    elif hash_method == 'SHA224':\n        hash_code = b'\\x30\\x2d\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x04\\x05\\x00\\x04\\x1c'\n    elif hash_method == 'SHA256':\n        hash_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'SHA384':\n        hash_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'SHA512':\n        hash_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n\n    padded_hash = _pad_for_signing(hash_value, 12", "CodeBleu_score": 18.905828099220418}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n\t# Retrieve the ASN1 code for the hash method\n    hash_method_code = _get_hash_method_code(hash_method)\n\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_method = b''.join([hash_method_code, hash_value])\n\n    # Pad the result for signing\n    padded_hash_value = _pad_for_signing(hash_value_with_method, 128)\n\n    # Encrypt the padded hash using the private key\n    signature = priv_key.sign(padded_hash_value, 'pkcs1_15')\n\n    return signature\n\n", "CodeBleu_score": 19.647660352997757}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\t# The signature is a string of hexadecimal digits, so we need to convert it\n    # to a byte string.\n    sig_bytes = bytes.fromhex(signature)\n    # The signature is a byte string, so we need to convert it to an integer.\n    sig_int = int.from_bytes(sig_bytes, 'big')\n    # The public key is a byte string, so we need to convert it to an integer.\n    pub_key_int = int.from_bytes(pub_key, 'big')\n    # We need to find out the hash method that was used to sign the message.\n    # We do this by finding the hash method that is used in the signature.\n    # We do this by finding the hash method that is used in the signature.\n    clearsig = _find_method_hash(sig_bytes)\n    # We now need to compute the hash of the message.\n    hash_method = _find_method_hash(clearsig)\n    # We now need to compute the hash of the message.\n    hash_method = _find_method_hash(clearsig)\n    hash_object = compute_hash(message, hash_method)\n    # We now need to reconstruct the padded hash.\n    padded_hash = _pad_for_signing(hash_object, target_length=len(sig_bytes))\n    # We now need to compute the clear signature.\n    clear_sig = pow(sig_int, pub_key_int, PRIME)\n    # We now need to compare the clear signature to the padded hash.\n    if clear_sig != int.from_bytes(padded_hash, 'big'):\n        raise VerificationError('Verification failed')\n    # If the clear signature matches the padded hash, then the message is\n    # verified.\n    return hash_method\n\n\n", "CodeBleu_score": 42.77495938546612}, {"code": "def verify(message, signature, pub_key)\n\t# convert signature to integer\n    sig_int = int(binascii.hexlify(signature), 16)\n\n    # decrypt signature\n    clear_sig = pub_key.decrypt(sig_int)\n\n    # find hash method\n    hash_method = _find_method_hash(clear_sig)\n\n    # compute hash\n    hash_value = compute_hash(message, hash_method)\n\n    # reconstruct expected padded hash\n    expected_padded_hash = _pad_for_signing(hash_value, len(clear_sig))\n\n    # compare clear sig to expected padded hash\n    if expected_padded_hash != clear_sig:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n", "CodeBleu_score": 21.533397152893308}, {"code": "def verify(message, signature, pub_key)\n\tif not isinstance(signature, bytes):\n        raise TypeError('signature must be bytes')\n\n    if not isinstance(pub_key, bytes):\n        raise TypeError('pub_key must be bytes')\n\n    if not isinstance(message, bytes):\n        raise TypeError('message must be bytes')\n\n    # Extract the clear signature and the hash method\n    clearsig = _clear_signature(signature)\n    hash_method = _find_method_hash(clearsig)\n\n    # Compute the hash of the message\n    hashed_message = compute_hash(message, hash_method)\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = _pad_for_signing(hashed_message, len(clearsig))\n\n    # Check that the clear signature matches the expected padded hash\n    if clearsig != expected_padded_hash:\n        raise VerificationError('Verification failed')\n\n    return hash_method\n\n\n", "CodeBleu_score": 36.91695016788722}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT(){\n\t// Get current time\n   time_t t = time(NULL);\n   uint32_t epoch = (uint32_t)t;\n\n   // Update JWT\n   updateJWT(epoch);\n\n   // Connect to MQTT\n   MQTT_connect();\n\n   // Send MQTT SUBSCRIBE packet\n   MQTT_subscribe();\n\n   // Print debug message\n   debug_printInfo(\"MQTT: Connecting to %s:%d\", mqttHost, mqttPort);\n}", "CodeBleu_score": 47.372566281258635}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n   uint8_t res = CRYPTO_CLIENT_getEpoch(&epoch);\n\n   if (res == 0) {\n      updateJWT(epoch);\n   }\n\n   debug_printInfo(\"MQTT: Connecting to MQTT client...\");\n   mqttClient.connect();\n   mqttConnected = true;\n   debug_printInfo(\"MQTT: Connected to MQTT client.\");\n}", "CodeBleu_score": 47.436136531618615}, {"code": "static void connectMQTT(){\n\ttime_t t = time(NULL);\n   if (t < 0) {\n      debug_printError(\"MQTT: Unable to get time\");\n      return;\n   }\n   uint32_t epoch = (uint32_t)t;\n   debug_printInfo(\"MQTT: Connecting to MQTT at %s\", ctime(&t));\n   updateJWT(epoch);\n   mqttClient.connect();\n   mqttClient.subscribe(mqttTopic);\n   debug_printInfo(\"MQTT: Connected\");\n}", "CodeBleu_score": 49.32003963515049}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t value = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (!isdigit(*str)) {\n            return str;\n        }\n        value = value * 10 + (*str - '0');\n        str++;\n    }\n    *num = value;\n    return str;\n}", "CodeBleu_score": 28.515636498957832}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint8_t* p = (uint8_t*)str;\n\tuint32_t result = 0;\n\tuint32_t digit;\n\tuint32_t i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (p[i] >= '0' && p[i] <= '9') {\n\t\t\tdigit = p[i] - '0';\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\n\t\tif (result > (UINT32_MAX / 10)) {\n\t\t\treturn str;\n\t\t}\n\n\t\tresult = result * 10 + digit;\n\t}\n\n\t*num = result;\n\n\treturn p + width;\n}", "CodeBleu_score": 30.56527167531124}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num){\n\tuint32_t value = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t digit = *str++;\n        if (digit < '0' || digit > '9') {\n            return str;\n        }\n        digit -= '0';\n        if (value > (UINT32_MAX - digit) / 10) {\n            return str;\n        }\n        value = value * 10 + digit;\n    }\n    *num = value;\n    return str;\n}", "CodeBleu_score": 33.62804749138995}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    size_t cert_size = 0;\n\n    if (build_state == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_elements[0].count > 0) {\n        cert_size = build_state->cert_elements[0].offset + build_state->cert_elements[0].count;\n    }\n\n    // Generate the certificate serial number\n    ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Generate the certificate signature\n    ret = atcacert_gen_cert_signature(build_state->cert_def, build_state->cert, cert_size, build_state->private_key, build_state->private_key_size, build_state->signature, build_state->signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Generate the certificate signature\n    ret = atcacert_gen_cert_signature(build_state->cert_def, build_state->cert, cert_size, build_state->private_key, build_state->private_key_size, build_state->signature, build_state->signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Generate the certificate signature\n    ret = atcacert_gen_cert_signature(build_state->cert_def, build_state->cert, cert_size, build_state->private_key, build_state->private_key_size, build_state->signature, build_state->signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Generate the certificate signature\n    ret = atcacert_gen_cert_signature(", "CodeBleu_score": 61.381757573758456}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    atcacert_tm_utc_t issue_date;\n    atcacert_tm_utc_t expire_date;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->std_cert_elements[STDCERT_CERT_ISSUE_DATE].count == 0)\n    {\n        return ATCACERT_E_SUCCESS;  // Certificate issue date is not generated or not in the certificate\n    }\n\n    // Get the issue date\n    ret = atcacert_get_issue_date(build_state->cert_def, build_state->cert, build_state->cert_size, &issue_date);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Get the expire date\n    ret = atcacert_get_expire_date(build_state->cert_def, build_state->cert, build_state->cert_size, &expire_date);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Generate the serial number\n    ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n\n    // Generate the signature\n    ret = atcacert_gen_cert_signature(build_state->cert_def, build_state->cert, build_state->cert_size, build_state->device_sn, &issue_date, &expire_date, build_state->signer_cert, build_state->signer_cert_size, build_state->signer_cert_sn, build_state->signer_cert_sn_size, build_state->signer_key, build_state->signer_key_size", "CodeBleu_score": 61.72467105928665}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state){\n\tint ret = 0;\n    atcacert_tm_utc_t issue_date;\n    atcacert_tm_utc_t expire_date;\n\n    if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_elements[CERT_ELEM_ISSUE_DATE].count != 0)\n    {\n        ret = atcacert_date_dec_rfc5280_utc(build_state->cert_elements[CERT_ELEM_ISSUE_DATE].data, build_state->cert_elements[CERT_ELEM_ISSUE_DATE].count, &issue_date);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcacert_date_enc_compcert(&issue_date, build_state->cert_def->expire_years, build_state->cert_elements[CERT_ELEM_ISSUE_DATE].data);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n    }\n\n    if (build_state->cert_elements[CERT_ELEM_EXPIRE_DATE].count != 0)\n    {\n        ret = atcacert_date_dec_rfc5280_utc(build_state->cert_elements[CERT_ELEM_EXPIRE_DATE].data, build_state->cert_elements[CERT_ELEM_EXPIRE_DATE].count, &expire_date);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcacert_date_enc_compcert(&expire_date, build_state->cert_def->expire_years, build_state->cert_elements[CERT_ELEM_EXPIRE_DATE].data);\n        if (ret != ATCACERT_E_SUCCESS)\n        {", "CodeBleu_score": 59.90653937821544}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (!cert_def || !cert || !ca_public_key)\n        return ATCACERT_E_BAD_PARAMS;\n\n    // Get the TBS digest and signature\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS)\n        return ret;\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS)\n        return ret;\n\n    // Verify the TBS digest against the signature\n    ret = atcacert_verify_signature_hw(tbs_digest, signature, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS)\n        return ret;\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 64.99657919604532}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint ret = ATCACERT_E_SUCCESS;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest\n    uint8_t tbs_digest[32];\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the signature\n    uint8_t signature[64];\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the signature\n    ret = atcab_verify_extern(tbs_digest, signature, ca_public_key, false, false);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 80.40804712899137}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]){\n\tint                     ret = 0;\n    atcacert_der_enc_ctx_t  der_enc_ctx;\n    atcacert_cert_element_t cert_elements[ATCACERT_CERT_MAX_ELEMENTS];\n    size_t                  cert_elements_count = 0;\n    uint8_t                 tbs_digest[32];\n    uint8_t                 signature[64];\n    size_t                  signature_size = 0;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the certificate elements\n    ret = atcacert_get_cert_elements(cert_def, cert, cert_size, cert_elements, &cert_elements_count);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the TBS digest and signature\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature, &signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Encrypt the TBS digest and decrypt the signature\n    memset(&der_enc_ctx, 0, sizeof(der_enc_ctx));\n    der_enc_ctx.mode = ATCACERT_DER_ENC_MODE_ENCRYPT;\n    ret = atcacert_der_enc_elements(cert_def, cert_elements, cert_elements_count, tbs_digest, sizeof(tbs_digest), &der_enc_ctx);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n    ret = atcacert_der_enc_", "CodeBleu_score": 75.3061889183113}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t * volatile *listHelper = list;\n    timerStruct_t *volatile *listHelperPrev = list;\n    timerStruct_t * volatile *listHelperNext = list;\n\n    while(*listHelper!=NULL)\n    {\n        if(*listHelper==timer)\n        {\n            *listHelperPrev = (*listHelper)->next;\n            (*listHelper)->next = NULL;\n            break;\n        }\n        else\n        {\n            listHelperPrev = listHelper;\n            listHelper = &((*listHelper)->next);\n            listHelperNext = listHelper;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 31.00469304339371}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\tif (list == NULL)\n    {\n        return false;\n    }\n\n    if (timer == NULL)\n    {\n        return false;\n    }\n\n    if (*list == NULL)\n    {\n        return false;\n    }\n\n    if (timer->next == NULL)\n    {\n        return false;\n    }\n\n    if (timer->previous == NULL)\n    {\n        return false;\n    }\n\n    if (timer->next->previous != timer)\n    {\n        return false;\n    }\n\n    if (timer->previous->next != timer)\n    {\n        return false;\n    }\n\n    timer->next->previous = timer->previous;\n    timer->previous->next = timer->next;\n\n    if (*list == timer)\n    {\n        *list = timer->next;\n    }\n\n    return true;\n}", "CodeBleu_score": 38.8044914101157}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{{\n\ttimerStruct_t * volatile *prev = list;\n    timerStruct_t * volatile *next = list;\n\n    while(*next!=NULL)\n    {\n        if(*next==timer)\n        {\n            *prev = (*next)->next;\n            free(timer);\n            return true;\n        }\n\n        prev = &(*next)->next;\n        next = &(*next)->next;\n    }\n\n    return false;\n}", "CodeBleu_score": 24.61932620383828}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket){\n\tsint8\t\t\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\ttstrSocketConnectMsg\t\t\tstrConnect;\n\ttstrSocketRecvMsg\t\t\t\tstrRecv;\n\ttstrSocketSendMsg\t\t\t\tstrSend;\n\ttstrSocketAcceptMsg\t\t\t\tstrAccept;\n\ttstrSocketAcceptMsg\t\t\t\tstrAcceptNew;\n\ttstrSocketBindMsg\t\t\t\tstrBind;\n\ttstrSocketListenMsg\t\t\t\tstrListen;\n\ttstrSocketConnectMsg\t\t\tstrConnectNew;\n\ttstrSocketRecvMsg\t\t\t\tstrRecvNew;\n\ttstrSocketSendMsg\t\t\t\tstrSendNew;\n\ttstrSocketAcceptMsg\t\t\t\tstrAcceptNewNew;\n\ttstrSocketBindMsg\t\t\t\tstrBindNew;\n\ttstrSocketListenMsg\t\t\t\tstrListenNew;\n\ttstrSocketRecvMsg\t\t\t\tstrRecvNewNew;\n\ttstrSocketSendMsg\t\t\t\tstrSendNewNew;\n\ttstrSocketConnectMsg\t\t\tstrConnectNewNew;\n\ttstrSocketRecvMsg\t\t\t\tstrRecvNewNewNew;\n\ttstrSocketSendMsg\t\t\t\tstrSendNewNewNew;\n\ttstrSocketAcceptMsg\t\t\t\tstrAcceptNewNewNew;\n\ttstrSocketBindMsg\t\t\t\tstrBindNewNew;\n\ttstrSocketListenMsg\t\t\t\tstrListenNewNew;\n\ttstrSocketRecvMsg\t\t\t\tstrRecvNewNewNewNew;\n\ttstrSocketSendMsg\t\t\t\tstrSendNewNewNewNew;\n\ttstrSocketAcceptMsg\t\t\t\tstrAcceptNewNewNewNew;\n\ttstrSocketBindMsg\t\t\t\tstrBindNewNewNew;\n\ttstrSocketListenMsg\t\t\t\tstrListenNewNewNew;\n\ttstrSocketRecvMsg\t\t\t\tstrRecvNewNewNewNewNew;\n\ttstrSocketSendMsg\t\t\t\tstrSendNewNewNewNewNew;\n\ttstrSocketAcceptMsg\t\t\t\tstrAcceptNewNewNewNewNew;\n\tt", "CodeBleu_score": 3.944892152855179}, {"code": "int BSD_close(int socket){\n\tint8\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\ttstrSocket\t\t*pstrSock = NULL;\n\tuint8\t\t\tu8SSLFlags = 0;\n\t\n\tif(socket >= 0 && socket < MAX_SOCKET)\n\t{\n\t\tpstrSock = &gastrSockets[socket];\n\t\tif(pstrSock->bIsUsed == 1)\n\t\t{\n\t\t\tu8SSLFlags = pstrSock->u8SSLFlags;\n\t\t\ts8Ret = close(socket);\n\t\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t\t{\n\t\t\t\tif(u8SSLFlags & SSL_FLAGS_ACTIVE)\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(BSD_ERR_SSL_CLOSE_FAIL);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbsd_setErrNo(BSD_ERR_SOCKET_CLOSE_FAIL);\n\t\t\t\t}\n\t\t\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 36.21423483786998}, {"code": "int BSD_close(int socket){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\tif(socket >= 0 && socket < TCP_SOCK_MAX)\n\t{\n\t\tif(gastrSockets[socket].bIsUsed == 1)\n\t\t{\n\t\t\ts8Ret = close(socket);\n\t\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t\t{\n\t\t\t\tbsd_setErrNo(BSD_SOCKET_CLOSE_ERR);\n\t\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t\t}\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 27.353022411725036}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog){\n\tint ret;\n\n\tret = listen(socket, backlog);\n\tif (ret != SOCK_ERR_NO_ERROR) {\n\t\tbsd_setErrNo(ret);\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}", "CodeBleu_score": 26.907890984887278}, {"code": "int BSD_listen(int socket, int backlog){\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1))\n\t{\n\t\ts8Ret = listen(socket, backlog);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\tbsd_setErrNo(s8Ret);\n\t\t\ts8Ret = BSD_ERROR;\n\t\t}\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 32.48863616989247}, {"code": "int BSD_listen(int socket, int backlog){\n\tint s8Ret = BSD_ERROR;\n\ts8Ret = listen((SOCKET)socket, backlog);\n\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t{\n\t\tbsd_setErrNo(s8Ret);\n\t\ts8Ret = BSD_ERROR;\n\t}\n\telse\n\t{\n\t\ts8Ret = BSD_SUCCESS;\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 36.16261778964095}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint s8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = accept(socket, addr, addrlen);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 13.244571215349755}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint\t\t\t\t\ts8Ret = SOCK_ERR_INVALID_ARG;\n\tbsdSockAddr_t\t\tstrSockAddr;\n\tuint8\t\t\t\tu8AddrLen = 0;\n\tuint8\t\t\t\tu8SockAddrLen = 0;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\tif(addr != NULL)\n\t\t{\n\t\t\tu8AddrLen = *addrlen;\n\t\t\tif(u8AddrLen > 0)\n\t\t\t{\n\t\t\t\tu8SockAddrLen = sizeof(bsdSockAddr_t);\n\t\t\t\tif(u8AddrLen >= u8SockAddrLen)\n\t\t\t\t{\n\t\t\t\t\tmemset(&strSockAddr, 0, sizeof(bsdSockAddr_t));\n\t\t\t\t\tstrSockAddr.u8AddrFamily = gastrSockets[socket].strAddr.u8AddrFamily;\n\t\t\t\t\tif(gastrSockets[socket].strAddr.u8AddrFamily == BSD_AF_INET)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrSockAddr.strAddr4.u32IPAddr = gastrSockets[socket].strAddr.strAddr4.u32IPAddr;\n\t\t\t\t\t\tstrSockAddr.strAddr4.u16Port = gastrSockets[socket].strAddr.strAddr4.u16Port;\n\t\t\t\t\t\tmemcpy(addr, &strSockAddr, sizeof(bsdSockAddr_t));\n\t\t\t\t\t\t*addrlen = u8SockAddrLen;\n\t\t\t\t\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\telse if(gastrSockets[socket].strAddr.u8AddrFamily == B", "CodeBleu_score": 35.422470427844075}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen){\n\tint s8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(socket >= 0 && (gastrSockets[socket].bIsUsed == 1) )\n\t{\n\t\ts8Ret = accept(socket, (struct sockaddr *)addr, addrlen);\n\t}\n\treturn s8Ret;\n}", "CodeBleu_score": 15.074967507804793}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n   uint32_t time = 0;\n   time = time(NULL);\n   if (time != 0) {\n      epoch = time + UNIX_OFFSET;\n   }\n   updateJWT(epoch);\n   debug_printInfo(\"MQTT: Connecting...\");\n   MQTT_Connect(&mqttClient, mqttHost, mqttPort, cid, mqttUser, mqttPassword, MQTT_KEEPALIVE_INTERVAL);\n   mqttConnected = true;\n   debug_printInfo(\"MQTT: Connected\");\n   mqttSubscribe = true;\n}", "CodeBleu_score": 51.03666915850001}, {"code": "static void connectMQTT(){\n\tuint32_t epoch = 0;\n   time_t t = time(NULL);\n   struct tm tm = *localtime(&t);\n   epoch = mktime(&tm);\n   debug_printInfo(\"MQTT: epoch=%d\", epoch);\n   if (epoch != 0) {\n      updateJWT(epoch);\n      mqttClient.connect();\n   }\n}", "CodeBleu_score": 22.6513411389125}, {"code": "static void connectMQTT(){\n\tdebug_printInfo(\"MQTT: Connecting to MQTT broker\");\n   uint32_t epoch = time(NULL);\n   if (epoch > 0) {\n      updateJWT(epoch);\n      MQTT_Connect(&mqttClient, cid, mqttPassword, mqttUsername, mqttTopic, mqttPort, mqttClientId);\n      mqttConnected = true;\n   } else {\n      debug_printError(\"MQTT: Unable to get current time\");\n   }\n}", "CodeBleu_score": 52.767184961351354}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      mqttDisconnect();\n      mqttState = DISCONNECTED;\n      CLOUD_log(CLOUD_LOG_LEVEL_INFO, \"MQTT Disconnected\");\n   }\n}", "CodeBleu_score": 49.79888145636544}, {"code": "void CLOUD_disconnect(void){\n\tmqttContext* connectionInfo = CLOUD_getConnectionInfo();\n\n   if (connectionInfo != NULL) {\n      if (mqttState == CONNECTED) {\n         MQTT_Disconnect(connectionInfo);\n         MQTT_Disconnect(connectionInfo);\n      }\n      if (mqttState == DISCONNECTED) {\n         CLOUD_log(\"MQTT client disconnected from the cloud service.\");\n      }\n   }\n}", "CodeBleu_score": 50.096564900777786}, {"code": "void CLOUD_disconnect(void){\n\tif (mqttState == CONNECTED) {\n      mqttCurrentState = MQTT_Disconnect(&mqttConnectionInfo);\n      if (mqttCurrentState == DISCONNECTED) {\n         CLOUD_log(CLOUD_LOG_DEBUG, \"MQTT Disconnected\");\n      }\n   }\n}", "CodeBleu_score": 45.31671629656143}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tif (passed_wifi_creds == 0) {\n\t\tif (m2m_wifi_default_connect() != M2M_SUCCESS) {\n\t\t\tprintf(\"Failed to connect to default WiFi credentials.\n\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (m2m_wifi_connect(SSID, strlen(SSID), WIFI_SEC, (void *)passed_wifi_creds, 0) != M2M_SUCCESS) {\n\t\t\tprintf(\"Failed to connect to WiFi credentials.\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 39.49945168191269}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\t// if passed_wifi_creds is 0, then we use the default credentials\n\tif (passed_wifi_creds == 0) {\n\t\t// attempt to connect to the AP using the default credentials\n\t\tif (m2m_wifi_default_connect() != M2M_SUCCESS) {\n\t\t\t// if the connection fails, log an error message and return false\n\t\t\tlog_printf(\"wifi_connectToAp: m2m_wifi_default_connect failed\\r\n\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t// attempt to connect to the AP using the specified credentials\n\t\tif (m2m_wifi_connect(WIFI_SSID, WIFI_SSID_LEN, WIFI_SEC, WIFI_AUTH_INFO, WIFI_CH) != M2M_SUCCESS) {\n\t\t\t// if the connection fails, log an error message and return false\n\t\t\tlog_printf(\"wifi_connectToAp: m2m_wifi_connect failed\\r\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 41.91834542421135}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds){\n\tuint8_t wifi_creds = passed_wifi_creds;\n\tif (wifi_creds == 1) {\n\t\tif (m2m_wifi_connect(ssid, strlen(ssid), M2M_WIFI_SEC_WPA_PSK, (void *) password, 0) != M2M_SUCCESS) {\n\t\t\tprintf(\"Connection to AP failed\n\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (m2m_wifi_default_connect() != M2M_SUCCESS) {\n\t\t\tprintf(\"Connection to AP failed\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "CodeBleu_score": 48.677227331820276}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\n        uri: \"https://api.spacex.land/graphql/\"\n    });\n\n    const query = gql`\n        query {\n            launchesPast(limit: 100) {\n                mission_name\n                rocket {\n                    second_stage {\n                        payloads {\n                            payload_type\n                            customers\n                            payload_mass_kg\n                            payload_mass_lbs\n                        }\n                    }\n                }\n                launch_site {\n                    site_name_long\n                }\n                launch_success\n            }\n        }\n    `;\n\n    const response = await client.query({ query });\n\n    console.log(response);\n\n    if (response.data.launchesPast.length > 0) {\n        console.log(\"Retrieved \" + response.data.launchesPast.length + \" launches\");\n\n        for (const launch of response.data.launchesPast) {\n            const payload = launch.rocket.second_stage.payloads[0];\n\n            if (payload.payload_type === \"Satellite\") {\n                const marker = new google.maps.Marker({\n                    position: { lat: launch.launch_site.site_name_long.split(\",\")[0], lng: launch.launch_site.site_name_long.split(\",\")[1] },\n                    map: map,\n                    title: payload.customers[0],\n                    icon: {\n                        url: \"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Satellite_icon.svg/200px-Satellite_icon.svg.png\",\n                        scaledSize: new google.maps.Size(30, 30),\n                        origin: new google.maps.Point(0, 0),\n                        anchor: new google.maps.Point(15, 15)\n                    }\n                });\n\n                const infowindow = new google.maps.InfoWindow({\n                    content: \"<h4>\" + payload.customers[0] + \"</h4>\" +", "CodeBleu_score": 30.907781630793774}, {"code": "async function DisplaySensors(map){\n\t// Create a GraphQL client\n  const client = new GraphQLClient(\n    \"https://api.spacexdata.com/v3/graphql\",\n    {\n      headers: {\n        authorization: \"Bearer 5b849292-799c-413f-997c-710411c475e6\"\n      }\n    }\n  );\n\n  // Create a GraphQL query\n  const query = gql`\n    query {\n      sensors {\n        id\n        name\n        status\n        longitude\n        latitude\n        norad_id\n      }\n    }\n  `;\n\n  // Send the query to the server\n  const response = await client.request(query);\n\n  // If the response contains data, log the retrieval of sensors\n  if (response.sensors) {\n    console.log(\"Sensors retrieved\");\n\n    // Iterate through each sensor to create a marker\n    response.sensors.forEach(sensor => {\n      // Create a marker\n      const marker = new google.maps.Marker({\n        position: { lat: sensor.latitude, lng: sensor.longitude },\n        map: map,\n        title: sensor.name,\n        icon: {\n          url: \"https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.spacex.com%2Fsites%2Fspacex%2Ffiles%2Fstyles%2Flarge%2Fpublic%2Fthumbnails%2Fspacex-logo-1.png&psig=AOvVaw1wvJ7Yn9L2gd2k3wYn57X4u&ust=1617395742859000&source=images&cd=vfe&ved=0CAIQjRxqFwoTCIjLj8r-v-OgCFQAAAAAdAAAAABAD\",\n          scaledSize: new google.maps.Size(30, 30),\n          origin: new google.maps.Point(0, 0),\n          anchor: new", "CodeBleu_score": 34.61935401689667}, {"code": "async function DisplaySensors(map){\n\tconst client = new ApolloClient({\n    uri: 'https://api.graph.cool/simple/v1/cj94gkq8709450186vv99156f',\n  });\n  const query = gql`\n    query {\n      Sensors {\n        id\n        name\n        location {\n          latitude\n          longitude\n        }\n      }\n    }\n  `;\n  const response = await client.query({ query });\n  if (response.data.Sensors) {\n    console.log('Sensors retrieved successfully');\n    response.data.Sensors.forEach((sensor) => {\n      const marker = new google.maps.Marker({\n        position: { lat: sensor.location.latitude, lng: sensor.location.longitude },\n        map: map,\n        title: sensor.name,\n        label: { text: sensor.name, color: 'black', fontSize: '12px' },\n      });\n      marker.addListener('click', () => {\n        const infoWindow = new google.maps.InfoWindow({\n          content: `<h3>${sensor.name}</h3><p>${sensor.id}</p>`,\n        });\n        infoWindow.open(map, marker);\n      });\n    });\n  }\n}", "CodeBleu_score": 35.01468718364041}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'sensor-marker';\n    marker.style.border = '2px solid';\n    marker.style.borderColor = 'black';\n    marker.style.borderRadius = '50%';\n    marker.style.width = '10px';\n    marker.style.height = '10px';\n    marker.style.backgroundColor = sensor.color;\n    return marker;\n}", "CodeBleu_score": 46.691988768386175}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.classList.add('sensor-marker');\n    marker.style.color = 'red';\n    marker.style.border = '1px solid red';\n    return marker;\n}", "CodeBleu_score": 42.386727951315564}, {"code": "const CreateSensorMarker = (sensor) =>{\n\tconst marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.classList.add(\"sensor-marker\");\n    marker.style.backgroundColor = \"rgba(255, 255, 255, 0.5)\";\n    marker.style.border = \"1px solid rgba(255, 255, 255, 0.5)\";\n    return marker;\n}", "CodeBleu_score": 45.97036991399975}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    if module_name in hass.config.skip_pip or module_name in hass.config.skip_pip_requirements:\n        _LOGGER.debug(\"Skipping MFA module %s\", module_name)\n        return importlib.import_module(module_path)\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\n            \"Failed to import MFA module %s: %s\", module_name, err\n        )\n        raise\n    if not hasattr(module, \"async_setup_mfa\"):\n        _LOGGER.error(\n            \"MFA module %s does not implement async_setup_mfa()\", module_name\n        )\n        raise\n    if not hasattr(module, \"async_setup_entry\"):\n        _LOGGER.error(\n            \"MFA module %s does not implement async_setup_entry()\", module_name\n        )\n        raise\n    if not hasattr(module, \"async_unload_entry\"):\n        _LOGGER.error(\n            \"MFA module %s does not implement async_unload_entry()\", module_name\n        )\n        raise\n    if not hasattr(module, \"async_remove_entry\"):\n        _LOGGER.error(\n            \"MFA module %s does not implement async_remove_entry()\", module_name\n        )\n        raise\n    if not hasattr(module, \"async_migrate_entry\"):\n        _LOGGER.error(\n            \"MFA module %s does not implement async_migrate_entry()\", module_name\n        )\n        raise\n    if not hasattr(module, \"async_get_or_create_entry\"):\n        _LOGGER.error(\n            \"MFA module %s does not implement async_get_or_create_entry()\", module_name\n        )\n        raise\n    if not hasattr(module, \"async_get_entry\"):\n        _LOGGER.error(\n            \"MFA module %s does not implement async_", "CodeBleu_score": 32.065307368631544}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\tmodule_path = f\"homeassistant.components.{module_name}\"\n    module = None\n    try:\n        module = importlib.import_module(module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Unable to load MFA module %s\", module_name)\n    else:\n        if hasattr(module, \"PLATFORM\"):\n            _LOGGER.debug(\"MFA module %s loaded\", module_name)\n        else:\n            _LOGGER.warning(\"MFA module %s does not contain PLATFORM constant\", module_name)\n    return module\n\n", "CodeBleu_score": 25.565524018283003}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n\timport importlib\n    import os\n    import sys\n    import site\n    import tempfile\n    import zipfile\n    from importlib.abc import MetaPathFinder\n    from importlib.util import spec_from_file_location\n    from pathlib import Path\n    from types import ModuleType\n    from typing import Any\n    from typing import Dict\n    from typing import List\n    from typing import Optional\n    from typing import Tuple\n    from typing import Union\n\n    if module_name in sys.modules:\n        return sys.modules[module_name]\n    if module_name in sys.builtin_module_names:\n        raise ModuleNotFoundError(f\"{module_name} is a built-in module\", name=module_name)\n    if module_name in sys.meta_path:\n        raise ModuleNotFoundError(f\"{module_name} is a meta-path module\", name=module_name)\n    if module_name in sys.path:\n        raise ModuleNotFoundError(f\"{module_name} is a path module\", name=module_name)\n    if module_name in sys.path_hooks:\n        raise ModuleNotFoundError(f\"{module_name} is a path hook module\", name=module_name)\n    if module_name in sys.path_importer_cache:\n        raise ModuleNotFoundError(f\"{module_name} is a path importer module\", name=module_name)\n    if module_name in sys.path_importer_caches:\n        raise ModuleNotFoundError(f\"{module_name} is a path importer cache module\", name=module_name)\n    if module_name in sys.path_importer_cache_stats:\n        raise ModuleNotFoundError(f\"{module_name} is a path importer cache stats module\", name=module_name)\n    if module_name in sys.path_importer_cache_stats_by_path:\n        raise ModuleNotFoundError(f\"{module_name} is a path importer cache stats by path module\", name=module_name)\n    if module_name in sys.path_hooks_by_path:\n        raise ModuleNotFoundError(f\"{module_name} is a path hook", "CodeBleu_score": 19.561644014842223}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    if user_id in self.data:\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return True\n\n", "CodeBleu_score": 36.29723751615515}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\tpin = setup_data[\"pin\"]\n    if user_id in self.data:\n        self.data[user_id] = pin\n        return True\n    else:\n        self.data[user_id] = pin\n        return False\n\n", "CodeBleu_score": 34.74070105546075}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n\t# Check if the user already has an entry in the internal data list\n    if user_id in self.user_data:\n        # If the user already has an entry in the internal data list, update the PIN\n        self.user_data[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        # If the user does not have an entry in the internal data list, add a new entry with the user ID and PIN to the data list\n        self.user_data[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n    return \"User setup successful\"\n\n", "CodeBleu_score": 36.18836645216052}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n\tasync with self._lock:\n        if self._data is not None:\n            return\n\n        data = await self._store.async_load()\n\n        if data is None:\n            data = {}\n\n        self._data = data\n\n        for user_id, user_data in data.items():\n            if user_id not in self._users:\n                self._users[user_id] = User(self, user_id)\n\n            self._users[user_id]._update_data(user_data)\n\n", "CodeBleu_score": 37.376037253829296}, {"code": "async def _async_load(self) -> None\n\tasync with self._store_lock:\n        if self._user_settings is not None:\n            return\n\n        if not (data := await self._store.async_load()):\n            self._user_settings = {}\n            return\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                data[user_id][\"enabled\"],\n                data[user_id][\"send_me\"],\n                data[user_id][\"send_xiaomi\"],\n                data[user_id][\"send_xiaomi_local\"],\n                data[user_id][\"send_xiaomi_cloud\"],\n                data[user_id][\"send_xiaomi_cloud_local\"],\n                data[user_id][\"send_xiaomi_cloud_remote\"],\n                data[user_id][\"send_xiaomi_cloud_remote_local\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_local\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_local\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_remote\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_remote_local\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_remote_remote\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_remote_remote_local\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_remote_remote_remote\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_remote_remote_remote_local\"],\n                data[user_id][\"send_xiaomi_cloud_remote_remote_remote_remote_remote_remote_remote\"],\n                data[user_id]", "CodeBleu_score": 26.290338546923696}, {"code": "async def _async_load(self) -> None\n\tif self._initialized:\n        return\n    async with self._lock:\n        if self._initialized:\n            return\n        if not (data := await self._store.async_load()):\n            data = {}\n        self._data = data\n        self._initialized = True\n\n", "CodeBleu_score": 24.676414574790194}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t# Ensure user settings are loaded\n    await self.async_get_user(user_id)\n    # Retrieve notification settings for the specified user\n    user_settings = self.get_user_settings(user_id)\n    # If no settings are found for the user, it returns False\n    if user_settings is None:\n        return False\n    # Validate the user input by verifying the OTP using an executor job\n    if user_settings.otp_secret is None:\n        return False\n    try:\n        totp = pyotp.TOTP(user_settings.otp_secret)\n        return totp.verify(user_input[\"otp\"])\n    except pyotp.exceptions.TOTPError:\n        return False\n\n", "CodeBleu_score": 50.48082447429041}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\tuser_settings = await self._async_get_user_settings(user_id)\n    if user_settings is None:\n        return False\n    notification_settings = await self._async_get_notification_settings(user_id)\n    if notification_settings is None:\n        return False\n    return await self._async_validate_user_input(\n        user_input, user_settings, notification_settings\n    )\n\n", "CodeBleu_score": 50.11823080430082}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n\t# Ensure user settings are loaded\n    await self.async_get_user(user_id)\n    # Retrieve notification settings for the specified user\n    settings = await self.async_get_user_settings(user_id)\n    if not settings:\n        return False\n    # Validate the user input\n    return await self._validate_input(user_input, settings)\n\n", "CodeBleu_score": 38.262234300504346}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.entities.get(entity_id)\n    if entity is None:\n        return None\n    device_id = entity.device\n    device = perm_lookup.devices.get(device_id)\n    if device is None:\n        return None\n    area_id = device.area\n    if area_id is None:\n        return None\n    area = area_dict.get(area_id)\n    if area is None:\n        return None\n    return area.permissions\n\n", "CodeBleu_score": 58.828473449641926}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n    area = perm_lookup.get_area(device.area_id)\n    if area is None:\n        return None\n    return area_dict.get(area.id)\n\n", "CodeBleu_score": 57.394685229075215}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\tentity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n\n    device = perm_lookup.get_device(entity.device_id)\n    if device is None:\n        return None\n\n    area_id = device.area_id\n    if area_id is None:\n        return None\n\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 53.241374078923066}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tpolicy: PolicyType = None\n    seen: set[str] = set()\n    for policy_dict in policies:\n        if policy is None:\n            policy = cast(PolicyType, {})\n\n        assert isinstance(policy, dict)\n\n        for category in policy_dict:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            category_sources = [src.get(category) for src in policies]\n\n            policy[category] = _merge_policies(category_sources)\n\n    return policy\n\n", "CodeBleu_score": 57.29323203503951}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\tif not policies:\n        return {}\n\n    policy: PolicyType = {}\n    seen: set[str] = set()\n    for policy_dict in policies:\n        for category in policy_dict:\n            if category in seen:\n                continue\n            seen.add(category)\n            policy[category] = _merge_policies([policy_dict.get(category), policy.get(category)])\n\n    return policy\n\n", "CodeBleu_score": 58.52488131632175}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n\t# pylint: disable=too-many-branches\n\n    if not policies:\n        return None\n\n    policy: PolicyType = None\n    seen: set[str] = set()\n    for policy_dict in policies:\n        if policy_dict is None:\n            continue\n\n        assert isinstance(policy_dict, dict)\n\n        for category in policy_dict:\n            if category in seen:\n                continue\n            seen.add(category)\n\n            if policy is None:\n                policy = cast(PolicyType, {})\n\n            assert isinstance(policy, dict)\n\n            policy[category] = _merge_policies([policy_dict.get(category), policy.get(category)])\n\n    return policy\n\n", "CodeBleu_score": 51.897006632729116}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        return await hass.async_add_executor_job(importlib.import_module, f\"homeassistant.auth.providers.{provider}\")\n    except (ImportError, ModuleNotFoundError) as ex:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\", provider, ex\n        )\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {ex}\"\n        ) from ex\n\n", "CodeBleu_score": 27.593809462741643}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        module = await hass.async_add_executor_job(\n            _load_auth_provider_module, provider\n        )\n    except HomeAssistantError:\n        raise\n    except Exception:\n        _LOGGER.exception(\"Error loading auth provider %s\", provider)\n        raise HomeAssistantError(f\"Error loading auth provider {provider}\")\n\n    if module is None:\n        return None\n\n    if not module.STORAGE_VERSION:\n        raise HomeAssistantError(f\"Auth provider {provider} has no STORAGE_VERSION\")\n\n    if module.STORAGE_VERSION not in AUTH_PROVIDER_SCHEMAS:\n        raise HomeAssistantError(\n            f\"Auth provider {provider} has unknown STORAGE_VERSION {module.STORAGE_VERSION}\"\n        )\n\n    if module.STORAGE_VERSION != AUTH_PROVIDER_SCHEMAS[module.STORAGE_VERSION]:\n        _LOGGER.warning(\n            \"Auth provider %s has STORAGE_VERSION %s, but the expected version is %s\",\n            provider,\n            module.STORAGE_VERSION,\n            AUTH_PROVIDER_SCHEMAS[module.STORAGE_VERSION],\n        )\n\n    if module.REQUIREMENTS:\n        await process_requirements(hass, module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 31.816981706397208}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n\ttry:\n        return await hass.async_add_executor_job(_load_auth_provider_module, provider)\n    except (ImportError, ModuleNotFoundError) as err:\n        _LOGGER.error(\"Unable to import auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n\n", "CodeBleu_score": 29.42235197720531}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}, {"code": "async def async_load(self) -> None\n\tif (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data\n\n", "CodeBleu_score": 94.95289363431134}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\t# Normalize the username\n    username = username.lower()\n\n    # Initialize a dummy hash\n    dummy_hash = bcrypt.hashpw(b'a', bcrypt.gensalt())\n\n    # Iterate through all users\n    for user in self.users:\n        # If the username matches, we have a match\n        if user['username'] == username:\n            # Decode the stored password hash\n            stored_hash = base64.b64decode(user['password'])\n\n            # Perform a timing-safe check\n            if bcrypt.hashpw(password.encode(), stored_hash) != stored_hash:\n                # If the passwords do not match, raise an \"InvalidAuth\" exception\n                raise InvalidAuth()\n\n            # If the passwords match, return\n            return\n\n    # If no matching user is found, perform a dummy hash check\n    if bcrypt.hashpw(password.encode(), dummy_hash) != dummy_hash:\n        # If the passwords do not match, raise an \"InvalidAuth\" exception\n        raise InvalidAuth()\n\n    # If the passwords match, return\n    return\n\n", "CodeBleu_score": 46.30980950130855}, {"code": "def validate_login(self, username: str, password: str) -> None\n\tusername = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            stored_hash = user[\"password\"]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n            else:\n                raise InvalidAuth()\n    if bcrypt.checkpw(dummy_hash, stored_hash):\n        raise InvalidAuth()\n\n", "CodeBleu_score": 36.226430621534114}, {"code": "def validate_login(self, username: str, password: str) -> None\n\t# Normalize the username\n    username = username.lower()\n    # Initialize the dummy hash\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt())\n    # Iterate through all users\n    for user in self.users:\n        # If a matching username is found, continue\n        if user[\"username\"] == username:\n            # Decode the stored password hash\n            stored_hash = bcrypt.hashpw(password.encode(), user[\"salt\"])\n            # If the passwords do not match, raise an exception\n            if stored_hash != user[\"hash\"]:\n                raise InvalidAuth\n            # If the passwords match, return\n            return\n    # If no matching username is found, raise an exception\n    raise InvalidAuth\n\n", "CodeBleu_score": 39.65911416891442}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n\tusername = normalize(username)\n    for user in self._users:\n        if user.username == username:\n            self._users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 26.404931373302702}, {"code": "def async_remove_auth(self, username: str) -> None\n\ttry:\n        username = username.lower()\n        for i in range(len(self.users)):\n            if self.users[i][0] == username:\n                del self.users[i]\n                return\n        raise InvalidUser(message=\"user_not_found\")\n    except Exception as e:\n        raise e\n\n", "CodeBleu_score": 38.91988427498575}, {"code": "def async_remove_auth(self, username: str) -> None\n\ttry:\n        self.users.remove(self.normalize_username(username))\n    except ValueError:\n        raise InvalidUser(message=\"user_not_found\")\n\n", "CodeBleu_score": 20.248553766725635}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        self._data = self._ConfigStore(self.hass).async_load()\n    if self._data is None:\n        self._data = {}\n    if credentials.username in self._data:\n        del self._data[credentials.username]\n        await self._store.async_save(self._data)\n\n", "CodeBleu_score": 45.21031030934108}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n    if credentials.username in self._data:\n        del self._data[credentials.username]\n    await self._store.async_save(self._data)\n\n", "CodeBleu_score": 47.361121437206485}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n\tif self._data is None:\n        self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n    if credentials.username in self._data:\n        del self._data[credentials.username]\n    await self._store.async_save(self._data)\n\n", "CodeBleu_score": 47.361121437206485}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined_threads = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if not thread.ident:\n            joined_threads.add(thread)\n            continue\n        thread_timeout = timeout - time.time()\n        if thread_timeout <= 0:\n            joined_threads.add(thread)\n            continue\n        try:\n            thread.join(thread_timeout)\n        except ValueError:\n            joined_threads.add(thread)\n            continue\n        except RuntimeError:\n            joined_threads.add(thread)\n            continue\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n        thread.raise_exception()\n        joined_threads.add(thread)\n    return joined_threads\n\n", "CodeBleu_score": 45.417492494028735}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tjoined_threads: set[Thread] = set()\n    timeout_remaining: float = timeout\n    for thread in threads:\n        if not thread.is_alive():\n            joined_threads.add(thread)\n            continue\n        if not thread.ident:\n            joined_threads.add(thread)\n            continue\n        timeout_remaining_thread: float = timeout_remaining\n        if log:\n            thread_name: str = thread.name\n            thread_ident: int = thread.ident\n            _log_thread_running_at_shutdown(thread_name, thread_ident)\n        thread.join(timeout_remaining_thread)\n        if not thread.is_alive():\n            joined_threads.add(thread)\n        timeout_remaining = timeout_remaining - thread.join(timeout_remaining)\n    if log:\n        if not joined_threads:\n            _LOGGER.warning(\"No threads were joined.\")\n        else:\n            _LOGGER.warning(\"The following threads were joined: %s\", \", \".join(str(t) for t in joined_threads))\n    if timeout_remaining < 0:\n        _LOGGER.warning(\"Threads were still running after the timeout.\")\n        for thread in threads:\n            if thread.is_alive():\n                thread.interrupt()\n    return joined_threads\n\n", "CodeBleu_score": 40.240347148583965}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\tif log:\n        _LOGGER.debug(\"Waiting for %s threads to complete\", len(threads))\n    joined_threads = set()\n    for thread in threads:\n        if thread.ident is None:\n            joined_threads.add(thread)\n            continue\n        if log:\n            _LOGGER.debug(\"Waiting for thread[%s] to complete\", thread.name)\n        try:\n            thread.join(timeout=timeout)\n        except Exception:\n            _LOGGER.exception(\"Failed to join thread[%s]\", thread.name)\n        else:\n            if thread.is_alive():\n                if log:\n                    _log_thread_running_at_shutdown(thread.name, thread.ident)\n                try:\n                    thread.interrupt()\n                except Exception:\n                    _LOGGER.exception(\n                        \"Failed to interrupt thread[%s]\", thread.name\n                    )\n            joined_threads.add(thread)\n    if log:\n        _LOGGER.debug(\"Joined %s threads\", len(joined_threads))\n    return joined_threads\n\n", "CodeBleu_score": 50.29371283821711}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n\timport sys\n    import threading\n    import time\n\n    def _deadlock_safe_shutdown(timeout: float, thread: threading.Thread) -> None:\n        \"\"\"The function \"deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.", "CodeBleu_score": 7.318381377928067}, {"code": "def deadlock_safe_shutdown() -> None\n\tthreads = []\n    for thread in threading.enumerate():\n        if thread.name != \"MainThread\" and thread.daemon == False and thread.is_alive():\n            threads.append(thread)\n    if len(threads) > 0:\n        timeout = config.shutdown_timeout / len(threads)\n        for thread in threads:\n            try:\n                thread.join(timeout)\n            except Exception:\n                logging.warning(f\"Failed to join thread {thread.name}\")\n        for thread in threads:\n            if thread.is_alive():\n                logging.warning(f\"Thread {thread.name} failed to shutdown within {timeout} seconds\")\n    logging.info(\"Shutdown complete\")\n\n", "CodeBleu_score": 30.389480630024273}, {"code": "def deadlock_safe_shutdown() -> None\n\tif not is_shutdown_in_progress():\n        threads = get_non_main_threads()\n        if len(threads) > 0:\n            timeout = get_shutdown_timeout()\n            for thread in threads:\n                if not thread.is_alive():\n                    continue\n                thread_timeout = timeout / len(threads)\n                try:\n                    thread.join(thread_timeout)\n                except Exception as e:\n                    log_warning(f\"Failed to join thread {thread} with exception {e}\")\n\n", "CodeBleu_score": 32.789574759162}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif self.remaining_setups:\n        if self.remaining_setups_started:\n            self.remaining_setups_started = {k: v for k, v in self.remaining_setups_started.items() if v}\n            if self.remaining_setups_started:\n                self.dispatch(\n                    signal=self.DISPATCH_SIGNAL_INTERNAL_DISPATCHER,\n                    remaining_setups=self.remaining_setups_started,\n                )\n        else:\n            self.dispatch(\n                signal=self.DISPATCH_SIGNAL_INTERNAL_DISPATCHER,\n                remaining_setups=self.remaining_setups,\n            )\n        self.remaining_setups_started = remaining_with_setup_started\n\n\n def _dispatch(self, signal: str, **kwargs: Any) -> None:\n    \"\"\"The function \"_dispatch\" dispatches a signal.\"\"\"\n    if signal in self.dispatch_signals:\n        self.dispatch_signals[signal](**kwargs)\n    else:\n        raise Exception(f\"Signal {signal} is not registered.\")\n\n\n def _dispatch_internal_dispatcher(self, remaining_setups: dict[str, float]) -> None:\n    \"\"\"The function \"_dispatch_internal_dispatcher\" dispatches a signal to the internal dispatcher.\"\"\"\n    self._dispatch(\n        signal=self.DISPATCH_SIGNAL_INTERNAL_DISPATCHER,\n        remaining_setups=remaining_setups,\n    )\n\n\n def _dispatch_setup_finished(self, setup_name: str, setup_time: float) -> None:\n    \"\"\"The function \"_dispatch_setup_finished\" dispatches a signal to the setup finished signal.\"\"\"\n    self._dispatch(\n        signal=self.DISPATCH_SIGNAL_SETUP_FINISHED,\n        setup_name=setup_name,\n        setup_time=setup_time,\n    )\n\n\n def _dispatch_setup_started(self, setup_name: str) -> None:\n    \"\"\"The function", "CodeBleu_score": 43.698542471781145}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif self._remaining_setups or remaining_with_setup_started:\n        self._dispatcher.send(\n            signal=self._signal_name,\n            sender=self,\n            remaining_setups=remaining_with_setup_started,\n        )\n        self._remaining_setups = remaining_with_setup_started\n\n\n def _dispatch(self, remaining_setups: dict[str, float]) -> None:\n    \"\"\"The function \"_dispatch\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 47.736340529608675}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n\tif self._remaining_setups:\n        if self._remaining_setups_started:\n            if remaining_with_setup_started:\n                self._remaining_setups_started = remaining_with_setup_started\n            self._dispatcher.dispatch(\n                signal=Signal.INTERNAL_DISPATCHER,\n                data=self._remaining_setups_started\n            )\n        else:\n            if remaining_with_setup_started:\n                self._remaining_setups_started = remaining_with_setup_started\n            self._dispatcher.dispatch(\n                signal=Signal.INTERNAL_DISPATCHER,\n                data=self._remaining_setups\n            )\n        self._remaining_setups = self._remaining_setups_started\n        self._remaining_setups_started = {}\n\n\n def _async_dispatch_setup_started(self, setup_name: str, setup_started: float) -> None:\n    \"\"\"The function \"_async_dispatch_setup_started\" dispatches a signal based on the state of remaining setups.", "CodeBleu_score": 39.57430547889081}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tif config.cache.get(\"bluetooth\") == generate_and_validate(integrations):\n        return\n\n    if config.cache.get(\"bluetooth\") is not None:\n        raise ConfigError(\n            \"Your bluetooth.py file is out of date. Run `hass-cli validate bluetooth` to fix it.\"\n        )\n\n    raise ConfigError(\n        \"Your bluetooth.py file is out of date. Run `hass-cli validate bluetooth` to fix it.\"\n    )\n\n", "CodeBleu_score": 29.624053380881698}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tgenerated = generate_and_validate(integrations)\n\n    if config.cache.get(\"bluetooth\") == generated:\n        return\n\n    if not config.cache.get(\"bluetooth\"):\n        raise HomeAssistantError(\n            \"Generated bluetooth.py is not up to date. Run `hass --script update_bluetooth` to fix this.\"\n        )\n\n    raise HomeAssistantError(\n        \"Generated bluetooth.py is not up to date. Run `hass --script update_bluetooth` to fix this.\"\n    )\n\n", "CodeBleu_score": 37.378419804266436}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\tbluetooth_path = config.path.joinpath(\"bluetooth.py\")\n    bluetooth_content = bluetooth_path.read_text()\n\n    if not config.cache.get(\"bluetooth\"):\n        config.cache[\"bluetooth\"] = generate_and_validate(integrations)\n\n    if config.cache[\"bluetooth\"] == bluetooth_content:\n        return\n\n    config.add_error(\n        \"bluetooth.py is not up to date. Please run `hassfest generate bluetooth` to update it.\",\n        fixable=True,\n        fix=fix_bluetooth,\n    )\n\n", "CodeBleu_score": 47.92728167428376}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error{\n\t// Create a new HTTP client.\n\tclient := &http.Client{}\n\n\t// Create a new POST request.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the headers.\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.appKey+\":\"+d.appSecret)))\n\n\t// Create the form.\n\tform := url.Values{}\n\tform.Add(\"grant_type\", \"refresh_token\")\n\tform.Add(\"refresh_token\", d.refreshToken)\n\n\t// Set the body.\n\treq.Body = ioutil.NopCloser(strings.NewReader(form.Encode()))\n\n\t// Send the request.\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Defer closing the response.\n\tdefer resp.Body.Close()\n\n\t// Read the response body.\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Unmarshal the response body.\n\tvar response map[string]interface{}\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check for errors.\n\tif response[\"error\"] != nil {\n\t\t// Log the error.\n\t\tlog.Println(response[\"error\"])\n\t\treturn errors.New(\"Error refreshing token: \" + response[\"error\"].(string))\n\t}\n\n\t// Check for an access token.\n\tif response[\"access_token\"] == nil {\n\t\t// Log the error.\n\t\tlog.Println(\"No access token.\")\n\t\treturn errors.New(\"No access token.\")\n\t}\n\n\t// Set the access token.\n\td.accessToken = response[\"", "CodeBleu_score": 46.71106136486094}, {"code": "func (d *Dropbox) refreshToken() error{\n\t// Create the URL.\n\turl := \"https://api.dropboxapi.com/2/auth/token\"\n\n\t// Create the request body.\n\tbody := &bytes.Buffer{}\n\twriter := multipart.NewWriter(body)\n\twriter.WriteField(\"grant_type\", \"refresh_token\")\n\twriter.WriteField(\"refresh_token\", d.refreshToken)\n\twriter.WriteField(\"client_id\", d.appKey)\n\twriter.WriteField(\"client_secret\", d.appSecret)\n\twriter.Close()\n\n\t// Create the request.\n\trequest, err := http.NewRequest(\"POST\", url, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\trequest.Header.Set(\"Content-Type\", writer.FormDataContentType())\n\n\t// Send the request.\n\tresponse, err := d.client.Do(request)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer response.Body.Close()\n\n\t// Read the response.\n\tresponseBody, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Parse the response.\n\tvar responseJSON map[string]interface{}\n\terr = json.Unmarshal(responseBody, &responseJSON)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the response is an error.\n\tif responseJSON[\"error\"] != nil {\n\t\treturn errors.New(fmt.Sprintf(\"Error: %s\", responseJSON[\"error\"]))\n\t}\n\n\t// Update the access token.\n\td.accessToken = responseJSON[\"access_token\"].(string)\n\td.expires = time.Now().Add(time.Duration(responseJSON[\"expires_in\"].(float64)) * time.Second)\n\treturn nil\n}", "CodeBleu_score": 47.40616821083323}, {"code": "func (d *Dropbox) refreshToken() error{\n\t// Create the request\n\trequest, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set the headers\n\trequest.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t// Set the body\n\trequest.Body = ioutil.NopCloser(strings.NewReader(fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s&client_id=%s&client_secret=%s\", d.RefreshToken, d.AppKey, d.AppSecret)))\n\t// Send the request\n\tresponse, err := d.Client.Do(request)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check the status code\n\tif response.StatusCode != http.StatusOK {\n\t\t// Read the response\n\t\tbody, err := ioutil.ReadAll(response.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Close the response\n\t\tresponse.Body.Close()\n\t\t// Log the response\n\t\tlog.Printf(\"Failed to refresh token: %s", "CodeBleu_score": 49.00281057122092}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar err error\n\tvar body []byte\n\n\t// set the request callback\n\tif callback != nil {\n\t\tcallback(d.client)\n\t}\n\n\t// set the request parameters\n\td.client.SetHeader(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\td.client.SetHeader(\"GData-Version\", \"3.0\")\n\td.client.SetHeader(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\n\t// make the request\n\tbody, err = d.client.Request(url, method, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// set the response structure\n\tif resp != nil {\n\t\terr = json.Unmarshal(body, &resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 45.20336406593686}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tif d.auth.Token == nil {\n\t\treturn nil, errors.New(\"no access token\")\n\t}\n\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Add(\"Authorization\", \"Bearer \"+d.auth.Token.AccessToken)\n\treq.Header.Add(\"GData-Version\", \"3.0\")\n\treq.Header.Add(\"X-GData-Key\", \"key=\"+d.auth.Key)\n\treq.Header.Add(\"X-GData-Key\", \"type=\"+d.auth.Type)\n\treq.Header.Add(\"X-GData-Key\", \"email=\"+d.auth.Email)\n\treq.Header.Add(\"X-GData-Key\", \"documentId=\"+d.auth.DocumentId)\n\treq.Header.Add(\"X-GData-Key\", \"clientId=\"+d.auth.ClientId)\n\treq.Header.Add(\"X-GData-Key\", \"appName=\"+d.auth.AppName)\n\treq.Header.Add(\"X-GData-Key\", \"appVersion=\"+d.auth.AppVersion)\n\treq.Header.Add(\"X-GData-Key\", \"scope=\"+d.auth.Scope)\n\treq.Header.Add(\"X-GData-Key\", \"expirationDate=\"+d.auth.ExpirationDate)\n\treq.Header.Add(\"X-GData-Key\", \"userId=\"+d.auth.UserId)\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tresp, err = d.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode == 401 {\n\t\terr = d.refreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresp, err", "CodeBleu_score": 52.12054004250882}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error){\n\tvar err error\n\tvar body []byte\n\n\tif d.auth.AccessToken == \"\" {\n\t\treturn nil, errors.New(\"no access token\")\n\t}\n\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\treq.Header.Add(\"Authorization\", \"Bearer \"+d.auth.AccessToken)\n\treq.Header.Add(\"GData-Version\", \"3.0\")\n\n\tclient := &http.Client{}\n\n\t// Retry request if access token has expired\n\tfor i := 0; i < 3; i++ {\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif resp.StatusCode == 401 {\n\t\t\t// Refresh access token\n\t\t\terr = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Retry request\n\t\t\tcontinue\n\t\t}\n\n\t\tbody, err = ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif resp.StatusCode != 200 {\n\t\t\treturn nil, errors.New(string(body))\n\t\t}\n\n\t\tbreak\n\t}\n\n\tif resp != nil {\n\t\terr = json.Unmarshal(body, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 56.63825388381654}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\tvar (\n\t\terr error\n\t\treq *http.Request\n\t\tres *http.Response\n\t\tbuf []byte\n\t)\n\n\t// Create a new HTTP request\n\tif req, err = http.NewRequest(\"POST\", url, stream); err != nil {\n\t\treturn err\n\t}\n\n\t// Set the content type\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\t// Set the content length\n\treq.ContentLength = stream.Len()\n\n\t// Set the content range\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", stream.Len()-1, stream.Len()))\n\n\t// Set the upload type\n\treq.Header.Set(\"X-Upload-Content-Type\", stream.ContentType())\n\n\t// Set the upload protocol\n\treq.Header.Set(\"X-Upload-Protocol\", \"raw\")\n\n\t// Set the authorization header\n\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", d.token))\n\n\t// Set the accept header\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\t// Set the content length header\n\treq.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", stream.Len()))\n\n\t// Set the accept encoding header\n\treq.Header.Set(\"Accept-Encoding\", \"gzip, deflate\")\n\n\t// Set the user agent header\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.101 Safari/537.36\")\n\n\t// Set the content transfer encoding header\n\treq.Header.Set(\"Content-Transfer-Encoding\", \"binary\")\n\n\t// Set the connection header\n\treq.Header.Set(\"Connection\", \"Keep-Alive\")\n\n\t// Set the te header\n\treq.Header.Set(\"TE\", \"trailers\")\n\n\t// Set the trailer header\n\treq", "CodeBleu_score": 31.81039260934827}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Get the file size\n\tsize, err := stream.Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Calculate the chunk size\n\tchunkSize := int64(d.ChunkSize)\n\tif chunkSize == 0 {\n\t\tchunkSize = size\n\t}\n\n\t// Calculate the number of chunks\n\tnumChunks := int64(math.Ceil(float64(size) / float64(chunkSize)))\n\n\t// Create the file\n\tfile, err := d.service.Files.Create(&drive.File{}).Media(stream).Do()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Upload each chunk\n\tfor i := int64(0); i < numChunks; i++ {\n\t\t// Get the chunk\n\t\tchunk, err := stream.Chunk(chunkSize, i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Upload the chunk\n\t\t_, err = d.service.Files.Update(file.Id, &drive.File{\n\t\t\tId: file.Id,\n\t\t}).Media(chunk).Do()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check for cancellation\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\t}\n\n\t// Complete the upload\n\t_, err = d.service.Files.Update(file.Id, &drive.File{\n\t\tId: file.Id,\n\t}).Media(stream).Do()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.721346473708415}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error{\n\t// Get the file size.\n\tfileSize, err := stream.Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Calculate the chunk size.\n\tchunkSize := int64(d.ChunkSize)\n\tif fileSize < chunkSize {\n\t\tchunkSize = fileSize\n\t}\n\n\t// Create a buffer for the chunk.\n\tbuffer := make([]byte, chunkSize)\n\n\t// Create a new request for the upload.\n\treq, err := http.NewRequest(\"POST\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a new file streamer.\n\tfileStreamer, err := stream.NewStreamer()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a new progress bar.\n\tprogressBar := pb.New64(fileSize).SetUnits(pb.U_BYTES)\n\tprogressBar.Start()\n\n\t// Create a new writer for the upload.\n\twriter := multipart.NewWriter(req)\n\n\t// Create a new reader for the upload.\n\treader := fileStreamer.NewReader(buffer)\n\n\t// Create a new file header.\n\tfileHeader := make(textproto.MIMEHeader)\n\tfileHeader.Set(\"Content-Type\", \"application/octet-stream\")\n\tfileHeader.Set(\"Content-Length\", strconv.FormatInt(chunkSize, 10))\n\tfileHeader.Set(\"Content-Range\", \"bytes 0-0/\"+strconv.FormatInt(fileSize, 10))\n\tfileWriter, err := writer.CreatePart(fileHeader)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a new chunk header.\n\tchunkHeader := make(textproto.MIMEHeader)\n\tchunkHeader.Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\tchunkHeader.Set(\"Content-Length\", strconv.FormatInt(int64(len(d.ChunkHeader)), 10))\n\tchunkWriter, err := writer.CreatePart(chunkHeader)\n\tif err != nil {\n\t\treturn", "CodeBleu_score": 43.92754042964489}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error{\n\tvar umountStorageRequest UmountStorageRequest\n\tvar umountStorageResponse UmountStorageResponse\n\tvar storageConfig StorageConfig\n\tvar storageConfigs []StorageConfig\n\tvar err error\n\tvar mountPoint string\n\tvar unmounted bool\n\n\t// Bind the request body to the request object.\n\tif err := ctx.Bind(&umountStorageRequest); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, Response{Status: \"failure\", Message: err.Error()})\n\t}\n\n\t// Retrieve the mount point.\n\tmountPoint = umountStorageRequest.MountPoint\n\n\t// Validate the mount point.\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, Response{Status: \"failure\", Message: \"Mount point cannot be empty.\"})\n\t}\n\n\t// Get the storage configurations.\n\tstorageConfigs, err = GetStorageConfigs()\n\n\t// Check for errors.\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, Response{Status: \"failure\", Message: err.Error()})\n\t}\n\n\t// Check if the mount point is present in the storage configurations.\n\tfor _, storageConfig = range storageConfigs {\n\t\tif storageConfig.MountPoint == mountPoint {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Check if the mount point is present in the storage configurations.\n\tif storageConfig.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, Response{Status: \"failure\", Message: \"Mount point not found.\"})\n\t}\n\n\t// Attempt to unmount the storage.\n\tunmounted, err = UnmountStorage(storageConfig.MountPoint)\n\n\t// Check for errors.\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, Response{Status: \"failure\", Message: err.Error()})\n\t}\n\n\t// Check if the storage was unmounted.\n\tif unmounted {\n\t\t// Delete the storage configuration.\n\t\terr = DeleteStorageConfig(mountPoint)\n\n\t\t// Check for errors.\n\t\tif err !=", "CodeBleu_score": 46.604607020504154}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t// Bind the data from the request body\n\tvar data UmountStorageRequest\n\tif err := ctx.Bind(&data); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\t// Retrieve the mount point\n\tmountPoint := data.MountPoint\n\t// If the mount point is empty, return an error\n\tif mountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Mount point is empty\")\n\t}\n\t// Attempt to unmount the storage\n\terr := umountStorage(mountPoint)\n\t// If unmounting fails, return a service error\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\t// Delete the configuration for the storage\n\terr = deleteStorageConfig(mountPoint)\n\t// If deleting the configuration fails, return a service error\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, UmountStorageResponse{\n\t\tMessage: \"Storage unmounted successfully\",\n\t})\n}", "CodeBleu_score": 40.77055686105123}, {"code": "func UmountStorage(ctx echo.Context) error{\n\t// Bind the request body to a JSON object.\n\tvar umountStorageReq UmountStorageRequest\n\tif err := ctx.Bind(&umountStorageReq); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Get the mount point from the request body.\n\tmountPoint := umountStorageReq.MountPoint\n\n\t// If the mount point is empty, return a client error response.\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point is empty.\")\n\t}\n\n\t// Unmount the storage at the specified mount point.\n\tif err := umountStorage(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err := deleteStorageConfig(mountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, \"Success\")\n}", "CodeBleu_score": 34.59075906134732}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"status\":  \"error\",\n\t\t\t\"message\": \"path is missing\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"status\":  \"error\",\n\t\t\t\"message\": \"file does not exist\",\n\t\t})\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"status\":  \"error\",\n\t\t\t\"message\": \"unable to open file\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\t// Get the file size\n\tfileInfo, _ := file.Stat()\n\tfileSize := fileInfo.Size()\n\n\t// Prepare the response\n\tresponse := ctx.Response()\n\tresponse.Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSON)\n\tresponse.Header().Set(echo.HeaderContentLength, strconv.FormatInt(fileSize, 10))\n\n\t// Write the file to the response\n\tif _, err := io.Copy(response, file); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"status\":  \"error\",\n\t\t\t\"message\": \"unable to write file to response\",\n\t\t})\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 42.60921061898143}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Get the file path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\t// The path is not provided\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"Missing path\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t// The file does not exist\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\n\t// Get the file content\n\tfile, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\t// Failed to read the file\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"Failed to read file\",\n\t\t})\n\t}\n\n\t// Return the file content to the client\n\treturn ctx.Blob(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 41.9162785364356}, {"code": "func GetLocalFile(ctx echo.Context) error{\n\t// Extract the file path from the query parameters.\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided.\n\tif path == \"\" {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"missing path\"})\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"file not found\"})\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\tdefer file.Close()\n\n\t// Get the file size.\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\t// Get the file contents.\n\tfileContents := make([]byte, fileInfo.Size())\n\t_, err = file.Read(fileContents)\n\tif err != nil {\n\t\t// Return a JSON response with an appropriate error message.\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\t// Return the file contents to the client.\n\treturn ctx.Blob(http.StatusOK, \"application/octet-stream\", fileContents)\n}", "CodeBleu_score": 40.208712347092145}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Get the name from the request context\n\tname := ctx.Param(\"name\")\n\n\t// Bind the request body to a message map\n\tmessage := map[string]string{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification\n\tif err := notify(name, message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.String(http.StatusOK, \"success\")\n}", "CodeBleu_score": 51.311402341511666}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif err := sendNotification(name, message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\"status\": \"success\"})\n}", "CodeBleu_score": 51.788081036576564}, {"code": "func PostNotifyMessage(ctx echo.Context) error{\n\t// Retrieve the \"name\" parameter from the request context.\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"missing name\")\n\t}\n\n\t// Bind the request body to a message map.\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Send the notification.\n\tif err := notifier.Send(name, message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\"status\": \"ok\"})\n}", "CodeBleu_score": 54.9662811146223}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error{\n\t// Upgrade the HTTP connection to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(\"Error during WebSocket upgrade:\", err)\n\t\treturn err\n\t}\n\t// Add the WebSocket connection to the list of connections.\n\tconnectionsLock.Lock()\n\tconnections = append(connections, ws)\n\tconnectionsLock.Unlock()\n\t// Start the message sending service.\n\tif !messageSendingServiceRunning {\n\t\tmessageSendingServiceRunning = true\n\t\tgo messageSendingService()\n\t}\n\t// Enter a loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read the next message.\n\t\tmessageType, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsCloseError(err, websocket.CloseNormalClosure) {\n\t\t\t\t// The client closed the connection, so remove the WebSocket connection from the list of connections.\n\t\t\t\tconnectionsLock.Lock()\n\t\t\t\tfor i, c := range connections {\n\t\t\t\t\tif c == ws {\n\t\t\t\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconnectionsLock.Unlock()\n\t\t\t} else {\n\t\t\t\tlog.Println(\"Error reading WebSocket message:\", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors.\n\t\tif messageType == websocket.TextMessage {\n\t\t\tlog.Println(\"WebSocket message:\", string(message))\n\t\t} else {\n\t\t\tlog.Println(\"WebSocket message:\", messageType, message)\n\t\t}\n\t}\n\treturn nil\n}", "CodeBleu_score": 47.59926519478065}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t// Get the WebSocket connection from the HTTP request.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service.\n\tgo sendMessage()\n\n\t// Enter the loop to continuously read messages from the WebSocket connection.\n\tfor {\n\t\t// Read the next message from the WebSocket connection.\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message.\n\t\tlog.Printf(\"Message Type: %d\", messageType)\n\t\tlog.Printf(\"Message: %s\", message)\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tfor i, c := range connections {\n\t\tif ws == c {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the WebSocket connection.\n\tws.Close()\n\n\treturn nil\n}", "CodeBleu_score": 48.60928202105343}, {"code": "func NotifyWS(ctx echo.Context) error{\n\t// Get the WebSocket connection from the HTTP request.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections.\n\tmutex.Lock()\n\tconnections = append(connections, ws)\n\tmutex.Unlock()\n\n\t// Ensure that the message sending service is running.\n\tif !sending {\n\t\tgo SendMessages()\n\t\tsending = true\n\t}\n\n\t// Enter the message receiving loop.\n\tfor {\n\t\t// Read the next message from the WebSocket connection.\n\t\tmessageType, p, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type, message, and any errors.\n\t\tlog.Printf(\"Message type: %d\n\", messageType)\n\t\tlog.Printf(\"Message: %s\n\", p)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tmutex.Lock()\n\tfor i, c := range connections {\n\t\tif c == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\tmutex.Unlock()\n\n\treturn nil\n}", "CodeBleu_score": 46.74098733937434}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get the CPU information.\n\tcpuInfo, err := cpu.Info()\n\tif err != nil {\n\t\t// If the CPU information is not available, return a nil response.\n\t\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"success\": false,\n\t\t\t\"message\": \"CPU information is not available.\",\n\t\t})\n\t}\n\n\t// Get the drive information.\n\tdriveInfo, err := disk.Usage(\"/\")\n\tif err != nil {\n\t\t// If the drive information is not available, return a nil response.\n\t\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"success\": false,\n\t\t\t\"message\": \"Drive information is not available.\",\n\t\t})\n\t}\n\n\t// Return the system hardware information as a JSON response.\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"success\": true,\n\t\t\"message\": \"System hardware information retrieved successfully.\",\n\t\t\"data\": map[string]interface{}{\n\t\t\t\"cpu\": map[string]interface{}{\n\t\t\t\t\"vendor\":  cpuInfo[0].VendorID,\n\t\t\t\t\"model\":   cpuInfo[0].ModelName,\n\t\t\t\t\"cores\":   len(cpuInfo),\n\t\t\t\t\"threads\": len(cpuInfo[0].Cores),\n\t\t\t},\n\t\t\t\"drive\": map[string]interface{}{\n\t\t\t\t\"model\": driveInfo.Fstype,\n\t\t\t\t\"size\":  driveInfo.Total,\n\t\t\t},\n\t\t},\n\t})\n}", "CodeBleu_score": 18.21810774859679}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Create a new system hardware information struct.\n\tsystemHardwareInfo := SystemHardwareInfo{}\n\n\t// Create a new system information struct.\n\tsystemInfo := SystemInfo{}\n\n\t// Create a new CPU information struct.\n\tcpuInfo := CPUInfo{}\n\n\t// Create a new CPU information struct.\n\tcpuInfo2 := CPUInfo{}\n\n\t// Create a new memory information struct.\n\tmemoryInfo := MemoryInfo{}\n\n\t// Create a new network information struct.\n\tnetworkInfo := NetworkInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo2 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo3 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo4 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo5 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo6 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo7 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo8 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo9 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo10 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo11 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo12 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo13 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo14 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo15 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo16 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo17 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo18 := DiskInfo{}\n\n\t// Create a new disk information struct.\n\tdiskInfo19 := DiskInfo{}", "CodeBleu_score": 3.6926230553710018}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error{\n\t// Get the system hardware information.\n\tsystemHardwareInfo, err := system.GetSystemHardwareInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return the system hardware information.\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}", "CodeBleu_score": 12.326355227550613}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 72.22552708282028}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 72.73581694770958}, {"code": "func (s *service) Services() (map[bool]*[]string, error){\n\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service.Name, \"casaos\") {\n\t\t\tif service.ActiveState == \"active\" {\n\t\t\t\trunning = append(running, service.Name)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 69.69445288705438}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Create a new JSON encoder.\n\tencoder := json.NewEncoder()\n\n\t// Encode the message values to JSON.\n\tjson, err := encoder.Encode(message)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to encode message values to JSON: %s\", err)\n\t\treturn\n\t}\n\n\t// Create a new request.\n\trequest := &http.Request{\n\t\tMethod: \"POST\",\n\t\tURL: &url.URL{\n\t\t\tScheme: \"http\",\n\t\t\tHost:   \"localhost:8080\",\n\t\t\tPath:   \"/notify/\" + name,\n\t\t},\n\t\tBody: ioutil.NopCloser(bytes.NewBuffer(json)),\n\t}\n\n\t// Create a new HTTP client.\n\tclient := &http.Client{}\n\n\t// Send the request.\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to send notification: %s\", err)\n\t\treturn\n\t}\n\n\t// Close the response body.\n\tdefer response.Body.Close()\n\n\t// Check the response status code.\n\tif response.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Failed to send notification: %s\", response.Status)\n\t\treturn\n\t}\n\n\t// Log a success message.\n\tlog.Printf(\"Notification sent: %s\", name)\n}", "CodeBleu_score": 37.979604807274725}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\tif i.bus == nil {\n\t\treturn\n\t}\n\tif len(message) == 0 {\n\t\treturn\n\t}\n\t// serialize message values to JSON strings\n\tdata, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"SendNotify: %v\", err)\n\t\treturn\n\t}\n\t// create a new notification\n\tn := &Notify{\n\t\tName:  name,\n\t\tData:  string(data),\n\t\tEvent: time.Now().UTC(),\n\t}\n\t// publish notification\n\tif err := i.bus.Publish(n); err != nil {\n\t\tlog.Printf(\"SendNotify: %v\", err)\n\t}\n}", "CodeBleu_score": 31.763787103538238}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}){\n\t// Create a new JSON encoder.\n\tencoder := json.NewEncoder()\n\n\t// Create a new JSON decoder.\n\tdecoder := json.NewDecoder()\n\n\t// Create a new HTTP client.\n\tclient := &http.Client{}\n\n\t// Create a new request.\n\trequest, err := http.NewRequest(\"POST\", \"http://localhost:8080/notify\", nil)\n\tif err != nil {\n\t\t// Log the error.\n\t\tlog.Println(err)\n\n\t\t// Return.\n\t\treturn\n\t}\n\n\t// Create a new JSON message.\n\tmessageJSON := map[string]interface{}{\n\t\t\"name\":   name,\n\t\t\"values\": message,\n\t}\n\n\t// Encode the message.\n\terr = encoder.Encode(messageJSON)\n\tif err != nil {\n\t\t// Log the error.\n\t\tlog.Println(err)\n\n\t\t// Return.\n\t\treturn\n\t}\n\n\t// Set the body.\n\trequest.Body = ioutil.NopCloser(bytes.NewReader(encoder.Buffer.Bytes()))\n\n\t// Set the content type.\n\trequest.Header.Set(\"Content-Type\", \"application/json\")\n\n\t// Send the request.\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\t// Log the error.\n\t\tlog.Println(err)\n\n\t\t// Return.\n\t\treturn\n\t}\n\n\t// Decode the response.\n\tvar responseJSON map[string]interface{}\n\terr = decoder.Decode(&responseJSON)\n\tif err != nil {\n\t\t// Log the error.\n\t\tlog.Println(err)\n\n\t\t// Return.\n\t\treturn\n\t}\n\n\t// Get the response status code.\n\tstatus := response.StatusCode\n\n\t// Get the response status text.\n\tstatusText := response.Status\n\n\t// Get the response body.\n\tresponseBody := responseJSON[\"body\"]\n\n\t// Get the response headers.\n\tresponseHeaders := responseJSON[\"headers\"]\n\n\t// Get the", "CodeBleu_score": 37.518777075670826}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\tc.init()\n\tif c.server != \"\" {\n\t\treturn message_bus.NewClientWithResponses(c.server)\n\t}\n\treturn message_bus.NewClientWithResponses(\"\")\n}", "CodeBleu_score": 17.947873117687312}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\treturn message_bus.NewClientWithResponses(\n\t\tc.runtimePath,\n\t\tc.logger,\n\t\tc.messageBus,\n\t\tc.messageBusResponse,\n\t)\n}", "CodeBleu_score": 12.583220936607717}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses{\n\t// Create a new message bus client\n\tbus := message_bus.NewClientWithResponses()\n\n\t// Initialize the client\n\tbus.Init()\n\n\t// Attempt to retrieve the message bus address\n\taddress, err := c.Runtime.Get(\"message_bus\")\n\n\t// If the address is found, set the client's server to the retrieved address\n\tif err == nil {\n\t\tbus.SetServer(address)\n\t} else {\n\t\t// Otherwise, set the server to a default error message\n\t\tbus.SetServer(\"Message bus not found\")\n\t}\n\n\t// Return the initialized client\n\treturn bus\n}", "CodeBleu_score": 30.41111071951981}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\treturn strings.Split(ip, \":\")[0]\n}", "CodeBleu_score": 31.763754881925983}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\treturn strings.Split(ip, \":\")[0]\n}", "CodeBleu_score": 31.763754881925983}, {"code": "func GetIP(request *http.Request) string{\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \":\") {\n\t\tip = strings.Split(ip, \":\")[0]\n\t}\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.245421648143974}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Get the path to the modules directory.\n\tmodulesPath := c.getModulesPath()\n\n\t// Get the path to the entry file.\n\tentryPath := c.getEntryPath()\n\n\t// Create a new file.\n\tfile, err := os.Create(entryPath)\n\tif err != nil {\n\t\tlog.Println(\"Error creating entry file: \" + err.Error())\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\t// Create a new JSON encoder.\n\tencoder := json.NewEncoder(file)\n\n\t// Create a new JSON array.\n\tarray := make([]map[string]interface{}, 0)\n\n\t// Get the file list.\n\tfiles, err := ioutil.ReadDir(modulesPath)\n\tif err != nil {\n\t\tlog.Println(\"Error reading directory: \" + err.Error())\n\t\treturn\n\t}\n\n\t// Iterate through each file.\n\tfor _, file := range files {\n\t\t// Get the file path.\n\t\tfilePath := path.Join(modulesPath, file.Name())\n\n\t\t// Get the entry file path.\n\t\tentryFilePath := path.Join(filePath, \"entry.json\")\n\n\t\t// Read the entry file.\n\t\tentryFile, err := os.Open(entryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading entry file: \" + err.Error())\n\t\t\treturn\n\t\t}\n\t\tdefer entryFile.Close()\n\n\t\t// Decode the entry file.\n\t\tdecoder := json.NewDecoder(entryFile)\n\n\t\t// Create a new JSON object.\n\t\tobject := make(map[string]interface{})\n\n\t\t// Decode the entry file.\n\t\terr = decoder.Decode(&object)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error decoding entry file: \" + err.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// Add the object to the array.\n\t\tarray = append(array, object)\n\t}\n\n\t// Encode the array.", "CodeBleu_score": 45.060315994936815}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\tvar (\n\t\tentryFilePath string\n\t\terr          error\n\t)\n\n\t// Check if the modules directory exists.\n\tif _, err = os.Stat(c.modulesDirectoryPath); os.IsNotExist(err) {\n\t\tc.logger.Println(\"Modules directory does not exist.\")\n\t\treturn\n\t}\n\n\t// Check if the entry file exists.\n\tif _, err = os.Stat(c.entryFilePath); os.IsNotExist(err) {\n\t\tentryFilePath = c.entryFilePath\n\t}\n\n\t// Create the entry file if it does not exist.\n\tif _, err = os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tc.logger.Println(\"Creating entry file.\")\n\t\tif err = ioutil.WriteFile(entryFilePath, []byte(\"[]\"), 0644); err != nil {\n\t\t\tc.logger.Println(\"Error creating entry file: \" + err.Error())\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read the entry file.\n\tvar entryFile []byte\n\tif entryFile, err = ioutil.ReadFile(entryFilePath); err != nil {\n\t\tc.logger.Println(\"Error reading entry file: \" + err.Error())\n\t\treturn\n\t}\n\n\t// Read the modules directory.\n\tvar modulesDirectory []os.FileInfo\n\tif modulesDirectory, err = ioutil.ReadDir(c.modulesDirectoryPath); err != nil {\n\t\tc.logger.Println(\"Error reading modules directory: \" + err.Error())\n\t\treturn\n\t}\n\n\t// Read each entry.json file in the modules directory.\n\tfor _, module := range modulesDirectory {\n\t\tif module.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar moduleEntryFilePath = filepath.Join(c.modulesDirectoryPath, module.Name(), \"entry.json\")\n\t\tvar moduleEntryFile []byte\n\t\tif moduleEntryFile, err = ioutil.ReadFile(moduleEntryFilePath); err != nil {\n\t\t\tc.logger.Println(\"Error reading", "CodeBleu_score": 42.67554836221673}, {"code": "func (c *systemService) GenreateSystemEntry(){\n\t// Create the modules directory if it doesn't exist\n\tif _, err := os.Stat(c.modulesDir); os.IsNotExist(err) {\n\t\tif err := os.Mkdir(c.modulesDir, 0777); err != nil {\n\t\t\tlog.Println(\"Error creating modules directory:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Create the entry file if it doesn't exist\n\tif _, err := os.Stat(c.entryFile); os.IsNotExist(err) {\n\t\tif _, err := os.Create(c.entryFile); err != nil {\n\t\t\tlog.Println(\"Error creating entry file:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory\n\tdir, err := ioutil.ReadDir(c.modulesDir)\n\tif err != nil {\n\t\tlog.Println(\"Error reading modules directory:\", err)\n\t\treturn\n\t}\n\n\t// Concatenate each module's entry.json file into a single JSON array\n\tvar modules []interface{}\n\tfor _, d := range dir {\n\t\tif d.IsDir() {\n\t\t\t// Read the module's entry.json file\n\t\t\tdata, err := ioutil.ReadFile(c.modulesDir + \"/\" + d.Name() + \"/entry.json\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Error reading entry.json file:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Unmarshal the JSON into an interface\n\t\t\tvar module interface{}\n\t\t\tif err := json.Unmarshal(data, &module); err != nil {\n\t\t\t\tlog.Println(\"Error unmarshalling JSON:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Append the module to the modules array\n\t\t\tmodules = append(modules, module)\n\t\t}\n\t}\n\n\t// Marshal the modules array into JSON\n\tdata, err := json.Marshal(modules)\n\tif err != nil {\n\t\tlog", "CodeBleu_score": 41.47766587187287}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tvar (\n\t\terr error\n\t\tinterfaces []win32.IP_ADAPTER_INFO\n\t\tnetworks []win32.IP_ADAPTER_ADDRESSES\n\t\tnetworkName string\n\t\tmacAddress string\n\t\tadapter *win32.IP_ADAPTER_INFO\n\t\tnetwork *win32.IP_ADAPTER_ADDRESSES\n\t)\n\n\t// Get the list of network interfaces\n\tif interfaces, err = c.getAdaptersInfo(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Get the list of network names\n\tif networks, err = c.getAdaptersAddresses(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over the interfaces and network names\n\tfor _, adapter = range interfaces {\n\t\tfor _, network = range networks {\n\t\t\tif adapter.AdapterName == network.AdapterName {\n\t\t\t\tnetworkName = network.FriendlyName\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check if the network name is empty\n\t\tif networkName == \"\" {\n\t\t\treturn \"\", errors.New(\"Could not find network name for interface \" + adapter.AdapterName)\n\t\t}\n\n\t\t// Check if the MAC address is empty\n\t\tif adapter.AddressLength == 0 {\n\t\t\treturn \"\", errors.New(\"Could not find MAC address for network \" + networkName)\n\t\t}\n\n\t\t// Check if the MAC address is valid\n\t\tif adapter.Address[0] == 0 && adapter.Address[1] == 0 && adapter.Address[2] == 0 && adapter.Address[3] == 0 && adapter.Address[4] == 0 && adapter.Address[5] == 0 {\n\t\t\treturn \"\", errors.New(\"Invalid MAC address for network \" + networkName)\n\t\t}\n\n\t\t// Check if the MAC address is valid\n\t\tif adapter.Address[0] == 0xFF && adapter.Address[1] == 0xFF && adapter.Address[2] == 0xFF && adapter.Address[3] == 0xFF && adapter.", "CodeBleu_score": 46.49131337440707}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tvar (\n\t\terr error\n\t\tinterfaces []net.Interface\n\t\tnetworkNames []string\n\t)\n\tif interfaces, err = net.Interfaces(); err != nil {\n\t\treturn \"\", err\n\t}\n\tif networkNames, err = c.GetNetworkNames(); err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, interface_ := range interfaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\tif interface_.Name == networkName {\n\t\t\t\treturn interface_.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 47.5136769744665}, {"code": "func (c *systemService) GetMacAddress() (string, error) {\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, interface_ := range interfaces {\n\t\t\tif interface_.Name == networkName {\n\t\t\t\treturn interface_.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching network interface found\")\n}", "CodeBleu_score": 64.21133756649685}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc = 0;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\trc = -1;\n\t} else {\n\t\tpRequest->pTscObj = pTscObj;\n\t\tpRequest->pNext = pTscObj->pRequestList;\n\t\tpTscObj->pRequestList = pRequest;\n\t\tpTscObj->requestCount++;\n\n\t\tif (pTscObj->pAppInfo != NULL) {\n\t\t\tpTscObj->pAppInfo->requestCount++;\n\t\t\tpTscObj->pAppInfo->currentRequestCount++;\n\t\t}\n\n\t\tif (g_debugLoggingEnabled) {\n\t\t\tchar *pRequestId = getRequestId(pRequest);\n\t\t\tlogDebug(\"Registering request %s for TSC %s\n\", pRequestId, getTscId(pTscObj));\n\t\t\tfree(pRequestId);\n\t\t}\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 36.56892997141635}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t rc;\n\tint32_t tscObjIdx;\n\tSTscObj *pTscObj2;\n\tSTscObj *pTscObj3;\n\n\tif (pRequest == NULL) {\n\t\treturn -1;\n\t}\n\tif (pTscObj == NULL) {\n\t\treturn -1;\n\t}\n\tif (pTscObj->requestCount == 0) {\n\t\tif (pTscObj->pApplication != NULL) {\n\t\t\tpTscObj->pApplication->requestCount++;\n\t\t\tpTscObj->pApplication->currentRequestCount++;\n\t\t}\n\t}\n\tpRequest->pTscObj = pTscObj;\n\tpRequest->requestId = pTscObj->requestCount;\n\tpTscObj->requestCount++;\n\tpTscObj->pRequestArray = (SRequestObj **) realloc(pTscObj->pRequestArray, pTscObj->requestCount * sizeof(SRequestObj *));\n\tif (pTscObj->pRequestArray == NULL) {\n\t\treturn -1;\n\t}\n\tpTscObj->pRequestArray[pTscObj->requestCount - 1] = pRequest;\n\tpRequest->pNext = NULL;\n\tif (pTscObj->pRequestList == NULL) {\n\t\tpTscObj->pRequestList = pRequest;\n\t} else {\n\t\tpRequest->pNext = pTscObj->pRequestList;\n\t\tpTscObj->pRequestList = pRequest;\n\t}\n\tif (pTscObj->requestCount == 1) {\n\t\tpTscObj->pApplication->pTscObj = pTscObj;\n\t\tpTscObj->pApplication->pTscObj->pNext = NULL;\n\t\tif (pTscObj->pApplication->pTscObjList == NULL) {\n\t\t\tpTscObj->pApplication->pTscObjList = pTscObj;\n\t\t} else {\n\t\t\tpTscObj->pApplication->pTscObjList->pNext = pTscObj", "CodeBleu_score": 35.51746086678583}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj){\n\tint32_t retVal = 0;\n\n    if (pRequest != NULL) {\n        pRequest->pTscObj = pTscObj;\n        pRequest->requestId = pTscObj->nextRequestId++;\n        pRequest->pTscObj->requestCount++;\n        if (pTscObj->pAppInfo != NULL) {\n            pTscObj->pAppInfo->requestCount++;\n            pTscObj->pAppInfo->currentRequestCount++;\n            pTscObj->pAppInfo->totalRequestCount++;\n        }\n\n        if (pTscObj->pAppInfo != NULL) {\n            pTscObj->pAppInfo->requestList = (SRequestObj **)realloc(pTscObj->pAppInfo->requestList, sizeof(SRequestObj *) * (pTscObj->pAppInfo->requestCount));\n            pTscObj->pAppInfo->requestList[pTscObj->pAppInfo->requestCount - 1] = pRequest;\n        }\n\n        pTscObj->requestList = (SRequestObj **)realloc(pTscObj->requestList, sizeof(SRequestObj *) * (pTscObj->requestCount));\n        pTscObj->requestList[pTscObj->requestCount - 1] = pRequest;\n\n        if (pTscObj->pAppInfo != NULL) {\n            if (pTscObj->pAppInfo->pLoggingInfo != NULL) {\n                if (pTscObj->pAppInfo->pLoggingInfo->debugLoggingEnabled) {\n                    pTscObj->pAppInfo->pLoggingInfo->logEntry(pTscObj->pAppInfo->pLoggingInfo->pLoggingObj,\n                            \"Register Request: %d\", pRequest->requestId);\n                }\n            }\n        }\n\n        retVal = 1;\n    }\n\n    return retVal;\n}", "CodeBleu_score": 41.86428506226994}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tchar* db = pRequest->db;\n    if (strcmp(db, exceptDb) != 0) {\n        int i = 0;\n        while (pRequest->dbs[i] != NULL) {\n            if (strcmp(pRequest->dbs[i], exceptDb) == 0) {\n                return false;\n            }\n            i++;\n        }\n    }\n    return true;\n}", "CodeBleu_score": 42.299470146263914}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tbool ret = true;\n    char *db = pRequest->db;\n    if (db == NULL) {\n        return ret;\n    }\n    if (strcmp(db, exceptDb) == 0) {\n        ret = false;\n    }\n    if (ret) {\n        List *dbs = pRequest->dbs;\n        if (dbs != NULL) {\n            ListCell *lc = NULL;\n            foreach (lc, dbs) {\n                char *db = (char *) lfirst(lc);\n                if (strcmp(db, exceptDb) == 0) {\n                    ret = false;\n                    break;\n                }\n            }\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 38.897284192703296}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb){\n\tchar* dbName = pRequest->dbName;\n\tchar* dbName2 = pRequest->dbName2;\n\tchar* dbName3 = pRequest->dbName3;\n\tif (dbName && strcmp(dbName, exceptDb) != 0) {\n\t\treturn true;\n\t}\n\tif (dbName2 && strcmp(dbName2, exceptDb) != 0) {\n\t\treturn true;\n\t}\n\tif (dbName3 && strcmp(dbName3, exceptDb) != 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 31.531229318386277}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tswitch (code) {\n\t\tcase E_NO_SUCH_USER:\n\t\t\tif (msgType != MSG_LOGIN_REQUEST && msgType != MSG_REGISTER_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_NO_SUCH_SERVER:\n\t\t\tif (msgType != MSG_LOGIN_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_NO_SUCH_ROOM:\n\t\t\tif (msgType != MSG_JOIN_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_ALREADY_IN_ROOM:\n\t\t\tif (msgType != MSG_JOIN_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_ALREADY_IN_ROOM_AS_GUEST:\n\t\t\tif (msgType != MSG_JOIN_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_ALREADY_IN_ROOM_AS_USER:\n\t\t\tif (msgType != MSG_JOIN_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_ALREADY_IN_ROOM_AS_ADMIN:\n\t\t\tif (msgType != MSG_JOIN_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_ALREADY_IN_ROOM_AS_MODERATOR:\n\t\t\tif (msgType != MSG_JOIN_REQUEST) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_NOT_IN_ROOM:\n\t\t\tif (msgType != MSG_LEAVE_REQUEST && msgType != MSG_LOGOUT_REQUEST && msgType != MSG_ROOM_REQUEST) {\n\t\t\t\treturn true", "CodeBleu_score": 40.47925639250403}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tif (code == 200) {\n\t\treturn false;\n\t}\n\tif (code == 301 || code == 302 || code == 303 || code == 307) {\n\t\tif (msgType == 1 || msgType == 2 || msgType == 3 || msgType == 4 || msgType == 5 || msgType == 6 || msgType == 7 || msgType == 8) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn true;\n}", "CodeBleu_score": 45.44643082984387}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType){\n\tif (code == ERR_NO_RPC_AVAILABLE || code == ERR_RPC_NOT_AVAILABLE) {\n\t\tif (msgType != MSG_RPC_REPLY && msgType != MSG_RPC_REPLY_SEND && msgType != MSG_RPC_REPLY_RECV && msgType != MSG_RPC_REPLY_RECV_SEND) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 39.644779118403775}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests){\n\tSHashNode *pNode = NULL;\n    TAOS_REQUEST *pRequest = NULL;\n    int64_t rid;\n    int32_t rc;\n\n    if (pRequests == NULL)\n        return;\n\n    pNode = SHashFirst(pRequests);\n    while (pNode != NULL) {\n        pRequest = (TAOS_REQUEST *) pNode->content;\n        rid = pRequest->rid;\n        if (pRequest->valid) {\n            rc = taosStopQuery(pRequest->taos, pRequest->query);\n            if (rc != TSDB_OK)\n                taos_errno = rc;\n        }\n        releaseRequest(rid);\n        pNode = SHashNext(pRequests);\n    }\n}", "CodeBleu_score": 40.32775172930793}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tint64_t rid = 0;\n    int32_t ret = 0;\n    int32_t n = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t nRequests = 0;\n    int32_t nReleased = 0;\n    int32_t nStopped = 0;\n    int32_t nError = 0;\n    int32_t nTimeout = 0;\n    int32_t nReconnect = 0;\n    int32_t nSuccess = 0;\n    int32_t nFailed = 0;\n    int32_t nException = 0;\n    int32_t nCanceled = 0;\n    int32_t nFinished = 0;\n    int32_t nRunning = 0;\n    int32_t nPending = 0;\n    int32_t nWaiting = 0;\n    int32_t nUnknown = 0;\n    int32_t nTotal = 0;\n    int32_t nTotalError = 0;\n    int32_t nTotalTimeout = 0;\n    int32_t nTotalReconnect = 0;\n    int32_t nTotalSuccess = 0;\n    int32_t nTotalFailed = 0;\n    int32_t nTotalException = 0;\n    int32_t nTotalCanceled = 0;\n    int32_t nTotalFinished = 0;\n    int32_t nTotalRunning = 0;\n    int32_t nTotalPending = 0;\n    int32_t nTotalWaiting = 0;\n    int32_t nTotalUnknown = 0;\n    int32_t nTotalRequests = 0;\n    int32_t nTotalReleased = 0;\n    int32_t nTotalStopped = 0;\n    int32", "CodeBleu_score": 7.109463468982473}, {"code": "void stopAllRequests(SHashObj *pRequests){\n\tif (pRequests == NULL) return;\n    SHashNode *pNode = SHash_first(pRequests);\n    while (pNode != NULL) {\n        int64_t rid = *(int64_t *)SHash_key(pNode);\n        TAOS_REQUEST *pRequest = (TAOS_REQUEST *)SHash_value(pNode);\n        if (pRequest != NULL) {\n            if (pRequest->status == TAOS_REQUEST_RUNNING) {\n                if (pRequest->query != NULL) {\n                    taos_query_stop(pRequest->query);\n                    pRequest->status = TAOS_REQUEST_STOPPED;\n                }\n            }\n            releaseRequest(rid);\n        }\n        pNode = SHash_next(pRequests);\n    }\n}", "CodeBleu_score": 45.15121332519737}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportEnabled) {\n        return;\n    }\n    if (!__sync_bool_compare_and_swap(&tscClientStop, 0, 1)) {\n        printf(\"[tsc] Crash report thread is already stopped.\n\");\n        return;\n    }\n    while (tscClientStop == 1) {\n        sleep(1);\n    }\n}", "CodeBleu_score": 55.33107676958255}, {"code": "void tscStopCrashReport(){\n\tif (tscIsCrashReportEnabled()) {\n\t\tint clientStop = 1;\n\t\tif (__sync_bool_compare_and_swap(&tscClientStop, 0, clientStop)) {\n\t\t\twhile (tscClientStop) {\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t} else {\n\t\t\ttscLog(TSF\"Crash report thread is already stopped\");\n\t\t}\n\t}\n}", "CodeBleu_score": 37.32849062877699}, {"code": "void tscStopCrashReport(){\n\tif (!tscCrashReportEnabled) {\n        return;\n    }\n\n    if (!tscAtomicCompareAndSwap(&tscCrashReportClientStop, 0, 1)) {\n        tscLog(TSF_LOG_INFO, TSC_LOG_CRASH_REPORT,\n               TSC_FUNCTION_NAME,\n               \"Crash report thread is already stopped\");\n        return;\n    }\n\n    while (tscCrashReportClientStop) {\n        usleep(100000);\n    }\n}", "CodeBleu_score": 59.67345668135783}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tstruct HBViewInfoRsp *hbViewInfoRsp = (struct HBViewInfoRsp *)value;\n\tstruct HBViewInfoRspEntry *hbViewInfoRspEntry;\n\tstruct SCView *pView;\n\tint32_t i;\n\tint32_t j;\n\tint32_t rc;\n\tint32_t rc2;\n\tint32_t rc3;\n\tint32_t rc4;\n\tint32_t rc5;\n\tint32_t rc6;\n\tint32_t rc7;\n\tint32_t rc8;\n\tint32_t rc9;\n\tint32_t rc10;\n\tint32_t rc11;\n\tint32_t rc12;\n\tint32_t rc13;\n\tint32_t rc14;\n\tint32_t rc15;\n\tint32_t rc16;\n\tint32_t rc17;\n\tint32_t rc18;\n\tint32_t rc19;\n\tint32_t rc20;\n\tint32_t rc21;\n\tint32_t rc22;\n\tint32_t rc23;\n\tint32_t rc24;\n\tint32_t rc25;\n\tint32_t rc26;\n\tint32_t rc27;\n\tint32_t rc28;\n\tint32_t rc29;\n\tint32_t rc30;\n\tint32_t rc31;\n\tint32_t rc32;\n\tint32_t rc33;\n\tint32_t rc34;\n\tint32_t rc35;\n\tint32_t rc36;\n\tint32_t rc37;\n\tint32", "CodeBleu_score": 6.939032548398908}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t rc = NO_ERR;\n\tstruct HBViewInfo *pViewInfo = NULL;\n\tstruct HBViewInfo *pViewInfoPtr = NULL;\n\tstruct HBViewInfo *pViewInfoTmp = NULL;\n\tstruct HBViewInfo *pViewInfoPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNew = NULL;\n\tstruct HBViewInfo *pViewInfoNewTmp = NULL;\n\tstruct HBViewInfo *pViewInfoNewPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNewNext = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextTmp = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNext = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextTmp = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNext = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextTmp = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNext = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextTmp = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextNext = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextNextTmp = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextNextPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextNextNext = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextNextNextTmp = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextNextNextPrev = NULL;\n\tstruct HBViewInfo *pViewInfoNewNextNextNextNextNextNextNext = NULL;\n\tstruct HBViewInfo *pView", "CodeBleu_score": 6.073051149602758}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog){\n\tint32_t i, j, k, rc, numViews, numCols, numViewsInRsp, numColsInRsp, numViewsInCat, numColsInCat, numViewsToRemove, numColsToRemove, numViewsToUpdate, numColsToUpdate;\n\tint32_t *viewIds, *colIds;\n\tint32_t *viewIdsInRsp, *colIdsInRsp;\n\tint32_t *viewIdsInCat, *colIdsInCat;\n\tint32_t *viewIdsToRemove, *colIdsToRemove;\n\tint32_t *viewIdsToUpdate, *colIdsToUpdate;\n\tint32_t *numViewsInCatPtr, *numColsInCatPtr;\n\tint32_t *numViewsInRspPtr, *numColsInRspPtr;\n\tint32_t *numViewsToRemovePtr, *numColsToRemovePtr;\n\tint32_t *numViewsToUpdatePtr, *numColsToUpdatePtr;\n\tint32_t *numViewsToUpdatePtr2, *numColsToUpdatePtr2;\n\tint32_t *numViewsToRemovePtr2, *numColsToRemovePtr2;\n\tint32_t *numViewsToUpdatePtr3, *numColsToUpdatePtr3;\n\tint32_t *numViewsToRemovePtr3, *numColsToRemovePtr3;\n\tchar **viewNames, **colNames;\n\tchar **viewNamesInRsp, **colNamesInRsp;\n\tchar **viewNamesInCat, **colNamesInCat;\n\tchar **viewNamesToRemove, **colNamesToRemove;\n\tchar **viewNamesToUpdate, **colNamesToUpdate;\n\tchar **viewNamesToUpdate2, **colNamesToUpdate2;\n\tchar **viewNamesToRemove2, **colNamesToRemove2;\n\tchar **viewNamesToUpdate3, **colNamesToUpdate3;\n\tchar **viewNamesToRemove3, **colNamesToRemove3;\n\tchar **viewNamesToUpdate4, **colNamesToUpdate4;\n\tchar **viewNames", "CodeBleu_score": 7.716605127192637}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status = S3StatusOK;\n    CallbackData *data = (CallbackData *) callbackData;\n\n    /* Check the parameters */\n    if ((properties == NULL) || (data == NULL)) {\n        status = S3StatusInternalError;\n    }\n\n    /* Check if the content length is greater than zero */\n    if (status == S3StatusOK) {\n        if (properties->contentLength > 0) {\n            data->contentLength = properties->contentLength;\n        }\n        else {\n            data->contentLength = 0;\n        }\n    }\n\n    return status;\n}", "CodeBleu_score": 65.97124129687386}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tS3Status status = S3StatusOK;\n    CallbackData *data = (CallbackData *) callbackData;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return status;\n}", "CodeBleu_score": 73.9436250391423}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData){\n\tif (properties->contentLength > 0) {\n        ((S3PutObjectCallbackData *)callbackData)->contentLength = properties->contentLength;\n    } else {\n        ((S3PutObjectCallbackData *)callbackData)->contentLength = 0;\n    }\n    return S3StatusOK;\n}", "CodeBleu_score": 68.05298355035978}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync(){\n\tchar confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n\n  if (taos_mkdir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] create backup dir error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(confDir) < 0) return;\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4,\n#ifdef WINDOWS\n           \"start /B rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort\n#else\n           \"rsync --daemon --config=%srsync.conf --port=%d\", tsCheckpointBackupDir, tsCheckpointBackupPort\n#endif\n  );\n  uDebug(\"[rsync] cmd:%s\", cmd);\n\n  int32_t pid = taos_fork();\n  if (pid == 0) {\n    execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n    uError(\"[rsync] execl error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    exit(1);\n  } else if (pid > 0) {\n    uDebug(\"[rsync] start rsync success, pid:%d\", pid);\n  } else {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n  }\n}", "CodeBleu_score": 57.391363634606265}, {"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync\");\n  if (taosMkdir(tsCheckpointBackupDir, 0777) == -1) {\n    uError(\"[rsync] mkdir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir, ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] generate conf file error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  char cmd[PATH_MAX * 4] = {0};\n  snprintf(cmd, PATH_MAX * 4, \"rsync --daemon --port %d --config %srsync.conf\", tsRsyncPort, tsCheckpointBackupDir);\n  uDebug(\"[rsync] cmd:%s\", cmd);\n  if (system(cmd) == -1) {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n  uDebug(\"[rsync] start rsync success\");\n}", "CodeBleu_score": 55.138964373971746}, {"code": "void startRsync(){\n\tuDebug(\"[rsync] start rsync\");\n  char confDir[PATH_MAX] = {0};\n  snprintf(confDir, sizeof(confDir), \"%s/rsync.conf\", tsCheckpointBackupDir);\n\n  if (taos_mkdir(tsCheckpointBackupDir, 0755) < 0) {\n    uError(\"[rsync] create checkpoint backup dir error, dir:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir,\n           ERRNO_ERR_DATA);\n    return;\n  }\n\n  removeEmptyDir();\n  if (generateConfigFile(confDir) < 0) {\n    uError(\"[rsync] generate conf file error, dir:%s\", tsCheckpointBackupDir);\n    return;\n  }\n\n  char command[PATH_MAX * 2] = {0};\n  snprintf(command, sizeof(command), \"rsync --daemon --config=%s\", confDir);\n  uDebug(\"[rsync] start rsync cmd:%s\", command);\n  if (system(command) < 0) {\n    uError(\"[rsync] start rsync error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    return;\n  }\n\n  uInfo(\"[rsync] start rsync success\");\n}", "CodeBleu_score": 61.626907359649984}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId){\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tExecutorService dispatcherExecutor = dispatchers.get(dispatcherId);\n\t\tdispatcherExecutor.shutdownNow();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found\");\n\t}\n}", "CodeBleu_score": 59.52172752607295}, {"code": "public void destroyDispatcher(String dispatcherId){\n\t// Retrieve the dispatcher from the dispatchers collection\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t\t\n\t\t// If the dispatcher is not found, throw an exception\n\t\tif (dispatcher == null) {\n\t\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found.\");\n\t\t}\n\t\t\n\t\t// Shut down the executor\n\t\tdispatcher.getExecutor().shutdownNow();\n\t\t\n\t\t// Remove the dispatcher from the dispatchers collection\n\t\tdispatchers.remove(dispatcherId);\n\t\t\n\t\t// Remove the dispatcher from the dispatcher IDs collection\n\t\tdispatcherIds.remove(dispatcherId);\n\t\t\n\t\t// Log the event\n\t\tlogger.info(\"Dispatcher with ID \" + dispatcherId + \" destroyed.\");\n\t}", "CodeBleu_score": 57.73434507562551}, {"code": "public void destroyDispatcher(String dispatcherId){\n\tif (dispatchers.containsKey(dispatcherId)) {\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t\tdispatcher.shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t} else {\n\t\tthrow new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not found\");\n\t}\n}", "CodeBleu_score": 62.2056353493036}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = childrenMap.get(parent);\n        if (children != null) {\n            for (TbActorId child : children) {\n                if (childFilter.test(child)) {\n                    tell(child, msg, highPriority);\n                }\n            }\n        }\n    }", "CodeBleu_score": 53.93609769556426}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = childrenMap.get(parent);\n        if (children == null) {\n            log.warn(\"[{}] Failed to broadcast message to children of [{}] because children are not registered!\", msg.getMsgName(), parent);\n            return;\n        }\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                tell(child, msg, highPriority);\n            }\n        }\n    }", "CodeBleu_score": 53.12676218626908}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority){\n\tTbActorId[] children = childrenMap.get(parent);\n    if (children != null) {\n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                tell(child, msg, highPriority);\n            }\n        }\n    }\n}", "CodeBleu_score": 51.43285074886088}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroying.get() == NOT_DESTROYING) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else if (destroying.get() == DESTROYING && msg instanceof RuleNodeToRuleChainMsg) {\n            RuleNodeToRuleChainMsg ruleNodeToRuleChainMsg = (RuleNodeToRuleChainMsg) msg;\n            if (ruleNodeToRuleChainMsg.getMsgType() == RuleNodeToRuleChainMsg.MsgType.RULE_NODE_UPDATED_MSG) {\n                tryInit(1);\n            } else {\n                msg.onFailure(new RuntimeException(\"Actor is being destroyed!\"));\n            }\n        } else {\n            msg.onFailure(new RuntimeException(\"Actor is being destroyed!\"));\n        }\n    }", "CodeBleu_score": 58.55003861330734}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyed.get() == DESTROYED) {\n            if (msg instanceof RuleNodeUpdatedMsg) {\n                if (highPriority) {\n                    tryInit(1);\n                } else {\n                    ((RuleNodeUpdatedMsg) msg).getCallback().onFailure(new RuntimeException(\"Actor is destroyed\"));\n                }\n            } else {\n                msg.onFailure(new RuntimeException(\"Actor is destroyed\"));\n            }\n        } else {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        }\n    }", "CodeBleu_score": 59.986438926405505}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority){\n\tif (destroyed.get() != DESTROYED) {\n            if (highPriority) {\n                highPriorityMsgs.add(msg);\n            } else {\n                normalPriorityMsgs.add(msg);\n            }\n            tryProcessQueue(true);\n        } else if (msg instanceof RuleNodeToRuleChainMsg) {\n            RuleNodeToRuleChainMsg ruleNodeToRuleChainMsg = (RuleNodeToRuleChainMsg) msg;\n            if (ruleNodeToRuleChainMsg.getMsgType() == RuleNodeToRuleChainMsgType.RULE_NODE_UPDATED_MSG) {\n                tryInit(0);\n            } else {\n                ruleNodeToRuleChainMsg.getCallback().onFailure(new RuntimeException(\"Rule Node is being destroyed!\"));\n            }\n        } else {\n            msg.replyTo.tell(new TbActorResponse(selfId, msg.getId(), new RuntimeException(\"Rule Node is being destroyed!\")), self());\n        }\n    }", "CodeBleu_score": 57.955097957107085}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox(){\n\twhile (true) {\n            if (destroyInProgress.get()) {\n                log.trace(\"[{}] Destroy in progress\", selfId);\n                break;\n            }\n            if (busy.compareAndSet(BUSY, FREE)) {\n                break;\n            }\n        }\n        try {\n            while (true) {\n                if (destroyInProgress.get()) {\n                    log.trace(\"[{}] Destroy in progress\", selfId);\n                    break;\n                }\n                if (busy.compareAndSet(FREE, BUSY)) {\n                    break;\n                }\n            }\n            if (destroyInProgress.get()) {\n                log.trace(\"[{}] Destroy in progress\", selfId);\n                break;\n            }\n            boolean newMsg = false;\n            if (!highPriorityMsgs.isEmpty()) {\n                newMsg = true;\n                while (!highPriorityMsgs.isEmpty()) {\n                    TbActorMsg msg = highPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                        } catch (Throwable t) {\n                            log.warn(\"[{}] Failed to process high priority message: {}\", selfId, t);\n                            if (msg.isTbActorMsgWithMetadata()) {\n                                ((TbActorMsgWithMetadata) msg).getMetaData().setFailure(t);\n                            }\n                            if (actor.getProcessFailureStrategy().equals(TbActorProcessingFailureStrategy.STOP)) {\n                                stopReason = TbActorStopReason.PROCESSING_FAILURE;\n                                destroy(t);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            if (!normalPriorityMsgs.isEmpty()) {\n                newMsg = true;\n                while (!normalPriorityMsgs.isEmpty()) {\n                    TbActorMsg msg = normalPriorityMsgs.poll();\n                    if (msg != null) {\n                        try {\n                            actor.process(msg);\n                        } catch (Throwable", "CodeBleu_score": 41.45018133876068}, {"code": "private void processMailbox(){\n\tif (destroyInProgress.get()) {\n            return;\n        }\n        try {\n            int processed = 0;\n            while (processed < throughputLimit && !highPriorityMsgs.isEmpty() && !normalPriorityMsgs.isEmpty()) {\n                TbActorMsg msg = highPriorityMsgs.poll();\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                        processed++;\n                    } catch (Throwable t) {\n                        log.warn(\"[{}] Failed to process high priority message: {}\", selfId, msg, t);\n                        msg.onTbActorFailed(t);\n                    }\n                }\n                msg = normalPriorityMsgs.poll();\n                if (msg != null) {\n                    try {\n                        actor.process(msg);\n                        processed++;\n                    } catch (Throwable t) {\n                        log.warn(\"[{}] Failed to process normal priority message: {}\", selfId, msg, t);\n                        msg.onTbActorFailed(t);\n                    }\n                }\n            }\n            if (processed == 0) {\n                if (highPriorityMsgs.isEmpty() && normalPriorityMsgs.isEmpty()) {\n                    busy.set(FREE);\n                    log.trace(\"[{}] Mailbox is empty\", selfId);\n                } else {\n                    log.trace(\"[{}] Mailbox is not empty\", selfId);\n                }\n            } else {\n                log.trace(\"[{}] Processed {} messages\", selfId, processed);\n            }\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to process message box\", selfId, t);\n        }\n    }", "CodeBleu_score": 42.19061388563209}, {"code": "private void processMailbox(){\n\ttry {\n        while (!highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n            if (highPriorityMsgs.isEmpty()) {\n                processQueue(normalPriorityMsgs);\n            } else if (normalPriorityMsgs.isEmpty()) {\n                processQueue(highPriorityMsgs);\n            } else {\n                int highPriorityMsgCount = highPriorityMsgs.size();\n                int normalPriorityMsgCount = normalPriorityMsgs.size();\n                if (highPriorityMsgCount > normalPriorityMsgCount) {\n                    processQueue(highPriorityMsgs);\n                    if (highPriorityMsgs.isEmpty()) {\n                        processQueue(normalPriorityMsgs);\n                    }\n                } else {\n                    processQueue(normalPriorityMsgs);\n                    if (normalPriorityMsgs.isEmpty()) {\n                        processQueue(highPriorityMsgs);\n                    }\n                }\n            }\n        }\n    } catch (Throwable t) {\n        log.warn(\"[{}] Failed to process mailbox: {}\", selfId, t);\n        if (t instanceof TbActorException) {\n            stop(t);\n        } else {\n            stop(new TbActorException(\"Failed to process mailbox\", t));\n        }\n    } finally {\n        busy.set(FREE);\n        tryProcessQueue(false);\n    }\n}", "CodeBleu_score": 32.91473018843046}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}", "CodeBleu_score": 98.66735696636148}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}, {"code": "public void destroy(Throwable cause){\n\tif (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }", "CodeBleu_score": 96.60422850378215}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isNullUid()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    long currentTime = System.currentTimeMillis();\n    long startOfPeriod = currentTime - currentTime % rateLimit.getPeriod();\n    long limit = rateLimit.getLimit();\n    long count = rateLimit.getCount();\n    long limitExceeded = count - limit + 1;\n    if (rateLimit.getPeriod() != 0) {\n        long countInPeriod = rateLimitCounter.countInPeriod(tenantId, api, startOfPeriod, limitExceeded);\n        if (countInPeriod >= limit) {\n            rateLimitCounter.notifyRateLimit(tenantId, api, level, countInPeriod);\n            return false;\n        }\n    }\n    long countInPeriod = rateLimitCounter.countInPeriod(tenantId, api, startOfPeriod, limit);\n    if (countInPeriod >= limit) {\n        rateLimitCounter.notifyRateLimit(tenantId, api, level, countInPeriod);\n        return false;\n    }\n    rateLimitCounter.add(tenantId, api, startOfPeriod, limitExceeded);\n    return true;\n}", "CodeBleu_score": 51.839398810958215}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isNullUid()) {\n            return true;\n        }\n        TenantProfile tenantProfile;\n        try {\n            tenantProfile = tenantProfileService.findTenantProfileById(tenantId, ignoreTenantNotFound);\n        } catch (TenantProfileNotFoundException e) {\n            if (ignoreTenantNotFound) {\n                return true;\n            } else {\n                throw e;\n            }\n        }\n        RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n        if (rateLimitConfiguration == null) {\n            return true;\n        }\n        RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n        if (rateLimit == null) {\n            return true;\n        }\n        if (rateLimit.isExceeded(level)) {\n            if (rateLimit.getNotifyRate() != null) {\n                rateLimitNotifyService.processNotification(tenantId, rateLimit, level);\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }", "CodeBleu_score": 50.091858437802806}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound){\n\tif (tenantId.isNullUid()) {\n            return true;\n        }\n        TenantProfile tenantProfile = tenantProfileCache.get(tenantId.getId());\n        if (tenantProfile == null) {\n            if (ignoreTenantNotFound) {\n                return true;\n            } else {\n                throw new TenantProfileNotFoundException(tenantId);\n            }\n        }\n        RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n        if (rateLimitConfiguration == null) {\n            return true;\n        }\n        RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n        if (rateLimit == null) {\n            return true;\n        }\n        long now = System.currentTimeMillis();\n        long windowStart = now - (now % rateLimit.getTimeWindow());\n        long count = rateLimit.getCount();\n        long limit = rateLimit.getLimit();\n        long windowSize = rateLimit.getTimeWindow();\n        RateLimitExceededNotification notification = null;\n        try {\n            if (rateLimit.isPerSource()) {\n                if (level != null) {\n                    count = rateLimit.getCount(level.toString());\n                    limit = rateLimit.getLimit(level.toString());\n                }\n            }\n            if (count >= limit) {\n                notification = new RateLimitExceededNotification(api, tenantId, level, windowStart, windowSize, count, limit);\n                rateLimitNotificationsService.process(notification);\n                return false;\n            }\n        } finally {\n            if (notification != null) {\n                rateLimitNotificationsService.log(notification);\n            }\n        }\n        return true;\n    }", "CodeBleu_score": 51.60780692505335}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions(){\n\t// TODO: YOUR CODE HERE\n    long now = System.currentTimeMillis();\n    long expirationTime = now - this.inactivityTimeout;\n    Iterator<Map.Entry<String, DTLSConnection>> it = this.dtlsSessions.entrySet().iterator();\n    while(it.hasNext()) {\n        Map.Entry<String, DTLSConnection> entry = it.next();\n        if(entry.getValue().getLastActivity() < expirationTime) {\n            it.remove();\n            this.log.info(\"Removed DTLS session with remote address \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 38.703330771277756}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\n    long expirationTime = currentTime - inactivityTimeout;\n    Iterator<Entry<String, DTLSConnection>> iterator = dtlsSessions.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Entry<String, DTLSConnection> entry = iterator.next();\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            log.info(\"Removing DTLS session for \" + entry.getKey());\n            iterator.remove();\n        }\n    }\n}", "CodeBleu_score": 39.081023775720716}, {"code": "public void evictTimeoutSessions(){\n\tlong currentTime = System.currentTimeMillis();\n\tlong expirationTime = currentTime - inactivityTimeout;\n\tfor (Entry<String, DTLSConnection> entry : sessions.entrySet()) {\n\t\tif (entry.getValue().getLastActivityTime() < expirationTime) {\n\t\t\tsessions.remove(entry.getKey());\n\t\t\tlogger.info(\"Removing DTLS session with remote address \" + entry.getValue().getRemoteAddress() + \" due to inactivity timeout\");\n\t\t}\n\t}\n}", "CodeBleu_score": 38.886964343483285}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> tsKvEntries = new ArrayList<>(timeseries.size());\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                tsKvEntries.add(parseTsValue(key, value));\n            }\n        }\n        return tsKvEntries;\n    }", "CodeBleu_score": 42.30145326315371}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries == null || timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> entries = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            if (values == null || values.isEmpty()) {\n                entries.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, \"\")));\n            } else {\n                for (JsonNode value : values) {\n                    entries.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, value)));\n                }\n            }\n        }\n        return entries;\n    }", "CodeBleu_score": 42.196657694220555}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries){\n\tif (timeseries.isEmpty()) {\n            return Collections.emptyList();\n        }\n        List<TsKvEntry> entries = new ArrayList<>(timeseries.size());\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                entries.add(new BasicTsKvEntry(System.currentTimeMillis(), parseValue(key, value)));\n            }\n        }\n        return entries;\n    }", "CodeBleu_score": 42.44409375855117}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", refreshToken);\n        String responseBody = this.sendRequest(\"POST\", this.authUrl, requestMap);\n        setTokenInfo(System.currentTimeMillis(), new ObjectMapper().readTree(responseBody));\n    }", "CodeBleu_score": 43.393412755134534}, {"code": "public void refreshToken(){\n\tMap<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"refreshToken\", this.refreshToken);\n        String response = HttpUtils.sendPostRequest(this.authUrl, requestMap);\n        setTokenInfo(System.currentTimeMillis(), JsonUtils.getJsonNodeFromString(response));\n    }", "CodeBleu_score": 40.915375498606174}, {"code": "public void refreshToken(){\n\tString url = this.authUrl + \"/token\";\n    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refreshToken\", this.refreshToken);\n    requestMap.put(\"client_id\", this.clientId);\n    requestMap.put(\"client_secret\", this.clientSecret);\n    requestMap.put(\"grant_type\", \"refresh_token\");\n    try {\n        JsonNode response = this.httpRequest(url, requestMap, \"POST\");\n        this.setTokenInfo(System.currentTimeMillis(), response);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 41.29393531204116}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin(){\n\ttry {\n            long ts = System.currentTimeMillis();\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", password);\n            String loginResponse = HttpRequest.sendPostRequest(AUTH_LOGIN_URL, loginRequest, \"application/json\");\n            JsonNode tokenInfo = mapper.readTree(loginResponse);\n            setTokenInfo(ts, tokenInfo);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }", "CodeBleu_score": 67.74475148810372}, {"code": " private void doLogin(){\n\ttry {\n            long ts = System.currentTimeMillis();\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", password);\n            JsonNode response = this.httpClient.post(\"http://localhost:8080/api/auth/login\", loginRequest, null, null, null);\n            this.setTokenInfo(ts, response);\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }", "CodeBleu_score": 67.74922002356743}, {"code": " private void doLogin(){\n\ttry {\n            long ts = System.currentTimeMillis();\n            Map<String, String> loginRequest = new HashMap<>();\n            loginRequest.put(\"username\", username);\n            loginRequest.put(\"password\", password);\n            loginRequest.put(\"client_id\", \"mobile\");\n            loginRequest.put(\"grant_type\", \"password\");\n            loginRequest.put(\"scope\", \"openid offline_access\");\n            loginRequest.put(\"client_secret\", \"\");\n            loginRequest.put(\"device_type\", \"mobile\");\n            loginRequest.put(\"device_id\", \"\");\n            loginRequest.put(\"device_name\", \"\");\n            loginRequest.put(\"device_os\", \"\");\n            loginRequest.put(\"device_os_version\", \"\");\n            loginRequest.put(\"device_model\", \"\");\n            loginRequest.put(\"device_manufacturer\", \"\");\n            loginRequest.put(\"device_uuid\", \"\");\n            loginRequest.put(\"device_timezone\", \"\");\n            loginRequest.put(\"device_timezone_offset\", \"\");\n            loginRequest.put(\"device_screen_width\", \"\");\n            loginRequest.put(\"device_screen_height\", \"\");\n            loginRequest.put(\"device_screen_density\", \"\");\n            loginRequest.put(\"device_screen_density_dpi\", \"\");\n            loginRequest.put(\"device_network_country\", \"\");\n            loginRequest.put(\"device_network_carrier\", \"\");\n            loginRequest.put(\"device_network_sim_operator\", \"\");\n            loginRequest.put(\"device_network_sim_country\", \"\");\n            loginRequest.put(\"device_network_wifi_ssid\", \"\");\n            loginRequest.put(\"device_network_wifi_bssid\", \"\");\n            loginRequest.put(\"device_network_wifi_mac\", \"\");\n            loginRequest.put(\"device_network_wifi_ip\", \"\");\n            loginRequest.put(\"device_network_wifi_link_speed\", \"\");\n            loginRequest.put(\"device_network_wifi_frequency\", \"\");\n            loginRequest.put(\"device_network_wifi_level\", \"\");", "CodeBleu_score": 47.255273296477064}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.of(\n                this.getRestTemplate().getForObject(\n                        this.getApiBaseUrl() + \"/device/{deviceId}\",\n                        Device.class,\n                        deviceId.getValue()\n                )\n        );\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 42.230485439364884}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        HttpResponse<String> response = Unirest.get(String.format(DEVICE_URL_TEMPLATE, deviceId.getId()))\n                .header(\"accept\", \"application/json\")\n                .header(\"X-Auth-Token\", token)\n                .asString();\n        return Optional.of(new ObjectMapper().readValue(response.getBody(), Device.class));\n    } catch (UnirestException e) {\n        if (e.getCause() instanceof HttpException) {\n            HttpException httpException = (HttpException) e.getCause();\n            if (httpException.getStatus() == 404) {\n                return Optional.empty();\n            } else {\n                throw e;\n            }\n        } else {\n            throw e;\n        }\n    } catch (JsonProcessingException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 50.99507495861586}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId){\n\ttry {\n        return Optional.ofNullable(\n            getApiClient().getDeviceById(deviceId)\n        );\n    } catch (ApiException e) {\n        if (e.getCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 36.66110523797998}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tHttpRequest request = HttpRequest.newBuilder()\n            .POST(\"/api/device-with-credentials\")\n            .header(\"Content-Type\", \"application/json\")\n            .body(BodyPublishers.ofString(\n                    new Gson().toJson(new DeviceWithCredentials(device, credentials))\n            ))\n            .build();\n    try {\n        HttpResponse<String> response = httpClient.send(request, BodyHandlers.ofString());\n        if (response.statusCode() == 200) {\n            return Optional.of(new Gson().fromJson(response.body(), Device.class));\n        } else if (response.statusCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw new RuntimeException(response.body());\n        }\n    } catch (IOException | InterruptedException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 48.34138270765714}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\tRequest request = new Request.Builder()\n            .url(API_BASE_URL + \"/device-with-credentials\")\n            .post(RequestBody.create(MEDIA_TYPE_JSON, new Gson().toJson(new DeviceCredentials(device, credentials))))\n            .build();\n\n    try {\n        Response response = client.newCall(request).execute();\n        if (response.isSuccessful()) {\n            return Optional.of(new Gson().fromJson(response.body().string(), Device.class));\n        } else if (response.code() == 404) {\n            return Optional.empty();\n        } else {\n            throw new IOException(\"Unexpected code \" + response);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 50.64602357628798}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials){\n\ttry {\n        Request request = new Request.Builder()\n                .url(BASE_URL + \"/api/device-with-credentials\")\n                .post(RequestBody.create(JSON, new Gson().toJson(new DeviceWithCredentials(device, credentials))))\n                .build();\n        Response response = client.newCall(request).execute();\n        if (response.isSuccessful()) {\n            return Optional.of(new Gson().fromJson(response.body().string(), Device.class));\n        } else if (response.code() == 404) {\n            return Optional.empty();\n        } else {\n            throw new IOException(\"Unexpected code \" + response);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 51.99939324642122}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}, {"code": "brightness(addr, val){\n\tif (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }", "CodeBleu_score": 98.16910982972271}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }", "CodeBleu_score": 98.2797540730344}, {"code": "device(addr){\n\tconst bound = {};\n\n  /* keys from prototype */\n  Object.keys(LedControl.prototype).forEach(key => {\n    bound[key] = this[key].bind(this, addr);\n  });\n\n  /* functions from interface */\n  Object.getOwnPropertyNames(this).forEach(key => {\n    if (this[key] && typeof this[key] === \"function\") {\n      bound[key] = this[key].bind(this, addr);\n    }\n  });\n  return bound;\n}", "CodeBleu_score": 99.65663921480761}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n        target[method] = function (duration, callback) {\n            let promises = [];\n            this.forEach(element => {\n                promises.push(new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                        try {\n                            let result = element[method]();\n                            if (result instanceof Promise) {\n                                result.then(resolve).catch(reject);\n                            } else {\n                                resolve(result);\n                            }\n                        } catch (error) {\n                            reject(error);\n                        }\n                    }, duration);\n                }));\n            });\n            return new Promise((resolve, reject) => {\n                Promise.all(promises).then(values => {\n                    if (callback instanceof Function) {\n                        callback(values);\n                    }\n                    resolve(values);\n                }).catch(error => {\n                    reject(error);\n                });\n            });\n        }\n    });\n}", "CodeBleu_score": 32.42219181982365}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n\n        if (typeof target[method] === \"function\") {\n\n            target[method + \"WithCallback\"] = (...args) => {\n\n                let duration = args.pop();\n                let callback = args.pop();\n\n                if (typeof duration !== \"number\") {\n\n                    duration = 1000;\n                }\n\n                if (typeof callback !== \"function\") {\n\n                    callback = () => {};\n                }\n\n                let promises = [];\n\n                target.forEach(element => {\n\n                    promises.push(new Promise((resolve, reject) => {\n\n                        setTimeout(() => {\n\n                            try {\n\n                                element[method](...args).then(resolve);\n                            }\n                            catch (error) {\n\n                                reject(error);\n                            }\n                        }, duration);\n                    }));\n                });\n\n                Promise.all(promises).then(() => {\n\n                    callback();\n                });\n            };\n        }\n    });\n}", "CodeBleu_score": 39.723002675645816}, {"code": "Collection.installCallbackReconciliation = (target, methods) => {\n\tmethods.forEach(method => {\n        target[method] = (duration, callback) => {\n            if (duration === undefined) duration = 1000;\n            if (typeof duration !== 'number') throw new Error('duration must be a number');\n            if (callback !== undefined && typeof callback !== 'function') throw new Error('callback must be a function');\n            let promises = [];\n            for (let i = 0; i < target.length; i++) {\n                let promise = new Promise((resolve, reject) => {\n                    let result = target[i][method](duration, () => {\n                        resolve(result);\n                    });\n                });\n                promises.push(promise);\n            }\n            if (callback !== undefined) {\n                Promise.all(promises).then(() => {\n                    callback();\n                });\n            }\n            return promises;\n        }\n    });\n}", "CodeBleu_score": 43.111780858288995}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}, {"code": "listen(){\n\tconst state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }", "CodeBleu_score": 91.85148430593136}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tint ret = 0;\n\tconst struct adc_ad559x_config *cfg = dev->config;\n\tuint8_t num_of_channels = 0;\n\tuint16_t buffer_size = 0;\n\tuint16_t channel_size = 0;\n\n\tif (sequence->channels == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tif (sequence->options->extra_samplings) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < sequence->num_entries; i++) {\n\t\tif (sequence->channels[i].channel_id >= cfg->num_channels) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sequence->channels[i].gain != ADC_GAIN_1) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tif (sequence->channels[i].reference != ADC_REF_INTERNAL) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tif (sequence->channels[i].acquisition_time != ADC_ACQ_TIME_DEFAULT) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tif (sequence->channels[i].differential) {\n\t\t\treturn -ENOTSUP;\n\t\t}\n\n\t\tif (sequence->channels[i].channel_id != ADC_CHANNEL_IDX_INACTIVE) {\n\t\t\tnum_of_channels++;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size) {\n\t\tbuffer_size = sequence->buffer_size;\n\t} else {\n\t\tbuffer_size = num_of_channels * cfg->resolution / 8;\n\t}\n\n\tif (sequence->resolution == 16) {\n\t\tchannel_size = 2;\n\t} else {\n\t\tchannel_size = 1;\n\t}", "CodeBleu_score": 40.438945622096576}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *cfg = dev->config;\n\tuint8_t active_channels = 0;\n\tuint32_t buffer_size = 0;\n\tuint8_t i;\n\n\tfor (i = 0; i < ADC_AD559X_MAX_CHANNELS; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = active_channels * sequence->resolution;\n\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 42.28605841420886}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence){\n\tconst struct adc_ad559x_config *cfg = dev->config;\n\tuint8_t num_of_channels = 0;\n\tuint32_t buffer_size = 0;\n\n\t/* Check if the buffer size is sufficient */\n\tfor (uint8_t i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->resolution > 12) {\n\t\t\tLOG_ERR(\"Invalid resolution for channel %d\", sequence->channels);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (sequence->channels_buffer[i].scan_type != ADC_SCAN_DISABLED) {\n\t\t\tnum_of_channels++;\n\t\t}\n\t}\n\n\tbuffer_size = num_of_channels * (sequence->resolution / 8);\n\tif (sequence->buffer_size < buffer_size) {\n\t\tLOG_ERR(\"Buffer size is too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 38.98666510069149}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t channels;\n\tint ret;\n\n\tif (sequence->resolution != ADC_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid resolution.\");\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = POPCOUNT(sequence->channels);\n\n\tif (channels > ADC_CHANNEL_COUNT) {\n\t\tLOG_ERR(\"Too many channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Invalid buffer size.\");\n\t\treturn ret;\n\t}\n\n\tadc_ad559x_start_read_op(dev);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn adc_ad559x_get_result(dev, sequence->channels, sequence->buffer);\n}", "CodeBleu_score": 62.79162878565593}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tstruct adc_ad559x_config *config = dev->config;\n\tint ret = 0;\n\tuint16_t *buffer = sequence->buffer;\n\tuint8_t channels = POPCOUNT(sequence->channels);\n\n\t/* Check if resolution is supported */\n\tif (sequence->resolution != ADC_RESOLUTION) {\n\t\tLOG_ERR(\"ADC resolution not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if channels are valid */\n\tif (!(sequence->channels & config->channels)) {\n\t\tLOG_ERR(\"ADC channels not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check buffer size */\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t/* Set buffer */\n\tdata->buffer = buffer;\n\n\t/* Start read */\n\tret = adc_ad559x_start_read_conversion(dev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t/* Wait for read to complete */\n\tret = adc_ad559x_wait_read_complete(dev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 60.86108442032801}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence){\n\tstruct adc_ad559x_data *data = dev->data;\n\tint ret;\n\n\t/* Check if resolution matches. */\n\tif (sequence->resolution != data->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if channels are valid. */\n\tif (sequence->channels & ~(ADC_AD559X_VALID_CHANNELS)) {\n\t\tLOG_ERR(\"Invalid channels\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if buffer size is sufficient. */\n\tret = adc_ad559x_validate_buffer_size(dev, sequence);\n\tif (ret) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn ret;\n\t}\n\n\t/* Set buffer and start the read context. */\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\tdata->read_complete = false;\n\tadc_ad559x_start_read_context(dev);\n\n\t/* Wait for read operation to complete. */\n\tk_sem_take(&data->read_sem, K_FOREVER);\n\n\treturn 0;\n}", "CodeBleu_score": 61.33441796590448}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_data *data = ctx->data;\n\tuint32_t channels = data->channels;\n\tuint8_t *buffer = data->buffer;\n\tuint16_t repeat = data->repeat;\n\tuint16_t length = data->length;\n\tuint16_t i;\n\n\t/* Set the channels to be sampled. */\n\tadc_set_channels(data->adc, channels);\n\n\t/* Initialize the repeat buffer with the data buffer. */\n\tfor (i = 0; i < length; i++) {\n\t\trepeat[i] = buffer[i];\n\t}\n\n\t/* Start sampling. */\n\tadc_start_conversion(data->adc);\n\n\t/* Release the semaphore. */\n\tk_sem_give(data->sem);\n}", "CodeBleu_score": 45.798574164664615}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_data *data = ctx->data;\n  uint32_t channels = 0;\n  uint32_t i;\n\n  /* Get the channels to be sampled from the context */\n  for (i = 0; i < ctx->sequence.channels; i++) {\n    channels |= 1 << ctx->sequence.channels_list[i];\n  }\n\n  /* Set the channels to be sampled */\n  adc_set_channels(data->dev, channels, true);\n\n  /* Initialize the repeat buffer */\n  data->repeat_buffer_idx = 0;\n\n  /* Release the semaphore to start sampling */\n  adc_release_semaphore(data->dev);\n}", "CodeBleu_score": 30.898830117704524}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx){\n\tstruct adc_data *data = ctx->data;\n    uint32_t channels = ctx->channels;\n    uint32_t repeat = ctx->repeat;\n\n    /*\n     * Initialize the repeat buffer with the data buffer.\n     */\n    memcpy(data->repeat, data->buffer, sizeof(data->buffer));\n\n    /*\n     * Set the channels to be sampled.\n     */\n    adc_set_channels(data->dev, channels);\n\n    /*\n     * Release the semaphore to start sampling.\n     */\n    k_sem_give(data->sem);\n}", "CodeBleu_score": 49.58735746605861}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->data_container->buffer;\n\t}\n}", "CodeBleu_score": 47.50396399421106}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n\t\tctx->buffer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer = ctx->data_container->buffer;\n\t}\n}", "CodeBleu_score": 47.50396399421106}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling){\n\tif (repeat_sampling) {\n        ctx->buffer = ctx->repeat_buffer;\n    } else {\n        ctx->buffer = ctx->data_container->buffer;\n    }\n}", "CodeBleu_score": 48.86384730882591}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tstruct adc_ad559x_channel_data *chan_data;\n\tuint16_t result;\n\tuint8_t channel;\n\tint ret;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < config->num_channels; channel++) {\n\t\t\tchan_data = &data->chan[channel];\n\n\t\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOG_ERR(\"Error reading channel %d: %d\", channel, ret);\n\t\t\t\tchan_data->ctx.sampling_error = ret;\n\t\t\t\tchan_data->ctx.result = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan_data->ctx.result = result;\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\t}\n}", "CodeBleu_score": 54.3822260408651}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint16_t *buf = data->buffer;\n\tint ret;\n\tuint8_t channel;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (channel = 0; channel < AD559X_CHANNEL_COUNT; channel++) {\n\t\t\tif (data->active_channels & BIT(channel)) {\n\t\t\t\tret = adc_ad559x_read_channel(data->dev, channel, buf++);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d (%d)\", channel, ret);\n\t\t\t\t\tdata->status = ret;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdata->status = 0;\n\n\t\tk_sem_give(&data->sem);\n\t}\n\nexit:\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 49.26257799912095}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data){\n\tconst struct adc_ad559x_config *config = data->dev->config;\n\tuint8_t channel;\n\tint ret;\n\tuint16_t result;\n\n\t/* Wait for sampling to be started */\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\t/* Acquire data */\n\tfor (channel = 0; channel < config->channels; channel++) {\n\t\tif (!(data->active_channels & BIT(channel))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = adc_ad559x_read_channel(data->dev, channel, &result);\n\t\tif (ret < 0) {\n\t\t\tLOG_ERR(\"Failed to read channel %d: %d\", channel, ret);\n\t\t\tdata->status = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->buffer[channel] = result;\n\t}\n\n\t/* Signal that sampling is done */\n\tk_sem_give(&data->sem);\n}", "CodeBleu_score": 54.58972742437115}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[2] = {0};\n\tint rc = 0;\n\n\twhile (1) {\n\t\trc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\t\tif (rc) {\n\t\t\tLOG_ERR(\"Error reading configuration register\");\n\t\t\treturn rc;\n\t\t}\n\t\tif ((buf[1] & ADS1112_CONFIG_RDY) == ADS1112_CONFIG_RDY) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_USEC(100));\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 36.17183927605054}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[3] = {0};\n\tint rc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\tuint8_t reg_val = buf[2];\n\tuint8_t ready_mask = 0x01 << config->ready_bit;\n\n\tif (rc != 0) {\n\t\treturn rc;\n\t}\n\n\tif ((reg_val & ready_mask) == ready_mask) {\n\t\treturn 0;\n\t}\n\n\twhile (1) {\n\t\tk_sleep(K_USEC(100));\n\t\trc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\t\treg_val = buf[2];\n\n\t\tif ((reg_val & ready_mask) == ready_mask) {\n\t\t\treturn 0;\n\t\t}\n\t}\n}", "CodeBleu_score": 43.570364936182564}, {"code": "static int ads1112_wait_data_ready(const struct device *dev){\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[2] = {0};\n\tint rc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\tint i = 0;\n\n\tif (rc) {\n\t\tLOG_ERR(\"i2c_read_dt failed: %d\", rc);\n\t\treturn rc;\n\t}\n\n\twhile (buf[1] & ADS1112_CONFIG_REG_DRDY_MASK) {\n\t\tif (i > 100) {\n\t\t\tLOG_ERR(\"ADS1112 data not ready\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tk_usleep(100);\n\t\trc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\t\tif (rc) {\n\t\t\tLOG_ERR(\"i2c_read_dt failed: %d\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 39.785405334807194}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint buffer_size;\n\tint required_size;\n\tint num_samplings;\n\tint num_extra_samplings;\n\n\tif (sequence == NULL) {\n\t\tLOG_ERR(\"ADS1112: NULL pointer given for sequence.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options == NULL) {\n\t\tLOG_ERR(\"ADS1112: NULL pointer given for options.\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_samplings = sequence->num_samples;\n\tnum_extra_samplings = sequence->options->extra_samplings;\n\n\tif (num_samplings < 0) {\n\t\tLOG_ERR(\"ADS1112: Invalid number of samplings: %d\", num_samplings);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_extra_samplings < 0) {\n\t\tLOG_ERR(\"ADS1112: Invalid number of extra samplings: %d\", num_extra_samplings);\n\t\treturn -EINVAL;\n\t}\n\n\trequired_size = num_samplings + num_extra_samplings;\n\tbuffer_size = sequence->buffer_size;\n\n\tif (buffer_size < required_size) {\n\t\tLOG_ERR(\"ADS1112: Buffer size (%d) is insufficient for the number of samplings (%d) and extra samplings (%d).\", buffer_size, num_samplings, num_extra_samplings);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 43.56250178782464}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint required_buffer_size = sequence->options.extra_samplings * sequence->samplings;\n\tif (sequence->buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"Buffer size too small for sequence.\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "CodeBleu_score": 35.055994481046845}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence){\n\tint required_size;\n\tint i;\n\n\t/* Calculate the required buffer size */\n\trequired_size = sequence->num_channels * sequence->num_samplings;\n\n\t/* Check if the buffer size is sufficient */\n\tif (sequence->buffer_size < required_size) {\n\t\tLOG_ERR(\"The buffer size (%d) is not sufficient for the sequence (%d channels, %d samplings)\",\n\t\t\tsequence->buffer_size, sequence->num_channels, sequence->num_samplings);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if any extra samplings are specified in the sequence options */\n\tif (sequence->options && sequence->options->extra_samplings) {\n\t\t/* Calculate the required buffer size for the extra samplings */\n\t\trequired_size += sequence->num_channels * sequence->options->extra_samplings;\n\n\t\t/* Check if the buffer size is sufficient */\n\t\tif (sequence->buffer_size < required_size) {\n\t\t\tLOG_ERR(\"The buffer size (%d) is not sufficient for the sequence (%d channels, %d samplings, %d extra samplings)\",\n\t\t\t\tsequence->buffer_size, sequence->num_channels, sequence->num_samplings, sequence->options->extra_samplings);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check if any extra samplings are specified in the channel options */\n\tfor (i = 0; i < sequence->num_channels; i++) {\n\t\tif (sequence->channels[i].options && sequence->channels[i].options->extra_samplings) {\n\t\t\t/* Calculate the required buffer size for the extra samplings */\n\t\t\trequired_size += sequence->channels[i].options->extra_samplings;\n\n\t\t\t/* Check if the buffer size is sufficient */\n\t\t\tif (sequence->buffer_size < required_size) {\n\t\t\t\tLOG_ERR(\"The buffer size (%d) is not sufficient for the sequence (%d channels, %d samplings, %", "CodeBleu_score": 41.92737871924025}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tint rc;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported sequence options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\trc = ads1112_validate_sequence(dev, sequence);\n\tif (rc) {\n\t\tLOG_ERR(\"Invalid sequence config\");\n\t\treturn rc;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\trc = ads1112_start_read(dev);\n\tif (rc) {\n\t\tLOG_ERR(\"Failed to start read\");\n\t\treturn rc;\n\t}\n\n\tif (wait) {\n\t\trc = ads1112_wait_read(dev);\n\t}\n\n\treturn rc;\n}", "CodeBleu_score": 57.36847203766937}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tstruct ads1112_data *data = dev->data;\n\tint ret = 0;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Invalid Channel 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ads1112_validate_buffer_size(sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tdata->buffer = sequence->buffer;\n\n\tret = ads1112_start_read(dev);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_wait_read(dev);\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 50.59330477816773}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait){\n\tconst struct ads1112_data *data = dev->data;\n\tstruct ads1112_config *cfg = dev->config;\n\tint ret = 0;\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unsupported options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Invalid Channel 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < 1) {\n\t\tLOG_ERR(\"Buffer size too small\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size > ADS1112_MAX_SAMPLES) {\n\t\tLOG_ERR(\"Buffer size too large\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != ADS1112_RESOLUTION) {\n\t\tLOG_ERR(\"Invalid Resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * If the ADC is already reading, return an error\n\t */\n\tif (data->read_in_progress) {\n\t\tLOG_ERR(\"ADC already reading\");\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Assign the sequence buffer to the device data\n\t */\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_size = sequence->buffer_size;\n\n\t/*\n\t * Start the ADC read context\n\t */\n\tdata->read_in_progress = true;\n\tret = ads1112_start_read(dev);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to start read\");\n\t\tdata->read_in_", "CodeBleu_score": 46.029021008478026}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tint err;\n\tstruct device *dev;\n\tstruct audio_codec_config config;\n\tchar *endptr;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tconfig.gain = strtol(argv[2], &endptr, 10);\n\tif (*endptr != '\\0') {\n\t\tshell_error(sh, \"Invalid gain value\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = audio_codec_config(dev, &config);\n\tif (err) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 58.27042106375081}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tint err_code;\n\tstruct device *dev;\n\tstruct audio_codec_config *cfg;\n\tstruct audio_codec_properties *prop;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tcfg = (struct audio_codec_config *)dev->config;\n\tprop = &cfg->properties;\n\n\tif (argc < 4) {\n\t\tshell_error(sh, \"Not enough arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(argv[2], \"gain\") == 0) {\n\t\tif (argc < 5) {\n\t\t\tshell_error(sh, \"Not enough arguments\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprop->gain.enable = strtoul(argv[3], NULL, 0);\n\t\tprop->gain.gain = strtoul(argv[4], NULL, 0);\n\t} else if (strcmp(argv[2], \"mute\") == 0) {\n\t\tif (argc < 5) {\n\t\t\tshell_error(sh, \"Not enough arguments\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprop->mute.enable = strtoul(argv[3], NULL, 0);\n\t\tprop->mute.mute = strtoul(argv[4], NULL, 0);\n\t} else if (strcmp(argv[2], \"mode\") == 0) {\n\t\tif (argc < 5) {\n\t\t\tshell_error(sh, \"Not enough arguments\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprop->mode.enable = strtoul(argv[3], NULL, 0);\n\t\tprop->mode.mode = strtoul(argv[4], NULL, 0);\n\t} else if (strcmp(argv[2], \"mic_gain\") == 0) {\n\t\tif (argc <", "CodeBleu_score": 54.17357824339844}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]){\n\tint err_code = 0;\n\tstruct device *dev = NULL;\n\tconst struct device *dev_audio = device_get_binding(argv[1]);\n\n\tif (dev_audio == NULL) {\n\t\tLOG_ERR(\"Failed to get device binding for %s\", argv[1]);\n\t\terr_code = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (dev == NULL) {\n\t\tLOG_ERR(\"Failed to get device binding for %s\", argv[1]);\n\t\terr_code = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\terr_code = audio_codec_apply_props(dev);\n\tif (err_code != 0) {\n\t\tLOG_ERR(\"Failed to apply audio codec properties\");\n\t\tgoto exit;\n\t}\n\n\tLOG_INF(\"Audio codec properties applied\");\n\nexit:\n\treturn err_code;\n}", "CodeBleu_score": 45.834449750799706}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\t// define local variables\n    struct mpxxdtyy_dev_data *data = dev->data;\n    int ret = 0;\n\n    // check if the device is in the correct state for the trigger command\n    if (data->state == DMIC_STATE_CONFIGURED) {\n        // device is in the configured state, so send the start command\n        if (cmd == DMIC_TRIGGER_START) {\n            // send the start command\n            ret = mpxxdtyy_i2s_start(dev);\n            if (ret) {\n                // error occurred, so log the error\n                LOG_ERR(\"Failed to start I2S device", "CodeBleu_score": 16.453886557636853}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tstruct mpxxdtyy_data *data = dev->data;\n\tstruct mpxxdtyy_config *cfg = dev->config;\n\n\tif (data->state == DMIC_STATE_CONFIGURED) {\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\tLOG_DBG(\"I2S Start\");\n\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t\tif (i2s_trigger(data->i2s_dev, I2S_DIR_RX) != 0) {\n\t\t\t\tLOG_ERR(\"I2S Start failed\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tLOG_DBG(\"I2S Stop\");\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t\tif (i2s_trigger(data->i2s_dev, I2S_DIR_RX) != 0) {\n\t\t\t\tLOG_ERR(\"I2S Stop failed\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t} else if (data->state == DMIC_STATE_ACTIVE) {\n\t\tif (cmd == DMIC_TRIGGER_STOP) {\n\t\t\tLOG_DBG(\"I2S Stop\");\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t\tif (i2s_trigger(data->i2s_dev, I2S_DIR_RX) != 0) {\n\t\t\t\tLOG_ERR(\"I2S Stop failed\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"I2S Trigger failed, invalid state\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 41.01181967658128}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd){\n\tconst struct mpxxdtyy_i2s_dev_cfg * const cfg = dev->config;\n\tstruct mpxxdtyy_i2s_dev_data * const data = dev->data;\n\tstruct mpxxdtyy_i2s_dev_cfg * const cfg_ptr = dev->config;\n\tint err;\n\tuint32_t i2s_cmd;\n\n\tif (data->state == DMIC_STATE_INIT) {\n\t\t/* The device is in the init state. */\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t/* The device is in the init state and the start command was received. */\n\t\t\ti2s_cmd = I2S_CMD_START;\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t} else {\n\t\t\t/* The device is in the init state and the stop command was received. */\n\t\t\ti2s_cmd = I2S_CMD_STOP;\n\t\t\tdata->state = DMIC_STATE_INIT;\n\t\t}\n\t} else if (data->state == DMIC_STATE_CONFIGURED) {\n\t\t/* The device is in the configured state. */\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t/* The device is in the configured state and the start command was received. */\n\t\t\ti2s_cmd = I2S_CMD_START;\n\t\t\tdata->state = DMIC_STATE_ACTIVE;\n\t\t} else {\n\t\t\t/* The device is in the configured state and the stop command was received. */\n\t\t\ti2s_cmd = I2S_CMD_STOP;\n\t\t\tdata->state = DMIC_STATE_CONFIGURED;\n\t\t}\n\t} else if (data->state == DMIC_STATE_ACTIVE) {\n\t\t/* The device is in the active state. */\n\t\tif (cmd == DMIC_TRIGGER_START) {\n\t\t\t/* The device is in the active state and the start command was received. */\n\t\t\ti2", "CodeBleu_score": 51.82185286397123}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= BIT(1);\n\t}\n\n\tif (config->cursor_blink) {\n\t\tcmd |= BIT(3);\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= BIT(2);\n\t}\n\n\tif (config->display_shift) {\n\t\tcmd |= BIT(4);\n\t}\n\n\tif (config->display_enabled) {\n\t\tcmd |= BIT(5);\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 51.039189881252334}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0;\n\n\tif (enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_ENABLE;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_BLINK;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_ENABLE;\n\t}\n\n\tif (config->cursor_direction == AUXDISPLAY_HD44780_CURSOR_DIRECTION_RIGHT) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_CURSOR_DIRECTION_RIGHT;\n\t}\n\n\tif (config->display_shift_enabled) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT;\n\t}\n\n\tif (config->display_shift_direction == AUXDISPLAY_HD44780_DISPLAY_SHIFT_DIRECTION_RIGHT) {\n\t\tcmd |= AUXDISPLAY_HD44780_DISPLAY_MODE_DISPLAY_SHIFT_DIRECTION_RIGHT;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, AUXDISPLAY_HD44780_COMMAND_DISPLAY_MODE, AUXDISPLAY_HD44780_MODE_8_BIT);\n\tauxdisplay_hd44780_command(dev, false, cmd, AUXDISPLAY_HD44780_MODE_8_BIT);\n}", "CodeBleu_score": 60.29900113311461}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled){\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tuint8_t cmd = 0x00;\n\n\tif (enabled) {\n\t\tcmd |= 0x08;\n\t}\n\n\tif (config->cursor_blink_enabled) {\n\t\tcmd |= 0x02;\n\t}\n\n\tif (config->cursor_enabled) {\n\t\tcmd |= 0x01;\n\t}\n\n\tauxdisplay_hd44780_command(dev, true, cmd, config->mode);\n}", "CodeBleu_score": 43.40512841467129}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tstruct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\n\tif (config->busy_port == NULL) {\n\t\tLOG_ERR(\"Busy GPIO port is not defined\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_port, config->busy_pin);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Failed to read busy GPIO pin\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 58.22868966016179}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tstruct auxdisplay_itron_data *data = dev->data;\n\n    if (data->busy_gpio_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get(data->busy_gpio_port, data->busy_gpio_pin);\n}", "CodeBleu_score": 60.39262013421447}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev){\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tstruct auxdisplay_itron_cfg *cfg = dev->config;\n\n\tif (cfg->busy_gpio_port == NULL) {\n\t\tLOG_ERR(\"Busy GPIO port is not defined.\");\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn gpio_pin_get_raw(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n}", "CodeBleu_score": 52.11975652770005}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(data->i2c, buffer, sizeof(buffer), data->i2c_address);\n\tif (ret != 0) {\n\t\tLOG_ERR(\"Error writing to I2C device\");\n\t\treturn ret;\n\t}\n\n\tk_msleep(data->delay_ms);\n\n\treturn 0;\n}", "CodeBleu_score": 51.63671903151599}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buffer[2];\n\n\t/* Construct the buffer containing the special command prefix and the command itself. */\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = (uint8_t)command;\n\n\t/* Write the buffer to the device. */\n\tint rc = i2c_write(data->i2c, buffer, sizeof(buffer), data->i2c_address);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"I2C write error: %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/* Wait for the device to process the command. */\n\tk_sleep(data->delay_ms);\n\n\treturn rc;\n}", "CodeBleu_score": 53.86923852683996}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command){\n\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tuint8_t buf[2];\n\n\tbuf[0] = (uint8_t)command;\n\tbuf[1] = (uint8_t)command;\n\n\tif (i2c_write(data->i2c, buf, sizeof(buf), data->i2c_address) != 0) {\n\t\tLOG_ERR(\"Error while writing to the device.\");\n\t\treturn -EIO;\n\t}\n\n\tk_sleep(data->delay);\n\n\treturn 0;\n}", "CodeBleu_score": 49.617951123039425}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tuint8_t *emul_mem = emul_data->mem;\n\tsize_t mem_size = emul_data->mem_size;\n\tint ret;\n\n\tif (offset > mem_size) {\n\t\tLOG_ERR(\"Requested offset is out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (size > mem_size - offset) {\n\t\tLOG_ERR(\"Requested read size is out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid memory\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, emul_mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 55.574394618315495}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\n\tif (size > emul_data->size) {\n\t\tLOG_ERR(\"Invalid read size: %zu\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul_data->size) {\n\t\tLOG_ERR(\"Invalid read offset: %zu\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"Invalid read\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, emul_data->mem + offset, size);\n\n\treturn 0;\n}", "CodeBleu_score": 61.83994793357627}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data){\n\tstruct bbram_emul_data *emul_data = dev->data;\n\tuint8_t *bbram_data = emul_data->data;\n\tint rc = 0;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset >= emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > emul_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, bbram_data + offset, size);\n\n\treturn rc;\n}", "CodeBleu_score": 59.61163828854389}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tuint8_t *bbram = data->bbram;\n\tint err;\n\n\tif (size > data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset > data->size - size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram[offset], data, size);\n\n\terr = bbram_emul_write_status(dev);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 49.15231439392613}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *data = dev->data;\n\tint ret;\n\n\tif (size > data->max_write_size) {\n\t\tLOG_ERR(\"Invalid write size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data->max_write_size) {\n\t\tLOG_ERR(\"Write operation exceeds bounds of BBRAM\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = memcpy_s(data->memory + offset, size, data, size);\n\tif (ret != 0) {\n\t\tLOG_ERR(\"Failed to write data to BBRAM\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 53.40509707032002}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data){\n\tstruct bbram_emul_data *bbram_emul_data = dev->data;\n\tint err;\n\n\tif (size > bbram_emul_data->config->size) {\n\t\tLOG_ERR(\"Invalid write size %zu\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > bbram_emul_data->config->size) {\n\t\tLOG_ERR(\"Write would overflow BBRAM\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_check_invalid(dev)) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&bbram_emul_data->memory[offset], data, size);\n\n\treturn 0;\n}", "CodeBleu_score": 49.95115775294985}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"No device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 85.0786354748892}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tif (argc < 2) {\n\t\tshell_error(sh, \"No device specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}", "CodeBleu_score": 85.0786354748892}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev){\n\tint rc = 0;\n\tconst char *device_name = argv[1];\n\n\tif (argc != 2) {\n\t\tshell_error(sh, \"Error: Device not specified\");\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t*bbram_dev = device_get_binding(device_name);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Error: Device not found\");\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn rc;\n}", "CodeBleu_score": 55.52838947568487}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev){\n\tstruct h4_dev_data *dev_data = DEV_DATA(dev);\n    struct h4_hdr *hdr = &dev_data->hdr;\n    uint8_t *hdr_buf = (uint8_t *) hdr;\n    size_t bytes_read = 0;\n    size_t bytes_remaining = sizeof(*hdr);\n    int ret;\n\n    /*\n     * The header is 8 bytes long.  The first two bytes are the length of the\n     * payload.  The next four bytes are the CRC32 of the header and payload.\n     * The last byte is the header checksum.\n     */\n\n    /*\n     * Read the first two bytes of the header.  The length of the payload is\n     * stored in the first two bytes.\n     */\n    ret = uart_fifo_read(dev_data->uart_dev, (uint8_t *) &hdr->len, 2);\n    if (ret != 2) {\n        LOG_ERR(\"Failed to read header length\");\n        return;\n    }\n    bytes_read += ret;\n    bytes_remaining -= ret;\n\n    /*\n     * Read the remaining bytes of the header.\n     */\n    ret = uart_fifo_read(dev_data->uart_dev, hdr_buf + bytes_read, bytes_remaining);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to read header\");\n        return;\n    }\n    bytes_read += ret;\n    bytes_remaining -= ret;\n\n    /*\n     * Check the header checksum.\n     */\n    if (hdr_buf[bytes_read - 1] != h4_checksum(hdr_buf, bytes_read - 1)) {\n        LOG_ERR(\"Header checksum failed\");\n        return;\n    }\n\n    /*\n     * Check the header CRC.\n     */\n    if (hdr->crc != h4_crc32(hdr_buf, bytes_read - 4)) {\n        LOG_ERR(\"Header CRC failed\");\n        return;\n    }\n\n    /*", "CodeBleu_score": 40.152248427818336}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tuint8_t *p_data = h4_rx_buf;\n    int i;\n    int rx_len = h4_rx_len;\n    int rx_count = 0;\n    int rx_avail;\n    int rx_bytes;\n    int ret;\n    int hdr_len;\n    int hdr_rem;\n\n    /* Calculate the number of bytes already read */\n    hdr_len = p_data[0];\n    hdr_rem = hdr_len - 1;\n\n    /* Read the remaining bytes from the UART FIFO */\n    while (hdr_rem > 0) {\n        rx_avail = rx_len - rx_count;\n        if (rx_avail > hdr_rem) {\n            rx_bytes = hdr_rem;\n        } else {\n            rx_bytes = rx_avail;\n        }\n\n        ret = uart_fifo_read(dev, p_data + rx_count, rx_bytes);\n        if (ret < 0) {\n            LOG_ERR(\"h4_read_hdr: Error %d reading header data from UART FIFO\", ret);\n            return;\n        }\n\n        rx_count += ret;\n        hdr_rem -= ret;\n    }\n\n    /* Update the number of bytes already read */\n    h4_rx_len = rx_count;\n\n    /* Check the CRC */\n    for (i = 1; i < h4_rx_len; i++) {\n        if (p_data[i] != p_data[0]) {\n            LOG_ERR(\"h4_read_hdr: CRC error\");\n            return;\n        }\n    }\n}", "CodeBleu_score": 36.39254114391737}, {"code": "static void h4_read_hdr(const struct device *dev){\n\tuint8_t *hdr_buf = h4_rx_buf;\n\tuint8_t *hdr_buf_end = hdr_buf + H4_HDR_SIZE;\n\tuint8_t *hdr_buf_ptr = hdr_buf;\n\tuint8_t *hdr_buf_ptr_end = hdr_buf_end;\n\tuint8_t *hdr_buf_ptr_tmp;\n\tuint8_t hdr_buf_tmp;\n\tuint8_t hdr_len;\n\tuint8_t hdr_len_tmp;\n\tuint8_t hdr_len_tmp2;\n\tuint8_t hdr_len_tmp3;\n\tuint8_t hdr_len_tmp4;\n\tuint8_t hdr_len_tmp5;\n\tuint8_t hdr_len_tmp6;\n\tuint8_t hdr_len_tmp7;\n\tuint8_t hdr_len_tmp8;\n\tuint8_t hdr_len_tmp9;\n\tuint8_t hdr_len_tmp10;\n\tuint8_t hdr_len_tmp11;\n\tuint8_t hdr_len_tmp12;\n\tuint8_t hdr_len_tmp13;\n\tuint8_t hdr_len_tmp14;\n\tuint8_t hdr_len_tmp15;\n\tuint8_t hdr_len_tmp16;\n\tuint8_t hdr_len_tmp17;\n\tuint8_t hdr_len_tmp18;\n\tuint8_t hdr_len_tmp19;\n\tuint8_t hdr_len_tmp20;\n\tuint8_t hdr_len_tmp21;\n\tuint8_t hdr_len_tmp22;\n\tuint8_t hdr_len_tmp23;\n\tuint8_t hdr_len_tmp24;\n\tuint8_t hdr_len_tmp25;\n\tuint8_t hdr_len_tmp26;\n\tuint8_", "CodeBleu_score": 7.212897325650097}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n\tsize_t n;\n\tsize_t i;\n\tsize_t ret;\n\tsize_t r;\n\n\tif (len > sizeof(buf)) {\n\t\tlen = sizeof(buf);\n\t}\n\n\tret = 0;\n\tn = len;\n\tr = 0;\n\n\twhile (n > 0) {\n\t\tif (uart_fifo_read(uart, buf, n, &r) != 0) {\n\t\t\tLOG_ERR(\"Failed to read from UART FIFO\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tif (buf[i] == 0x0D) {\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\n\t\tn -= r;\n\t}\n\n\treturn ret;\n}", "CodeBleu_score": 50.30450476988075}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t ret = 0;\n    size_t i;\n\n    while (len > 0) {\n        i = len;\n        if (i > sizeof(buf)) {\n            i = sizeof(buf);\n        }\n        if (uart_fifo_read(uart, buf, i) != i) {\n            break;\n        }\n        ret += i;\n        len -= i;\n    }\n\n    return ret;\n}", "CodeBleu_score": 33.348151036546945}, {"code": "static size_t h4_discard(const struct device *uart, size_t len){\n\tuint8_t buf[33];\n    size_t ret;\n\n    while (len > 0) {\n        ret = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n        if (ret == 0) {\n            LOG_ERR(\"Error reading from UART FIFO\");\n            return 0;\n        }\n        len -= ret;\n    }\n\n    return len;\n}", "CodeBleu_score": 48.92725636159224}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tint i;\n\tint max = -1;\n\t\n\tfor (i = 0; i < ZBUS_CHAN_OBSERVERS; i++) {\n\t\tif (chan->observers[i].enabled && chan->observers[i].priority > max) {\n\t\t\tmax = chan->observers[i].priority;\n\t\t}\n\t}\n\t\n\tchan->highest_observer = max;\n}", "CodeBleu_score": 21.674128568190255}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tint i;\n\tint highest = 0;\n\tint highest_prio = 0;\n\t\n\tfor (i = 0; i < ZBUS_CHAN_OBSERVERS_MAX; i++) {\n\t\tif (chan->observers[i].enabled) {\n\t\t\tif (chan->observers[i].priority > highest_prio) {\n\t\t\t\thighest = i;\n\t\t\t\thighest_prio = chan->observers[i].priority;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tchan->highest_observer = highest;\n}", "CodeBleu_score": 25.243759338775583}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan){\n\tstruct zbus_observer *observer;\n\tint i, j, prio;\n\n\tprio = 0;\n\tfor (i = 0; i < chan->observer_count; i++) {\n\t\tobserver = &chan->observers[i];\n\t\tif (observer->enabled) {\n\t\t\tfor (j = 0; j < observer->observer_count; j++) {\n\t\t\t\tif (observer->observers[j].priority > prio) {\n\t\t\t\t\tprio = observer->observers[j].priority;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = prio;\n}", "CodeBleu_score": 32.63662532018008}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->observers_end_idx;\n\n\t\tfor (int16_t i = obs->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 21.10327736912844}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->observers_end_idx;\n\n\t\tfor (int16_t i = obs->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs != obs || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchan_update_hop(observation->chan);\n\t\t}\n\t}\n}", "CodeBleu_score": 30.632914814644742}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs){\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint chan_highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = obs->data->channels_end_idx;\n\n\t\tfor (int16_t i = obs->data->channels_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tif (observation->obs == obs) {\n\t\t\t\tchan_update_hop(observation->chan);\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 20.607913883095776}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tassert(!in_isr());\n\tassert(obs != NULL);\n\n\tspin_lock(&obs->lock);\n\tobs->priority = 0;\n\tupdate_all_channels_hop(obs);\n\tspin_unlock(&obs->lock);\n\n\treturn 0;\n}", "CodeBleu_score": 46.13251281309088}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tif (k_is_in_isr()) {\n\t\treturn -EPERM;\n\t}\n\n\tif (obs == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&obs_lock);\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs_lock, key);\n\n\treturn 0;\n}", "CodeBleu_score": 37.960260906638425}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs){\n\tint ret = 0;\n\n\t__ASSERT(!k_is_in_isr(), \"Cannot attach an observer in an ISR\");\n\t__ASSERT(obs != NULL, \"Cannot attach a NULL observer\");\n\n\tk_spinlock_key_t key = k_spin_lock(&obs->lock);\n\tobs->priority = K_LOWEST_THREAD_PRIO;\n\tupdate_all_channels_hop(obs);\n\tk_spin_unlock(&obs->lock, key);\n\n\treturn ret;\n}", "CodeBleu_score": 54.49106833248244}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tint prio = 0;\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tk_timepoint_t end_time = sys_time_timeout(timeout);\n\n\tif (k_is_in_isr()) {\n\t\tend_time = sys_time_max_delay;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 56.45635805803244}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"channel must be not NULL\");\n\n\tk_timepoint_t end_time;\n\n\tif (k_is_in_isr()) {\n\t\tend_time = K_TIMEOUT_ABS_MAX;\n\t} else {\n\t\tend_time = sys_time_timeout(timeout);\n\t}\n\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 55.23302243330234}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n\t_ZBUS_ASSERT(chan != NULL, \"zbus channel must not be NULL\");\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_timepoint_t end_time = sys_time_tick_get() + timeout;\n\tint prio = 0;\n\n\tint err = chan_lock(chan, timeout, &prio);\n\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _zbus_vded_exec(chan, end_time);\n\n\tchan_unlock(chan, prio);\n\n\treturn err;\n}", "CodeBleu_score": 58.52345385859685}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tuint32_t tmpreg;\n\n  /* Check the parameters */\n  assert_param(IS_ETH_CONFIG_IT(Int));\n\n  /* Get the ETHERNET MACMIIAR register value */\n  tmpreg = ETH->MACMIIAR;\n\n  /* Clear the ETHERNET interrupt bit */\n  tmpreg &= (uint32_t)~Int;\n\n  if (enable != FALSE) {\n    /* Enable the selected ETHERNET interrupt */\n    tmpreg |= Int;\n  }\n\n  /* Store the new value */\n  ETH->MACMIIAR = tmpreg;\n}", "CodeBleu_score": 27.78616627972869}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tuint32_t itmask = 0x00;\n    uint32_t itstatus = 0x00;\n    uint32_t itenable = 0x00;\n    uint32_t itenable_abnormal = 0x00;\n    uint32_t itenable_normal = 0x00;\n    uint32_t itenable_abnormal_mask = 0x00;\n    uint32_t itenable_normal_mask = 0x00;\n    uint32_t itenable_abnormal_shift = 0x00;\n    uint32_t itenable_normal_shift = 0x00;\n    uint32_t itenable_abnormal_shift_mask = 0x00;\n    uint32_t itenable_normal_shift_mask = 0x00;\n    uint32_t itenable_abnormal_shift_mask_mask = 0x00;\n    uint32_t itenable_normal_shift_mask_mask = 0x00;\n    uint32_t itenable_abnormal_shift_mask_shift = 0x00;\n    uint32_t itenable_normal_shift_mask_shift = 0x00;\n    uint32_t itenable_abnormal_shift_mask_shift_mask = 0x00;\n    uint32_t itenable_normal_shift_mask_shift_mask = 0x00;\n    uint32_t itenable_abnormal_shift_mask_shift_mask_mask = 0x00;\n    uint32_t itenable_normal_shift_mask_shift_mask_mask = 0x00;\n    uint32_t itenable_abnormal_shift_mask_shift_mask_shift = 0x00;\n    uint32_t itenable_normal_shift_mask_shift_mask_shift = 0x00;\n    uint32_t itenable_abnormal_shift_mask_shift_mask_shift_mask = 0x00;\n    uint32", "CodeBleu_score": 6.846364079833915}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable){\n\tif (enable) {\n    if (Int & ETH_INT_Msk) {\n      ETH->IER |= Int;\n    }\n  } else {\n    if (Int & ETH_INT_Msk) {\n      ETH->IER &= ~Int;\n    }\n  }\n}", "CodeBleu_score": 24.897861924496784}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *pTxDesc;\n\tuint32_t i;\n\n\t/* Get the current transmit descriptor address */\n\tpTxDesc = &ETH_TxDesc[ETH_TxDescIndex];\n\n\t/* Check if the descriptor is owned by the device */\n\tif ((pTxDesc->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET) {\n\t\t/* Current descriptor is still used by the device */\n\t\treturn 0;\n\t}\n\n\t/* Check if the descriptor is the last descriptor in the ring */\n\tif (ETH_TxDescIndex == (uint32_t)(ETH_TX_DESC_CNT - 1)) {\n\t\t/* Set the TxDescIndex to the first descriptor of the ring */\n\t\tETH_TxDescIndex = 0;\n\t\t/* Check if the first descriptor is free */\n\t\tpTxDesc = &ETH_TxDesc[ETH_TxDescIndex];\n\t\tif ((pTxDesc->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET) {\n\t\t\t/* First descriptor is still used by the device */\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/* Increment current descriptor index */\n\t\tETH_TxDescIndex++;\n\t}\n\n\t/* Return the descriptor */\n\treturn pTxDesc;\n}", "CodeBleu_score": 40.622338239289}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *txDesc;\n\n\ttxDesc = (ETH_TX_DESC *)(ETH_BASE + ETH_TX_DESC_ADDR);\n\n\twhile (txDesc->status & ETH_TX_DESC_STATUS_OWN) {\n\t\ttxDesc = (ETH_TX_DESC *)((uint32_t)txDesc + ETH_TX_DESC_SIZE);\n\n\t\tif (txDesc == (ETH_TX_DESC *)(ETH_BASE + ETH_TX_DESC_ADDR)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn txDesc;\n}", "CodeBleu_score": 48.734732303276346}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void){\n\tETH_TX_DESC *tx_desc;\n\n\ttx_desc = (ETH_TX_DESC *) ETH_TX_DESC_BASE;\n\n\twhile (tx_desc->status & ETH_TX_DESC_STATUS_OWN) {\n\t\ttx_desc = (ETH_TX_DESC *) (tx_desc->next_desc_addr);\n\t\tif (tx_desc == (ETH_TX_DESC *) ETH_TX_DESC_BASE) {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (tx_desc);\n}", "CodeBleu_score": 46.213056509748945}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n    struct cyp_dac *cyp_dac = (struct cyp_dac *)device->parent.user_data;\n    rt_uint32_t cyp_dac_channel = 0;\n\n    if (device == RT_NULL)\n    {\n        LOG_E(\"DAC device is NULL\");\n        return -RT_EIO;\n    }\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    if (cyp_dac_channel == 0)\n    {\n        LOG_E(\"DAC channel is invalid\");\n        return -RT_EIO;\n    }\n\n    if (value == RT_NULL)\n    {\n        LOG_E(\"DAC value is NULL\");\n        return -RT_EIO;\n    }\n\n    if (cyp_dac->cyp_dac_status == 0)\n    {\n        result = cyp_dac_init(cyp_dac);\n        if (result != RT_EOK)\n        {\n            LOG_E(\"DAC init failed\");\n            return result;\n        }\n    }\n\n    result = cyp_dac_output_enable(cyp_dac, cyp_dac_channel);\n    if (result != RT_EOK)\n    {\n        LOG_E(\"DAC output enable failed\");\n        return result;\n    }\n\n    result = cyp_dac_output_value_set(cyp_dac, cyp_dac_channel, *value);\n    if (result != RT_EOK)\n    {\n        LOG_E(\"DAC output value set failed\");\n        return result;\n    }\n\n    return result;\n}", "CodeBleu_score": 51.24115374314757}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t result = RT_EOK;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    struct cyp_dac_device *cyp_dac_device = (struct cyp_dac_device *)device;\n    rt_uint32_t cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    result = Cy_CSDIDAC_OutputEnable(cyp_dac_device->base, cyp_dac_channel, *value);\n    if (result != CY_CSDIDAC_SUCCESS)\n    {\n        LOG_E(\"Failed to enable DAC channel %d with value %d.\", cyp_dac_channel, *value);\n        result = -RT_ERROR;\n    }\n\n    return result;\n}", "CodeBleu_score": 57.0407937508207}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value){\n\trt_err_t ret = RT_EOK;\n    rt_uint32_t cyp_dac_channel = 0;\n    rt_uint32_t cyp_dac_value = 0;\n    struct cyp_dac_device *cyp_dac_dev = NULL;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cyp_dac_dev = (struct cyp_dac_device *)device;\n\n    cyp_dac_channel = cyp_dac_get_channel(channel);\n\n    cyp_dac_value = *value;\n\n    if (cyp_dac_dev->cyp_dac_handle == RT_NULL) {\n        ret = cyp_dac_init(cyp_dac_dev);\n        if (ret != RT_EOK) {\n            rt_kprintf(\"cyp_dac_init failed!\n\");\n            return ret;\n        }\n    }\n\n    ret = Cy_CSDIDAC_OutputEnable(cyp_dac_dev->cyp_dac_handle, cyp_dac_channel, cyp_dac_value);\n    if (ret != CY_CSDIDAC_SUCCESS) {\n        rt_kprintf(\"Cy_CSDIDAC_OutputEnable failed!\n\");\n        return ret;\n    }\n\n    return ret;\n}", "CodeBleu_score": 49.92295329116514}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\trt_uint32_t i;\n\n\tif ((addr + size) > (IFX_FLASH_SIZE)) {\n\t\tIFX_PRINT(\"ifx_flash_read_32k: invalid address\n\");\n\t\treturn IFX_ERROR;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *)(addr + i);\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 52.066917109964805}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > IFX_FLASH_32K_END_ADDR) {\n\t\trt_kprintf(\"ifx_flash_read_32k: read address exceeds flash memory end address\n\");\n\t\treturn IFX_ERROR;\n\t}\n\n\tfor (rt_uint32_t i = 0; i < size; i++) {\n\t\tbuf[i] = *((rt_uint8_t *)(addr + i));\n\t}\n\n\treturn size;\n}", "CodeBleu_score": 41.90213856510451}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size){\n\tif (addr + size > FLASH_32K_END) {\n        LOG_E(\"ifx_flash_read_32k: Invalid argument\");\n        return -RT_EINVAL;\n    }\n\n    rt_uint32_t i;\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(FLASH_32K_BASE + addr + i);\n    }\n\n    return size;\n}", "CodeBleu_score": 48.52604026589693}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    rt_uint32_t count = 0;\n    cyhal_timer_t *timer_obj = (cyhal_timer_t *) timer->parent.user_data;\n    RT_ASSERT(timer_obj != RT_NULL);\n    count = cyhal_timer_read(timer_obj);\n    return count;\n}", "CodeBleu_score": 65.69497028958695}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != RT_NULL);\n    rt_uint32_t count = 0;\n    cyhal_timer_t *obj = (cyhal_timer_t *) timer->parent.user_data;\n    count = cyhal_timer_read(obj);\n    return count;\n}", "CodeBleu_score": 65.58722655794669}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer){\n\tRT_ASSERT(timer != NULL);\n    struct rt_cyhal_timer *cy_timer = (struct rt_cyhal_timer *)timer->parent.user_data;\n    return cyhal_timer_read(cy_timer->timer);\n}", "CodeBleu_score": 22.869192398175635}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void){\n\twhile (true) {\n        int32_t ret = pthread_mutex_lock(&dfs_lock_mutex);\n        if (ret == 0) {\n            break;\n        } else if (ret == EBUSY) {\n            continue;\n        } else {\n            assert(false);\n        }\n    }\n}", "CodeBleu_score": 30.71132721734523}, {"code": "void dfs_lock(void){\n\tint rc;\n    while ((rc = pthread_mutex_lock(&dfs_lock_mutex)) != 0) {\n        if (rc != EBUSY) {\n            assert(0);\n        }\n    }\n}", "CodeBleu_score": 36.75279611240645}, {"code": "void dfs_lock(void){\n\tint i;\n\n  for (i = 0; i < 10000; i++) {\n    if (pthread_mutex_trylock(&dfs_lock_mutex) == 0) {\n      return;\n    }\n  }\n  assert(0);\n}", "CodeBleu_score": 25.104158600183908}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (fdt->fds[fd] == NULL)\n        {\n            break;\n        }\n    }\n\n    if (fd >= fdt->maxfd)\n    {\n        fd = fd_slot_expand(fdt, fd);\n    }\n\n    return fd;\n}", "CodeBleu_score": 37.31914396688959}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint fd;\n    int index;\n    struct dfs_file **fds = NULL;\n\n    if (startfd < 0)\n    {\n        startfd = 0;\n    }\n\n    for (fd = startfd; fd < fdt->maxfd; fd++)\n    {\n        if (!fdt->fds[fd])\n        {\n            return fd;\n        }\n    }\n\n    fd = fd_slot_expand(fdt, fd);\n    if (fd < 0)\n    {\n        return -1;\n    }\n\n    fds = (struct dfs_file **)rt_realloc(fdt->fds, fd * sizeof(struct dfs_file *));\n    if (!fds)\n    {\n        return -1;\n    }\n    fdt->fds = fds;\n\n    return fd;\n}", "CodeBleu_score": 44.98419491335272}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd){\n\tint i;\n\n    if (fdt->maxfd <= startfd)\n    {\n        return -1;\n    }\n\n    for (i = startfd; i < fdt->maxfd; i++)\n    {\n        if (fdt->fds[i] == NULL)\n        {\n            return i;\n        }\n    }\n\n    return fd_slot_expand(fdt, startfd);\n}", "CodeBleu_score": 44.56158820702102}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error){\n\tif (error < 0) {\n        error = -error;\n    }\n    switch (error) {\n        case RT_ERR_NONE:\n            return \"RT_ERR_NONE\";\n        case RT_ERR_UNKNOWN:\n            return \"RT_ERR_UNKNOWN\";\n        case RT_ERR_NO_MEM:\n            return \"RT_ERR_NO_MEM\";\n        case RT_ERR_INV_VAL:\n            return \"RT_ERR_INV_VAL\";\n        case RT_ERR_NOT_FOUND:\n            return \"RT_ERR_NOT_FOUND\";\n        case RT_ERR_INV_OP:\n            return \"RT_ERR_INV_OP\";\n        case RT_ERR_NOT_INIT:\n            return \"RT_ERR_NOT_INIT\";\n        case RT_ERR_NOT_SUPPORTED:\n            return \"RT_ERR_NOT_SUPPORTED\";\n        case RT_ERR_TIMEOUT:\n            return \"RT_ERR_TIMEOUT\";\n        case RT_ERR_BUSY:\n            return \"RT_ERR_BUSY\";\n        case RT_ERR_INV_STATE:\n            return \"RT_ERR_INV_STATE\";\n        case RT_ERR_ALREADY_INIT:\n            return \"RT_ERR_ALREADY_INIT\";\n        case RT_ERR_ALREADY_EXISTS:\n            return \"RT_ERR_ALREADY_EXISTS\";\n        case RT_ERR_NO_MORE:\n            return \"RT_ERR_NO_MORE\";\n        case RT_ERR_INV_CONTEXT:\n            return \"RT_ERR_INV_CONTEXT\";\n        case RT_ERR_INV_DEV:\n            return \"RT_ERR_INV_DEV\";\n        case RT_ERR_INV_CH:\n            return \"RT_ERR_INV_CH\";\n        case RT_ERR_INV_PORT:\n            return \"RT_ERR_INV_PORT\";\n        case RT_ERR_INV_QUEUE_ID:", "CodeBleu_score": 31.673530699099917}, {"code": "const char *rt_strerror(rt_err_t error){\n\tif (error < 0) {\n        error = -error;\n    }\n    switch (error) {\n        case RT_ERR_NONE:\n            return \"RT_ERR_NONE\";\n        case RT_ERR_UNKNOWN:\n            return \"RT_ERR_UNKNOWN\";\n        case RT_ERR_INVALID_VALUE:\n            return \"RT_ERR_INVALID_VALUE\";\n        case RT_ERR_NO_MEMORY:\n            return \"RT_ERR_NO_MEMORY\";\n        case RT_ERR_NOT_INITIALIZED:\n            return \"RT_ERR_NOT_INITIALIZED\";\n        case RT_ERR_NOT_SUPPORTED:\n            return \"RT_ERR_NOT_SUPPORTED\";\n        case RT_ERR_TIMEOUT:\n            return \"RT_ERR_TIMEOUT\";\n        case RT_ERR_BUSY:\n            return \"RT_ERR_BUSY\";\n        case RT_ERR_INVALID_STATE:\n            return \"RT_ERR_INVALID_STATE\";\n        case RT_ERR_INVALID_DATA:\n            return \"RT_ERR_INVALID_DATA\";\n        case RT_ERR_INVALID_DEVICE:\n            return \"RT_ERR_INVALID_DEVICE\";\n        case RT_ERR_INVALID_PIN:\n            return \"RT_ERR_INVALID_PIN\";\n        case RT_ERR_INVALID_ARG:\n            return \"RT_ERR_INVALID_ARG\";\n        case RT_ERR_INVALID_REG:\n            return \"RT_ERR_INVALID_REG\";\n        case RT_ERR_INVALID_OPERATION:\n            return \"RT_ERR_INVALID_OPERATION\";\n        case RT_ERR_INVALID_LEN:\n            return \"RT_ERR_INVALID_LEN\";\n        case RT_ERR_INVALID_ADDR:\n            return \"RT_ERR_INVALID_ADDR\";\n        case RT_ERR_INVALID_SIZE:\n            return \"RT_ERR_INVALID_SIZE\";\n        case R", "CodeBleu_score": 31.526494827844566}, {"code": "const char *rt_strerror(rt_err_t error){\n\tstatic const char *err_str[] = {\n        \"EOK\",\n        \"EUNKNOW\",\n        \"EINVAL\",\n        \"ENOMEM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"EAGAIN\",\n        \"EINTR\",\n        \"EOVERFLOW\",\n        \"EUNFINISHED\",\n        \"EUNFINISHED_COPY\",\n        \"EUNFINISHED_WRITE\",\n        \"EUNFINISHED_READ\",\n        \"EUNFINISHED_SEEK\",\n        \"EUNFINISHED_TELL\",\n        \"EUNFINISHED_FLUSH\",\n        \"EUNFINISHED_TRUNCATE\",\n        \"EUNFINISHED_SYNC\",\n        \"EUNFINISHED_CLOSE\",\n        \"EUNFINISHED_FREE\",\n        \"EUNFINISHED_SEEKABLE\",\n        \"EUNFINISHED_GET_SIZE\",\n        \"EUNFINISHED_SET_SIZE\",\n        \"EUNFINISHED_RESIZE\",\n        \"EUNFINISHED_APPEND\",\n        \"EUNFINISHED_GET_POS\",\n        \"EUNFINISHED_SET_POS\",\n        \"EUNFINISHED_SEEK_SET\",\n        \"EUNFINISHED_SEEK_CUR\",\n        \"EUNFINISHED_SEEK_END\",\n        \"EUNFINISHED_TELL_SET\",\n        \"EUNFINISHED_TELL_CUR\",\n        \"EUNFINISHED_TELL_END\",\n        \"EUNFINISHED_FLUSHABLE\",\n        \"EUNFINISHED_FLUSHABLE_SET\",\n        \"EUNFINISHED_FLUSHABLE_GET\",\n        \"EUNFINISHED_CLOSEABLE\",\n        \"EUNFINISHED_CLOSE", "CodeBleu_score": 5.89316872116635}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n    rt_thread_t idle;\n    rt_list_t *node;\n\n    idle = rt_thread_find(\"idle\");\n    if (idle == RT_NULL) return -RT_ERROR;\n\n    level = rt_hw_interrupt_disable();\n    for (node = idle->idle_hook.next; node != &idle->idle_hook; node = node->next) {\n        if (((rt_list_t *)node)->next == node) {\n            ((rt_list_t *)node)->next = (rt_list_t *)hook;\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n    }\n    rt_hw_interrupt_enable(level);\n\n    return -RT_EFULL;\n}", "CodeBleu_score": 41.48998746956782}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_base_t level;\n    rt_err_t result;\n    rt_uint8_t i;\n\n    level = rt_hw_interrupt_disable();\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i] == RT_NULL) {\n            rt_thread_idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}", "CodeBleu_score": 66.95120759457348}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void)){\n\trt_err_t result;\n\trt_uint32_t i;\n\trt_spin_lock(&idle_hook_lock);\n\tfor (i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (idle_hook_list[i] == RT_NULL) {\n\t\t\tidle_hook_list[i] = hook;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\trt_spin_unlock(&idle_hook_lock);\n\treturn result;\n}", "CodeBleu_score": 60.0379501692913}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_base_t level;\n    rt_thread_t tid;\n    rt_list_t *node;\n    rt_thread_idle_hook_t *hook_list;\n\n    level = rt_hw_interrupt_disable();\n\n    tid = rt_thread_self();\n    if (tid->stat == RT_THREAD_CLOSE)\n    {\n        rt_hw_interrupt_enable(level);\n        return -RT_ERROR;\n    }\n\n    if (tid->stat != RT_THREAD_READY)\n    {\n        rt_hw_interrupt_enable(level);\n        return -RT_ERROR;\n    }\n\n    /* find hook in list */\n    hook_list = &(tid->idle_hook);\n    for (node = hook_list->next; node != hook_list; node = node->next)\n    {\n        if (((rt_thread_idle_hook_t)node)->hook == hook)\n        {\n            /* found hook, delete it */\n            rt_list_remove(node);\n\n            /* enable interrupt */\n            rt_hw_interrupt_enable(level);\n\n            return RT_EOK;\n        }\n    }\n\n    /* disable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return -RT_ERROR;\n}", "CodeBleu_score": 37.3224780013865}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_list_t *node;\n    rt_list_t *head;\n    rt_spin_lock(&_idle_hook_lock);\n    head = &_idle_hook_list;\n    for (node = head->next; node != head; node = node->next) {\n        if (((rt_thread_idle_hook_t) node->content)->hook == hook) {\n            rt_list_remove(node);\n            rt_free(node);\n            rt_spin_unlock(&_idle_hook_lock);\n            return RT_EOK;\n        }\n    }\n    rt_spin_unlock(&_idle_hook_lock);\n    return -RT_ERROR;\n}", "CodeBleu_score": 47.55697742025063}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void)){\n\trt_spinlock_t lock;\n    rt_thread_idle_hook_t *hook_list;\n    rt_thread_idle_hook_t *hook_ptr;\n    rt_thread_idle_hook_t *hook_prev;\n    rt_err_t result;\n\n    /* lock idle hook list */\n    lock = rt_thread_idle_hook_list_lock;\n    RT_ASSERT(lock != RT_NULL);\n    rt_spin_lock(lock);\n\n    /* find specified hook */\n    hook_list = rt_thread_idle_hook_list;\n    hook_ptr = hook_list;\n    while (hook_ptr != RT_NULL) {\n        if (hook_ptr->hook == hook) {\n            break;\n        }\n\n        hook_prev = hook_ptr;\n        hook_ptr = hook_ptr->next;\n    }\n\n    /* hook not found */\n    if (hook_ptr == RT_NULL) {\n        result = -RT_ENOSYS;\n        goto __exit;\n    }\n\n    /* remove hook */\n    if (hook_ptr == hook_list) {\n        rt_thread_idle_hook_list = hook_ptr->next;\n    } else {\n        hook_prev->next = hook_ptr->next;\n    }\n\n    /* free hook */\n    rt_free(hook_ptr);\n\n    /* idle hook list empty */\n    if (rt_thread_idle_hook_list == RT_NULL) {\n        rt_thread_idle_hook_list_lock = RT_NULL;\n    }\n\n    result = RT_EOK;\n\n__exit:\n    /* unlock idle hook list */\n    rt_spin_unlock(lock);\n\n    return result;\n}", "CodeBleu_score": 40.89134511176276}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n    rt_err_t ret;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* Ensure the scheduler is unlocked */\n    rt_scheduler_unlock();\n\n    /* Dequeue and wake up each thread from the suspension list one by one */\n    while (!rt_list_isempty(susp_list)) {\n        /* Dequeue a thread from the suspension list */\n        thread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n        rt_list_remove(&(thread->tlist));\n\n        /* Change the thread state to ready */\n        thread->stat = RT_THREAD_READY;\n        thread->error = thread_error;\n\n        /* Wake up the thread */\n        ret = rt_thread_wakeup(thread);\n        if (ret != RT_EOK) {\n            return ret;\n        }\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 33.466921496724936}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n    rt_list_t *node;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* ensure scheduler is unlocked */\n    if (rt_thread_self() != RT_NULL) {\n        rt_enter_critical();\n    }\n\n    /* dequeue and wake up each thread from the suspension list */\n    while (!rt_list_isempty(susp_list)) {\n        node = rt_list_first(susp_list);\n        rt_list_remove(node);\n\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        thread->error = thread_error;\n\n        rt_thread_resume(thread);\n    }\n\n    /* release scheduler lock */\n    if (rt_thread_self() != RT_NULL) {\n        rt_exit_critical();\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 38.61946771031114}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error){\n\trt_thread_t thread;\n    rt_list_t *node;\n\n    /* Ensure the scheduler is unlocked */\n    RT_ASSERT(rt_is_scheduler_locked() == RT_FALSE);\n\n    /* Dequeue and wake up each suspended thread from the list */\n    while (!rt_list_isempty(susp_list)) {\n        node = rt_list_entry(susp_list->next, rt_list_t, list);\n        thread = rt_list_entry(node, rt_thread_t, tlist);\n        rt_list_remove(node);\n        rt_thread_resume(thread, thread_error);\n    }\n\n    return RT_EOK;\n}", "CodeBleu_score": 42.339247827629336}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console, new_console;\n    rt_err_t ret;\n\n    old_console = rt_console_get_device();\n    if (old_console == RT_NULL) {\n        return RT_NULL;\n    }\n\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (old_console == new_console) {\n        return old_console;\n    }\n\n    if ((new_console->type != RT_Device_Class_Char) ||\n        (new_console->rx_indicate == RT_NULL)) {\n        return RT_NULL;\n    }\n\n    ret = rt_device_close(old_console);\n    if (ret != RT_EOK) {\n        return RT_NULL;\n    }\n\n    ret = rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (ret != RT_EOK) {\n        return RT_NULL;\n    }\n\n    rt_console_set_device(new_console);\n\n    return old_console;\n}", "CodeBleu_score": 51.95203774926074}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console;\n    rt_device_t new_console;\n\n    /* save current console device */\n    old_console = rt_console_get_device();\n\n    /* find new console device */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        rt_kprintf(\"Can't find device %s!", "CodeBleu_score": 22.01200656347741}, {"code": "rt_device_t rt_console_set_device(const char *name){\n\trt_device_t old_console, new_console;\n\n    old_console = rt_console_get_device();\n    new_console = rt_device_find(name);\n    if (new_console != RT_NULL) {\n        if (new_console != old_console) {\n            if (old_console != RT_NULL) {\n                rt_device_close(old_console);\n            }\n            rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n            rt_console_set_device(new_console);\n        }\n    }\n\n    return old_console;\n}", "CodeBleu_score": 56.37066185894318}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint count = 0;\n    struct rt_object *object;\n    unsigned long flags;\n\n    spin_lock_irqsave(&rt_object_spinlock, &flags);\n\n    list_for_each_entry(object, &rt_object_list, list) {\n        if (object->type == type) {\n            count++;\n        }\n    }\n\n    spin_unlock_irqrestore(&rt_object_spinlock, &flags);\n\n    return count;\n}", "CodeBleu_score": 45.50395306305355}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint count = 0;\n\tstruct rt_object *object;\n\tunsigned long flags;\n\tspin_lock_irqsave(&rt_object_lock, flags);\n\tlist_for_each_entry(object, &rt_object_list, list) {\n\t\tif (object->type == type) {\n\t\t\tcount++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rt_object_lock, flags);\n\treturn count;\n}", "CodeBleu_score": 41.32574458283598}, {"code": "int rt_object_get_length(enum rt_object_class_type type){\n\tint i, count = 0;\n\tstruct rt_object_information *object_info;\n\n\tobject_info = rt_object_get_info(type);\n\tif (object_info == NULL) {\n\t\treturn 0;\n\t}\n\n\tspin_lock(&object_info->lock);\n\tfor (i = 0; i < object_info->max_number; i++) {\n\t\tif (object_info->object_array[i].object != NULL) {\n\t\t\tcount++;\n\t\t}\n\t}\n\tspin_unlock(&object_info->lock);\n\n\treturn count;\n}", "CodeBleu_score": 35.664194850946615}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object){\n\t/* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* object type check */\n    RT_ASSERT(object->type != RT_Object_Class_Static);\n\n    /* invoke detach hook */\n    if (object->ops->detach != RT_NULL) {\n        object->ops->detach(object);\n    }\n\n    /* get object information */\n    struct rt_object_information *information = RT_OBJECT_GET_INFO(object);\n\n    /* lock object */\n    rt_spin_lock(&information->lock);\n\n    /* remove from list */\n    if (information->object_list.next != RT_NULL) {\n        rt_list_remove(&(object->list));\n    }\n\n    /* unlock object */\n    rt_spin_unlock(&information->lock);\n\n    /* set object type to zero */\n    object->type = RT_Object_Class_Static;\n}", "CodeBleu_score": 57.78548065016991}, {"code": "void rt_object_detach(rt_object_t object){\n\trt_object_information_t object_info;\n\n    if (object == RT_NULL) {\n        return;\n    }\n\n    object_info = object->object_info;\n\n    /* detach object */\n    if (object_info->detach_hook != RT_NULL) {\n        object_info->detach_hook(object);\n    }\n\n    /* remove object from object list */\n    rt_enter_critical();\n    if (object_info->object_list.next != RT_NULL) {\n        object_info->object_list.next->prev = object_info->object_list.prev;\n        object_info->object_list.prev->next = object_info->object_list.next;\n    }\n    rt_exit_critical();\n\n    /* set object type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 40.006892576403935}, {"code": "void rt_object_detach(rt_object_t object){\n\trt_object_info_t object_info;\n\n    /* check object */\n    if (object == RT_NULL) {\n        return;\n    }\n\n    /* get object information */\n    object_info = (rt_object_info_t)object->object_info;\n\n    /* check object type */\n    if (object_info->type == RT_Object_Class_Static) {\n        return;\n    }\n\n    /* lock object */\n    rt_enter_critical();\n\n    /* detach object */\n    object_info->object_list->object_next = object_info->object_list->object_next->object_next;\n    object_info->object_list->object_next->object_prev = object_info->object_list->object_next;\n\n    /* unlock object */\n    rt_exit_critical();\n\n    /* set object type to zero */\n    object->type = 0;\n\n    /* invoke detach hook */\n    if (object_info->detach_hook != RT_NULL) {\n        object_info->detach_hook(object);\n    }\n}", "CodeBleu_score": 37.40277508985132}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t result;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    if (obj->ops->control != RT_NULL) {\n        result = obj->ops->control(obj, RT_Object_Command_Delete, RT_NULL);\n    } else {\n        result = RT_EOK;\n    }\n\n    rt_object_delete(obj);\n\n    return result;\n}", "CodeBleu_score": 47.9004046900877}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t ret = RT_EOK;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    if (obj->ops->destructor != RT_NULL) {\n        ret = obj->ops->destructor(obj);\n    }\n\n    rt_object_delete(obj);\n\n    return ret;\n}", "CodeBleu_score": 50.91831057198228}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj){\n\trt_err_t ret = RT_EOK;\n\n    /* object check */\n    RT_ASSERT(obj != RT_NULL);\n    RT_ASSERT(obj->type != RT_Object_Class_Static);\n    RT_ASSERT(obj->type == RT_Object_Class_Custom);\n\n    /* call custom object's destroy method */\n    if (obj->ops->destroy != RT_NULL)\n    {\n        ret = obj->ops->destroy(obj);\n    }\n\n    /* delete the object */\n    rt_object_delete(obj);\n\n    return ret;\n}", "CodeBleu_score": 52.486194482134074}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void){\n\trt_thread_t self;\n\n    self = rt_thread_self();\n\n    /* enter critical */\n    rt_enter_critical();\n\n    /* thread is not initialized */\n    if (self->stat == RT_THREAD_CLOSE)\n    {\n        /* leave critical */\n        rt_exit_critical();\n\n        return;\n    }\n\n    /* thread is initialized */\n    if (self->stat == RT_THREAD_INIT)\n    {\n        /* thread is initialized but not started */\n        rt_schedule();\n\n        /* leave critical */\n        rt_exit_critical();\n\n        return;\n    }\n\n    /* thread is running */\n    if (self->stat == RT_THREAD_RUNNING)\n    {\n        /* thread is running and not suspended */\n        if (self->stat & RT_THREAD_STAT_MASK)\n        {\n            /* thread is running and not suspended, suspend it */\n            rt_thread_suspend(self);\n        }\n    }\n\n    /* thread is suspended */\n    if (self->stat == RT_THREAD_SUSPEND)\n    {\n        /* thread is suspended, resume it */\n        rt_thread_resume(self);\n    }\n\n    /* thread is suspended */\n    if (self->stat == RT_THREAD_SUSPEND)\n    {\n        /* thread is suspended, resume it */\n        rt_thread_resume(self);\n    }\n\n    /* thread is suspended */\n    if (self->stat == RT_THREAD_SUSPEND)\n    {\n        /* thread is suspended, resume it */\n        rt_thread_resume(self);\n    }\n\n    /* thread is suspended */\n    if (self->stat == RT_THREAD_SUSPEND)\n    {\n        /* thread is suspended, resume it */\n        rt_thread_resume(self);\n    }\n\n    /* thread is suspended */\n    if (self->stat == RT_TH", "CodeBleu_score": 51.59154350075382}, {"code": "static void _thread_exit(void){\n\trt_thread_t self;\n\n    self = rt_thread_self();\n\n    /* thread exit */\n    rt_thread_close(self);\n\n    /* insert to defunct thread list */\n    rt_thread_detach(self);\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 52.245677112720124}, {"code": "static void _thread_exit(void){\n\trt_thread_t self = rt_thread_self();\n\n    /* thread exit */\n    rt_thread_close(self);\n\n    /* add to defunct thread list */\n    rt_thread_detach(self);\n\n    /* schedule */\n    rt_schedule();\n}", "CodeBleu_score": 47.2952834795952}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter){\n\t/*\n     * Verify that the thread is suspended.\n     */\n    if (((struct thread *) parameter)->state != THREAD_STATE_SUSPENDED) {\n\n        /*\n         * The thread is not suspended.\n         */\n        return;\n    }\n\n    /*\n     * Lock the scheduler.\n     */\n    _scheduler_lock();\n\n    /*\n     * Verify that the thread is still suspended.\n     */\n    if (((struct thread *) parameter)->state != THREAD_STATE_SUSPENDED) {\n\n        /*\n         * The thread is no longer suspended.\n         */\n        _scheduler_unlock();\n        return;\n    }\n\n    /*\n     * Set the thread's error number to a timeout value.\n     */\n    ((struct thread *) parameter)->error_number = ERROR_TIMEOUT;\n\n    /*\n     * Remove the thread from the suspend list.\n     */\n    _scheduler_remove_from_suspend_list((struct thread *) parameter);\n\n    /*\n     * Insert the thread into the ready list.\n     */\n    _scheduler_insert_into_ready_list((struct thread *) parameter);\n\n    /*\n     * Unlock the scheduler.\n     */\n    _scheduler_unlock();\n}", "CodeBleu_score": 41.54739396927533}, {"code": "static void _thread_timeout(void *parameter){\n\t/*\n\t * The thread that is timing out is passed as a parameter.\n\t */\n\tstruct thread *thread = parameter;\n\t/*\n\t * Check that the thread is valid.\n\t */\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\t/*\n\t * Lock the scheduler.\n\t */\n\t_scheduler_lock();\n\t/*\n\t * Verify that the thread is suspended.\n\t */\n\tif (thread->state != THREAD_STATE_SUSPENDED) {\n\t\t/*\n\t\t * The thread is not suspended.\n\t\t */\n\t\t_scheduler_unlock();\n\t\treturn;\n\t}\n\t/*\n\t * Set the thread's error number to a timeout value.\n\t */\n\tthread->error = THREAD_ERROR_TIMEOUT;\n\t/*\n\t * Remove the thread from the suspend list.\n\t */\n\t_scheduler_remove_suspend_thread(thread);\n\t/*\n\t * Insert the thread into the ready list.\n\t */\n\t_scheduler_insert_ready_thread(thread);\n\t/*\n\t * Unlock the scheduler.\n\t */\n\t_scheduler_unlock();\n}", "CodeBleu_score": 35.38752368884651}, {"code": "static void _thread_timeout(void *parameter){\n\tstruct _thread *thread;\n\n\t/*\n\t * Check the parameter.\n\t */\n\tif (parameter == NULL) {\n\t\treturn;\n\t}\n\n\t/*\n\t * Lock the scheduler.\n\t */\n\t_scheduler_lock();\n\n\t/*\n\t * Verify the thread is suspended.\n\t */\n\tthread = (struct _thread *)parameter;\n\tif (thread->state != _THREAD_STATE_SUSPENDED) {\n\t\t_scheduler_unlock();\n\t\treturn;\n\t}\n\n\t/*\n\t * Set the thread's error number.\n\t */\n\tthread->error = _THREAD_ERROR_TIMEOUT;\n\n\t/*\n\t * Remove the thread from the suspend list.\n\t */\n\t_scheduler_remove_suspend_list(thread);\n\n\t/*\n\t * Insert the thread into the ready list.\n\t */\n\t_scheduler_insert_ready_list(thread);\n\n\t/*\n\t * Unlock the scheduler.\n\t */\n\t_scheduler_unlock();\n}", "CodeBleu_score": 39.865504498862435}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n\n    /* Lock the thread's spinlock */\n    _spinlock_lock(&thread->spinlock);\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->pending_object != NULL) {\n        /* Get the mutex the thread is waiting on */\n        mutex = (rt_mutex_t)thread->pending_object;\n\n        /* Remove the thread from the mutex's waiting list */\n        _mutex_remove_from_waiting_list(mutex, thread);\n\n        /* Clear the thread's pending object */\n        thread->pending_object = NULL;\n    }\n\n    /* Unlock the thread's spinlock */\n    _spinlock_unlock(&thread->spinlock);\n\n    /* Detach the thread from all mutexes it has taken */\n    _mutex_detach_from_mutexes(thread);\n}", "CodeBleu_score": 22.640933788448706}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_list_t *iterator;\n    rt_list_t *next;\n    rt_thread_t waiting_thread;\n    rt_thread_t current_thread;\n\n    /* Lock the thread's spinlock */\n    rt_spinlock_lock(&(thread->spinlock));\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->pending_object != NULL) {\n        /* Get the mutex the thread is waiting on */\n        mutex = thread->pending_object;\n\n        /* Remove the thread from the mutex's waiting list */\n        rt_list_for_each_safe(iterator, &(mutex->waiting_list), next) {\n            waiting_thread = rt_list_entry(iterator, rt_thread_t, pending_object_list);\n\n            if (waiting_thread == thread) {\n                rt_list_remove(iterator);\n                break;\n            }\n        }\n\n        /* Clear the thread's pending object */\n        thread->pending_object = NULL;\n    }\n\n    /* Get the current thread */\n    current_thread = rt_thread_self();\n\n    /* Check if the thread has taken any mutexes */\n    if (thread->mutex_count > 0) {\n        /* Check if the thread is the current thread */\n        if (thread == current_thread) {\n            /* Check if the thread has taken any mutexes */\n            if (thread->mutex_count > 0) {\n                /* Check if the thread has taken the mutex the thread is waiting on */\n                if (thread->mutex_count > 1) {\n                    /* Decrement the thread's mutex count */\n                    thread->mutex_count--;\n                } else {\n                    /* Decrement the thread's mutex count */\n                    thread->mutex_count--;\n\n                    /* Check if the thread has taken the mutex the thread is waiting on */\n                    if (thread->mutex_count == 0) {\n                        /* Release the mutex the", "CodeBleu_score": 44.61569463066772}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread){\n\trt_mutex_t mutex;\n    rt_list_t *node;\n\n    // Lock the thread's spinlock.\n    rt_spinlock_lock(&thread->spinlock);\n\n    // Check if the thread is waiting on a mutex.\n    if (thread->waiting_mutex != NULL) {\n        // Remove the thread from the mutex's waiting list.\n        mutex = thread->waiting_mutex;\n        rt_list_remove(&mutex->waiting_threads, &thread->waiting_node);\n\n        // Clear the pending object.\n        thread->waiting_mutex = NULL;\n        thread->waiting_node.next = NULL;\n        thread->waiting_node.prev = NULL;\n    }\n\n    // Release all mutexes the thread has taken.\n    while (thread->taken_mutexes != NULL) {\n        mutex = thread->taken_mutexes;\n        rt_list_remove(&mutex->taken_threads, &thread->taken_node);\n        thread->taken_mutexes = mutex->taken_threads.next;\n        mutex->taken_threads.next = NULL;\n        mutex->taken_threads.prev = NULL;\n    }\n\n    // Release the thread's spinlock.\n    rt_spinlock_unlock(&thread->spinlock);\n}", "CodeBleu_score": 44.54231164970513}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n    rt_thread_t cur_thread;\n    rt_uint8_t level;\n\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* set thread priority */\n    thread->current_priority = thread->init_priority;\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* reset thread stat */\n    thread->stat = RT_THREAD_READY;\n\n    /* reset thread cleanup list */\n    thread->cleanup = RT_NULL;\n\n    /* reset thread stack frame */\n    thread->stack_frame = RT_NULL;\n\n    /* set thread time slice and time */\n    thread->remaining_tick = thread->init_tick;\n    thread->time_slice = thread->init_tick;\n    thread->tick_remain = 0;\n\n    /* set thread stack frame */\n    rt_hw_context_init(thread->stack_addr, (void *)rt_thread_enter, (void *)thread, RT_TRUE);\n\n    /* init thread timer and timer list */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->parent.name,\n                  rt_thread_timeout,\n                  thread,\n                  thread->init_tick);\n    rt_timer_start(&(thread->thread_timer));\n\n    /* set error number */\n    thread->error = RT_EOK;\n\n    /* resume thread */\n    error = rt_sched_thread_resume(thread);\n    if (error != RT_EOK)\n    {\n        LOG_E(\"resume thread: %s failed\", thread->parent.name);\n\n        return error;\n    }\n\n    /* trigger a schedule */\n    cur_thread = rt_thread_self();\n    if (cur_thread != RT_NULL && cur_thread->stat != RT_THREAD_CLOSE)", "CodeBleu_score": 42.504279146607935}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    /* thread state check */\n    if (thread->stat == RT_THREAD_INIT)\n    {\n        /* thread is in init state, change to suspend state */\n        thread->stat = RT_THREAD_SUSPEND;\n    }\n\n    /* thread priority check */\n    RT_ASSERT(thread->current_priority >= RT_THREAD_PRIORITY_MAX / 2);\n\n    /* calculate the priority attributes */\n    thread->number = _RT_THREAD_PRIORITY_MAX - thread->current_priority;\n\n    /* reset the thread error number */\n    thread->error = RT_EOK;\n\n    /* reset the thread stack information */\n    thread->stack_size = 0;\n    thread->stack_addr = RT_NULL;\n\n    /* resume thread */\n    error = rt_thread_resume(thread);\n    if (error == RT_EOK)\n    {\n        /* trigger scheduler */\n        rt_schedule();\n    }\n\n    return error;\n}", "CodeBleu_score": 52.08087156450746}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread){\n\trt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    /* thread startup */\n    LOG_D(\"thread startup: %s\", thread->parent.name);\n\n    /* thread priority */\n    thread->current_priority = thread->init_priority;\n    thread->number = 0;\n    thread->number_mask = 1;\n\n    /* reset thread stat */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    error = rt_sched_thread_resume(thread);\n\n    /* trigger scheduler if resume successfully */\n    if (error == RT_EOK)\n    {\n        rt_schedule();\n    }\n\n    return error;\n}", "CodeBleu_score": 57.886285901177814}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_timer_entry_t timer;\n    rt_tick_t timeout;\n    rt_uint32_t i;\n    rt_uint32_t level;\n\n    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL_MAX; i++) {\n        level = RT_TIMER_SKIP_LIST_LEVEL_MAX - 1 - i;\n        if (timer_list[level].next != &timer_list[level]) {\n            timer = rt_list_entry(timer_list[level].next, rt_timer_entry_t, list);\n            timeout = timer->timeout_tick - rt_tick_get();\n            if (timeout > 0) {\n                *timeout_tick = timeout;\n                return RT_EOK;\n            }\n        }\n    }\n\n    return -RT_ETIMEOUT;\n}", "CodeBleu_score": 35.578194492914605}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\trt_timer_t timer;\n\n    if (rt_list_isempty(timer_list))\n        return -RT_ERROR;\n\n    timer = rt_list_entry(timer_list->next, struct rt_timer, row);\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 41.78628001981792}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick){\n\tstruct rt_timer_list *timer_entry;\n\n    if (rt_list_isempty(timer_list)) {\n        *timeout_tick = RT_TICK_MAX;\n        return -RT_ERROR;\n    }\n\n    timer_entry = rt_list_entry(timer_list->next, struct rt_timer_list, list);\n    *timeout_tick = timer_entry->timeout_tick;\n\n    return RT_EOK;\n}", "CodeBleu_score": 52.92074344822718}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check name */\n    RT_ASSERT(name != RT_NULL);\n\n    /* check timeout function */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* check time */\n    RT_ASSERT(time > 0);\n\n    /* allocate memory */\n    timer = rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL) return RT_NULL;\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* register timer object */\n    if (rt_object_register(RT_Object_Class_Timer, timer, name, RT_ObjectFlag_Static) != RT_EOK)\n    {\n        rt_object_delete(&(timer->parent));\n        return RT_NULL;\n    }\n\n    return timer;\n}", "CodeBleu_score": 63.394513627024885}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* check name */\n    RT_ASSERT(name != RT_NULL);\n\n    /* check timeout function */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* check time */\n    RT_ASSERT(time > 0);\n\n    /* allocate object */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return timer;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* initialize object */\n    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n\n    /* insert timer to timer list */\n    rt_timer_list_insert(timer);\n\n    return timer;\n}", "CodeBleu_score": 67.63954459141924}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag){\n\trt_timer_t timer;\n\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time > 0);\n\n    /* allocate memory */\n    timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n\n    /* initialize timer */\n    _timer_init(timer, timeout, parameter, time, flag);\n\n    /* insert timer to timer list */\n    rt_timer_list_insert(timer);\n\n    return timer;\n}", "CodeBleu_score": 75.79451781487579}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\trecorder := httptest.NewRecorder()\n\ta.handler.ServeHTTP(recorder, req)\n\tfor k, v := range recorder.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tres.WriteHeader(recorder.Code)\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 38.13542498917986}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\t// Capture the response writer and request\n\trec := httptest.NewRecorder()\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Forward the request to the router\n\t\ta.Router.ServeHTTP(w, r)\n\t})\n\n\t// Create a context with the request and response\n\tctx := context.WithValue(req.Context(), ContextResponseWriter, rec)\n\tctx = context.WithValue(ctx, ContextRequest, req)\n\tctx = context.WithValue(ctx, ContextLogger, a.Logger)\n\n\t// Create a new request with the context\n\tnewReq := req.WithContext(ctx)\n\n\t// Serve the request\n\thandler.ServeHTTP(rec, newReq)\n\n\t// Copy the headers\n\tfor key, values := range rec.Header() {\n\t\tfor _, value := range values {\n\t\t\tres.Header().Add(key, value)\n\t\t}\n\t}\n\n\t// Write the status code\n\tres.WriteHeader(rec.Code)\n\n\t// Write the body\n\tres.Write(rec.Body.Bytes())\n}", "CodeBleu_score": 42.79682126260221}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request){\n\trecorder := httptest.NewRecorder()\n\ta.handler.ServeHTTP(recorder, req)\n\tfor k, v := range recorder.HeaderMap {\n\t\tres.Header()[k] = v\n\t}\n\tres.WriteHeader(recorder.Code)\n\tres.Write(recorder.Body.Bytes())\n}", "CodeBleu_score": 37.524721468741845}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Get the requested path from the request.\n\tpath := req.URL.Path\n\n\t// If the request path is \"/\", serve the index.html file.\n\tif path == \"/\" {\n\t\ta.serveFile(res, req, \"index.html\")\n\t\treturn\n\t}\n\n\t// Otherwise, serve the requested file.\n\ta.serveFile(res, req, path)\n}", "CodeBleu_score": 23.48849864155257}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Parse the request URL\n\tpath := strings.Split(req.URL.Path, \"/\")\n\tif len(path) < 3 {\n\t\ta.error(res, req, 404)\n\t\treturn\n\t}\n\t// Get the asset name\n\tname := path[2]\n\t// Get the asset type\n\tvar assetType string\n\tif strings.HasSuffix(name, \".js\") {\n\t\tassetType = \"application/javascript\"\n\t} else if strings.HasSuffix(name, \".css\") {\n\t\tassetType = \"text/css\"\n\t} else if strings.HasSuffix(name, \".html\") {\n\t\tassetType = \"text/html\"\n\t} else {\n\t\ta.error(res, req, 404)\n\t\treturn\n\t}\n\t// Get the asset content\n\tasset, err := a.assets.ReadFile(name)\n\tif err != nil {\n\t\ta.error(res, req, 404)\n\t\treturn\n\t}\n\t// Write the asset content\n\tres.Header().Set(\"Content-Type\", assetType)\n\tres.Write(asset)\n}", "CodeBleu_score": 45.80340754948907}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Get the requested asset from the URL path.\n\tasset, err := a.getAsset(req.URL.Path)\n\tif err != nil {\n\t\t// If the asset is not found, return a 404 error.\n\t\thttp.Error(res, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Set the appropriate Content-Type header based on the file extension.\n\tswitch path.Ext(asset.Name) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\t// Write the asset content to the response.\n\tres.Write(asset.Content)\n}", "CodeBleu_score": 51.029616622403836}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Get the robot from the master\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, \"Robot not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\thttp.Error(res, \"Could not convert connections to JSON\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 36.63610019877067}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\t// Get the robot\n\trobot, err := a.master.GetRobot(robotName)\n\tif err != nil {\n\t\t// No robot found with the specified name\n\t\ta.writeError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\t// Get the connections\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\t// Error converting the connections to JSON\n\t\ta.writeError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// Write the JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 36.32416388553856}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request){\n\t// Get the robot name from the request URL.\n\tname := strings.TrimPrefix(req.URL.Path, \"/robots/\")\n\n\t// Get the robot from the master instance.\n\trobot, err := a.master.Robot(name)\n\tif err != nil {\n\t\t// If the robot is not found, write an error message.\n\t\tif err == robomaster.ErrRobotNotFound {\n\t\t\ta.writeError(res, http.StatusNotFound, \"Robot not found\")\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise, write an error message indicating that the robot could not be retrieved.\n\t\ta.writeError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// Convert the connections to JSON.\n\tconnections := make([]map[string]interface{}, len(robot.Connections()))\n\tfor i, connection := range robot.Connections() {\n\t\tconnections[i] = connection.JSON()\n\t}\n\n\t// Write the JSON response.\n\ta.writeJSON(res, connections)\n}", "CodeBleu_score": 44.057759684995936}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tif secureCompare(pair[0], username) && secureCompare(pair[1], password) {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\treturn\n\t\t}\n\n\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n}", "CodeBleu_score": 48.622039757286096}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If we get here, the request is authenticated.\n\t\t// Proceed to the next handler in the chain.\n\t\t//\n\t\t// If the request is not authenticated, the next handler in the chain will be\n\t\t// invoked and it will return an error.\n\t\tnext := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tfmt.Fprintln(w, \"Welcome!\")\n\t\t})\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 47.63072938587422}, {"code": "func BasicAuth(username, password string) http.HandlerFunc{\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || !secureCompare(user, username) || !secureCompare(pass, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\tw.WriteHeader(401)\n\t\t\tw.Write([]byte(\"Not authorized\n\"))\n\t\t\treturn\n\t\t}\n\t\t// All good, call the next handler\n\t\tw.Write([]byte(\"Authorized\n\"))\n\t}\n}", "CodeBleu_score": 50.29665194252527}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (float64(toMax) - float64(toMin)) / (float64(fromMax) - float64(fromMin))\n\tintercept := float64(toMin) - slope * float64(fromMin)\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope * input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.45013860364038}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n\tintercept := float64(toMin) - (slope * float64(fromMin))\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(math.Min(float64(toMin) + (slope * input) + intercept, float64(toMax)), float64(toMin)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.1177701539846}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n\tslope := (float64(toMax) - float64(toMin)) / (float64(fromMax) - float64(fromMin))\n\tintercept := float64(toMin) - slope*float64(fromMin)\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Max(math.Min(float64(toMin)+slope*input+intercept, float64(toMax)), float64(toMin)))\n\t\treturn\n\t}\n}", "CodeBleu_score": 48.4737049498225}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"analogSensorRead: connection is nil\")\n\t}\n\tif !a.connection.IsAnalog() {\n\t\treturn 0, 0, errors.New(\"analogSensorRead: connection does not support analog reading\")\n\t}\n\traw, err := a.connection.ReadAnalog(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 50.90231195078994}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\tvar err error\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"Connection is not valid\")\n\t}\n\tif !a.connection.IsAnalogReadSupported() {\n\t\treturn 0, 0, errors.New(\"Analog read is not supported\")\n\t}\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scaleValue(rawValue)\n\treturn rawValue, a.lastScaledValue, nil\n}", "CodeBleu_score": 54.51480743240879}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error){\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0.0, errors.New(\"No connection to device\")\n\t}\n\tif !a.connection.IsAnalog() {\n\t\treturn 0, 0.0, errors.New(\"Connection is not analog\")\n\t}\n\traw, err := a.connection.ReadAnalog(a.pin)\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\treturn raw, a.lastScaled, nil\n}", "CodeBleu_score": 48.44700460182793}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tif fromMin == fromMax {\n\t\tfromMin = fromMin - 1\n\t}\n\tif toMin == toMax {\n\t\ttoMin = toMin - 1\n\t}\n\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tn := toMin - (m * float64(fromMin))\n\treturn func(x int) float64 {\n\t\treturn m * float64(x) + n\n\t}\n}", "CodeBleu_score": 54.84322433239659}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\tvar slope float64 = 0.0\n\tvar intercept float64 = 0.0\n\n\tif fromMin == fromMax {\n\t\tfromMin = 0\n\t}\n\n\tif toMin == toMax {\n\t\ttoMin = 0\n\t}\n\n\tslope = (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\tintercept = (toMax - (slope * float64(fromMax)))\n\n\treturn func(val int) float64 {\n\t\treturn slope * float64(val) + intercept\n\t}\n}", "CodeBleu_score": 40.251274692592816}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n\treturn func(val int) float64 {\n\t\tif val == 0 {\n\t\t\treturn 0\n\t\t}\n\t\tm := (toMax - toMin) / (float64(fromMax) - float64(fromMin))\n\t\tn := toMin - m*float64(fromMin)\n\t\treturn m*float64(val) + n\n\t}\n}", "CodeBleu_score": 54.59280351487917}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Create a new driver.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:            \"Grove Piezo Vibration Sensor\",\n\t\tanalogReader:    a,\n\t\tpin:             pin,\n\t\tvibrationEvents: make(chan *VibrationEvent),\n\t}\n\n\t// Create a default threshold of 1000.\n\tthreshold := 1000\n\n\t// Check if the optional parameters contain a threshold.\n\tfor _, opt := range opts {\n\t\tif v, ok := opt.(int); ok {\n\t\t\tthreshold = v\n\t\t}\n\t}\n\n\t// Create a new analog sensor driver.\n\tsensor, err := NewAnalogSensorDriver(a, pin, opts...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Add a vibration event.\n\tsensor.AddEvent(VibrationEventName, func(data interface{}) {\n\t\t// Get the data as an int.\n\t\tvibration := data.(int)\n\n\t\t// Publish a vibration event if the data exceeds the threshold.\n\t\tif vibration >= threshold {\n\t\t\td.vibrationEvents <- &VibrationEvent{\n\t\t\t\tname:   VibrationEventName,\n\t\t\t\tdata:   vibration,\n\t\t\t\tsource: d,\n\t\t\t}\n\t\t}\n\t})\n\n\t// Return the initialized driver.\n\treturn d\n}", "CodeBleu_score": 49.81591608817131}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Initialize the driver.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: DefaultGrovePiezoVibrationSensorDriverName,\n\t\ta:    a,\n\t\tpin:  pin,\n\t}\n\n\t// Initialize the event publisher.\n\td.e = NewEventPublisher()\n\n\t// Set the vibration event.\n\td.vibrationEvent = NewVibrationEvent(d.name, d.pin)\n\n\t// Set the default vibration threshold.\n\td.vibrationThreshold = DefaultGrovePiezoVibrationSensorDriverVibrationThreshold\n\n\t// Set the vibration event handler.\n\td.vibrationEventHandler = func(e VibrationEvent) {\n\t\tif e.Value >= d.vibrationThreshold {\n\t\t\td.e.Publish(d.vibrationEvent)\n\t\t}\n\t}\n\n\t// Set up the event listener.\n\td.e.AddListener(d.vibrationEventHandler)\n\n\t// Return the initialized driver.\n\treturn d\n}", "CodeBleu_score": 38.32266068557717}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver{\n\t// Create a new driver.\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: *NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"GrovePiezoVibrationSensor\",\n\t\tthreshold:          1000,\n\t}\n\n\t// Set up an event listener for data events.\n\tif err := d.AddEventListener(\n\t\tDataEvent,\n\t\tfunc(e Event) {\n\t\t\t// Get the data event.\n\t\t\tdataEvent := e.(DataEvent)\n\n\t\t\t// If the data exceeds the threshold, publish a vibration event.\n\t\t\tif dataEvent.Value() > d.threshold {\n\t\t\t\td.PublishEvent(VibrationEvent{\n\t\t\t\t\tValue: dataEvent.Value(),\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}", "CodeBleu_score": 48.40214600650407}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif d.bus == nil {\n\t\treturn errors.New(\"bus is nil\")\n\t}\n\tif d.pin == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.Value == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.Set == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.SetDutyCycle == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.SetPeriod == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.SetMode == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.SetValue == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.SetPull == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.SetName == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.SetNumber == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.Get == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.GetMode == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.GetNumber == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.GetName == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.GetValue == nil {\n\t\treturn errors.New(\"pin is nil\")\n\t}\n\tif d.pin.Pin.GetPull == nil {", "CodeBleu_score": 12.133957815622736}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif hz <= 0 || duration <= 0 {\n\t\treturn errors.New(\"Invalid frequency or duration\")\n\t}\n\n\t// Calculate the tone period\n\tperiod := 1000000 / hz\n\n\t// Calculate the tempo based on the buzzer's beats per minute\n\ttempo := d.bpm / 60\n\n\t// Calculate the number of ticks for the duration\n\tticks := int(duration * tempo)\n\n\t// Turn the buzzer on\n\tif err := d.On(); err != nil {\n\t\treturn err\n\t}\n\n\t// Generate the tone\n\tfor i := 0; i < ticks; i++ {\n\t\t// Turn the buzzer on\n\t\tif err := d.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\n\t\t// Turn the buzzer off\n\t\tif err := d.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Wait for the tone period\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t}\n\n\t// Turn the buzzer off\n\tif err := d.Off(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 54.255902067325536}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error{\n\tif d.buzzer == nil {\n\t\treturn errors.New(\"buzzer not initialized\")\n\t}\n\tif hz <= 0 {\n\t\treturn errors.New(\"frequency must be greater than 0\")\n\t}\n\tif duration <= 0 {\n\t\treturn errors.New(\"duration must be greater than 0\")\n\t}\n\tif d.buzzer.Period() == 0 {\n\t\treturn errors.New(\"buzzer period is 0\")\n\t}\n\tperiod := d.buzzer.Period()\n\tperiod = int(float64(period) * (hz / 1000.0))\n\tif period == 0 {\n\t\treturn errors.New(\"period is 0\")\n\t}\n\ttone := time.Duration(period) * time.Microsecond\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(tone)\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(tone)\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(tone)\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(tone)\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(tone)\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(tone)\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(tone)\n\td.buzzer.Off()\n\ttime.Sleep(tone)\n\td.buzzer.On()\n\ttime.Sleep(", "CodeBleu_score": 23.729389646872235}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"Sleep pin not set\")\n\t}\n\n\td.stop()\n\td.sleepPin.SetLow()\n\td.sleep = true\n\n\treturn nil\n}", "CodeBleu_score": 27.980853151898984}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\tif d.sleepPin.Get() {\n\t\treturn errors.New(\"sleep pin already set\")\n\t}\n\td.stop()\n\td.sleepPin.SetLow()\n\td.sleeping = true\n\treturn nil\n}", "CodeBleu_score": 36.77889667110722}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error{\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\tif d.isSleeping {\n\t\treturn errors.New(\"already sleeping\")\n\t}\n\tif d.isRunning {\n\t\td.stop()\n\t}\n\td.sleepPin.Low()\n\td.isSleeping = true\n\treturn nil\n}", "CodeBleu_score": 36.236953620002986}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"analog pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.newAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 46.7382533030502}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.AnalogPins == nil {\n\t\treturn nil, errors.New(\"analog pins map is not initialized\")\n\t}\n\n\tpin, ok := a.AnalogPins[id]\n\tif !ok {\n\t\tpath, params, err := a.analogPinPathAndParams(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = a.adaptor().NewAnalogPin(path, params)\n\t\ta.AnalogPins[id] = pin\n\t}\n\treturn pin, nil\n}", "CodeBleu_score": 54.48945787257702}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error){\n\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, params, err := a.analogPinPathAndParams(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := NewAnalogPin(a, path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}", "CodeBleu_score": 52.658521935245126}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\tif a.isPinValid(id) {\n\t\ta.pinMutex[a.pinMap[id]].Lock()\n\t\tdefer a.pinMutex[a.pinMap[id]].Unlock()\n\t\tpin, err := a.getPin(id)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpin.Write(val)\n\t\treturn nil\n\t} else {\n\t\treturn errors.New(\"Invalid Pin\")\n\t}\n}", "CodeBleu_score": 55.35405607507947}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connected == false {\n\t\treturn errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pin.Mode != OUTPUT {\n\t\treturn errors.New(\"Pin \" + id + \" is not an output\")\n\t}\n\n\terr = pin.Write(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 65.28563138196215}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n\tif err := a.lock(); err != nil {\n\t\treturn err\n\t}\n\tdefer a.unlock()\n\n\tp, err := a.GetDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.Write(val)\n\treturn nil\n}", "CodeBleu_score": 52.46968435246433}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.Pins) == 0 {\n\t\treturn nil, errors.New(\"No pins configured for this adaptor\")\n\t}\n\tif _, ok := a.Pins[id]; !ok {\n\t\t// Translate the ID to obtain chip and line information\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Create a new digital pin\n\t\tpin := &gpio.DigitalPin{\n\t\t\tID:     id,\n\t\t\tChip:   chip,\n\t\t\tLine:   line,\n\t\t\tAdaptor: a,\n\t\t}\n\t\t// Initialize the pin\n\t\tif err := pin.Init(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Apply the provided options to the pin\n\t\tfor _, opt := range opts {\n\t\t\tif !opt(pin) {\n\t\t\t\treturn nil, errors.New(\"Invalid option\")\n\t\t\t}\n\t\t}\n\t\t// Store the pin\n\t\ta.Pins[id] = pin\n\t\treturn pin, nil\n\t}\n\t// Apply the provided options to the pin\n\tfor _, opt := range opts {\n\t\tif !opt(a.Pins[id]) {\n\t\t\treturn nil, errors.New(\"Invalid option\")\n\t\t}\n\t}\n\t// Return the configured pin\n\treturn a.Pins[id], nil\n}", "CodeBleu_score": 52.35274068834972}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\t// Check if the adaptor is connected to any pins.\n\tif len(a.digitalPins) == 0 {\n\t\treturn nil, errors.New(\"No pins configured\")\n\t}\n\n\t// Append additional options to the pin's existing options.\n\tfor _, opt := range opts {\n\t\ta.digitalPins[id].Options = append(a.digitalPins[id].Options, opt)\n\t}\n\n\t// Retrieve the pin by its ID.\n\tpin, ok := a.digitalPins[id]\n\tif ok {\n\t\t// Apply the provided options to the pin.\n\t\tfor _, opt := range opts {\n\t\t\topt(pin)\n\t\t}\n\n\t\t// Return the configured pin.\n\t\treturn pin, nil\n\t}\n\n\t// Translate the ID to obtain chip and line information.\n\tchip, line, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new digital pin.\n\tpin = &gpio.DigitalPin{\n\t\tID:      id,\n\t\tChip:    chip,\n\t\tLine:    line,\n\t\tOptions: opts,\n\t}\n\n\t// Initialize the pin.\n\terr = pin.Init()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Store the pin.\n\ta.digitalPins[id] = pin\n\n\t// Return the configured pin.\n\treturn pin, nil\n}", "CodeBleu_score": 50.66428284559075}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error){\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"No pins defined\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\t// Translate the ID to obtain chip and line information\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Create a new digital pin\n\t\tpin = newDigitalPin(a, chip, line)\n\n\t\t// Initialize the pin\n\t\tif err := pin.initialize(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Store the new pin\n\t\ta.pins[id] = pin\n\t}\n\n\t// Apply options to the pin\n\tfor _, opt := range opts {\n\t\tif !opt(pin) {\n\t\t\treturn nil, errors.New(\"Invalid option\")\n\t\t}\n\t}\n\n\t// Return the configured pin\n\treturn pin, nil\n}", "CodeBleu_score": 54.84139207176937}]}
