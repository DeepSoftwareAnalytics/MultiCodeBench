{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n    auto files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n        for (const auto &file : files) {\n            // If the file does not exist locally, request it\n            if (!FileTransfer::FileExists(file)) {\n                RequestFile(file);\n                Log::Info(\"Downloaded required file: \", file);\n            }\n            // If the file exists locally, log that it was found in the cache\n            else {\n                Log::Info(\"Found required file in cache: \", file);\n            }\n        }\n    }\n\n    // Return the list of required files\n    return files;\n}", "CodeBleu_score": 67.8128041882219}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files from the server\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n        for (const auto &file : required_files) {\n            // If the file is not found locally, request it and log the download action\n            if (!FileTransfer::FileExists(file)) {\n                RequestFile(file);\n                Log::Info(\"Downloading file: \" + file);\n            }\n            // If the file exists locally, log that the file is found in the cache\n            else {\n                Log::Info(\"File found in cache: \" + file);\n            }\n        }\n    }\n    // Return the list of required files\n    return required_files;\n}", "CodeBleu_score": 67.47575931153811}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const{\n\t// Get the list of required files\n    auto required_files = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n    // If the download flag is set to true, check if each file exists locally\n    if (download) {\n      for (auto &file : required_files) {\n        // If the file exists locally, log that it is found in the cache\n        if (FileTransfer::FileExists(file)) {\n          std::cout << \"Found \" << file << \" in the cache.\" << std::endl;\n        }\n        // Otherwise, request the file and log the download action\n        else {\n          std::cout << \"Downloading \" << file << \"...\" << std::endl;\n          RequestFile(file);\n        }\n      }\n    }\n    // Return the list of required files\n    return required_files;\n  }", "CodeBleu_score": 66.90011626829234}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tauto actor = SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n  if (actor.id == 0u) {\n    return actor;\n  }\n  auto &actor_ctx = GetActorContext(actor);\n  actor_ctx.parent = parent;\n  actor_ctx.attachment_type = attachment_type;\n  actor_ctx.socket_name = socket_name;\n  actor_ctx.transform = transform;\n  return actor;\n}", "CodeBleu_score": 35.57113274173579}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tauto &parent_actor = GetActor(parent);\n  if (parent_actor == nullptr) {\n    throw std::runtime_error(\"Parent actor is not valid\");\n  }\n\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x != 0.0f || transform.location.y != 0.0f) {\n      LogWarning(\n          \"SpawnActorWithParent: Translation in X or Y is not supported \"\n          \"for attachment type: \"\n          \"SpringArm\");\n    }\n  }\n\n  auto actor = SpawnActorInternal(description, transform, parent,\n                                  attachment_type, socket_name);\n\n  // send the response\n  return actor;\n}", "CodeBleu_score": 51.176030561526375}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name){\n\tstd::lock_guard<std::mutex> lock(mutex_);\n\n  auto parent_actor = GetActor(parent);\n  if (parent_actor == nullptr) {\n    throw std::runtime_error(\"Parent actor does not exist\");\n  }\n\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (std::abs(transform.location.y) > 0.0001f ||\n        std::abs(transform.location.x) > 0.0001f) {\n      LogWarning(\n          \"SpawnActorWithParent: SpringArm and SpringArmGhost attachment \"\n          \"types only support a translation in the z axis.\");\n    }\n  }\n\n  auto actor = SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n  if (actor.id == 0) {\n    throw std::runtime_error(\"Failed to spawn actor\");\n  }\n\n  return actor;\n}", "CodeBleu_score": 55.44814180278234}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer\n    auto token = GetTokenForGBuffer(ActorId, GBufferId);\n\n    // Copy the token data\n    auto token_data = token.data();\n\n    // Subscribe to the streaming client using the provided callback function\n    SubscribeToStreamingClient(token_data, token.size(), callback);\n}", "CodeBleu_score": 38.963194717365035}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer.\n  auto token = GetToken(ActorId, GBufferId);\n\n  // Copy the token data.\n  rpc::TokenData token_data;\n  token_data.set_actor_id(token.ActorId);\n  token_data.set_gbuffer_id(token.GBufferId);\n  token_data.set_token(token.Token);\n\n  // Subscribe to the streaming client using the provided callback function.\n  SubscribeToStreamingClient(token_data, callback);\n}", "CodeBleu_score": 41.1679514330818}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback){\n\t// Get the token for the G-buffer\n  auto token = GetToken(ActorId, GBufferId);\n\n  // Copy the token data\n  auto tokenData = std::make_unique<char[]>(token.size());\n  memcpy(tokenData.get(), token.data(), token.size());\n\n  // Subscribe to the streaming client\n  streamingClient->Subscribe(\n    std::move(tokenData),\n    token.size(),\n    callback);\n}", "CodeBleu_score": 44.22275497481216}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tif (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(this);\n    if (navigation == nullptr) {\n      throw std::runtime_error(\"Episode::CreateNavigationIfMissing: Failed to create WalkerNavigation\");\n    }\n  }\n  return navigation;\n}", "CodeBleu_score": 37.10575009151774}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tstd::shared_ptr<WalkerNavigation> navigation = GetNavigation();\n  while (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>();\n    SetNavigation(navigation);\n    navigation = GetNavigation();\n  }\n  return navigation;\n}", "CodeBleu_score": 48.21034127091021}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing(){\n\tif (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(this);\n  }\n  return navigation;\n}", "CodeBleu_score": 25.41534179246921}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tauto start = std::chrono::system_clock::now();\n    while (episode.GetFrameCount() < frame) {\n        if (std::chrono::system_clock::now() - start > timeout) {\n            return false;\n        }\n        std::this_thread::yield();\n    }\n    episode.Tick();\n    return true;\n}", "CodeBleu_score": 40.64820348684562}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\tauto start = std::chrono::system_clock::now();\n  while (episode.GetFrameCount() < frame) {\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start).count() > timeout.count()) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetTrafficManager().SetTimeStep(frame);\n  return true;\n}", "CodeBleu_score": 49.01851819960979}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout){\n\twhile (episode.GetFrameCount() < frame) {\n    if (timeout.total_microseconds() <= 0) {\n      return false;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    timeout -= time_duration(milliseconds(10));\n  }\n  episode.Tick();\n  return true;\n}", "CodeBleu_score": 27.789510781738834}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tstd::vector<rpc::MapLayer> layers;\n    layers.push_back(map_layers);\n    return LoadEpisode(map_name, reset_settings, layers);\n}", "CodeBleu_score": 16.531085609197618}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\trpc::LoadEpisodeRequest request;\n    request.set_map_name(map_name);\n    request.set_reset_settings(reset_settings);\n    request.set_map_layers(map_layers);\n    rpc::LoadEpisodeReply reply;\n    Client::GetClient().SendCommand(request, reply);\n    if (reply.status() != rpc::Status::Success) {\n        throw std::runtime_error(\"Failed to load episode: \" + reply.error());\n    }\n    return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 30.012866590148246}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers){\n\tstd::string map_name_ = map_name;\n    bool reset_settings_ = reset_settings;\n    rpc::MapLayer map_layers_ = map_layers;\n\n    // Validate parameters\n    if (map_name_.empty()) {\n        throw std::invalid_argument(\"map_name must not be empty\");\n    }\n\n    // Setup request\n    Client client = GetClient();\n    rpc::LoadEpisodeRequest request;\n    request.set_map_name(map_name_);\n    request.set_reset_settings(reset_settings_);\n    request.set_map_layers(map_layers_);\n\n    // Send request\n    ClientID client_id = client.Connect();\n    rpc::LoadEpisodeReply reply;\n    client.Send(request, reply, client_id);\n    client.Disconnect(client_id);\n\n    // Validate response\n    if (reply.status() != rpc::FINISHED) {\n        throw std::runtime_error(\"Failed to load episode\");\n    }\n\n    // Return result\n    return EpisodeProxy{shared_from_this()};\n}", "CodeBleu_score": 46.830188818565276}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tauto it = _walkers.find(controller.GetWalkerId());\n  if (it == _walkers.end()) {\n    throw std::runtime_error(\"Walker \" + controller.GetWalkerId() + \" not found\");\n  }\n  it->second->RegisterAIController(controller);\n}", "CodeBleu_score": 43.354697891452446}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tassert(controller.GetEpisode() != nullptr);\n  auto walker = GetWalker(controller.GetId());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n  if (walker->GetNavigation() == nullptr) {\n    walker->SetNavigation(new Navigation(controller.GetEpisode(), controller.GetId()));\n  }\n  walker->GetNavigation()->RegisterWalker(controller.GetId());\n}", "CodeBleu_score": 52.03241360128721}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller){\n\tauto walker = GetWalker(controller.GetWalkerId());\n  if (walker == nullptr) {\n    throw std::invalid_argument(\"Walker not found\");\n  }\n  if (walker->GetWalkerState() == WalkerState::Walking) {\n    throw std::invalid_argument(\"Walker is already walking\");\n  }\n  if (walker->GetWalkerState() == WalkerState::Dead) {\n    throw std::invalid_argument(\"Walker is dead\");\n  }\n  if (controller.GetEpisode() == nullptr) {\n    throw std::invalid_argument(\"Episode is null\");\n  }\n  if (controller.GetEpisode()->GetSimulator() != this) {\n    throw std::invalid_argument(\"Episode is not associated with this simulator\");\n  }\n  if (walker->GetNavigation() == nullptr) {\n    walker->SetNavigation(controller.GetEpisode()->GetNavigation());\n  }\n  walker->RegisterController(controller);\n}", "CodeBleu_score": 48.03783214330718}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t// Check if the actor is already spawned\n    if (GetActor(blueprint.id)) {\n      throw Exception(\n          \"Simulator::SpawnActor: Actor with the same id already spawned\");\n    }\n\n    // Spawn the actor\n    SharedPtr<Actor> actor = blueprint.SpawnActor(\n        transform, parent, attachment_type, socket_name);\n\n    // Add the actor to the current episode\n    GetCurrentEpisode().AddActor(actor);\n\n    // Apply the garbage collection policy\n    if (gc == GarbageCollectionPolicy::eKeep) {\n      // Keep the actor\n      actor->SetActorGarbageCollectionStatus(ActorGarbageCollectionStatus::Keep);\n    } else {\n      // Remove the actor\n      actor->SetActorGarbageCollectionStatus(ActorGarbageCollectionStatus::Remove);\n    }\n\n    // Log the actor creation\n    LogActorCreation(actor);\n\n    // Return the actor\n    return actor;\n  }", "CodeBleu_score": 41.99711418643487}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\t// TODO: add attachment_type, gc, socket_name\n    // TODO: check if parent is nullptr\n    // TODO: check if socket_name is empty\n    // TODO: check if gc is not GarbageCollectionPolicy::NONE\n    // TODO: check if attachment_type is not rpc::AttachmentType::Rigid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Spring\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc::AttachmentType::Invalid\n    // TODO: check if attachment_type is not rpc", "CodeBleu_score": 7.364393041596169}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name){\n\tauto actor = blueprint.SpawnActor(transform, parent, attachment_type, socket_name);\n    auto actor_ptr = actor.lock();\n    if (actor_ptr == nullptr) {\n      return nullptr;\n    }\n    auto actor_id = actor_ptr->GetId();\n    // TODO(michael): We should not be storing the actor in the map\n    // here. The map should be owned by the actor.\n    auto it = actor_factory_->actor_map_.find(actor_id);\n    if (it != actor_factory_->actor_map_.end()) {\n      // This actor already exists.\n      return nullptr;\n    }\n    actor_factory_->actor_map_.emplace(actor_id, actor);\n    if (gc == GarbageCollectionPolicy::keep) {\n      // We need to keep this actor around.\n      actor_factory_->keep_actors_.emplace(actor_id);\n    }\n    // Log the creation of the actor.\n    LogActorCreation(actor_id, blueprint.GetType(), transform, parent, attachment_type, socket_name);\n    return actor;\n  }", "CodeBleu_score": 50.155668052794475}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t// Ensure that the episode is valid\n    if (!IsEpisodeRunning()) {\n      throw std::runtime_error(\"Episode has not been initialized or has ended\");\n    }\n\n    // Subscribe to the sensor's data stream\n    client->SubscribeToStream(sensor.GetStream(),\n        [this, &sensor, callback](const std::string &stream_name,\n                                  const std::string &message) {\n          // Deserialize the incoming data\n          SharedPtr<sensor::SensorData> data =\n              sensor::Deserialize(stream_name, message);\n\n          // Associate the data with the current episode\n          data->episode_id = current_episode->id;\n          data->sensor_id = sensor.id;\n\n          // Invoke the provided callback\n          callback(data);\n        });\n  }", "CodeBleu_score": 38.93955056708713}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\tif (!IsEpisodeRunning()) {\n      throw std::runtime_error(\"Episode not running\");\n    }\n\n    if (sensor.GetType() == SensorType::Lidar) {\n      auto lidar_sensor = std::dynamic_pointer_cast<LidarSensor>(sensor.GetSensor());\n      if (lidar_sensor == nullptr) {\n        throw std::runtime_error(\"Invalid lidar sensor\");\n      }\n      if (lidar_sensor->GetLidarToken().empty()) {\n        throw std::runtime_error(\"Invalid lidar token\");\n      }\n      if (lidar_sensor->GetLidarChannel().empty()) {\n        throw std::runtime_error(\"Invalid lidar channel\");\n      }\n    }\n\n    if (sensor.GetType() == SensorType::DepthCamera) {\n      auto depth_camera_sensor = std::dynamic_pointer_cast<DepthCameraSensor>(sensor.GetSensor());\n      if (depth_camera_sensor == nullptr) {\n        throw std::runtime_error(\"Invalid depth camera sensor\");\n      }\n      if (depth_camera_sensor->GetDepthCameraToken().empty()) {\n        throw std::runtime_error(\"Invalid depth camera token\");\n      }\n      if (depth_camera_sensor->GetDepthCameraChannel().empty()) {\n        throw std::runtime_error(\"Invalid depth camera channel\");\n      }\n    }\n\n    if (sensor.GetType() == SensorType::SemanticSegmentationCamera) {\n      auto semantic_camera_sensor = std::dynamic_pointer_cast<SemanticSegmentationCameraSensor>(sensor.GetSensor());\n      if (semantic_camera_sensor == nullptr) {\n        throw std::runtime_error(\"Invalid semantic segmentation camera sensor\");\n      }\n      if (semantic_camera_sensor->GetSemanticSegmentationCameraToken().empty()) {\n        throw std::runtime_error(\"Invalid semantic segmentation camera token\");\n      }\n      if (semantic_camera_sensor->GetSemanticSegmentationCameraChannel().empty()) {\n        throw std::", "CodeBleu_score": 35.14067526508878}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback){\n\t// Check that the episode is valid\n  if (!episode) {\n    throw std::runtime_error(\"No episode available to subscribe to sensor\");\n  }\n\n  // Subscribe to the sensor's data stream\n  auto stream = client->SubscribeToStream(sensor);\n\n  // Set up a callback to handle incoming sensor data\n  stream->SetCallback(\n      [this, callback](const std::string &data) {\n        // Deserialize the incoming data\n        SharedPtr<sensor::SensorData> sensor_data =\n            sensor::SensorData::FromBytes(data);\n\n        // Associate the sensor data with the current episode\n        sensor_data->episode_id = episode->id;\n\n        // Invoke the provided callback\n        callback(sensor_data);\n      });\n}", "CodeBleu_score": 40.33897253453931}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the current walkers\n    std::vector<WalkerHandle> walkers = LoadWalkers(episode);\n    if (walkers.empty()) return;\n\n    // check if the list is empty\n    if (_next_check_index >= walkers.size())\n      _next_check_index = 0;\n\n    // retrieve the current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // remove any walkers that no longer exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update the vehicles in the crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd itself in the navigation module\n    _nav.UpdateCrowd();\n\n    // get the current state of the walkers\n    std::vector<carla::geom::Transform> walker_transforms;\n    std::vector<float> walker_speeds;\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n      // add to the vectors\n      walker_transforms.emplace_back(snapshot.transform);\n      walker_speeds.emplace_back(snapshot.actor_control.throttle);\n    }\n\n    // apply the states in a batch to the simulator\n    _simulator.lock()->ApplyBatchSnapshots(walker_transforms, walker_speeds);\n\n    // check if any walker has been killed\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n      // check if the walker is dead\n      if (snapshot.actor_control.is_alive == false) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.", "CodeBleu_score": 52.011249615687014}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // get the walkers\n    std::vector<WalkerHandle> walkers = GetWalkers();\n\n    // check if the list is empty\n    if (walkers.size() == 0) return;\n\n    // check if walkers exist\n    CheckIfWalkerExist(walkers, *state);\n\n    // update vehicles in crowd\n    UpdateVehiclesInCrowd(episode, false);\n\n    // update the crowd\n    _nav.UpdateCrowd();\n\n    // get the walker transforms and speeds\n    std::vector<carla::geom::Transform> walker_transforms;\n    std::vector<float> walker_speeds;\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n      // get the transform\n      carla::geom::Transform transform = snapshot.transform;\n      // get the speed\n      float speed = snapshot.velocity.x;\n      // add to the vectors\n      walker_transforms.emplace_back(transform);\n      walker_speeds.emplace_back(speed);\n    }\n\n    // update the walkers\n    _nav.UpdateWalkers(walker_transforms, walker_speeds);\n\n    // check if any walkers are dead\n    for (auto &&walker : walkers) {\n      // get the snapshot\n      ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n      // check if dead\n      if (snapshot.health <= 0) {\n        // remove from the crowd\n        _nav.RemoveAgent(walker.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(walker.controller);\n        // unregister from list\n        UnregisterWalker(walker.walker, walker.controller);\n      }\n    }\n  }", "CodeBleu_score": 56.49424885000044}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode){\n\t// load the walkers\n  std::vector<WalkerHandle> walkers = LoadWalkers(episode);\n  if (walkers.empty())\n    return;\n\n  // check if walkers exist\n  CheckIfWalkerExist(walkers, episode->GetState());\n\n  // update the vehicles\n  UpdateVehiclesInCrowd(episode, false);\n\n  // update the crowd\n  _nav.UpdateCrowd();\n\n  // get the current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n  // get the transforms and speeds of the walkers\n  std::vector<carla::geom::Transform> walker_trans;\n  std::vector<float> walker_speeds;\n  for (auto &&walker : walkers) {\n    // get the snapshot\n    ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n    // get the transform\n    walker_trans.push_back(snapshot.transform);\n    // get the speed\n    walker_speeds.push_back(snapshot.speed);\n  }\n\n  // apply the transforms and speeds\n  _nav.ApplyTransformBatch(walker_trans);\n  _nav.ApplySpeedBatch(walker_speeds);\n\n  // check if any walker has been killed\n  for (auto &&walker : walkers) {\n    // get the snapshot\n    ActorSnapshot snapshot = state->GetActorSnapshot(walker.walker);\n    // check if dead\n    if (snapshot.health == 0.0f) {\n      // remove from the crowd\n      _nav.RemoveAgent(walker.walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walker.controller);\n      // unregister from list\n      UnregisterWalker(walker.walker, walker.controller);\n    }\n  }\n}", "CodeBleu_score": 51.861365279911865}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.set_id(id);\n  description.set_parent_id(parent_id);\n  description.set_parent_name(parent_name);\n  description.set_transform(transform);\n  description.set_bounding_box(bounding_box);\n  description.set_class_name(class_name);\n  description.set_type(type);\n  description.set_parent_type(parent_type);\n  description.set_parent_id(parent_id);\n  description.set_parent_name(parent_name);\n  description.set_attributes(attributes);\n  return description;\n}", "CodeBleu_score": 45.46242451308136}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription description;\n  description.id = id;\n  description.parent = parent;\n  description.parent_id = parent_id;\n  description.transform = transform;\n  description.bounding_box = bounding_box;\n  description.attributes = attributes;\n  description.parent_hash = parent_hash;\n  description.parent_name = parent_name;\n  description.static_actor = static_actor;\n  description.actors_to_destroy = actors_to_destroy;\n  description.attachments = attachments;\n  description.attachment_points = attachment_points;\n  description.attachment_transforms = attachment_transforms;\n  description.attachment_offset = attachment_offset;\n  description.attachment_id = attachment_id;\n  description.attachment_name = attachment_name;\n  description.attachment_type = attachment_type;\n  description.attachment_com = attachment_com;\n  description.attachment_com_offset = attachment_com_offset;\n  description.attachment_semantic = attachment_semantic;\n  description.attachment_semantic_offset = attachment_semantic_offset;\n  description.attachment_semantic_size = attachment_semantic_size;\n  description.attachment_semantic_rotation = attachment_semantic_rotation;\n  description.attachment_semantic_rotation_offset = attachment_semantic_rotation_offset;\n  description.attachment_semantic_rotation_size = attachment_semantic_rotation_size;\n  description.attachment_semantic_scale = attachment_semantic_scale;\n  description.attachment_semantic_scale_offset = attachment_semantic_scale_offset;\n  description.attachment_semantic_scale_size = attachment_semantic_scale_size;\n  description.attachment_semantic_attach_type = attachment_semantic_attach_type;\n  description.attachment_semantic_attach_type_offset = attachment_semantic_attach_type_offset;\n  description.attachment_semantic_attach_type_size = attachment_semantic_attach_type_size;\n  description.attachment", "CodeBleu_score": 34.147988227864374}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const{\n\trpc::ActorDescription desc;\n  desc.id = this->id;\n  desc.parent_id = this->parent_id;\n  desc.parent_name = this->parent_name;\n  desc.parent_type = this->parent_type;\n  desc.transform = this->transform;\n  desc.bounding_box = this->bounding_box;\n  desc.attributes = this->attributes;\n  desc.parent_hash = this->parent_hash;\n  return desc;\n}", "CodeBleu_score": 38.078096636270246}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tBlueprintLibrary result;\n    for (auto blueprint : blueprints) {\n      if (blueprint->HasAttribute(name) && blueprint->GetAttribute(name) == value) {\n        result.Add(blueprint);\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 27.91592346449599}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tBlueprintLibrary result;\n    for (const auto& blueprint : blueprints) {\n      if (blueprint->HasAttribute(name) && blueprint->GetAttribute(name) == value) {\n        result.AddBlueprint(blueprint);\n      }\n    }\n    return result;\n  }", "CodeBleu_score": 28.29644436548967}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const{\n\tstd::vector<Blueprint> filtered_blueprints;\n  for (const Blueprint &blueprint : blueprints) {\n    if (blueprint.HasAttribute(name)) {\n      std::string attr_value = blueprint.GetAttribute(name);\n      if (attr_value == value) {\n        filtered_blueprints.push_back(blueprint);\n      }\n    }\n  }\n  return std::make_shared<BlueprintLibrary>(filtered_blueprints);\n}", "CodeBleu_score": 36.0375726582456}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = basePath + path + \"/\" + version + \".bin\";\n\tstd::ofstream file(fullPath, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.281426935040514}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = this->baseFolder + path;\n\n\tif (this->ValidateFilePath(fullPath)) {\n\t\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\n\t\tif (file.is_open()) {\n\t\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\t\tfile.close();\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 42.55635209999227}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content){\n\tstd::string fullPath = baseFolder + path;\n\tstd::string fullPathVersion = fullPath + version;\n\tstd::ofstream file(fullPathVersion, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<const char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}", "CodeBleu_score": 37.0126557762374}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto parent = transform.parent();\n    const auto location = parent->location() + transform.location();\n    const auto corners = Rotate(transform.yaw(), {\n        -parent->extents().x / 2.0f,\n        -parent->extents().y / 2.0f,\n        -parent->extents().z / 2.0f});\n    return std::make_shared<const Bounds>(frame, corners);\n  }", "CodeBleu_score": 32.52512641537193}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst auto location = transform.location + parent_->GetBounds(frame).location;\n    const auto corners = Rotate(transform.rotation.yaw, geom::Location{-extent_, -extent_, 0.0f}) + location;\n    return std::make_shared<Bounds>(frame, corners);\n  }", "CodeBleu_score": 32.935862670457574}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const{\n\tconst geom::Location location = transform.Location() + parent_->Location();\n    const geom::Vector extent = transform.Extent();\n    const geom::Location corner0 = Rotate(transform.Yaw(), {-extent.x, extent.y, 0.0f});\n    const geom::Location corner1 = Rotate(transform.Yaw(), {extent.x, extent.y, 0.0f});\n    const geom::Location corner2 = Rotate(transform.Yaw(), {-extent.x, -extent.y, 0.0f});\n    const geom::Location corner3 = Rotate(transform.Yaw(), {extent.x, -extent.y, 0.0f});\n    return std::make_shared<Bounds>(frame, location, corner0, corner1, corner2, corner3);\n  }", "CodeBleu_score": 40.928707568686455}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer(){\n\tstd::lock_guard<std::mutex> lock(lightsMutex);\n    std::vector<Light> lights;\n    std::vector<Light> lightsToAdd;\n    std::vector<Light> lightsToRemove;\n    std::vector<Light> lightsToUpdate;\n\n    // Query the server for the light states\n    if (serverConnection->QueryLightsState(lights)) {\n        // Check if the lights have been added to the server\n        for (Light light : lights) {\n            // Check if the light is already in the map\n            if (_lights.count(light.GetId()) == 0) {\n                // Add the light to the map and vector to add\n                _lights[light.GetId()] = light;\n                lightsToAdd.push_back(light);\n            } else {\n                // Check if the light has been updated\n                if (_lights[light.GetId()] != light) {\n                    // Add the light to the vector to update\n                    lightsToUpdate.push_back(light);\n                }\n            }\n        }\n\n        // Check if lights have been removed from the server\n        for (auto light : _lights) {\n            if (std::find(lights.begin(), lights.end(), light.second) == lights.end()) {\n                // Add the light to the vector to remove\n                lightsToRemove.push_back(light.second);\n            }\n        }\n\n        // Remove the lights from the map\n        for (Light light : lightsToRemove) {\n            _lights.erase(light.GetId());\n        }\n\n        // Add the new lights to the map\n        for (Light light : lightsToAdd) {\n            _lights[light.GetId()] = light;\n        }\n\n        // Update the lights\n        for (Light light : lightsToUpdate) {\n            _lights[light.GetId()] = light;\n        }\n    }\n}", "CodeBleu_score": 44.25858300605691}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex\n    std::lock_guard<std::mutex> lock(light_mutex);\n\n    // Get the current light states from the server\n    std::vector<LightState> light_states = _light_service->GetLightStates();\n\n    // Get the current light states from the server\n    std::vector<LightState> light_states_to_add = _light_service->GetLightStatesToAdd();\n\n    // Get the current light states from the server\n    std::vector<LightState> light_states_to_remove = _light_service->GetLightStatesToRemove();\n\n    // Update the local light states\n    for (auto &light_state : light_states) {\n        if (_lights.find(light_state.GetID()) == _lights.end()) {\n            _lights[light_state.GetID()] = new Light(light_state);\n        } else {\n            _lights[light_state.GetID()]->UpdateState(light_state);\n        }\n    }\n\n    // Add lights that were added\n    for (auto &light_state : light_states_to_add) {\n        if (_lights.find(light_state.GetID()) == _lights.end()) {\n            _lights[light_state.GetID()] = new Light(light_state);\n        }\n    }\n\n    // Remove lights that were removed\n    for (auto &light_state : light_states_to_remove) {\n        if (_lights.find(light_state.GetID()) != _lights.end()) {\n            delete _lights[light_state.GetID()];\n            _lights.erase(light_state.GetID());\n        }\n    }\n}", "CodeBleu_score": 44.91260835358095}, {"code": "void LightManager::QueryLightsStateToServer(){\n\t// Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(lights_mutex);\n\n    // Get the light states from the server\n    std::vector<LightState> light_states = _light_client->get_light_states();\n\n    // Update the local light states and create new light objects if they do not already exist in the _lights map\n    for (LightState light_state : light_states) {\n        if (_lights.find(light_state.id) == _lights.end()) {\n            Light light(light_state.id, light_state.name, light_state.type);\n            _lights.insert(std::make_pair(light_state.id, light));\n        }\n        _lights[light_state.id].UpdateLightState(light_state);\n    }\n}", "CodeBleu_score": 36.86693259341754}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tif (dirty) {\n\t\tif (server_socket != NULL) {\n\t\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t\t\tif (dirty) {\n\t\t\t\tif (discard_client) {\n\t\t\t\t\t// Create a message with the updated light states\n\t\t\t\t\tMessage* message = new Message();\n\t\t\t\t\tmessage->type = MessageType::LIGHT_STATE_UPDATE;\n\t\t\t\t\tmessage->data = new LightStateUpdate();\n\t\t\t\t\tmessage->data->lights = lights;\n\t\t\t\t\tmessage->data->discard_client = true;\n\n\t\t\t\t\t// Send the message to the server\n\t\t\t\t\tserver_socket->SendMessage(message);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Create a message with the updated light states\n\t\t\t\t\tMessage* message = new Message();\n\t\t\t\t\tmessage->type = MessageType::LIGHT_STATE_UPDATE;\n\t\t\t\t\tmessage->data = new LightStateUpdate();\n\t\t\t\t\tmessage->data->lights = lights;\n\t\t\t\t\tmessage->data->discard_client = false;\n\n\t\t\t\t\t// Send the message to the server\n\t\t\t\t\tserver_socket->SendMessage(message);\n\t\t\t\t}\n\n\t\t\t\t// Clear the changes\n\t\t\t\tchanges.clear();\n\t\t\t\tdirty = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 36.90195264175416}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tif (dirty) {\n\t\tstd::lock_guard<std::mutex> lock(lights_mutex);\n\t\tif (dirty) {\n\t\t\tMessage msg;\n\t\t\tmsg.type = MessageType::LIGHTS_STATE;\n\t\t\tmsg.lights_state.lights.clear();\n\t\t\tmsg.lights_state.lights.resize(lights.size());\n\t\t\tfor (int i = 0; i < lights.size(); i++) {\n\t\t\t\tmsg.lights_state.lights[i] = lights[i].state;\n\t\t\t}\n\t\t\tif (discard_client) {\n\t\t\t\tmsg.lights_state.discard_client = true;\n\t\t\t}\n\t\t\tSendMessage(msg);\n\t\t\tchanges.clear();\n\t\t\tdirty = false;\n\t\t}\n\t}\n}", "CodeBleu_score": 37.7788487599957}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client){\n\tstd::lock_guard<std::mutex> lock(light_mutex);\n\tif (dirty) {\n\t\tstd::string message = \"lights\";\n\t\tstd::stringstream ss;\n\t\tss << lights_state;\n\t\tmessage += ss.str();\n\t\tif (discard_client) {\n\t\t\tmessage += \" 1\";\n\t\t}\n\t\telse {\n\t\t\tmessage += \" 0\";\n\t\t}\n\t\t// Send the message to the server\n\t\tif (sockfd != -1) {\n\t\t\tsend(sockfd, message.c_str(), message.length(), 0);\n\t\t}\n\t\tdirty = false;\n\t}\n}", "CodeBleu_score": 28.81460265075781}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message){\n\tif (sensor_id == \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"Sending message: \" << message << std::endl;\n\t\tepisode->Send(sensor_id, message);\n\t} else {\n\t\tstd::cout << \"Warning: Sensor ID is not 'sensor.other.v2x_custom', so message will not be sent.\" << std::endl;\n\t}\n}", "CodeBleu_score": 41.45364075005843}, {"code": "void ServerSideSensor::Send(std::string message){\n\tif (sensor_id != \"sensor.other.v2x_custom\") {\n    std::cout << \"Warning: Sending a message to a non-V2X sensor.\" << std::endl;\n    return;\n  }\n\n  if (episode == nullptr) {\n    std::cout << \"Warning: Sending a message to a sensor with no episode.\" << std::endl;\n    return;\n  }\n\n  std::cout << \"Sending message to episode: \" << episode->GetEpisodeId() << std::endl;\n  std::cout << \"Message: \" << message << std::endl;\n  episode->SendCustomMessage(message);\n}", "CodeBleu_score": 43.4901228950274}, {"code": "void ServerSideSensor::Send(std::string message){\n\tif (this->id == \"sensor.other.v2x_custom\") {\n\t\tstd::cout << \"Sending message to episode: \" << message << std::endl;\n\t\tthis->context->Send(message);\n\t}\n\telse {\n\t\tstd::cout << \"WARNING: Sensor ID does not match.\" << std::endl;\n\t}\n}", "CodeBleu_score": 38.35440406791979}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n\t\t// Register the vehicle with the traffic manager\n\t\ttm_port_ = tm_port;\n\t\ttm_enabled_ = true;\n\t\ttm_->RegisterVehicle(this);\n\t} else {\n\t\t// Unregister the vehicle with the traffic manager\n\t\ttm_enabled_ = false;\n\t\ttm_->UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 42.53468686520748}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n        // Register with the traffic manager\n        if (tm_port != 0) {\n            TrafficMgr::GetInstance().RegisterVehicle(this, tm_port);\n        }\n    } else {\n        // Unregister with the traffic manager\n        if (tm_port != 0) {\n            TrafficMgr::GetInstance().UnregisterVehicle(this, tm_port);\n        }\n    }\n}", "CodeBleu_score": 44.76075999866201}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port){\n\tif (enabled) {\n\t\t// Register with TM\n\t\ttm_port_ = tm_port;\n\t\ttm_->RegisterVehicle(this);\n\t} else {\n\t\t// Unregister with TM\n\t\ttm_->UnregisterVehicle(this);\n\t}\n}", "CodeBleu_score": 41.16751329378403}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start(){\n\t// Get the walker actor\n\tauto walker = GetOwner();\n\n\t// Register the walker with the navigation system\n\tauto navSystem = GetWorld()->GetNavigationSystem();\n\tnavSystem->RegisterWalker(walker, GetOwner()->GetActorLocation());\n\n\t// Disable the physics simulation and collisions for the walker\n\twalker->SetActorEnableCollision(false);\n\twalker->SetActorEnableGravity(false);\n}", "CodeBleu_score": 36.82361563123455}, {"code": "void WalkerAIController::Start(){\n\t// Get the walker actor from the controller's owner\n    auto walker = Cast<AWalker>(GetOwner());\n\n    // Retrieve the episode\n    auto episode = GetOwner()->GetWorld()->GetEpisode();\n\n    // Register the walker with the navigation system\n    auto navigationSystem = episode->GetNavigationSystem();\n    navigationSystem->RegisterWalker(walker);\n\n    // Disable the walker's physics and collisions\n    walker->DisablePhysics();\n    walker->SetActorEnableCollision(false);\n\n    // Set the walker's speed\n    walker->SetSpeed(walkerSpeed);\n}", "CodeBleu_score": 44.05862531450698}, {"code": "void WalkerAIController::Start(){\n\tSuper::Start();\n\n\t// Get the walker actor\n\tACharacter* walker = GetPawn();\n\tif (walker) {\n\t\t// Get the walker's location\n\t\tFVector location = walker->GetActorLocation();\n\n\t\t// Add the walker to the navigation system\n\t\tnavSystem->AddWalker(walker, location);\n\n\t\t// Disable the physics simulation and collisions for the walker\n\t\twalker->SetActorEnableCollision(false);\n\t\twalker->SetActorSimulatePhysics(false);\n\t}\n}", "CodeBleu_score": 37.22362215949669}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (auto* nav = GetNavAgent()) {\n        auto* walker = GetPawn<AWalker>();\n        if (walker) {\n            walker->SetMaxSpeed(max_speed);\n        }\n        else {\n            UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to find walker\"));\n        }\n    }\n    else {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to find navigation instance\"));\n    }\n}", "CodeBleu_score": 47.83310545193896}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tif (navigation_instance_ != nullptr) {\n    auto walker_component = GetOwner()->GetComponent<Walker>();\n    if (walker_component != nullptr) {\n      if (navigation_instance_->SetMaxSpeed(walker_component, max_speed)) {\n        UE_LOG(LogCarla, Log, TEXT(\"Walker speed set to %f\"), max_speed);\n      } else {\n        UE_LOG(LogCarla, Log, TEXT(\"Walker speed not set\"));\n      }\n    } else {\n      UE_LOG(LogCarla, Log, TEXT(\"Walker not found\"));\n    }\n  } else {\n    UE_LOG(LogCarla, Log, TEXT(\"Navigation instance not found\"));\n  }\n}", "CodeBleu_score": 51.72307682287772}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed){\n\tauto navigation = GetOwner()->GetWorld()->GetNavigationSystem();\n\tif (navigation) {\n\t\tauto walker = Cast<AWalker>(GetOwner());\n\t\tif (walker) {\n\t\t\tif (navigation->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Successfully set maximum speed for walker %s\"), *GetOwner()->GetName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed for walker %s\"), *GetOwner()->GetName());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to retrieve walker %s\"), *GetOwner()->GetName());\n\t\t}\n\t}\n\telse {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to retrieve navigation system\"));\n\t}\n}", "CodeBleu_score": 45.94580162924326}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> prev = parent->GetPrevious(this);\n\n    for (auto &wp : prev) {\n        if (wp->DistanceTo(this) > distance) {\n            result.push_back(wp);\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 51.48214717032984}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n\n\t// Get previous waypoints from the parent map\n\tstd::vector<Waypoint> previousWaypoints = GetParentMap()->GetPreviousWaypoints(*this, distance);\n\n\t// For each previous waypoint, create a new Waypoint object and add it to the result vector\n\tfor (auto &wp : previousWaypoints) {\n\t\tresult.push_back(new Waypoint(wp));\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 45.91425833902504}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const{\n\tstd::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> previous = map_->GetPreviousWaypoints(this);\n    for (auto waypoint : previous) {\n        if (distance > waypoint->DistanceTo(this)) {\n            result.push_back(waypoint);\n        }\n    }\n    return result;\n}", "CodeBleu_score": 46.60648595177381}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::unordered_set<SharedPtr<Signal>> unique_signals;\n  for (auto signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      result.push_back(signal->GetLandmark());\n    }\n  }\n  return result;\n}", "CodeBleu_score": 40.84333580961293}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (auto signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      result.push_back(signal->GetLandmark());\n    }\n  }\n  return result;\n}", "CodeBleu_score": 40.30538700112764}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const{\n\tstd::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (auto signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      SharedPtr<Landmark> landmark = new Landmark(signal->GetWaypoint(), signal->GetSignal());\n      result.push_back(landmark);\n    }\n  }\n  return result;\n}", "CodeBleu_score": 44.990640602250444}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\ttime_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->ApplySettings(settings, local_timeout);\n}", "CodeBleu_score": 21.143182593448735}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t// Get the current world snapshot\n    WorldSnapshot snapshot = GetSnapshot();\n\n    // Apply the settings\n    snapshot.ApplySettings(settings);\n\n    // Set a local timeout based on the provided timeout or the episode's networking timeout\n    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n\n    // Apply the settings\n    uint64_t tick_id = _episode.Lock()->ApplySettings(settings, local_timeout);\n\n    // If the settings include a fixed delta time, attempt to verify the accuracy of this setting over a series of ticks\n    if (settings.fixed_delta_seconds.has_value()) {\n        // Attempt to verify the accuracy of this setting over a series of ticks\n        double delta_seconds = settings.fixed_delta_seconds.value();\n        uint64_t num_ticks = 10;\n        double max_delta_seconds = 0.0;\n        for (uint64_t i = 0; i < num_ticks; ++i) {\n            // Tick the world\n            Tick(local_timeout);\n\n            // Get the current world snapshot\n            snapshot = GetSnapshot();\n\n            // Get the current tick\n            uint64_t current_tick = snapshot.GetTick();\n\n            // Get the delta time\n            double current_delta_seconds = snapshot.GetDeltaSeconds();\n\n            // Compute the delta time\n            double delta_seconds_error = current_delta_seconds - delta_seconds;\n\n            // If the delta time is greater than the maximum, update the maximum\n            if (delta_seconds_error > max_delta_seconds) {\n                max_delta_seconds = delta_seconds_error;\n            }\n        }\n\n        // If the delta time is not within 10% of the expected delta time, log a warning\n        if (max_delta_seconds > 0.10 * delta_seconds) {\n            LogWarning(\"The delta time setting was not applied correctly. \"\n                       \"The delta time is expected to be \" +\n                       std::to_string(delta_seconds) + \" but was \"", "CodeBleu_score": 54.07278342030959}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout){\n\t// Apply the settings to the world.\n    uint64_t settings_id = _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    // Apply the settings to the world.\n    _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    _episode.Lock()->ApplySettings(settings);\n    // Apply the settings to the world.\n    _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    _episode.Lock()->ApplySettings(settings);\n    // Apply the settings to the world.\n    _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    _episode.Lock()->ApplySettings(settings);\n    // Apply the settings to the world.\n    _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    _episode.Lock()->ApplySettings(settings);\n    // Apply the settings to the world.\n    _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    _episode.Lock()->ApplySettings(settings);\n    // Apply the settings to the world.\n    _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    _episode.Lock()->ApplySettings(settings);\n    // Apply the settings to the world.\n    _episode.Lock()->ApplySettings(settings);\n    // Set a local timeout based on the provided timeout or the episode's networking timeout.\n    _episode.Lock()->Apply", "CodeBleu_score": 32.87656459954076}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tfloat x1, y1, x2, y2, x, y;\n    float dx, dy;\n    float lengthSquared;\n    float length;\n    float t;\n\n    x1 = p1.x;\n    y1 = p1.y;\n    x2 = p2.x;\n    y2 = p2.y;\n    x = point.x;\n    y = point.y;\n\n    dx = x2 - x1;\n    dy = y2 - y1;\n    lengthSquared = dx * dx + dy * dy;\n    if (lengthSquared == 0)\n        return {0, std::sqrt(x * x + y * y - x1 * x1 - y1 * y1)};\n\n    length = std::sqrt(lengthSquared);\n    t = ((x - x1) * dx + (y - y1) * dy) / lengthSquared;\n    if (t < 0)\n        return {0, std::sqrt(x * x + y * y - x1 * x1 - y1 * y1)};\n    if (t > length)\n        return {length, std::sqrt(x * x + y * y - x2 * x2 - y2 * y2)};\n\n    return {t, std::sqrt(x * x + y * y - (x1 + t * dx) * (x1 + t * dx) - (y1 + t * dy) * (y1 + t * dy))};\n}", "CodeBleu_score": 37.85748597032105}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\t[](const Math::Vector2& point, const Math::Vector2& start, const Math::Vector2& end) -> std::pair<float, float> {\n\t\tMath::Vector2 segment = end - start;\n\t\tfloat length = segment.Length();\n\t\tfloat squaredLength = length * length;\n\n\t\tif (squaredLength == 0) {\n\t\t\treturn std::make_pair(0.f, (point - start).Length());\n\t\t}\n\n\t\tfloat t = Math::Clamp(Math::Dot(point - start, segment) / squaredLength, 0.f, 1.f);\n\n\t\tMath::Vector2 projection = start + t * segment;\n\n\t\treturn std::make_pair(Math::Distance(point, projection), Math::Distance(point, projection));\n\t}\n}", "CodeBleu_score": 43.568093908206706}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint{\n\tstd::pair<float, float> Math::DistanceSegmentToPoint(const Vector2& point, const Vector2& p1, const Vector2& p2) {\n\t\tVector2 v = p2 - p1;\n\t\tfloat lengthSquared = v.LengthSquared();\n\t\tfloat length = std::sqrt(lengthSquared);\n\t\tif (length == 0.0f) {\n\t\t\treturn std::make_pair(0.0f, (point - p1).Length());\n\t\t}\n\t\tfloat t = ((point - p1).Dot(v) / lengthSquared);\n\t\tt = Math::Clamp(t, 0.0f, 1.0f);\n\t\tVector2 projection = p1 + (t * v);\n\t\treturn std::make_pair(length, (point - projection).Length());\n\t}\n}", "CodeBleu_score": 47.000066123824695}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    index_type initial_index = static_cast<index_type>(_vertices.size());\n    _vertices.insert(_vertices.end(), vertices.begin(), vertices.end());\n    for (size_t i = 1; i < vertices.size() - 1; i++) {\n        AddIndex(initial_index);\n        AddIndex(initial_index + i);\n        AddIndex(initial_index + i + 1);\n    }\n}", "CodeBleu_score": 53.662137575045556}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    index_type initial = _indexes.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size() - 1; i++) {\n        AddIndex(initial);\n        AddIndex(initial + i);\n        AddIndex(initial + i + 1);\n    }\n}", "CodeBleu_score": 49.02604908756892}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices){\n\tassert(vertices.size() >= 3);\n    index_type initial_index = _indexes.size();\n    AddVertices(vertices);\n    for (size_t i = 1; i < vertices.size(); ++i) {\n        AddIndex(initial_index);\n        AddIndex(initial_index + i);\n        AddIndex(initial_index + i - 1);\n    }\n}", "CodeBleu_score": 49.16611713832944}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (message->IsValid()) {\n    _strand.post([this, message]() {\n      if (_socket.is_open()) {\n        _socket.expires_after(std::chrono::seconds(1));\n        _socket.async_write_some(\n            boost::asio::buffer(message->Data(), message->Size()),\n            std::bind(&Primary::handle_sent,\n                      shared_from_this(),\n                      std::placeholders::_1,\n                      std::placeholders::_2,\n                      message));\n      }\n    });\n  } else {\n    std::stringstream ss;\n    ss << \"Invalid message sent: \" << message->Data();\n    Log(ss.str());\n  }\n}", "CodeBleu_score": 29.83963395732664}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (message->IsValid()) {\n    boost::asio::post(strand, [this, message]() {\n      if (socket.is_open()) {\n        boost::asio::async_write(socket, boost::asio::buffer(message->GetData(), message->GetSize()),\n          boost::asio::bind_executor(strand,\n            [this, message](const boost::system::error_code &error, std::size_t bytes_transferred) {\n              handle_sent(error, bytes_transferred, message);\n            }));\n      }\n    });\n  } else {\n    Log(\"Invalid message\");\n  }\n}", "CodeBleu_score": 31.963543023931827}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message){\n\tif (message->IsValid()) {\n    // The message is valid, so we post a lambda to the strand to send the message.\n    strand.post([this, message]() {\n      // Check if the socket is open.\n      if (socket.is_open()) {\n        // The socket is open, so we set a timeout and send the message.\n        boost::system::error_code ec;\n        socket.expires_from_now(boost::posix_time::seconds(timeout), ec);\n        if (!ec) {\n          // The timeout was set successfully, so we initiate the asynchronous write.\n          boost::asio::async_write(socket,\n            boost::asio::buffer(message->GetData(), message->GetSize()),\n            boost::bind(&Primary::handle_sent, shared_from_this(), boost::asio::placeholders::error));\n        } else {\n          // The timeout could not be set, so we log the error and close the connection.\n          Log(\"Failed to set timeout for write: \" + ec.message());\n          Close();\n        }\n      } else {\n        // The socket is not open, so we log the error and close the connection.\n        Log(\"Socket is not open for write.\");\n        Close();\n      }\n    });\n  } else {\n    // The message is not valid, so we log the error and close the connection.\n    Log(\"Message is not valid for write.\");\n    Close();\n  }\n}", "CodeBleu_score": 39.41258131794329}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (ec) {\n        if (ec == boost::asio::error::operation_aborted) {\n            return;\n        }\n        LOG(WARNING) << \"Error while closing socket: \" << ec.message();\n    }\n    deadline_timer.cancel();\n    if (socket.is_open()) {\n        boost::system::error_code ec;\n        socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        if (ec) {\n            LOG(WARNING) << \"Error while shutting down socket: \" << ec.message();\n        }\n        socket.close();\n    }\n    if (on_closed) {\n        on_closed();\n    }\n    LOG(INFO) << \"Session closed\";\n}", "CodeBleu_score": 50.98579360646389}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (deadline_timer.is_active()) {\n\t\tdeadline_timer.cancel();\n\t}\n\tif (socket.is_open() && !ec) {\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\tsocket.close(ignored_ec);\n\t}\n\tif (on_closed) {\n\t\ton_closed(this);\n\t}\n\tLog(LogLevel::Debug, \"Session closed\");\n}", "CodeBleu_score": 51.30208711189671}, {"code": "void Primary::CloseNow(boost::system::error_code ec){\n\tif (ec) {\n\t\tif (ec.value() != boost::system::errc::operation_canceled) {\n\t\t\tstd::cerr << \"Error while closing socket: \" << ec.message() << std::endl;\n\t\t}\n\t}\n\telse {\n\t\tif (socket_.is_open()) {\n\t\t\tboost::system::error_code ec;\n\t\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n\t\t\tif (ec && ec.value() != boost::system::errc::not_connected) {\n\t\t\t\tstd::cerr << \"Error while shutting down socket: \" << ec.message() << std::endl;\n\t\t\t}\n\t\t\tsocket_.close(ec);\n\t\t\tif (ec) {\n\t\t\t\tstd::cerr << \"Error while closing socket: \" << ec.message() << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (on_closed_) {\n\t\ton_closed_();\n\t}\n\n\tstd::cout << \"Session closed\" << std::endl;\n}", "CodeBleu_score": 46.760107302619254}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive(){\n\tstd::string message = \"Are you alive?\";\n\tstd::string buffer = message + \"\n\";\n\tstd::string response;\n\tstd::string command = \"YOU_ALIVE\";\n\tstd::string error;\n\n\tstd::cout << \"Sending message: \" << message << std::endl;\n\tWriteToNextRouter(buffer, command, error);\n\tif (error != \"\") {\n\t\tstd::cout << \"Error: \" << error << std::endl;\n\t}\n\telse {\n\t\tstd::cout << \"Message sent.\" << std::endl;\n\t}\n\n\tReadFromNextRouter(response, error);\n\tif (error != \"\") {\n\t\tstd::cout << \"Error: \" << error << std::endl;\n\t}\n\telse {\n\t\tstd::cout << \"Response: \" << response << std::endl;\n\t}\n}", "CodeBleu_score": 36.318862945218136}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t// Create a buffer to hold the message\n\tchar buffer[100];\n\n\t// Create a string to hold the message\n\tstring message = \"Are you alive?\";\n\n\t// Create a string to hold the response\n\tstring response;\n\n\t// Create a string to hold the response type\n\tstring responseType;\n\n\t// Create a string to hold the response length\n\tstring responseLength;\n\n\t// Create a string to hold the response data\n\tstring responseData;\n\n\t// Create a string to hold the response checksum\n\tstring responseChecksum;\n\n\t// Create a string to hold the response command\n\tstring responseCommand;\n\n\t// Create a string to hold the response status\n\tstring responseStatus;\n\n\t// Create a string to hold the response data\n\tstring responseData;\n\n\t// Create a string to hold the response checksum\n\tstring responseChecksum;\n\n\t// Create a string to hold the response command\n\tstring responseCommand;\n\n\t// Create a string to hold the response status\n\tstring responseStatus;\n\n\t// Create a string to hold the response data\n\tstring responseData;\n\n\t// Create a string to hold the response checksum\n\tstring responseChecksum;\n\n\t// Create a string to hold the response command\n\tstring responseCommand;\n\n\t// Create a string to hold the response status\n\tstring responseStatus;\n\n\t// Create a string to hold the response data\n\tstring responseData;\n\n\t// Create a string to hold the response checksum\n\tstring responseChecksum;\n\n\t// Create a string to hold the response command\n\tstring responseCommand;\n\n\t// Create a string to hold the response status\n\tstring responseStatus;\n\n\t// Create a string to hold the response data\n\tstring responseData;\n\n\t// Create a string to hold the response checksum\n\tstring responseChecksum;\n\n\t// Create a string to hold the response command\n\tstring responseCommand;\n\n\t// Create a string to hold the response status\n\tstring responseStatus;\n\n\t// Create a string to hold the response data\n\tstring responseData;\n\n\t// Create a string to hold the response checksum\n\tstring responseChecksum;\n\n\t// Create a string to hold the response", "CodeBleu_score": 27.856268201097638}, {"code": "void PrimaryCommands::SendIsAlive(){\n\t// Create buffer\n\tchar buffer[1024];\n\tsprintf(buffer, \"Are you alive?\");\n\n\t// Log sending action\n\tstd::cout << \"Sending \\\"\" << buffer << \"\\\" to router with command YOU_ALIVE.\" << std::endl;\n\n\t// Write to router\n\tWriteToRouter(YOU_ALIVE, buffer);\n\n\t// Read from router\n\tReadFromRouter();\n}", "CodeBleu_score": 19.092743357693816}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Create a buffer with the sensor ID and send the ENABLE_ROS command to the router\n    Buffer* buffer = new Buffer(sensor_id, ENABLE_ROS);\n    router->Send(buffer);\n\n    // Wait for and process the server's response\n    Buffer* response = router->Receive();\n    if (response->GetCommand() == ENABLE_ROS_SUCCESS) {\n        // The sensor has been activated on at least one server\n        // Log a success message\n        cout << \"Successfully activated sensor \" << sensor_id << \" on a secondary server.\" << endl;\n    } else if (response->GetCommand() == ENABLE_ROS_FAILURE) {\n        // The sensor was not found on any server\n        // Log an error message\n        cout << \"Unable to activate sensor \" << sensor_id << \" on any secondary server.\" << endl;\n    } else {\n        // The server's response was invalid\n        // Log an error message\n        cout << \"Invalid response from secondary server.\" << endl;\n    }\n    delete response;\n}", "CodeBleu_score": 42.85327854191402}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Check if the sensor has been activated on any secondary server\n  if (sensor_id < 0 || sensor_id >= sensor_ids.size()) {\n    std::cout << \"Sensor ID \" << sensor_id << \" not found on any secondary server.\" << std::endl;\n    return;\n  }\n\n  // Create a buffer with the sensor ID and send the command\n  char* buffer = new char[sizeof(stream_id)];\n  memcpy(buffer, &sensor_id, sizeof(stream_id));\n  router->SendCommand(ENABLE_ROS, buffer, sizeof(stream_id));\n\n  // Wait for the server's response\n  router->WaitForResponse(ENABLE_ROS);\n  if (router->GetResponseCode() != RESPONSE_OK) {\n    std::cout << \"Server failed to enable sensor \" << sensor_id << \" for ROS.\" << std::endl;\n  }\n\n  // Delete the buffer\n  delete[] buffer;\n}", "CodeBleu_score": 46.46510633096748}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id){\n\t// Check if the sensor is activated on any secondary server\n\tif (SensorIsActivated(sensor_id)) {\n\t\t// Create buffer with sensor ID\n\t\tstd::stringstream buffer;\n\t\tbuffer << sensor_id;\n\t\t// Send ENABLE_ROS command to server using the router\n\t\tSendCommand(buffer.str(), \"ENABLE_ROS\");\n\t\t// Wait for and process the server's response\n\t\tProcessResponse();\n\t}\n\telse {\n\t\t// Log error message\n\t\tstd::cout << \"Error: Sensor \" << sensor_id << \" not activated on any secondary server.\" << std::endl;\n\t}\n}", "CodeBleu_score": 26.770588949845354}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tauto token = GetTokenIfEnabled(sensor_id);\n  if (token) {\n    log_info(\"using existing token for sensor: \", sensor_id);\n    return token;\n  }\n  log_info(\"activating sensor: \", sensor_id);\n  auto new_token = SendGetToken(sensor_id);\n  _tokens[sensor_id] = new_token;\n  _enabled_sensors.insert(sensor_id);\n  log_info(\"activated sensor: \", sensor_id);\n  return new_token;\n}", "CodeBleu_score": 41.98935138122734}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"sensor already activated\");\n    return it->second;\n  }\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, carla::Buffer((carla::Buffer::value_type *) &sensor_id, (size_t) sizeof(stream_id)));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  _tokens[sensor_id] = new_token;\n  return new_token;\n}", "CodeBleu_score": 57.86565636788661}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id){\n\tlog_info(\"asking for a token\");\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    log_info(\"token already exists for sensor \", sensor_id);\n    return it->second;\n  }\n\n  token_type new_token = SendGetToken(sensor_id);\n  _tokens.insert(std::make_pair(sensor_id, new_token));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}", "CodeBleu_score": 51.976656929943864}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename){\n\tstd::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n\n  // parse the content\n  return Load(std::move(content));\n}", "CodeBleu_score": 99.56354618969615}, {"code": "bool Navigation::Load(const std::string &filename){\n\treturn Load(filename.c_str());\n}", "CodeBleu_score": 18.65403852183727}, {"code": "bool Navigation::Load(const std::string &filename){\n\treturn Load(filename);\n}", "CodeBleu_score": 15.784950759647561}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (IsReady()) {\n        if (m_crowd != nullptr) {\n            std::lock_guard<std::mutex> lock(m_mutex);\n            auto walker = m_walker_map.find(id);\n            auto vehicle = m_vehicle_map.find(id);\n            if (walker != m_walker_map.end()) {\n                m_crowd->removeAgent(walker->second);\n                m_walker_map.erase(walker);\n                return true;\n            }\n            else if (vehicle != m_vehicle_map.end()) {\n                m_crowd->removeAgent(vehicle->second);\n                m_vehicle_map.erase(vehicle);\n                return true;\n            }\n        }\n    }\n    return false;\n}", "CodeBleu_score": 53.52877381094745}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (ready) {\n\t\tif (crowd != nullptr) {\n\t\t\tif (walker_manager != nullptr) {\n\t\t\t\tif (vehicle_manager != nullptr) {\n\t\t\t\t\tif (walker_manager->Contains(id)) {\n\t\t\t\t\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t\t\t\t\t\tcrowd->removeAgent(walker_manager->GetAgent(id));\n\t\t\t\t\t\twalker_manager->RemoveAgent(id);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (vehicle_manager->Contains(id)) {\n\t\t\t\t\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t\t\t\t\t\tcrowd->removeAgent(vehicle_manager->GetAgent(id));\n\t\t\t\t\t\tvehicle_manager->RemoveAgent(id);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 43.65570123730389}, {"code": "bool Navigation::RemoveAgent(ActorId id){\n\tif (!Ready()) {\n\t\treturn false;\n\t}\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\tif (walker_mapping.count(id) > 0) {\n\t\t// walker\n\t\tif (crowd->removeAgent(walker_mapping[id])) {\n\t\t\twalker_mapping.erase(id);\n\t\t\treturn true;\n\t\t}\n\t}\n\telse if (vehicle_mapping.count(id) > 0) {\n\t\t// vehicle\n\t\tif (crowd->removeAgent(vehicle_mapping[id])) {\n\t\t\tvehicle_mapping.erase(id);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "CodeBleu_score": 33.20620739942892}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles){\n\tge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }", "CodeBleu_score": 31.214345939371647}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\tbool result = false;\n\n\t// Check if the actor is a walker or a vehicle\n\tif (actor_map_.find(id) != actor_map_.end()) {\n\n\t\t// Check if the actor is in the map\n\t\tif (actor_map_.at(id) != nullptr) {\n\n\t\t\t// Check if the actor is a walker\n\t\t\tif (actor_map_.at(id)->GetTypeId() == Actor::GetTypeIdStatic()) {\n\n\t\t\t\t// Check if the actor is a vehicle\n\t\t\t\tif (actor_map_.at(id)->GetTypeId() == Walker::GetTypeIdStatic()) {\n\n\t\t\t\t\t// Get the walker\n\t\t\t\t\tauto walker = boost::static_pointer_cast<Walker>(actor_map_.at(id));\n\n\t\t\t\t\t// Check if the walker is a pedestrian\n\t\t\t\t\tif (walker->GetWalkerType() == Walker::WalkerType::Pedestrian) {\n\n\t\t\t\t\t\t// Get the pedestrian\n\t\t\t\t\t\tauto pedestrian = boost::static_pointer_cast<Pedestrian>(walker);\n\n\t\t\t\t\t\t// Get the pedestrian's bounding box\n\t\t\t\t\t\tauto bounding_box = pedestrian->GetBoundingBox();\n\n\t\t\t\t\t\t// Compute the squared distance\n\t\t\t\t\t\tauto squared_distance = (bounding_box.location - direction).LengthSquared();\n\n\t\t\t\t\t\t// Check if the pedestrian is near\n\t\t\t\t\t\tif (squared_distance < distance * distance) {\n\n\t\t\t\t\t\t\t// Enter the critical section\n\t\t\t\t\t\t\tstd::lock_guard<std::mutex> lock(mutex_);\n\n\t\t\t\t\t\t\t// Check if the pedestrian is near\n\t\t\t\t\t\t\tif (pedestrian_map_.find(id) != pedestrian_map_.end()) {\n\n\t\t\t\t\t\t\t\t// Check if the ped", "CodeBleu_score": 43.14906762393752}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t// Check if the actor is a walker or a vehicle\n\tif (id == -1) {\n\t\treturn false;\n\t}\n\telse if (id < 0) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the map\n\tif (map.find(id) == map.end()) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (map[id].crowd_idx == -1) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (crowd[map[id].crowd_idx].GetState() == CROWDAGENT_STATE_INVALID) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (crowd[map[id].crowd_idx].GetState() == CROWDAGENT_STATE_WALKING) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (crowd[map[id].crowd_idx].GetState() == CROWDAGENT_STATE_OFFMESH) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (crowd[map[id].crowd_idx].GetState() == CROWDAGENT_STATE_IDLE) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (crowd[map[id].crowd_idx].GetState() == CROWDAGENT_STATE_VEHICLE) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (crowd[map[id].crowd_idx].GetState() == CROWDAGENT_STATE_INVALID) {\n\t\treturn false;\n\t}\n\n\t// Check if the actor is in the crowd\n\tif (crowd[map[id].crowd_idx].GetState() == CROWDAGENT_STATE_INVALID) {", "CodeBleu_score": 29.762534785785178}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction){\n\t// Check if the actor is a walker or a vehicle\n\tif (IsWalker(id) || IsVehicle(id)) {\n\t\t// Get the actor's location\n\t\tcarla::geom::Location actorLocation = GetActorLocation(id);\n\t\t// Check if the actor is near a vehicle\n\t\treturn HasVehicleNear(actorLocation, distance, direction);\n\t}\n\t// If the actor is not a walker or a vehicle, return false\n\treturn false;\n}", "CodeBleu_score": 20.346146745714}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tEventResult result;\n    WalkerEventVisitor visitor(id, delta, info, *this);\n    boost::apply_visitor(visitor, info.route[info.current]);\n    result = visitor.result;\n    return result;\n}", "CodeBleu_score": 53.89408519227206}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tauto &walker = m_walkers.at(id);\n    auto &route = walker.GetRoute();\n    auto &routePoints = route.GetPoints();\n    auto &routeIndex = walker.GetRouteIndex();\n    auto &routePoint = routePoints.at(routeIndex);\n    auto &context = walker.GetContext();\n    auto &event = routePoint.GetEvent();\n\n    WalkerEventVisitor visitor(delta, id, walker, routePoint, context);\n    auto result = boost::apply_visitor(visitor, event);\n    return result;\n}", "CodeBleu_score": 43.47029569058983}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta){\n\tWalkerEventVisitor visitor(id, delta, *this);\n    EventResult result;\n    result = boost::apply_visitor(visitor, info.route.GetCurrentPoint().event);\n    return result;\n}", "CodeBleu_score": 50.37556750279069}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder){\n\t       // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }", "CodeBleu_score": 8.364645955963596}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\t// first connection\n\t\t\tthis->first_connection_ = true;\n\t\t}\n\t\tthis->matched_count_ = info.current_count;\n\t} else if (info.current_count_change == -1) {\n\t\t// lost connection\n\t\tthis->matched_count_ = info.current_count;\n\t} else {\n\t\t// invalid count change\n\t\tstd::stringstream ss;\n\t\tss << \"CarlaListenerImpl::on_publication_matched: Invalid count change \" << info.current_count_change << \".\";\n\t\tROS_ERROR(\"%s\", ss.str().c_str());\n\t}\n}", "CodeBleu_score": 59.957405083832796}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.total_count == 0) {\n            RCLCPP_ERROR(this->get_logger(), \"Publication count is 0\");\n        } else {\n            RCLCPP_INFO(this->get_logger(), \"Publication count is %d\", info.total_count);\n            this->matched_count = info.total_count;\n            this->first_connection = true;\n        }\n    } else if (info.current_count_change == -1) {\n        if (this->matched_count == 0) {\n            RCLCPP_ERROR(this->get_logger(), \"Publication count is 0\");\n        } else {\n            this->matched_count--;\n        }\n    } else {\n        RCLCPP_ERROR(this->get_logger(), \"Invalid publication count change\");\n    }\n}", "CodeBleu_score": 55.82759339827243}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info){\n\tstd::lock_guard<std::mutex> lock(mutex_);\n    if (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            first_connection_ = true;\n            matched_count_ = 1;\n        } else if (info.current_count > 1) {\n            matched_count_ = info.current_count;\n            std::cout << \"CarlaListenerImpl::on_publication_matched: \" << matched_count_ << \" matches\" << std::endl;\n        } else {\n            std::cout << \"CarlaListenerImpl::on_publication_matched: Invalid count change: \" << info.current_count_change << \" -> \" << info.current_count << std::endl;\n        }\n    } else if (info.current_count_change == -1) {\n        if (info.current_count == 0) {\n            matched_count_ = 0;\n            std::cout << \"CarlaListenerImpl::on_publication_matched: \" << matched_count_ << \" matches\" << std::endl;\n        } else {\n            std::cout << \"CarlaListenerImpl::on_publication_matched: Invalid count change: \" << info.current_count_change << \" -> \" << info.current_count << std::endl;\n        }\n    } else {\n        std::cout << \"CarlaListenerImpl::on_publication_matched: Invalid count change: \" << info.current_count_change << \" -> \" << info.current_count << std::endl;\n    }\n}", "CodeBleu_score": 56.99706809980756}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            first_connected = true;\n        }\n        matched = info.current_count;\n    } else if (info.current_count_change == -1) {\n        if (info.current_count == 0) {\n            matched = 0;\n            if (first_connected) {\n                first_connected = false;\n                subscriber->destroy();\n            }\n        } else {\n            matched = info.current_count;\n        }\n    } else {\n        std::cout << \"CarlaSubscriberListenerImpl::on_subscription_matched: Invalid change count.\" << std::endl;\n    }\n}", "CodeBleu_score": 64.02829546777367}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tstd::cout << \"Subscription matched\" << std::endl;\n\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tfirst_connected = true;\n\t\t}\n\t\tmatched_count++;\n\t} else if (info.current_count_change == -1) {\n\t\tmatched_count--;\n\t\tif (matched_count == 0) {\n\t\t\tstd::cout << \"Destroying subscriber\" << std::endl;\n\t\t\tdelete subscriber;\n\t\t\tsubscriber = nullptr;\n\t\t}\n\t} else {\n\t\tstd::cout << \"Invalid count change\" << std::endl;\n\t}\n}", "CodeBleu_score": 56.64318319863707}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info){\n\tif (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            if (info.last_publication_handle == efd::InstanceHandle_t()) {\n                first_connected = true;\n            }\n            subscriber_count++;\n        } else {\n            subscriber_count--;\n            if (subscriber_count == 0) {\n                subscriber_count = 0;\n                if (reader->get_status_mask() & efd::StatusMask::data_available) {\n                    reader->set_status_mask(efd::StatusMask::data_available);\n                }\n                reader->set_listener(nullptr);\n                reader->destroy();\n            }\n        }\n    } else {\n        std::cout << \"Invalid count change\" << std::endl;\n    }\n}", "CodeBleu_score": 55.14144057626752}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    if (!p_type->m_key.empty()) {\n        *handle = p_type->m_key;\n        return true;\n    }\n    if (!p_type->m_key_md5.empty() && !force_md5) {\n        *handle = p_type->m_key_md5;\n        return true;\n    }\n    if (p_type->m_key_md5.empty()) {\n        p_type->computeKey(p_type->m_key);\n    }\n    *handle = p_type->m_key_md5;\n    return true;\n}", "CodeBleu_score": 19.08124834118576}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    *handle = p_type->getKey();\n    return true;\n}", "CodeBleu_score": 13.65550463513654}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5){\n\tif (!m_get_key) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    *handle = p_type->getKey();\n    return true;\n}", "CodeBleu_score": 17.452542408399058}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, CarlaEgoVehicleControl::getMaxCdrSerializedSize());\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness();\n    payload->length = CarlaEgoVehicleControl::getCdrSerializedSize();\n    // Serialize encapsulation\n    ser.serializeEncapsulation();\n\n    try {\n        p_type->serialize(ser);\n    } catch (std::exception& e) {\n        return false;\n    }\n\n    payload->length = ser.getSerializedDataLength();\n    return true;\n}", "CodeBleu_score": 62.575348613195914}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, CarlaEgoVehicleControl::getBufferMaxLength()); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness(); // Set encapsulation.\n    try {\n        p_type->serialize(ser); // Serialize the object: write the appropriate amount of data with respect to the endianness specified\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n    payload->length = (uint32_t)ser.getSerializedDataLength(); // Get the serialized length\n    return true;\n}", "CodeBleu_score": 62.65791492879404}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload){\n\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, CarlaEgoVehicleControl::getMaxCdrSerializedSize());\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness();\n    payload->length = CarlaEgoVehicleControl::getCdrSerializedSize();\n    payload->pos = 0;\n    p_type->serialize(ser);\n    if (ser.getSerializedDataLength() != payload->length) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 56.19824282247787}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_SYSTEM_TIME:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_SYSTEM_TIME_CORRECTION:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_PING:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_REQUEST_DATA_STREAM:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_REQUEST_DATA_STREAM_ACK:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_COMMAND_LONG:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_COMMAND_ACK:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_SET_MODE:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_SET_MODE_ACK:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_PARAM_REQUEST_READ:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_PARAM_REQUEST_LIST:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_PARAM_VALUE:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_PARAM_SET:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_PARAM_SET_ACK:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_PARAM_REQUEST_READ_ACK:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_AUTOPILOT_VERSION:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_GPS_RAW_INT:\n\t\tbreak;\n\n\tcase MAVLINK_MSG_ID_GPS_STATUS:", "CodeBleu_score": 14.37689247876904}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) return;\n\n\tswitch (msg.msgid) {\n\t\tcase MAVLINK_MSG_ID_HEARTBEAT: {\n\t\t\tmavlink_heartbeat_t hb;\n\t\t\tmavlink_msg_heartbeat_decode(&msg, &hb);\n\n\t\t\tif (hb.type != MAV_TYPE_GCS) {\n\t\t\t\ttarget_set = true;\n\t\t\t\ttarget_sysid = hb.sysid;\n\t\t\t\ttarget_compid = hb.compid;\n\t\t\t\trequest_data_streams();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdefault:\n\t\t\treturn;\n\t}\n}", "CodeBleu_score": 32.49698221990873}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg){\n\tif (target_set) {\n        return;\n    }\n\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_HEARTBEAT: {\n            mavlink_heartbeat_t hb;\n            mavlink_msg_heartbeat_decode(&msg, &hb);\n            if (hb.type == MAV_TYPE_GCS) {\n                target_set = true;\n                target_sysid = hb.sysid;\n                mavlink_request_data_stream(target_sysid, MAV_DATA_STREAM_POSITION);\n                mavlink_request_data_stream(target_sysid, MAV_DATA_STREAM_AIR_PRESSURE);\n                return;\n            }\n            break;\n        }\n        case MAVLINK_MSG_ID_SYS_STATUS: {\n            mavlink_sys_status_t ss;\n            mavlink_msg_sys_status_decode(&msg, &ss);\n            if (ss.onboard_control_sensors_present & (1 << MAV_SYS_STATUS_SENSOR_3D_GYRO)) {\n                target_set = true;\n                target_sysid = msg.sysid;\n                mavlink_request_data_stream(target_sysid, MAV_DATA_STREAM_POSITION);\n                mavlink_request_data_stream(target_sysid, MAV_DATA_STREAM_AIR_PRESSURE);\n                return;\n            }\n            break;\n        }\n        case MAVLINK_MSG_ID_STATUSTEXT: {\n            mavlink_statustext_t st;\n            mavlink_msg_statustext_decode(&msg, &st);\n            if (st.text[0] == 'T' && st.text[1] == 'A' && st.text[2] == 'R' && st.text[3] == 'G' && st.text[4] == 'E' && st.text[5] == 'T') {\n                target_set = true;\n                target", "CodeBleu_score": 38.87948525892223}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.278978970394}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}", "CodeBleu_score": 68.278978970394}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (msg.sysid == _sysid) {\n        result = _handle_command_preflight_calibration(msg);\n\n        if (result == MAV_RESULT_ACCEPTED) {\n            _need_altitude_calibration = true;\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 45.960229534281986}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    if (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n        if (packet.param1 == 1.0) {\n            result = MAV_RESULT_ACCEPTED;\n            arm_disarm(true);\n        } else if (packet.param1 == 0) {\n            result = MAV_RESULT_ACCEPTED;\n            arm_disarm(false);\n        }\n    }\n\n    return result;\n}", "CodeBleu_score": 49.633643988260665}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\tif (packet.param1 == 1.0f) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tarm_disarm(true);\n\t} else if (packet.param1 == 0.0f) {\n\t\tresult = MAV_RESULT_ACCEPTED;\n\t\tarm_disarm(false);\n\t}\n\treturn result;\n}", "CodeBleu_score": 48.68814713575763}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet){\n\t//TODO: Implement\n\treturn MAV_RESULT_UNSUPPORTED;\n}", "CodeBleu_score": 8.484763582851587}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// Iterate over the available GCS channels\n    for (uint8_t i = 0; i < _gcs_channels.size(); i++) {\n\n        // Check if the channel is available\n        if (_gcs_channels[i].available()) {\n\n            // Check if the channel is in use\n            if (_gcs_channels[i].in_use()) {\n\n                // Check if the channel is connected\n                if (_gcs_channels[i].connected()) {\n\n                    // Check if the channel is ready for a new request\n                    if (_gcs_channels[i].ready()) {\n\n                        // Check if the channel is ready to stream position data\n                        if (_gcs_channels[i].streaming_position() == false) {\n\n                            // Send a request to start streaming position data\n                            _gcs_channels[i].send_request_datastream_position(sysid, compid);\n\n                            // Set the channel as streaming position data\n                            _gcs_channels[i].streaming_position(true);\n\n                            // Set the channel as ready for a new request\n                            _gcs_channels[i].ready(false);\n\n                            // Return\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 47.52515822793485}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// Iterate over all available GCS channels\n  for (uint8_t i = 0; i < GCS_CHANNEL_COUNT; i++) {\n\n    // Check if the GCS channel is available and if the payload space is available\n    if (gcs_channels[i].available && gcs_channels[i].payload_space > 0) {\n\n      // Send a request to start the data stream on the corresponding channel with the specified update rate\n      send_request_datastream_position(i, sysid, compid, GCS_CHANNEL_UPDATE_RATE);\n\n      // Decrease the payload space\n      gcs_channels[i].payload_space--;\n\n      // Exit the function\n      return;\n    }\n  }\n}", "CodeBleu_score": 42.409450679199566}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid){\n\t// Iterate over all channels and check for available payload space\n    for (uint8_t i = 0; i < _channels.size(); i++) {\n\n        // Check if channel is available\n        if (_channels[i]->get_available_payload_space() > sizeof(MAVLink_message_t)) {\n\n            // Send request to start data stream\n            _channels[i]->send_request_datastream_position(sysid, compid);\n        }\n    }\n}", "CodeBleu_score": 43.416131598216445}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS* ahrs = AHRS::getInstance();\n\tif (ahrs->get_pitch_cos() == 0) {\n\t\treturn false;\n\t}\n\telse {\n\t\tef_pitch = atan(ahrs->get_pitch_sin() / ahrs->get_pitch_cos()) * RAD_TO_DEG;\n\t\tef_yaw = yaw - ahrs->get_roll() - pitch;\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 46.62857639035008}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS* ahrs = AHRS::getInstance();\n\tfloat cos_pitch = ahrs->get_cos_pitch();\n\tif (cos_pitch != 0) {\n\t\tef_pitch = asin(cos_pitch * sin(pitch) + ahrs->get_sin_pitch() * cos(pitch) * cos(yaw));\n\t\tef_yaw = atan2(ahrs->get_sin_pitch() * sin(pitch) - cos_pitch * cos(pitch) * cos(yaw), cos_pitch * cos(pitch) * sin(yaw) - ahrs->get_sin_pitch() * sin(yaw));\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}", "CodeBleu_score": 47.65013750333986}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw){\n\tAHRS *ahrs = AHRS::get_instance();\n    if (ahrs->get_pitch_cos() == 0) {\n        return false;\n    }\n    ef_pitch = atan2(ahrs->get_pitch_sin(), ahrs->get_pitch_cos()) * 180 / M_PI;\n    ef_yaw = yaw;\n    return true;\n}", "CodeBleu_score": 43.42002115848373}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void){\n\t// get navigation status\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float distance = nav_status.distance;\n    float distance_min = tracker.g.distance_min;\n\n    // calculate target pitch and yaw in centidegrees\n    float pitch = (nav_status.bearing + tracker.g.pitch_trim) * 100;\n    float yaw = (nav_status.bearing + tracker.g.yaw_trim) * 100;\n\n    // check if direction is reversed\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate angle error in centidegrees\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // convert error to body frame\n    float bf_pitch_err;\n    float bf_yaw_err;\n    convert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n\n    // check if we can use the regular, shortest path to the target\n    if (!direction_reversed && !tracker.g.distance_min_enabled) {\n        tracker.g.pidPitch2Srv.set_target_angle(pitch);\n        tracker.g.pidYaw2Srv.set_target_angle(yaw);\n    } else {\n        // if we can't use the regular, shortest path to the target,\n        // then we need to calculate the target pitch and yaw for the reversed direction\n        float pitch_rev = pitch - 18000;\n        float yaw_rev = yaw - 18000;\n        calc_angle_error(pitch_rev, yaw_rev, direction_reversed);\n        convert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n        tracker.g.pidP", "CodeBleu_score": 55.36169083648892}, {"code": "void Mode::update_auto(void){\n\tParameters &g = tracker.g;\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float ef_yaw_target;\n    float ef_pitch_target;\n    bool direction_reversed = false;\n\n    // check if the tracker is trying to move clockwise to reach the vehicle,\n    // but the tracker could get closer to the vehicle by moving counter-clockwise\n    if (get_ef_yaw_direction()) {\n        direction_reversed = true;\n    }\n\n    // calculate the target pitch and yaw in centidegrees\n    // note: this is the same as the target_pitch and target_yaw in the nav_status struct\n    // but we need to calculate them here to calculate the angle error\n    // and we need to convert them to centidegrees to compare them to the limits\n    calc_target_angle(nav_status.target_distance, nav_status.target_bearing, nav_status.target_pitch, nav_status.target_yaw);\n\n    // calculate the angle error in centidegrees\n    calc_angle_error(nav_status.target_pitch, nav_status.target_yaw, direction_reversed);\n\n    // convert the angle error to body frame\n    float bf_pitch_err;\n    float bf_yaw_err;\n    convert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n\n    // check if the target distance is valid or no minimum distance is set\n    if (nav_status.target_distance_valid || (g.min_distance_to_target == 0)) {\n        // if the target distance is valid or no minimum distance is set,\n        // update the pitch and yaw servos accordingly\n        g.pidPitch2Srv.set_target_angle(bf_pitch_err);\n        g.pidYaw2Srv.set_target_angle(bf_yaw_err);\n        g.pidPitch2Srv.set_", "CodeBleu_score": 49.03848659068368}, {"code": "void Mode::update_auto(void){\n\t// get the current position and heading\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float distance = nav_status.distance;\n    float bearing = nav_status.bearing;\n    float target_distance = nav_status.target_distance;\n    float target_bearing = nav_status.target_bearing;\n    bool distance_valid = nav_status.distance_valid;\n    bool direction_reversed = get_ef_yaw_direction();\n\n    // calculate target yaw and pitch in centidegrees\n    float yaw = bearing * 100;\n    float pitch = (target_distance - g.distance_trim) * g.pitch_factor;\n\n    // calculate angle error in centidegrees\n    calc_angle_error(pitch, yaw, direction_reversed);\n\n    // convert angle errors from earth frame to body frame\n    float bf_pitch_err;\n    float bf_yaw_err;\n    convert_ef_to_bf(nav_status.angle_error_pitch, nav_status.angle_error_yaw, bf_pitch_err, bf_yaw_err);\n\n    // update the pitch and yaw servos\n    if (distance_valid || target_distance < g.min_distance) {\n        // update the pitch and yaw servos\n        if (g.pitch_factor != 0) {\n            tracker.pitch_servo_out_filt.set(bf_pitch_err);\n        }\n        if (g.yaw_factor != 0) {\n            tracker.yaw_servo_out_filt.set(bf_yaw_err);\n        }\n    }\n}", "CodeBleu_score": 53.06337562759771}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void){\n\t// Check if the last message time has changed and if the GPS status is at least 3D fix\n  if (millis() - GPS_last_message_time >= 1000 && GPS_status >= 3) {\n    // Update the GPS data\n    GPS.read();\n\n    // Check if the GPS data is valid\n    if (GPS.fix) {\n      // Check if the GPS location is valid\n      if (GPS.location.isValid()) {\n        // Check if the GPS altitude is valid\n        if (GPS.altitude.isValid()) {\n          // Check if the GPS course is valid\n          if (GPS.course.isValid()) {\n            // Check if the GPS speed is valid\n            if (GPS.speed.isValid()) {\n              // Check if the GPS time is valid\n              if (GPS.time.isValid()) {\n                // Check if the GPS date is valid\n                if (GPS.date.isValid()) {\n                  // Check if the GPS latitude is valid\n                  if (GPS.latitude.isValid()) {\n                    // Check if the GPS longitude is valid\n                    if (GPS.longitude.isValid()) {\n                      // Check if the GPS latitude and longitude are valid\n                      if (GPS.latitude.isValid() && GPS.longitude.isValid()) {\n                        // Check if the GPS latitude and longitude are within the valid range\n                        if (GPS.latitude.value() >= -90 && GPS.latitude.value() <= 90 && GPS.longitude.value() >= -180 && GPS.longitude.value() <= 180) {\n                          // Check if the GPS altitude is within the valid range\n                          if (GPS.altitude.value() >= -100 && GPS.altitude.value() <= 10000) {\n                            // Check if the GPS course is within the valid range\n                            if (GPS.course.value() >= 0 && GPS.course.value() <= 360) {\n                              // Check if the", "CodeBleu_score": 25.26604734953597}, {"code": "void Tracker::update_GPS(void){\n\t//Check if the GPS has new data\n  if (gps.available()) {\n    //Get the latest GPS data\n    gps.read();\n    //Check if the GPS has a valid fix\n    if (gps.location.isValid() && gps.location.isUpdated()) {\n      //Check if the GPS has a valid fix\n      if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n        //Check if the GPS has a valid fix\n        if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n          //Check if the GPS has a valid fix\n          if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n            //Check if the GPS has a valid fix\n            if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n              //Check if the GPS has a valid fix\n              if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n                //Check if the GPS has a valid fix\n                if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n                  //Check if the GPS has a valid fix\n                  if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n                    //Check if the GPS has a valid fix\n                    if (gps.location.isValid() && gps.location.isUpdated() && gps.location.isValid() && gps.location.isUpdated()) {\n                      //Check if the GPS has a valid fix\n                      if (gps.location", "CodeBleu_score": 21.22502274748413}, {"code": "void Tracker::update_GPS(void){\n\t// Check if the GPS is connected\n\tif (!GPS_connected) {\n\t\t// If not, print a message and return\n\t\tSerial.println(\"GPS not connected\");\n\t\treturn;\n\t}\n\n\t// Read the GPS data\n\tGPS.read();\n\n\t// If the last message time has changed, update the GPS data\n\tif (GPS.newNMEAreceived()) {\n\t\t// If the GPS data is valid, update the GPS data\n\t\tif (!GPS.parse(GPS.lastNMEA())) {\n\t\t\t// If the GPS data is valid, update the GPS data\n\t\t\tif (GPS.fix) {\n\t\t\t\t// Update the GPS data\n\t\t\t\tGPS_lat = GPS.latitude;\n\t\t\t\tGPS_lon = GPS.longitude;\n\t\t\t\tGPS_alt = GPS.altitude;\n\t\t\t\tGPS_speed = GPS.speed;\n\t\t\t\tGPS_course = GPS.angle;\n\t\t\t\tGPS_satellites = GPS.satellites;\n\t\t\t\tGPS_last_msg_time = millis();\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the GPS is not valid, return\n\tif (!GPS.fix) {\n\t\t// If the GPS is not valid, return\n\t\treturn;\n\t}\n\n\t// If the GPS is valid, check if the GPS is initialized\n\tif (!GPS_initialized) {\n\t\t// If the GPS is not initialized, initialize it\n\t\tGPS_initialized = true;\n\t\t// Set the home location to the current location\n\t\thome_lat = GPS_lat;\n\t\thome_lon = GPS_lon;\n\t\t// Set the home altitude to the current altitude\n\t\thome_alt = GPS_alt;\n\t\t// Set the home course to the current course\n\t\thome_course = GPS_course;\n\t\t// Set the home speed to the current speed\n\t\thome_speed = GPS_speed;", "CodeBleu_score": 28.236245622016025}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch < 0) {\n        pitch_servo.write(0);\n    }\n    else if (pitch > 0) {\n        pitch_servo.write(180);\n    }\n}", "CodeBleu_score": 15.219572628168285}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch > 0.0) {\n\t\tif (pitch_onoff_servo.read() == 0) {\n\t\t\tpitch_onoff_servo.write(180);\n\t\t\tdelay(500);\n\t\t}\n\t}\n\telse {\n\t\tif (pitch_onoff_servo.read() == 180) {\n\t\t\tpitch_onoff_servo.write(0);\n\t\t\tdelay(500);\n\t\t}\n\t}\n}", "CodeBleu_score": 17.333941560793182}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const{\n\tif (pitch_servo_on) {\n    if (pitch_servo_onoff_pin == 0) {\n      pitch_servo.write(pitch);\n    } else {\n      digitalWrite(pitch_servo_onoff_pin, pitch_servo.read() > pitch ? HIGH : LOW);\n    }\n  }\n}", "CodeBleu_score": 18.95331025940707}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (AP_Arming::barometer_checks(display_failure)) {\n        if (AP_ARMING_CHECK_BARO) {\n            if (abs(barometer.get_altitude_ref() - barometer.get_altitude()) > ARMING_BARO_REF_ALT_THRESHOLD) {\n                if (display_failure) {\n                    AP_Notify::flags.barometer_alt_fail = true;\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 29.935246900019873}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (AP_ARMING_CHECK_BARO) {\n        if (barometer.get_ref() == 0) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Barometer not calibrated\n\"));\n            }\n            return false;\n        }\n\n        if (abs(barometer.get_altitude_ref() - barometer.get_altitude()) > AP_ARMING_BARO_ALT_LIMIT) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Barometer altitude too high\n\"));\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 47.10508450501848}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure){\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n    return false;\n  }\n\n  if (ARMING_CHECK_BARO && !check_barometer_reference()) {\n    if (display_failure) {\n      AP_HAL::BetterStream *port = hal.console;\n      port->printf_P(PSTR(\"Barometer reference failed\n\"));\n    }\n    return false;\n  }\n\n  if (ARMING_CHECK_BARO && !check_barometer_altitude()) {\n    if (display_failure) {\n      AP_HAL::BetterStream *port = hal.console;\n      port->printf_P(PSTR(\"Barometer altitude failed\n\"));\n    }\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 44.0455409249632}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\tif (ap.get_terrain_source() == AP_TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (ap.get_terrain_source() == AP_TERRAIN_SOURCE_TERRAIN_DB && ap.get_rtl_altitude_type() == AP_RTL_ALTITUDE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 63.64385355577448}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\treturn (_terrain_source == TerrainSource::TERRAIN_DATABASE && _rtl_altitude_type == AP_RTL::TERRAIN_RTL);\n}", "CodeBleu_score": 6.770988123387974}, {"code": "bool AP_Arming_Copter::terrain_database_required() const{\n\treturn (terrain_source == TERRAIN_SOURCE_TERRAIN_DB && rtl_altitude_type == RTL_ALTITUDE_TYPE_TERRAIN);\n}", "CodeBleu_score": 6.483012087470738}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller(){\n\t// If we are not armed, we don't want to do anything.\n    if (!ap.armed) {\n        return;\n    }\n\n    // If we are not in a mode that requires attitude control, we don't want to do anything.\n    if (!ap.control_mode.flag.attitude_control_enabled) {\n        return;\n    }\n\n    // If we are not in a mode that requires position control, we don't want to do anything.\n    if (!ap.control_mode.flag.position_control_enabled) {\n        return;\n    }\n\n    // If we are not in a mode that requires motor control, we don't want to do anything.\n    if (!ap.control_mode.flag.motor_output_enabled) {\n        return;\n    }\n\n    // Run the rate controllers\n    attitude_control.run_rate_controller();\n    position_control.run_rate_controller();\n\n    // Set the loop time for the attitude and position controllers\n    attitude_control.set_loop_time(scheduler.get_loop_time());\n    position_control.set_loop_time(scheduler.get_loop_time());\n\n    // Run the low-level rate controllers that require only IMU data\n    attitude_control.run_low_level_rate_controller();\n\n    // Run the low-level rate controllers that require IMU and attitude data\n    attitude_control.run_low_level_rate_controller_with_attitude();\n\n    // Run the low-level rate controllers that require IMU, attitude, and position data\n    attitude_control.run_low_level_rate_controller_with_attitude_and_position();\n\n    // Run the low-level rate controllers that require IMU, attitude, position, and velocity data\n    attitude_control.run_low_level_rate_controller_with_attitude_and_position_and_velocity();\n\n    // Run the low-level rate controllers that require IMU, attitude, position, velocity, and altitude data\n    attitude_control.run_low_level_rate_controller_with_attitude_and_position_and_velocity_and_altitude();", "CodeBleu_score": 36.333283572638294}, {"code": "void Copter::run_rate_controller(){\n\t// update the time stamps\n    _time_last_loop = _time_last_loop_rate_control;\n    _time_last_loop_rate_control = hal.scheduler->micros();\n    // calculate the loop time\n    uint32_t dt = _time_last_loop_rate_control - _time_last_loop;\n    // set the loop time for the attitude and position controllers\n    _control_mode.flags.rate_control = true;\n    _control_mode.flags.altitude_control = false;\n    _control_mode.flags.position_control = false;\n    _control_mode.flags.acro_mode = false;\n    _control_mode.flags.altitude_lock = false;\n    _control_mode.flags.stabilize = false;\n    _control_mode.flags.auto_mode = false;\n    _control_mode.flags.guided_mode = false;\n    _control_mode.flags.rattitude_mode = false;\n    _control_mode.flags.vtol_transition_mode = false;\n    _control_mode.flags.vtol_fw_mode = false;\n    _control_mode.flags.vtol_mc_mode = false;\n    _control_mode.flags.vtol_tailsitter_mode = false;\n    _control_mode.flags.vtol_tailsitter_transition_mode = false;\n    _control_mode.flags.vtol_landing_mode = false;\n    _control_mode.flags.land_detected = false;\n    _control_mode.flags.force_vtol = false;\n    _control_mode.flags.euler_mode = false;\n    _control_mode.flags.level_mode = false;\n    _control_mode.flags.stabilize_maneuver = false;\n    _control_mode.flags.auto_takeoff = false;\n    _control_mode.flags.auto_land = false;\n    _control_mode.flags.auto_rtl = false;\n    _control_mode.flags.auto_rc_release = false;\n    _control_mode.flags.auto_precland =", "CodeBleu_score": 28.960840275308236}, {"code": "void Copter::run_rate_controller(){\n\t// update the loop time\n    _loop_time = loop_counter();\n\n    // run the attitude controller\n    attitude_control();\n\n    // run the position controller\n    position_control();\n\n    // run the altitude controller\n    altitude_control();\n\n    // run the navigator\n    navigator_update();\n\n    // run the land detector\n    land_detector_update();\n\n    // run the mission manager\n    mission_manager_update();\n\n    // run the failsafe\n    failsafe_update();\n\n    // run the battery monitor\n    battery_monitor_update();\n\n    // run the logging\n    logging_update();\n\n    // run the camera\n    camera_update();\n\n    // run the GCS_MAVLink\n    gcs_update();\n\n    // run the OSD\n    osd_update();\n\n    // run the LED control\n    led_control_update();\n\n    // run the EKF\n    ekf_update();\n\n    // run the safety checks\n    safety_check();\n\n    // run the pre-arm check\n    prearm_check();\n\n    // run the battery monitor\n    battery_monitor_update();\n\n    // run the safety checks\n    safety_check();\n\n    // run the pre-arm check\n    prearm_check();\n\n    // run the battery monitor\n    battery_monitor_update();\n\n    // run the safety checks\n    safety_check();\n\n    // run the pre-arm check\n    prearm_check();\n\n    // run the battery monitor\n    battery_monitor_update();\n\n    // run the safety checks\n    safety_check();\n\n    // run the pre-arm check\n    prearm_check();\n\n    // run the battery monitor\n    battery_monitor_update();\n\n    // run the safety checks\n    safety_check();\n\n    // run the pre-arm check\n    prearm_check();\n\n    // run the battery monitor\n    battery_monitor_update();\n\n    // run the safety checks\n    safety_check();\n\n    // run the pre-arm check\n    prearm_check();\n\n    // run", "CodeBleu_score": 35.03510016796966}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (old_loc.distance(new_loc) < 0.001f && old_loc.alt == new_loc.alt) {\n        return false;\n    }\n\n    set_target_location(new_loc);\n    return true;\n}", "CodeBleu_score": 46.36157138173851}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (old_loc != new_loc) {\n        if (old_loc.alt != new_loc.alt) {\n            return false;\n        }\n        set_target_location(new_loc);\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 48.33334793102717}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc){\n\tif (old_loc.equals_ignoring_alt(new_loc) && old_loc.alt == new_loc.alt) {\n        return false;\n    }\n    else {\n        return set_target_location(new_loc);\n    }\n}", "CodeBleu_score": 49.71132208426701}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AuxSwitchPos::HIGH) {\n        set_mode(mode);\n    } else if (ch_flag == AuxSwitchPos::LOW && get_mode() == mode) {\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 47.55910542679729}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AuxSwitchPos::HIGH) {\n        set_mode(mode);\n    } else if (ch_flag == AuxSwitchPos::LOW && get_mode() == mode) {\n        reset_mode_switch();\n    }\n}", "CodeBleu_score": 39.29144909230963}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag){\n\tif (ch_flag == AuxSwitchPos::HIGH) {\n        if (mode == this->mode) {\n            this->reset_mode_switch();\n        } else {\n            this->set_mode(mode);\n        }\n    } else if (ch_flag == AuxSwitchPos::LOW && mode == this->mode) {\n        this->reset_mode_switch();\n    }\n}", "CodeBleu_score": 42.03673558375165}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim(){\n\t// Save the trim values\n  set_trim_roll_pitch(\n    (float)channels[ROLL_CONTROL_INDEX] * (float)RAD_PER_DEG,\n    (float)channels[PITCH_CONTROL_INDEX] * (float)RAD_PER_DEG\n  );\n\n  // Log the event\n  Log_Write_Event(DATA_LOGGING_TRIM_SAVED);\n\n  // Send a confirmation message\n  send_message(MAV_SEVERITY_INFO, \"Trim saved\");\n}", "CodeBleu_score": 33.361050621428404}, {"code": "void Copter::save_trim(){\n\tif (channel_roll->control_in < 1000) {\n        trim_roll_rad = (channel_roll->control_in - 1500) * 0.0005 * M_PI / 180;\n    }\n    if (channel_pitch->control_in < 1000) {\n        trim_pitch_rad = (channel_pitch->control_in - 1500) * 0.0005 * M_PI / 180;\n    }\n    // If the trim values are not set, set them to zero\n    if (isnan(trim_roll_rad)) {\n        trim_roll_rad = 0;\n    }\n    if (isnan(trim_pitch_rad)) {\n        trim_pitch_rad = 0;\n    }\n    // Log the trim values\n    Log_Write_Message(LOG_TRIM_VALUES, TRIM_VALUES_MESSAGE, TRIM_VALUES_MESSAGE_LENGTH);\n    Log_Write_Parameter(LOG_TRIM_ROLL, trim_roll_rad);\n    Log_Write_Parameter(LOG_TRIM_PITCH, trim_pitch_rad);\n    // Send confirmation message\n    MAV_Send_Message(MAV_SEVERITY_INFO, MAV_ACTION_TRIM_SAVED, NULL, 0);\n}", "CodeBleu_score": 36.12083871145314}, {"code": "void Copter::save_trim(){\n\tif (control_mode == MANUAL) {\n        if (ahrs.get_mode() == AHRS_MODE_MAG) {\n            // Save the trim values\n            ahrs.set_trim_roll(ahrs.get_trim_roll() + (float)rc_in.get_control(ROLL) * 0.001f);\n            ahrs.set_trim_pitch(ahrs.get_trim_pitch() + (float)rc_in.get_control(PITCH) * 0.001f);\n            ahrs.set_trim_yaw(ahrs.get_trim_yaw() + (float)rc_in.get_control(YAW) * 0.001f);\n\n            // Log the event\n            log_event(MAV_SEVERITY_INFO, \"SAVE_TRIM\");\n\n            // Send a confirmation message\n            send_statustext_all(MAV_SEVERITY_INFO, \"SAVE_TRIM\");\n        }\n    }\n}", "CodeBleu_score": 43.17946429958087}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t//Retrieve the copter's velocity\n\tVector3 velocity = _parent->get_velocity();\n\n\t//Calculate the speed squared\n\tfloat speed_sq = velocity.x * velocity.x + velocity.y * velocity.y;\n\n\t//If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components\n\tif (speed_sq > 0.01f && _parent->get_position().is_valid()) {\n\t\t_look_ahead_yaw_angle = atan2f(velocity.y, velocity.x);\n\t}\n\n\t//Return the computed look-ahead yaw angle\n\treturn _look_ahead_yaw_angle;\n}", "CodeBleu_score": 44.20194164402362}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t//Retrieve the copter's velocity\n    float vel_x = _vehicle->get_velocity()->get_x();\n    float vel_y = _vehicle->get_velocity()->get_y();\n\n    //Calculate the speed squared\n    float speed_sq = vel_x * vel_x + vel_y * vel_y;\n\n    //If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components\n    if (_vehicle->get_position()->is_valid() && speed_sq >= 0.000001) {\n        _look_ahead_yaw = atan2(vel_y, vel_x);\n    }\n\n    //Return the computed look-ahead yaw angle\n    return _look_ahead_yaw;\n\n}", "CodeBleu_score": 53.684167598873564}, {"code": "float Mode::AutoYaw::look_ahead_yaw(){\n\t// Retrieve the velocity\n  Vector3f velocity = vehicle.get_velocity();\n\n  // Calculate the speed squared\n  float speed_squared = velocity.length_squared();\n\n  // Check if the copter is valid and the speed exceeds a minimum threshold\n  if (vehicle.is_valid() && speed_squared >= MINIMUM_SPEED_SQUARED) {\n    // Calculate the look-ahead yaw angle\n    float look_ahead_yaw = atan2f(velocity.x(), velocity.y());\n\n    // Update the look-ahead yaw angle\n    look_ahead_yaw_angle = look_ahead_yaw;\n\n    // Return the look-ahead yaw angle\n    return look_ahead_yaw;\n  }\n\n  // Return 0\n  return 0;\n}", "CodeBleu_score": 44.58462953995947}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_Arming::RUDDER) {\n        if (!_arming.get_rudder_arming_check()) {\n            return false;\n        }\n        if (_arming.get_throttle_zero_check()) {\n            return false;\n        }\n    }\n    if (_arming.get_disabled_check()) {\n        return true;\n    }\n    if (_arming.get_watchdog_armed()) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 55.699059818322574}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\tif (method == AP_ARMING_RUDDER) {\n        if (!AP_Arming::arm_checks(method)) {\n            return false;\n        }\n        if (armed.rudder_arming_disabled) {\n            return false;\n        }\n        if (armed.watchdog_armed) {\n            return true;\n        }\n        if (rc_channels.chan_17_raw == 0) {\n            return false;\n        }\n    }\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 53.04832206190253}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method){\n\t// bypass arming checks if watchdog is armed\n    if (watchdog_armed()) {\n        return true;\n    }\n\n    // bypass arming checks if arming checks are disabled\n    if (_disable_arming_checks) {\n        return true;\n    }\n\n    // rudder arming disabled?\n    if (_disable_rudder_arming) {\n        return false;\n    }\n\n    // rudder arming enabled\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 32.300949157402684}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// if arming is already in progress, return false\n    if (arming_state == ARMING_STATE_IN_PROGRESS) {\n        return false;\n    }\n\n    // if we're already armed, return false\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we're disarmed and throttle is low, return false\n    if (!is_armed() && !hal.rcin->read(AP_RcChannel::THROTTLE_CHANNEL) && !hal.rcin->read(AP_RcChannel::AUX1_CHANNEL)) {\n        return false;\n    }\n\n    // if we're disarmed and throttle is high, return false\n    if (!is_armed() && hal.rcin->read(AP_RcChannel::THROTTLE_CHANNEL) > 1100) {\n        return false;\n    }\n\n    // if we're disarmed and throttle is low and we're using the failsafe method, return false\n    if (!is_armed() && method == AP_Arming::FAILSAFE) {\n        return false;\n    }\n\n    // if we're disarmed and throttle is high and we're using the failsafe method, return false\n    if (!is_armed() && method == AP_Arming::FAILSAFE && hal.rcin->read(AP_RcChannel::THROTTLE_CHANNEL) > 1100) {\n        return false;\n    }\n\n    // if we're disarmed and throttle is low and we're using the failsafe method, return false\n    if (!is_armed() && method == AP_Arming::FAILSAFE && !hal.rcin->read(AP_RcChannel::AUX1_CHANNEL)) {\n        return false;\n    }\n\n    // if we're disarmed and throttle is high and we're using the failsafe method, return false\n    if (!is_armed() && method == AP_", "CodeBleu_score": 44.51154577224285}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\tbool success = false;\n    bool armed = false;\n    bool armed_by_gcs = false;\n    bool armed_by_user = false;\n    bool armed_by_rc = false;\n\n    // check for a valid arming method\n    if (method == AP_ARMING::ARMED_BY_RC_CHANNEL) {\n        armed_by_rc = true;\n        armed = true;\n        success = true;\n    } else if (method == AP_ARMING::ARMED_BY_USER) {\n        armed_by_user = true;\n        armed = true;\n        success = true;\n    } else if (method == AP_ARMING::ARMED_BY_GROUND_STATION) {\n        armed_by_gcs = true;\n        armed = true;\n        success = true;\n    }\n\n    // if we have an arming method, then arm\n    if (success) {\n        // update arming state\n        _armed = armed;\n        _armed_by_rc = armed_by_rc;\n        _armed_by_user = armed_by_user;\n        _armed_by_gcs = armed_by_gcs;\n\n        // update soft armed state\n        update_soft_armed();\n\n        // set home location\n        if (_home.set_from_current_position()) {\n            // set home in AHRS\n            _ahrs.set_home(_home.lat, _home.lng);\n        }\n\n        // update current location\n        _location.update();\n\n        // change arm state\n        change_arm_state();\n\n        // set delay arming flag\n        _delay_arming = true;\n\n        // send status text\n        hal.util->set_soft_armed(true);\n        hal.console->printf_P(PSTR(\"Throttle arming complete\n\"));\n    }\n\n    return success;\n}", "CodeBleu_score": 44.31296730348063}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks){\n\t// check that we are not already armed\n    if (is_armed()) {\n        return false;\n    }\n\n    // check that we are not already disarmed\n    if (is_disarmed()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_gps->status().location.isValid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ahrs->get_home().is_home_position_valid()) {\n        return false;\n    }\n\n    // check that we have a valid position\n    if (!_ah", "CodeBleu_score": 25.80305653706864}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\t// if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // if no disarm function, return true\n    if (!has_disarm_function()) {\n        return true;\n    }\n\n    // if disarm function is configured, call the standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 62.36700909510956}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (is_armed()) {\n        return true;\n    }\n\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            AP_Notify::flags.arm_no_disarm_button = true;\n            AP_Notify::notify(AP_Notify::warning, AP_NOTIFY_ARM_NO_DISARM_BUTTON);\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 66.98460844407184}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure){\n\tif (armed()) {\n        return true;\n    }\n\n    if (!has_disarm_function()) {\n        if (display_failure) {\n            display_message(MAV_SEVERITY_CRITICAL, AP_ARMING_NO_DISARM_BUTTON_MSG);\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 69.31084471751038}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\t// Rotation matrix\n    float rotation_matrix[3][3] = {\n        {cos(yaw), -sin(yaw), 0},\n        {sin(yaw), cos(yaw), 0},\n        {0, 0, 1}\n    };\n\n    // New coordinates\n    float ne_x = x * rotation_matrix[0][0] + y * rotation_matrix[0][1];\n    float ne_y = x * rotation_matrix[1][0] + y * rotation_matrix[1][1];\n\n    // Update x and y\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 48.074172750405296}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x, ne_y;\n    float yaw = get_yaw();\n    ne_x = x * cos(yaw) - y * sin(yaw);\n    ne_y = x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 58.30759664674654}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y){\n\tfloat ne_x = x * cos(yaw) - y * sin(yaw);\n    float ne_y = x * sin(yaw) + y * cos(yaw);\n\n    x = ne_x;\n    y = ne_y;\n}", "CodeBleu_score": 56.964150230586654}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t// Check if the yaw angle and param4 values are within acceptable ranges\n    if (packet.param1 < 0 || packet.param1 > 360 || packet.param2 < 0 || packet.param2 > 360 || packet.param3 < 0 || packet.param3 > 360 || packet.param4 < 0 || packet.param4 > 360) {\n        // The values are not within acceptable ranges\n        return MAV_RESULT_DENIED;\n    }\n\n    // The values are within acceptable ranges\n    // Set the yaw heading using the provided parameters\n    // TODO: Add a yaw condition to the mission\n\n    return MAV_RESULT_ACCEPTED;\n}", "CodeBleu_score": 50.20990737316865}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\tMAV_RESULT result = MAV_RESULT_ACCEPTED;\n\n\t// Check if the yaw angle and param4 values are within acceptable ranges.\n\tif (packet.param1 >= -180.0f && packet.param1 <= 180.0f && packet.param2 >= 0.0f && packet.param2 <= 1.0f && packet.param3 >= 0.0f && packet.param3 <= 1.0f && packet.param4 >= 0.0f && packet.param4 <= 1.0f) {\n\t\t// Set the yaw heading using the provided parameters.\n\t\t_yaw_heading = packet.param1;\n\t\t_yaw_acceptance = packet.param2;\n\t\t_yaw_rate = packet.param3;\n\t\t_yaw_duration = packet.param4;\n\t} else {\n\t\tresult = MAV_RESULT_DENIED;\n\t}\n\n\treturn result;\n}", "CodeBleu_score": 47.966032873001005}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet){\n\t// check if the yaw angle is within the range of 0-360\n\tif (packet.param1 >= 0 && packet.param1 <= 360) {\n\t\t// check if the yaw speed is within the range of 0-360\n\t\tif (packet.param2 >= 0 && packet.param2 <= 360) {\n\t\t\t// check if the yaw direction is within the range of 0-360\n\t\t\tif (packet.param3 >= 0 && packet.param3 <= 360) {\n\t\t\t\t// check if the yaw radius is within the range of 0-360\n\t\t\t\tif (packet.param4 >= 0 && packet.param4 <= 360) {\n\t\t\t\t\t// set the yaw heading using the provided parameters\n\t\t\t\t\t_yaw_heading = packet.param1;\n\t\t\t\t\t_yaw_speed = packet.param2;\n\t\t\t\t\t_yaw_direction = packet.param3;\n\t\t\t\t\t_yaw_radius = packet.param4;\n\t\t\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t\t\t} else {\n\t\t\t\t\treturn MAV_RESULT_DENIED;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn MAV_RESULT_DENIED;\n\t\t\t}\n\t\t} else {\n\t\t\treturn MAV_RESULT_DENIED;\n\t\t}\n\t} else {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n}", "CodeBleu_score": 47.19510597356066}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.139455216244209}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.139455216244209}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const{\n\treturn _high_latency_tgt_heading;\n}", "CodeBleu_score": 6.139455216244209}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (logging_enabled) {\n\t\tLog_Packet packet = {\n\t\t\t.id = id,\n\t\t\t.value = value,\n\t\t\t.time = HAL_GetTick()\n\t\t};\n\t\tHAL_CAN_AddMessageToTxFifoQ(&hcan1, &packet, sizeof(Log_Packet), 0);\n\t}\n}", "CodeBleu_score": 33.577242700177756}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (this->logging_enabled) {\n\t\tLog_Packet packet;\n\t\tpacket.id = id;\n\t\tpacket.time = this->get_time();\n\t\tpacket.value = value;\n\t\tthis->write_log_packet(packet, true);\n\t}\n}", "CodeBleu_score": 34.07785451366847}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value){\n\tif (logging_enabled) {\n    uint32_t time = millis();\n    uint8_t packet[12];\n    packet[0] = 0x00;\n    packet[1] = 0x00;\n    packet[2] = 0x00;\n    packet[3] = 0x00;\n    packet[4] = 0x00;\n    packet[5] = 0x00;\n    packet[6] = 0x00;\n    packet[7] = 0x00;\n    packet[8] = 0x00;\n    packet[9] = 0x00;\n    packet[10] = 0x00;\n    packet[11] = 0x00;\n    packet[0] = time >> 24;\n    packet[1] = time >> 16;\n    packet[2] = time >> 8;\n    packet[3] = time;\n    packet[4] = id;\n    packet[5] = value >> 24;\n    packet[6] = value >> 16;\n    packet[7] = value >> 8;\n    packet[8] = value;\n    packet[9] = 0x00;\n    packet[10] = 0x00;\n    packet[11] = 0x00;\n    logger.write(packet, 12);\n  }\n}", "CodeBleu_score": 33.04351723171666}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF(){\n\tif (home_set) {\n        return;\n    }\n    if (armed) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 38.558036745172764}, {"code": "void Sub::update_home_from_EKF(){\n\tif (home_is_set) {\n        return;\n    }\n    if (armed) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 39.06894202203399}, {"code": "void Sub::update_home_from_EKF(){\n\tif (home_is_set) {\n        return;\n    }\n    if (armed) {\n        set_home_to_current_location_inflight();\n    } else {\n        set_home_to_current_location(false);\n    }\n}", "CodeBleu_score": 39.06894202203399}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run(){\n\t// If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\tif (!armed) {\n\t\tthrottle = 0;\n\t\tspool_state = SpoolState::kUnlimitedThrottle;\n\t\tattitude_controller.relax();\n\t\treturn;\n\t}\n\n\t// Set the spool state to unlimited throttle.\n\tspool_state = SpoolState::kUnlimitedThrottle;\n\n\t// Convert pilot inputs to desired body frame rates.\n\tfloat roll_rate = pilot_inputs.roll * roll_rate_gain;\n\tfloat pitch_rate = pilot_inputs.pitch * pitch_rate_gain;\n\tfloat yaw_rate = pilot_inputs.yaw * yaw_rate_gain;\n\n\t// Run the attitude controller with these rates.\n\tattitude_controller.run(roll_rate, pitch_rate, yaw_rate);\n\n\t// Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\tthrottle = pilot_inputs.throttle;\n\tmotor_inputs.forward = pilot_inputs.forward;\n\tmotor_inputs.lateral = pilot_inputs.lateral;\n}", "CodeBleu_score": 37.88855821490228}, {"code": "void ModeAcro::run(){\n\tif (!armed) {\n    throttle = 0;\n    spool->setThrottle(throttle);\n    relaxAttitude();\n    return;\n  }\n\n  // convert pilot inputs to desired body frame rates\n  float rollRate = pilot->getRoll();\n  float pitchRate = pilot->getPitch();\n  float yawRate = pilot->getYaw();\n\n  // run attitude controller\n  attitudeController->run(rollRate, pitchRate, yawRate);\n\n  // set forward and lateral motor inputs\n  spool->setForwardMotorInput(attitudeController->getForwardMotorInput());\n  spool->setLateralMotorInput(attitudeController->getLateralMotorInput());\n\n  // set throttle\n  throttle = pilot->getThrottle();\n  spool->setThrottle(throttle);\n}", "CodeBleu_score": 43.75479564203617}, {"code": "void ModeAcro::run(){\n\t//If the motors are not armed, set the throttle to zero, adjust the spool state, and exit.\n\tif (!armed) {\n\t\tthrottle = 0;\n\t\tspool_state = SpoolState::UNLIMITED_THROTTLE;\n\t\texit();\n\t\treturn;\n\t}\n\n\t//If armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\tspool_state = SpoolState::UNLIMITED_THROTTLE;\n\tfloat roll_rate = pilot_inputs.roll * roll_rate_multiplier;\n\tfloat pitch_rate = pilot_inputs.pitch * pitch_rate_multiplier;\n\tfloat yaw_rate = pilot_inputs.yaw * yaw_rate_multiplier;\n\tif (pilot_inputs.throttle < 0) {\n\t\troll_rate *= -1;\n\t\tpitch_rate *= -1;\n\t\tyaw_rate *= -1;\n\t}\n\t//If the pilot is holding the throttle at zero, set the roll and pitch rates to zero.\n\tif (pilot_inputs.throttle == 0) {\n\t\troll_rate = 0;\n\t\tpitch_rate = 0;\n\t}\n\t//If the pilot is holding the throttle at the minimum throttle, set the yaw rate to zero.\n\tif (pilot_inputs.throttle == MIN_THROTTLE) {\n\t\tyaw_rate = 0;\n\t}\n\t//If the pilot is holding the throttle at the maximum throttle, set the yaw rate to zero.\n\tif (pilot_inputs.throttle == MAX_THROTTLE) {\n\t\tyaw_rate = 0;\n\t}\n\t//If the pilot is holding the throttle at the minimum throttle, set the roll and pitch rates to zero.\n\tif (pilot_inputs.throttle == MIN_THROTTLE) {", "CodeBleu_score": 37.569066789471236}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start(){\n\t// set mode to position control\n    set_mode(GUIDED_POSITION);\n\n    // initialize waypoint controller\n    wp_nav.set_destination(sub.get_position());\n\n    // initialize yaw using default auto yaw mode\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 20.095941051578905}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set position control mode\n    set_control_mode(GUIDED_POS_CONTROL);\n\n    // initialize waypoint controller\n    wpnav.start();\n\n    // initialize yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 17.821854935563668}, {"code": "void ModeGuided::guided_pos_control_start(){\n\t// set to position control\n    set_control_mode(GUIDED_POSITION);\n\n    // get stopping point\n    wp_nav.get_stopping_point(sub.wp_loc);\n\n    // set waypoint destination\n    wp_nav.set_destination(sub.wp_loc);\n\n    // initialize yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}", "CodeBleu_score": 37.96161894845181}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start(){\n\t// set vertical max speeds\n    sub.v_max_up = sub.v_cruise_up + sub.v_cruise_up * sub.v_up_pct_max;\n    sub.v_max_down = sub.v_cruise_down - sub.v_cruise_down * sub.v_down_pct_max;\n\n    // initialize vertical velocity controller\n    v_control.initialize(sub.v_max_up, sub.v_max_down);\n\n    // initialize horizontal velocity controller\n    h_control.initialize(sub.h_cruise);\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 25.61285541167389}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set vertical max speed and acceleration\n    if (sub.pilot_velocity_z_max < 0.0f) {\n        sub.pilot_velocity_z_max = 0.0f;\n    }\n    if (sub.pilot_acceleration_z_max < 0.0f) {\n        sub.pilot_acceleration_z_max = 0.0f;\n    }\n    if (sub.pilot_velocity_xy_max < 0.0f) {\n        sub.pilot_velocity_xy_max = 0.0f;\n    }\n    if (sub.pilot_acceleration_xy_max < 0.0f) {\n        sub.pilot_acceleration_xy_max = 0.0f;\n    }\n\n    // initialize vertical and horizontal velocity controllers\n    sub.vertical_velocity_control.set_max_speed(sub.pilot_velocity_z_max);\n    sub.vertical_velocity_control.set_max_acceleration(sub.pilot_acceleration_z_max);\n    sub.horizontal_velocity_control.set_max_speed(sub.pilot_velocity_xy_max);\n    sub.horizontal_velocity_control.set_max_acceleration(sub.pilot_acceleration_xy_max);\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 25.787504709316618}, {"code": "void ModeGuided::guided_vel_control_start(){\n\t// set vertical max speed and acceleration\n    set_vertical_velocity_limits(sub.max_up_speed, sub.max_down_speed);\n    set_vertical_acceleration_limits(sub.max_up_acceleration, sub.max_down_acceleration);\n\n    // initialize vertical velocity controller\n    v_control.init();\n\n    // initialize horizontal velocity controller\n    h_control.init();\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}", "CodeBleu_score": 33.025130405055286}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check(){\n\tbool limit_check = false;\n\n\tif (_control_mode.flag_control_auto_enabled) {\n\t\tif (_time_started_this_loop > 0) {\n\t\t\t// Check for timeout\n\t\t\tif (hrt_elapsed_time(&_time_started_this_loop) > _param_nav_loiter_time.get()) {\n\t\t\t\tlimit_check = true;\n\t\t\t}\n\n\t\t\t// Check for min altitude\n\t\t\tif (_global_position.alt < _param_nav_loiter_min_alt.get()) {\n\t\t\t\tlimit_check = true;\n\t\t\t}\n\n\t\t\t// Check for max altitude\n\t\t\tif (_global_position.alt > _param_nav_loiter_max_alt.get()) {\n\t\t\t\tlimit_check = true;\n\t\t\t}\n\n\t\t\t// Check for horizontal distance moved\n\t\t\tif (_global_position.dist_to_current_position > _param_nav_loiter_rad.get()) {\n\t\t\t\tlimit_check = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn limit_check;\n}", "CodeBleu_score": 29.598357335792613}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// Check if we have exceeded the time limit\n\tif (millis() - _time_last_move_rc > GUIDED_MODE_TIMEOUT) {\n\t\treturn true;\n\t}\n\n\t// Check if we have exceeded the altitude limit\n\tif (_param_com_guard_max_alt.get() != 0.0f && (_global_position.alt - _home_position.alt) > _param_com_guard_max_alt.get()) {\n\t\treturn true;\n\t}\n\n\tif (_param_com_guard_min_alt.get() != 0.0f && (_global_position.alt - _home_position.alt) < _param_com_guard_min_alt.get()) {\n\t\treturn true;\n\t}\n\n\t// Check if we have exceeded the horizontal distance limit\n\tif (_param_com_guard_max_xy.get() != 0.0f && get_distance_to_next_waypoint() > _param_com_guard_max_xy.get()) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}", "CodeBleu_score": 36.50287856915968}, {"code": "bool ModeGuided::guided_limit_check(){\n\t// Check if we've exceeded our timeout\n  if (millis() > (guided_time + guided_timeout)) {\n    guided_time = millis();\n    return true;\n  }\n\n  // Check if we're below the minimum altitude\n  if (alt_m < guided_min_alt) {\n    return true;\n  }\n\n  // Check if we're above the maximum altitude\n  if (alt_m > guided_max_alt) {\n    return true;\n  }\n\n  // Check if we've exceeded the horizontal distance limit\n  if (sqrt(pow(guided_x_max - x_m, 2) + pow(guided_y_max - y_m, 2)) > guided_dist_limit) {\n    return true;\n  }\n\n  // If we've made it this far, we're not done yet\n  return false;\n}", "CodeBleu_score": 28.82553878827934}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test(){\n\t// Check if the motor test has timed out.\n  if (millis() - motor_test_time > 2000) {\n\n    // Set the pass flag to false.\n    pass = false;\n\n    // Disable the motor test.\n    motor_test = false;\n\n    // Disarm the system.\n    disarm();\n\n    // Record the failure time.\n    failure_time = millis();\n\n    // Send a timeout message.\n    Serial.println(\"Timeout\");\n\n    // Return false.\n    return false;\n\n  }\n\n  // If the motor test has not timed out, return true.\n  return true;\n\n}", "CodeBleu_score": 31.507622658227564}, {"code": "bool Sub::verify_motor_test(){\n\tif (motor_test_pass) {\n    if (motor_test_count < 1000) {\n      if (motor_test_count % 100 == 0) {\n        if (motor_test_count % 500 == 0) {\n          if (motor_test_count % 250 == 0) {\n            if (motor_test_count % 200 == 0) {\n              if (motor_test_count % 150 == 0) {\n                if (motor_test_count % 100 == 0) {\n                  if (motor_test_count % 50 == 0) {\n                    if (motor_test_count % 20 == 0) {\n                      if (motor_test_count % 10 == 0) {\n                        if (motor_test_count % 5 == 0) {\n                          if (motor_test_count % 2 == 0) {\n                            if (motor_test_count % 1 == 0) {\n                              motor_test_count = 0;\n                              motor_test_pass = true;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    } else {\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass = false;\n      motor_test_count = 0;\n      motor_test_pass =", "CodeBleu_score": 34.1499144071328}, {"code": "bool Sub::verify_motor_test(){\n\tif (motor_test_pass) {\n    if (motor_test_pass_counter > 0) {\n      motor_test_pass_counter--;\n    }\n    else {\n      if (motor_test_pass_counter == 0) {\n        if (motor_test_pass_counter_2 > 0) {\n          motor_test_pass_counter_2--;\n        }\n        else {\n          if (motor_test_pass_counter_2 == 0) {\n            motor_test_pass = false;\n            motor_test_pass_counter = 0;\n            motor_test_pass_counter_2 = 0;\n            if (motor_test_pass_counter_3 > 0) {\n              motor_test_pass_counter_3--;\n            }\n            else {\n              if (motor_test_pass_counter_3 == 0) {\n                motor_test_pass_counter_3 = 0;\n                motor_test_pass_counter_4 = 0;\n                motor_test_pass_counter_5 = 0;\n                motor_test_pass_counter_6 = 0;\n                motor_test_pass_counter_7 = 0;\n                motor_test_pass_counter_8 = 0;\n                motor_test_pass_counter_9 = 0;\n                motor_test_pass_counter_10 = 0;\n                motor_test_pass_counter_11 = 0;\n                motor_test_pass_counter_12 = 0;\n                motor_test_pass_counter_13 = 0;\n                motor_test_pass_counter_14 = 0;\n                motor_test_pass_counter_15 = 0;\n                motor_test_pass_counter_16 = 0;\n                motor_test_pass_counter_17 = 0;\n                motor_test_pass_counter_18 = 0;\n                motor_test_pass_counter_19 = 0;\n                motor_test_pass_counter_20 = 0;\n                motor_test_pass_counter_21 =", "CodeBleu_score": 28.58226833841313}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get current wp_nav values\n    float wp_roll = wp_nav.roll;\n    float wp_pitch = wp_nav.pitch;\n    float wp_yaw = wp_nav.yaw;\n\n    // Get current attitude\n    float roll = attitude.roll;\n    float pitch = attitude.pitch;\n\n    // Get current position\n    float x = position.x;\n    float y = position.y;\n\n    // Get current velocity\n    float vx = velocity.x;\n    float vy = velocity.y;\n\n    // Get current yaw rate\n    float yaw_rate = attitude.yaw_rate;\n\n    // Get current yaw\n    float yaw = attitude.yaw;\n\n    // Get current wp_nav yaw\n    float wp_yaw_current = wp_nav.yaw;\n\n    // Get current wp_nav yaw\n    float wp_yaw_target = wp_nav.yaw_target;\n\n    // Get current wp_nav yaw\n    float wp_yaw_rate = wp_nav.yaw_rate;\n\n    // Get current wp_nav yaw\n    float wp_yaw_rate_target = wp_nav.yaw_rate_target;\n\n    // Get current wp_nav yaw\n    float wp_yaw_rate_max = wp_nav.yaw_rate_max;\n\n    // Get current wp_nav yaw\n    float wp_yaw_max = wp_nav.yaw_max;\n\n    // Get current wp_nav yaw\n    float wp_yaw_min = wp_nav.yaw_min;\n\n    // Get current wp_nav yaw\n    float wp_yaw_min_rate = wp_nav.yaw_min_rate;\n\n    // Get current wp_nav yaw\n    float wp_yaw_max_rate = wp_nav.yaw_max_rate;\n\n    // Get current wp_nav yaw\n    float wp_yaw_rate_min = wp_nav.yaw_rate_min;\n\n    // Get current wp_nav yaw\n    float wp_yaw_rate_max =", "CodeBleu_score": 32.70743335282645}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get the roll and pitch targets from wp_nav\n    float roll_target = wp_nav.get_roll_target();\n    float pitch_target = wp_nav.get_pitch_target();\n\n    // If the roll or pitch targets are invalid, return 0\n    if (isnan(roll_target) || isnan(pitch_target)) {\n        lateral_out = 0;\n        forward_out = 0;\n        return;\n    }\n\n    // If the roll or pitch targets are not in the range [-90, 90], return 0\n    if (roll_target < -90 || roll_target > 90 || pitch_target < -90 || pitch_target > 90) {\n        lateral_out = 0;\n        forward_out = 0;\n        return;\n    }\n\n    // Normalize the roll and pitch targets\n    float roll_norm = normalize_angle(roll_target, -90, 90);\n    float pitch_norm = normalize_angle(pitch_target, -90, 90);\n\n    // If the roll and pitch targets are both 0, return 0\n    if (roll_norm == 0 && pitch_norm == 0) {\n        lateral_out = 0;\n        forward_out = 0;\n        return;\n    }\n\n    // If the roll and pitch targets are both 90, return 0\n    if (roll_norm == 90 && pitch_norm == 90) {\n        lateral_out = 0;\n        forward_out = 0;\n        return;\n    }\n\n    // If the roll target is 90, set the lateral output to the pitch target\n    if (roll_norm == 90) {\n        lateral_out = pitch_norm;\n        forward_out = 0;\n        return;\n    }\n\n    // If the pitch target is 90, set the forward output to the roll target\n    if (pitch_norm == 90) {\n        lateral_out = 0;\n        forward_out = roll_norm;\n        return;", "CodeBleu_score": 40.45531945425401}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out){\n\t// Get roll and pitch targets from wp_nav.\n\tfloat wp_roll = wp_nav.wp_rp[0];\n\tfloat wp_pitch = wp_nav.wp_rp[1];\n\n\t// Constrain roll and pitch targets to the specified maximum angle range.\n\tfloat wp_roll_norm = constrain_target(wp_roll, wp_nav.max_roll);\n\tfloat wp_pitch_norm = constrain_target(wp_pitch, wp_nav.max_pitch);\n\n\t// Normalize roll and pitch targets.\n\tfloat wp_roll_norm_normalized = normalize_target(wp_roll_norm, wp_nav.max_roll);\n\tfloat wp_pitch_norm_normalized = normalize_target(wp_pitch_norm, wp_nav.max_pitch);\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out.\n\tlateral_out = wp_roll_norm_normalized;\n\tforward_out = wp_pitch_norm_normalized;\n\n}", "CodeBleu_score": 31.07020669826109}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer(){\n\tif (barometer.read()) {\n        if (barometer.altitude() < 0) {\n            barometer_altitude = 0;\n            barometer_calibration = 0;\n        } else {\n            barometer_altitude = barometer.altitude();\n            if (barometer_calibration == 0) {\n                barometer_calibration = barometer_altitude;\n            }\n        }\n        if (depth_sensor.present()) {\n            if (barometer.healthy()) {\n                depth_sensor.set_health(true);\n            } else {\n                depth_sensor.set_health(false);\n            }\n        }\n    }\n}", "CodeBleu_score": 47.88955467043152}, {"code": "void Sub::read_barometer(){\n\tif (barometer.read()) {\n        // Update the barometer calibration\n        if (barometer.altitude() > 0) {\n            if (barometer.altitude() < 100) {\n                barometer_calibration = barometer.altitude();\n            }\n        }\n        // Update the sensor health status\n        if (depth_sensor.present()) {\n            if (barometer.healthy()) {\n                depth_sensor.set_sensor_health(true);\n            } else {\n                depth_sensor.set_sensor_health(false);\n            }\n        }\n    }\n}", "CodeBleu_score": 51.58479848535018}, {"code": "void Sub::read_barometer(){\n\t// Read the barometer\n\tbarometer.read();\n\n\t// Update the barometer calibration\n\tif (barometer.get_altitude() > 0) {\n\t\tbarometer_calibration = barometer.get_altitude();\n\t}\n\n\t// Update the sensor health\n\tif (barometer.get_status() == 0) {\n\t\tbarometer_health = 0;\n\t} else {\n\t\tbarometer_health = 1;\n\t}\n}", "CodeBleu_score": 55.01743201053183}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok(){\n\tif (!status.flags.inertial_valid) {\n        return false;\n    }\n\n    if (status.state != vehicle_status_s::VEHICLE_STATE_FLAGS::VEHICLE_STATE_ACTIVE) {\n        return false;\n    }\n\n    if (status.condition_landed) {\n        return false;\n    }\n\n    if (status.rc_signal_lost) {\n        return false;\n    }\n\n    if (status.condition_landed) {\n        return false;\n    }\n\n    if (status.armed) {\n        if (ekf.pos_ref_type == vehicle_local_position_s::POS_REF_TAKEOFF || ekf.pos_ref_type == vehicle_local_position_s::POS_REF_TAKEOFF_FLOAT) {\n            return false;\n        }\n\n        if (ekf.pos_ref_type == vehicle_local_position_s::POS_REF_LAND) {\n            return false;\n        }\n\n        if (ekf.pos_ref_type == vehicle_local_position_s::POS_REF_LOITER) {\n            return false;\n        }\n\n        if (ekf.pos_ref_type == vehicle_local_position_s::POS_REF_NONE) {\n            return false;\n        }\n\n        if (ekf.pos_ref_type == vehicle_local_position_s::POS_REF_OTHER) {\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 44.022986519618506}, {"code": "bool Sub::ekf_position_ok(){\n\tbool ret = false;\n\n\tif (!_armed.armed) {\n\t\tret = true;\n\n\t} else if (_control_mode.flag_control_manual_enabled && _control_mode.flag_control_altitude_enabled && !_control_mode.flag_control_climb_rate_enabled && !_control_mode.flag_control_position_enabled) {\n\t\tret = true;\n\n\t} else if (_control_mode.flag_control_manual_enabled && _control_mode.flag_control_altitude_enabled && _control_mode.flag_control_climb_rate_enabled && _control_mode.flag_control_position_enabled) {\n\t\tret = true;\n\n\t} else if (_control_mode.flag_control_auto_enabled && _control_mode.flag_control_altitude_enabled && _control_mode.flag_control_climb_rate_enabled && _control_mode.flag_control_position_enabled) {\n\t\tret = true;\n\n\t} else if (_control_mode.flag_control_auto_enabled && _control_mode.flag_control_altitude_enabled && !_control_mode.flag_control_climb_rate_enabled && _control_mode.flag_control_position_enabled) {\n\t\tret = true;\n\n\t} else if (_control_mode.flag_control_auto_enabled && !_control_mode.flag_control_altitude_enabled && _control_mode.flag_control_climb_rate_enabled && _control_mode.flag_control_position_enabled) {\n\t\tret = true;\n\n\t} else if (_control_mode.flag_control_auto_enabled && !_control_mode.flag_control_altitude_enabled && !_control_mode.flag_control_climb_rate_enabled && _control_mode.flag_control_position_enabled) {\n\t\tret = true;\n\n\t} else if (_control_mode.flag_control_auto_enabled && !_control_mode.flag_control_altitude_enabled && !_control_mode.flag_control_climb_rate_enabled && !_control_mode.flag_control", "CodeBleu_score": 32.81283953043587}, {"code": "bool Sub::ekf_position_ok(){\n\tbool ekf_position_ok = false;\n\n    // Check if inertial navigation is available\n    if (inertial_nav) {\n\n        // Check if the motors are disarmed\n        if (!armed) {\n\n            // Check if the EKF is in constant position mode\n            if (ekf_pos_mode != 1) {\n\n                // Check if the EKF is not in bad position mode\n                if (ekf_pos_mode != 2) {\n\n                    // Check if the EKF is not in bad velocity mode\n                    if (ekf_vel_mode != 2) {\n                        ekf_position_ok = true;\n                    }\n                }\n            }\n        }\n        else {\n\n            // Check if the EKF is not in bad position mode\n            if (ekf_pos_mode != 2) {\n\n                // Check if the EKF is not in bad velocity mode\n                if (ekf_vel_mode != 2) {\n                    ekf_position_ok = true;\n                }\n            }\n        }\n    }\n\n    return ekf_position_ok;\n}", "CodeBleu_score": 33.501432970648025}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\tif (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    if (!_ahrs.get_ahrs_initialised()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"AHRS not initialised\n\"));\n        }\n        return false;\n    }\n\n    if (_ekf_checks_enabled && _ekf.failsafe()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"EKF failsafe\n\"));\n        }\n        return false;\n    }\n\n    if (_ekf.control_mode() == EKF_CONTROL_MODE_NONE) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"EKF control mode none\n\"));\n        }\n        return false;\n    }\n\n    if (!_ekf.position_valid()) {\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"EKF position invalid\n\"));\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 53.20519631209157}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// Check if the AHRS system is ready\n  if (!ahrs.get_new_gyro()) {\n    if (display_failure) {\n      hal.console->println_P(PSTR(\"AHRS not ready\"));\n    }\n    return false;\n  }\n\n  // Check if the EKF failsafe is active\n  if (ekf_check_failsafe()) {\n    if (display_failure) {\n      hal.console->println_P(PSTR(\"EKF failsafe active\"));\n    }\n    return false;\n  }\n\n  // Check if the position estimate is valid\n  if (!ekf_position_valid()) {\n    if (display_failure) {\n      hal.console->println_P(PSTR(\"EKF position invalid\"));\n    }\n    return false;\n  }\n\n  // Check if the parent class's GPS checks pass\n  return AP_Arming::gps_checks(display_failure);\n}", "CodeBleu_score": 40.28821922488144}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure){\n\t// Call the parent class's gps_checks() function\n  if (!AP_Arming::gps_checks(display_failure)) {\n    return false;\n  }\n\n  // Check the AHRS system is ready\n  if (!ahrs.get_initialized()) {\n    if (display_failure) {\n      hal.console->printf(\"AHRS not initialized\n\");\n    }\n    return false;\n  }\n\n  // Check the EKF failsafe is not active\n  if (ahrs.failsafe_status.value & EKF_FAILSAFE_MASK) {\n    if (display_failure) {\n      hal.console->printf(\"EKF failsafe active\n\");\n    }\n    return false;\n  }\n\n  // Check the position estimate is valid\n  if (!ahrs.position_valid) {\n    if (display_failure) {\n      hal.console->printf(\"Position estimate invalid\n\");\n    }\n    return false;\n  }\n\n  // All checks passed\n  return true;\n}", "CodeBleu_score": 46.9109649166484}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\t// check if we are already armed\n    if (is_armed()) {\n        // we are already armed\n        return true;\n    }\n\n    // check if we are in failsafe\n    if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {\n        // we are in failsafe\n        return false;\n    }\n\n    // check if we are in arming checks\n    if (do_arming_checks && !_check_arming_conditions()) {\n        // arming checks failed\n        return false;\n    }\n\n    // check if we are in a soft disarmed state\n    if (!hal.util->get_soft_armed()) {\n        // we are in a soft disarmed state\n        return false;\n    }\n\n    // we are now ready to arm\n    _arming_method = method;\n\n    // set the armed status\n    _set_armed(true);\n\n    // update the soft armed status\n    update_soft_armed();\n\n    // set the arming status text\n    hal.console->printf(\"Arming %s\n\", AP_Arming::method_name(method));\n\n    // send the arm/disarm status text\n    hal.util->set_arming_status_text(AP_Arming::method_name(method));\n\n    // record the home heading for sail vehicles\n    if (_is_sail_vehicle()) {\n        _set_home_heading();\n    }\n\n    // set the home location for smart rtl\n    if (_is_smart_rtl_vehicle()) {\n        _set_smart_rtl_home();\n    }\n\n    // return success\n    return true;\n}", "CodeBleu_score": 47.167885246743396}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tbool armed = false;\n    AP_Arming::reason_t reason = AP_Arming::INIT;\n\n    if (method == AP_Arming::INIT) {\n        // initialise arming state\n        armed = false;\n        reason = AP_Arming::INIT;\n        _last_arm_reason = reason;\n        _last_disarm_reason = reason;\n    } else if (method == AP_Arming::MANUAL) {\n        // manual arming\n        armed = true;\n        reason = AP_Arming::MANUAL;\n        _last_arm_reason = reason;\n        _last_disarm_reason = reason;\n    } else if (method == AP_Arming::SAFETY) {\n        // safety switch arming\n        armed = true;\n        reason = AP_Arming::SAFETY;\n        _last_arm_reason = reason;\n        _last_disarm_reason = reason;\n    } else if (method == AP_Arming::RC_REPEATER) {\n        // RC Repeater arming\n        armed = true;\n        reason = AP_Arming::RC_REPEATER;\n        _last_arm_reason = reason;\n        _last_disarm_reason = reason;\n    } else if (method == AP_Arming::GPS_WARM) {\n        // GPS warm arming\n        armed = true;\n        reason = AP_Arming::GPS_WARM;\n        _last_arm_reason = reason;\n        _last_disarm_reason = reason;\n    } else if (method == AP_Arming::GPS_COLD) {\n        // GPS cold arming\n        armed = true;\n        reason = AP_Arming::GPS_COLD;\n        _last_arm_reason = reason;\n        _last_disarm_reason = reason;\n    } else if (method == AP_Arming::FAILSAFE) {\n        // failsafe arming\n        armed = true;\n        reason = AP_Arming::FAILSAFE;\n        _last_arm_reason = reason;\n        _last_disarm_", "CodeBleu_score": 33.78895054155478}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks){\n\tbool ret = false;\n    if (method == AP_Arming::INITIALISED) {\n        ret = true;\n    } else if (method == AP_Arming::MANUAL) {\n        // set armed to true\n        set_armed(true);\n        // set soft armed to true\n        update_soft_armed();\n        // send arm/disarm status text\n        hal.console->printf_P(PSTR(\"Arming", "CodeBleu_score": 32.14751234794744}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (charge_enabled) {\n                if (charge_disabled_time != 0) {\n                    charge_disabled_time = 0;\n                }\n            } else {\n                enableCharging();\n            }\n        } else {\n            if (charge_enabled) {\n                if (charge_disabled_time == 0) {\n                    charge_disabled_time = millis();\n                }\n            } else {\n                if (millis() - charge_disabled_time > 10000) {\n                    disableCharging();\n                }\n            }\n        }\n    } else {\n        if (charge_enabled) {\n            disableCharging();\n        }\n    }\n}", "CodeBleu_score": 43.33306232516862}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (enableCharging()) {\n                charging_enabled = true;\n            } else {\n                charging_enabled = false;\n                charging_disabled_time = millis();\n            }\n        } else {\n            if (disableCharging()) {\n                charging_enabled = false;\n            } else {\n                charging_enabled = true;\n            }\n        }\n    } else {\n        if (millis() - charging_disabled_time > 10000) {\n            if (enableCharging()) {\n                charging_enabled = true;\n            } else {\n                charging_enabled = false;\n                charging_disabled_time = millis();\n            }\n        }\n    }\n}", "CodeBleu_score": 54.00106426518323}, {"code": "void updateChargingEnabled(){\n\tif (charging_allowed) {\n        if (checkShouldCharge()) {\n            if (!charging_enabled) {\n                charging_enabled = true;\n                charging_disabled_time = 0.0;\n            }\n        } else {\n            if (charging_enabled) {\n                charging_enabled = false;\n                charging_disabled_time = getTime();\n            }\n        }\n    } else {\n        if (charging_enabled) {\n            charging_enabled = false;\n            charging_disabled_time = getTime();\n        } else {\n            if (getTime() - charging_disabled_time > 10.0) {\n                charging_enabled = true;\n                charging_disabled_time = 0.0;\n            }\n        }\n    }\n}", "CodeBleu_score": 47.75611496421487}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size){\n\tif (ros_running && size >= 4) {\n    uint8_t crc = crc8(message, size);\n    uint8_t *message_with_crc = (uint8_t*) malloc(size + 1);\n    memcpy(message_with_crc, message, size);\n    message_with_crc[size] = crc;\n    packetSerial.write(message_with_crc, size + 1);\n    free(message_with_crc);\n  }\n}", "CodeBleu_score": 43.657401582482606}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros_running && size >= 4) {\n    uint8_t *message_uint8 = (uint8_t *)message;\n    uint8_t message_crc = 0;\n    for (int i = 0; i < size; i++) {\n      message_crc ^= message_uint8[i];\n    }\n    message_uint8[size] = message_crc;\n    packetSerial.write(message_uint8, size + 1);\n  }\n}", "CodeBleu_score": 44.88148749077829}, {"code": "void sendMessage(void *message, size_t size){\n\tif (ros_running && size >= 4) {\n\t\tuint8_t crc = 0;\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tcrc ^= ((uint8_t *)message)[i];\n\t\t}\n\t\t((uint8_t *)message)[size] = crc;\n\t\tpacketSerial.write((uint8_t *)message, size + 1);\n\t}\n}", "CodeBleu_score": 44.42911866542104}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin(){\n\tSerial.begin(9600);\n\tSerial.println(\"Initializing MP3 module...\");\n\tSerial.println(\"Initializing SD card...\");\n\tif (!SD.begin(SD_CS)) {\n\t\tSerial.println(\"SD card failed to initialize!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"SD card initialized!\");\n\tSerial.println(\"Initializing MP3 module...\");\n\tif (!SD.exists(\"init.mp3\")) {\n\t\tSerial.println(\"init.mp3 not found on SD card!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"init.mp3 found on SD card!\");\n\tif (!playFile(\"init.mp3\")) {\n\t\tSerial.println(\"init.mp3 failed to play!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"init.mp3 played successfully!\");\n\tSerial.println(\"Initializing MP3 module...\");\n\tif (!SD.exists(\"ready.mp3\")) {\n\t\tSerial.println(\"ready.mp3 not found on SD card!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"ready.mp3 found on SD card!\");\n\tif (!playFile(\"ready.mp3\")) {\n\t\tSerial.println(\"ready.mp3 failed to play!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"ready.mp3 played successfully!\");\n\tSerial.println(\"Initializing MP3 module...\");\n\tif (!SD.exists(\"ready.mp3\")) {\n\t\tSerial.println(\"ready.mp3 not found on SD card!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"ready.mp3 found on SD card!\");\n\tif (!playFile(\"ready.mp3\")) {\n\t\tSerial.println(\"ready.mp3 failed to play!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"ready.mp3 played successfully!\");\n\tSerial.println(\"Initializing MP3 module...\");\n\tif (!SD.exists(\"ready.mp3\")) {\n\t\tSerial.println(\"ready.mp3 not found on SD card!\");\n\t\treturn false;\n\t}\n\tSerial.println(\"ready.mp3 found on SD card!\");\n\tif (!playFile(\"ready.mp", "CodeBleu_score": 35.27059555571965}, {"code": "bool MP3Sound::begin(){\n\t// initialize serial communication\n  Serial.begin(9600);\n  delay(100);\n\n  // clear buffer\n  for (int i = 0; i < 100; i++) {\n    buffer[i] = 0;\n  }\n\n  // initialize the sound module\n  Serial.println(\"AT+RST\");\n  delay(100);\n  readSerial();\n\n  // retrieve the number of sound files available\n  Serial.println(\"AT+CSCAN\");\n  delay(100);\n  readSerial();\n\n  // check if there are any sound files available\n  if (buffer[0] != '+') {\n    return false;\n  }\n\n  return true;\n}", "CodeBleu_score": 38.18747553547489}, {"code": "bool MP3Sound::begin(){\n\t// Initialize serial communication\n\tSerial.begin(9600);\n\tSerial.setTimeout(100);\n\tSerial.println(F(\"MP3_SOUND_BEGIN\"));\n\tif (Serial.read() != 'R') {\n\t\treturn false;\n\t}\n\t// Clear any existing data in the buffer\n\twhile (Serial.available() > 0) {\n\t\tSerial.read();\n\t}\n\t// Initialize sound module\n\tSerial.println(F(\"MP3_SOUND_INIT\"));\n\tif (Serial.read() != 'R') {\n\t\treturn false;\n\t}\n\t// Get number of sound files\n\tSerial.println(F(\"MP3_SOUND_COUNT\"));\n\tif (Serial.read() != 'R') {\n\t\treturn false;\n\t}\n\tsoundCount = Serial.parseInt();\n\treturn (soundCount > 0);\n}", "CodeBleu_score": 44.25506039962465}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds(){\n\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\telse if (playing) {\n\t\treturn activeSounds.size();\n\t}\n\telse {\n\t\tMP3Sound* sound = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tsound->play();\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 39.45435933760889}, {"code": "int MP3Sound::processSounds(){\n\tif (activeSounds.size() == 0 || isPlaying)\n\t\treturn activeSounds.size();\n\telse {\n\t\tMP3Sound* sound = activeSounds.back();\n\t\tactiveSounds.pop_back();\n\t\tsound->play();\n\t\treturn activeSounds.size();\n\t}\n}", "CodeBleu_score": 38.12418790637542}, {"code": "int MP3Sound::processSounds(){\n\tif (activeSounds.size() == 0) {\n\t\treturn 0;\n\t}\n\tif (mp3.isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\tif (activeSounds.size() == 1) {\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\treturn 0;\n\t}\n\tif (activeSounds.size() > 1) {\n\t\tplaySound(activeSounds.front());\n\t\tactiveSounds.pop_front();\n\t\treturn activeSounds.size();\n\t}\n\treturn 0;\n}", "CodeBleu_score": 35.308937789633134}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *camera = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      int request_size = wb_request_get_content_size(r);\n      if (request_size < 2) {\n        wb_abstract_camera_cleanup_memory_mapped_file(camera);\n        return true;\n      }\n      int width = wb_request_get_short(r);\n      int height = wb_request_get_short(r);\n      wb_abstract_camera_cleanup_memory_mapped_file(camera);\n      if (width < 0 || height < 0)\n        return false;\n      camera->width = width;\n      camera->height = height;\n      camera->memory_mapped_file = wb_memory_mapped_file_new(camera->width * camera->height * camera->pixel_size);\n      return true;\n    }\n    case C_CAMERA_SET_CAPTURE_FRAME_RATE:\n      wb_abstract_camera_set_capture_frame_rate(camera, wb_request_get_short(r));\n      return true;\n    case C_CAMERA_SET_CAPTURE_DEPTH_RANGE:\n      wb_abstract_camera_set_capture_depth_range(camera, wb_request_get_short(r));\n      return true;\n    case C_CAMERA_SET_CAPTURE_QUALITY:\n      wb_abstract_camera_set_capture_quality(camera, wb_request_get_short(r));\n      return true;\n    case C_CAMERA_SET_CAPTURE_RESOLUTION:\n      wb_abstract_camera_set_capture_resolution(camera, wb_request_get_short(r));\n      return true;\n    case C_CAMERA_SET_CAPTURE_TARGET:\n      wb_abstract_camera_set_capture_target(camera, wb_request_", "CodeBleu_score": 43.37776549803479}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *camera = d->pdata;\n  switch (command) {\n    case C_CAMERA_GET_FRAME:\n      wb_camera_get_frame(camera);\n      break;\n    case C_CAMERA_GET_FRAME_RGBA:\n      wb_camera_get_frame_RGBA(camera);\n      break;\n    case C_CAMERA_GET_PIXEL:\n      wb_camera_get_pixel(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_RGBA:\n      wb_camera_get_pixel_RGBA(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_F:\n      wb_camera_get_pixel_F(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_RGB:\n      wb_camera_get_pixel_RGB(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_VECTOR:\n      wb_camera_get_pixel_vector(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_VECTOR_F:\n      wb_camera_get_pixel_vector_F(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_VECTOR_RGB:\n      wb_camera_get_pixel_vector_RGB(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_VECTOR_RGBA:\n      wb_camera_get_pixel_vector_RGBA(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_VECTOR_RGB_F:\n      wb_camera_get_pixel_vector_RGB_F(camera);\n      break;\n    case C_CAMERA_GET_PIXEL_VECTOR_RGBA_F:\n      wb_camera_get_pixel_vector_RG", "CodeBleu_score": 42.87550415618793}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command){\n\tWbAbstractCamera *c = d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (r->size == 1) {\n        unsigned char request = wb_packet_get_byte(r);\n        if (request == C_CAMERA_MEMORY_MAPPED_FILE_CLEAN) {\n          if (c->mmap_file) {\n            wb_camera_clean_mmap_file(c->mmap_file);\n            c->mmap_file = NULL;\n          }\n        } else if (request == C_CAMERA_MEMORY_MAPPED_FILE_CREATE) {\n          if (c->mmap_file)\n            wb_camera_clean_mmap_file(c->mmap_file);\n          c->mmap_file = wb_camera_create_mmap_file(d);\n        }\n      } else\n        command_handled = false;\n      break;\n    }\n    default:\n      command_handled = false;\n  }\n  return command_handled;\n}", "CodeBleu_score": 61.85937053525684}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tWbAbstractCamera *c = d->pdata;\n  int height;\n  wb_abstract_camera_lock(c);\n  height = c->height;\n  wb_abstract_camera_unlock(c);\n  return height;\n}", "CodeBleu_score": 45.765539278573925}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\tint result = -1;\n  WbDeviceTag tag = d->tag;\n  d->mutex_lock();\n  if (wb_abstract_camera_get_number_of_channels(tag) > 0)\n    result = wb_abstract_camera_get_height(tag, 0);\n  d->mutex_unlock();\n  return result;\n}", "CodeBleu_score": 53.01349745336674}, {"code": "int wb_abstract_camera_get_height(WbDevice *d){\n\treturn wb_abstract_camera_get_height_p(d);\n}", "CodeBleu_score": 3.180461204704374}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  wb_accelerometer_private *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n  return sampling_period;\n}", "CodeBleu_score": 48.84469594976446}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  wb_accelerometer_get_sampling_period_function wb_accelerometer_get_sampling_period_ptr = (wb_accelerometer_get_sampling_period_function) accelerometers[tag].external_functions[accelerometers[tag].accelerometer_get_sampling_period_index];\n  wb_accelerometer_get_sampling_period_ptr(accelerometers[tag].self, &sampling_period);\n  return sampling_period;\n}", "CodeBleu_score": 26.204993840086065}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag){\n\tint sampling_period;\n  wb_accelerometer_private_t *accelerometer;\n  accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\n\", __FUNCTION__);\n    return -1;\n  }\n  pthread_mutex_lock(&accelerometer->mutex);\n  if (accelerometer->state == WB_ACCELEROMETER_READY) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s(): device not ready.\n\", __FUNCTION__);\n    sampling_period = -1;\n  }\n  pthread_mutex_unlock(&accelerometer->mutex);\n  return sampling_period;\n}", "CodeBleu_score": 50.91007865370998}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString(dms);\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 39.192479297986715}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsStr = dms;\n\tfree(dms);\n\treturn dmsStr;\n}", "CodeBleu_score": 41.82862713648705}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree){\n\tchar *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString = dms;\n\tfree(dms);\n\treturn dmsString;\n}", "CodeBleu_score": 42.98311638092734}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g && plane);\n  dUASSERT (g->type == dBoxClass, \"argument not a box\");\n  const dReal *R = dGeomGetRotation (g);\n  const dReal *pos = dGeomGetPosition (g);\n  dVector3 p;\n  dMULTIPLY0_331 (p,R,&x);\n  p[0] += pos[0];\n  p[1] += pos[1];\n  p[2] += pos[2];\n  dVector3 p_rel;\n  dSubtract3 (p_rel,p,pos);\n  dVector3 p_abs;\n  dMultiply0 (p_abs,R,p_rel);\n  dVector3 n;\n  dMULTIPLY1_331 (n,R,dVector3 (1,0,0));\n  dReal d = dDOT (p_abs,n);\n  if (d > 0.5 * g->max_size[0]) {\n    dMULTIPLY1_331 (n,R,dVector3 (0,1,0));\n    d = dDOT (p_abs,n);\n    if (d > 0.5 * g->max_size[1]) {\n      dMULTIPLY1_331 (n,R,dVector3 (0,0,1));\n      d = dDOT (p_abs,n);\n      if (d > 0.5 * g->max_size[2]) {\n        dMULTIPLY1_331 (n,R,dVector3 (1,0,0));\n      }\n    }\n  }\n  dMULTIPLY0_331 (plane,R,n);\n  plane[0] += pos[0];\n  plane[1] += pos[1];\n  plane[2] += pos[2];\n  plane[3] = -dDOT (p_abs,n);\n}", "CodeBleu_score": 40.00020268584556}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdAASSERT (g);\n\tdAASSERT (g->type == dBoxClass);\n\tdAASSERT (plane);\n\tconst dReal *R = dGeomGetRotation (g);\n\tconst dReal *C = dGeomGetPosition (g);\n\tconst dReal *s = dGeomBoxGetLengths (g);\n\tconst dReal *p = dGeomBoxGetPoint (g, x, y, z);\n\tdVector4Set (plane, 0, 0, 0, 0);\n\tdVector4SetW (plane, 0);\n\tdVector4Copy (plane, dGeomBoxGetTangentPlane (g, p, R, C, s));\n}", "CodeBleu_score": 17.1806993999781}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane){\n\tdUASSERT (g && g->type == dBoxClass, \"argument not a box\");\n\tconst dReal *R = dGeomGetRotation (g);\n\tconst dReal *pos = dGeomGetPosition (g);\n\tdVector3 center;\n\tdMULTIPLY0_331 (center, R, pos);\n\tdVector3 p;\n\tdSubtract3 (p, center, x, y, z);\n\tdReal px = dDOT (p, R[0]);\n\tdReal py = dDOT (p, R[1]);\n\tdReal pz = dDOT (p, R[2]);\n\tdReal half_lx = g->max_x - g->min_x;\n\tdReal half_ly = g->max_y - g->min_y;\n\tdReal half_lz = g->max_z - g->min_z;\n\tdVector3 normal;\n\tif (px < -half_lx) {\n\t\tnormal[0] = -R[0][0];\n\t\tnormal[1] = -R[0][1];\n\t\tnormal[2] = -R[0][2];\n\t\tnormal[3] = 0;\n\t\tplane[0] = -half_lx;\n\t}\n\telse if (px > half_lx) {\n\t\tnormal[0] = R[0][0];\n\t\tnormal[1] = R[0][1];\n\t\tnormal[2] = R[0][2];\n\t\tnormal[3] = 0;\n\t\tplane[0] = half_lx;\n\t}\n\telse {\n\t\tnormal[0] = 0;\n\t\tnormal[1] = 0;\n\t\tnormal[2] = 0;\n\t\tnormal[3] = 1;\n\t\tplane[0] = 0;\n\t}\n\tif (py < -half_ly) {\n\t\tnormal[0] = -R[1][0];\n\t\tnormal[1] = -R[1][1];\n\t\tnormal[2] = -R[1][2];", "CodeBleu_score": 35.43261914808172}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\t// Checks\n    if (box == NULL) {\n        dDebug (0,\"dImmerseBox: Box is NULL\");\n        return 0;\n    }\n    if (immersion == NULL) {\n        dDebug (0,\"dImmerseBox: Immersion is NULL\");\n        return 0;\n    }\n\n    // Initializes the sBoxImmersionData object\n    sBoxImmersionData boxImmersionData;\n    boxImmersionData.box = box;\n    boxImmersionData.fluidPlane = fluidPlane;\n    boxImmersionData.flags = flags;\n    boxImmersionData.immersion = immersion;\n\n    // Checks the immersion\n    int immersed = dImmerseBox_checkImmersion (&boxImmersionData);\n    if (!immersed) {\n        return 0;\n    }\n\n    // Checks the distance to the fluid plane\n    dImmerseBox_checkDistance (&boxImmersionData);\n\n    // Checks the contact points\n    dImmerseBox_checkContactPoints (&boxImmersionData);\n\n    // Checks the contact normal\n    dImmerseBox_checkContactNormal (&boxImmersionData);\n\n    // Checks the contact depth\n    dImmerseBox_checkContactDepth (&boxImmersionData);\n\n    // Checks the contact velocity\n    dImmerseBox_checkContactVelocity (&boxImmersionData);\n\n    // Checks the contact force\n    dImmerseBox_checkContactForce (&boxImmersionData);\n\n    // Checks the contact torque\n    dImmerseBox_checkContactTorque (&boxImmersionData);\n\n    // Checks the contact position\n    dImmerseBox_checkContactPosition (&boxImmersionData);\n\n    // Checks the contact rotation\n    dImmerseBox_checkContactRotation (&boxImmersionData);\n\n    // Checks the contact axis\n    dImmerseBox_checkContactAxis (&boxImmersionData);\n\n    // Checks the contact point", "CodeBleu_score": 37.514225299558554}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tdAASSERT (box);\n  dAASSERT (immersion);\n\n  // Check the flags\n  if (flags & ~(dIMM_BOX_BODY | dIMM_BOX_FLUID_PLANE | dIMM_BOX_FLUID_PLANE_NORMAL | dIMM_BOX_FLUID_PLANE_OFFSET | dIMM_BOX_FLUID_PLANE_NORMAL_REVERSED)) {\n    dWarning(\"dImmerseBox: Invalid flags.\n\");\n    return 0;\n  }\n\n  // Check the box body\n  if (!box->body) {\n    dWarning(\"dImmerseBox: Box has no body.\n\");\n    return 0;\n  }\n\n  // Initialize the sBoxImmersionData object\n  sBoxImmersionData *data = (sBoxImmersionData *)immersion->data;\n  data->box = box;\n  data->flags = flags;\n  data->fluidPlane = fluidPlane;\n\n  // Check the fluid plane\n  if (!data->fluidPlane) {\n    dWarning(\"dImmerseBox: Fluid plane is NULL.\n\");\n    return 0;\n  }\n\n  // Perform the immersion checking\n  return dImmerseBoxInternal (data);\n}", "CodeBleu_score": 41.68574426665257}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion){\n\tint result = 0;\n\n   // Check the input parameters\n   if (box == NULL) {\n      dDebug (0,\"dImmerseBox: box is NULL\");\n      return 0;\n   }\n   if (fluidPlane == NULL) {\n      dDebug (0,\"dImmerseBox: fluidPlane is NULL\");\n      return 0;\n   }\n   if (immersion == NULL) {\n      dDebug (0,\"dImmerseBox: immersion is NULL\");\n      return 0;\n   }\n\n   // Initialize the immersion data\n   sBoxImmersionData *data = (sBoxImmersionData *)immersion->data;\n   data->box = box;\n   data->fluidPlane = fluidPlane;\n   data->flags = flags;\n   data->immersion = immersion;\n\n   // Perform the immersion checking\n   result = dImmerseBox_internal (data);\n\n   // Return the result\n   return result;\n}", "CodeBleu_score": 40.454626782141744}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  dUASSERT(box->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\n  dVector3 fluidPlane;\n  dVector3 fluidNormal;\n\n  dImmersionGeom *immersionData = new dImmersionGeom();\n\n  dImmerseCapsuleBox(capsule, box, flags, immersionData);\n\n  if (immersionData->immersed) {\n    dVector3Set(fluidPlane, immersionData->plane[0], immersionData->plane[1], immersionData->plane[2], immersionData->plane[3]);\n    dVector3Set(fluidNormal, immersionData->normal[0], immersionData->normal[1], immersionData->normal[2]);\n\n    dImmerseBox(box, fluidPlane, flags, immersion);\n\n    dVector3Set(immersion->normal, fluidNormal[0], fluidNormal[1], fluidNormal[2]);\n    immersion->depth = immersionData->depth;\n    immersion->immersed = immersionData->immersed;\n    immersion->point[0] = immersionData->point[0];\n    immersion->point[1] = immersionData->point[1];\n    immersion->point[2] = immersionData->point[2];\n    immersion->point[3] = immersionData->point[3];\n\n    delete immersionData;\n\n    return 1;\n  }\n\n  delete immersionData;\n\n  return 0;\n}", "CodeBleu_score": 43.25269505890843}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT (o1->type == dBoxClass);\n  dIASSERT (o2->type == dCapsuleClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dxBox *box = (dxBox*) o1;\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  dVector3 fluidPlane;\n  dVector3Set(fluidPlane, 0, 0, 1, 0);\n\n  dImmersionGeom data;\n  data.o1 = o1;\n  data.o2 = o2;\n  data.immersion = immersion;\n  data.flags = flags;\n  data.normal = fluidPlane;\n  data.depth = 0;\n  data.point = fluidPlane;\n  data.box = box;\n  data.capsule = capsule;\n  data.capsule_radius = capsule->radius;\n  data.capsule_length = capsule->length;\n\n  // Check for collisions\n  if (dBoxCapsuleCollision(box, capsule, &data.depth, &data.point, &data.normal) == 0)\n    return 0;\n\n  // Set the immersion parameters\n  data.depth = -data.depth;\n  data.point[0] += data.depth * data.normal[0];\n  data.point[1] += data.depth * data.normal[1];\n  data.point[2] += data.depth * data.normal[2];\n\n  // Compute the immersion plane for the capsule\n  dVector3Set(data.normal, data.point[0], data.point[1], data.point[2], 0);\n  dVector3Subtract(data.normal, data.point, data.normal);\n  dNormalize3(data.normal);\n\n  // Perform the immersion check\n  return dImmerseBox(box, fluidPlane, flags, immersion);\n}", "CodeBleu_score": 50.706362253468825}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sBoxCapsuleImmersionData data(o1, o2, immersion, flags);\n\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 27.723582473240644}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tdReal volume = 0.0;\n\tdReal zIOverR0 = zIOverR;\n\tdReal zIOverR1 = zIOverR;\n\tdReal zIOverR2 = zIOverR;\n\tdReal zIOverR3 = zIOverR;\n\tdReal zIOverR4 = zIOverR;\n\tdReal zIOverR5 = zIOverR;\n\tdReal zIOverR6 = zIOverR;\n\tdReal zIOverR7 = zIOverR;\n\tdReal zIOverR8 = zIOverR;\n\tdReal zIOverR9 = zIOverR;\n\tdReal zIOverR10 = zIOverR;\n\tdReal zIOverR11 = zIOverR;\n\tdReal zIOverR12 = zIOverR;\n\tdReal zIOverR13 = zIOverR;\n\tdReal zIOverR14 = zIOverR;\n\tdReal zIOverR15 = zIOverR;\n\tdReal zIOverR16 = zIOverR;\n\tdReal zIOverR17 = zIOverR;\n\tdReal zIOverR18 = zIOverR;\n\tdReal zIOverR19 = zIOverR;\n\tdReal zIOverR20 = zIOverR;\n\tdReal zIOverR21 = zIOverR;\n\tdReal zIOverR22 = zIOverR;\n\tdReal zIOverR23 = zIOverR;\n\tdReal zIOverR24 = zIOverR;\n\tdReal zIOverR25 = zIOverR;\n\tdReal zIOverR26 = zIOverR;\n\tdReal zIOverR27 = zIOverR;\n\tdReal zIOverR28 = zIOverR;\n\tdReal zIOverR29 = zIOverR;\n\tdReal zIOverR30 = zIOverR;\n\tdReal zIOverR31 = zIOverR;", "CodeBleu_score": 12.282893155114678}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tdReal sinTheta0 = 1.0;\n\tdReal tanTheta1 = 0.0;\n\tdReal volume = 0.0;\n\n\t// Handle singularities\n\tif (sinTheta0 == 0.0) {\n\t\tvolume += (mRadius * mRadius * mRadius) * (1.0 / 3.0) * (tanTheta1 - tanTheta0);\n\t}\n\telse if (sinTheta1 == 0.0) {\n\t\tvolume += (mRadius * mRadius * mRadius) * (1.0 / 3.0) * (tanTheta1 - tanTheta0);\n\t}\n\telse {\n\t\t// Calculate volume of first part\n\t\tvolume += (mRadius * mRadius * mRadius) * (1.0 / 3.0) * (tanTheta1 - tanTheta0) * (1.0 + sinTheta0 + sinTheta1);\n\n\t\t// Calculate volume of second part\n\t\tdReal sinTheta2 = 0.0;\n\t\tdReal tanTheta2 = 0.0;\n\t\tdReal sinTheta3 = 0.0;\n\t\tdReal tanTheta3 = 0.0;\n\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tsinTheta2 = sinTheta1 * sinTheta1;\n\t\t\ttanTheta2 = tanTheta1 * tanTheta1;\n\t\t\tsinTheta3 = sinTheta2 * sinTheta1;\n\t\t\ttanTheta3 = tanTheta2 * tanTheta1;\n\n\t\t\tvolume += (mRadius * mRadius * mRadius) * (1.0 / 3.0) * (tanTheta3 - tanTheta2) * (1.0 + sinTheta2 + sinTheta3);\n\n\t\t\tsinTheta1 = sinTheta2;\n\t\t\ttanTheta1 = tanTheta2;\n\t\t}\n\t}\n\n\treturn volume;\n}", "CodeBleu_score": 40.460490386723514}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const{\n\tdReal zIOverR0 = zIOverR;\n\tdReal zIOverR1 = zIOverR;\n\tdReal zIOverR2 = zIOverR;\n\tdReal zIOverR3 = zIOverR;\n\tdReal zIOverR4 = zIOverR;\n\tdReal zIOverR5 = zIOverR;\n\tdReal zIOverR6 = zIOverR;\n\tdReal zIOverR7 = zIOverR;\n\tdReal zIOverR8 = zIOverR;\n\tdReal zIOverR9 = zIOverR;\n\tdReal zIOverR10 = zIOverR;\n\tdReal zIOverR11 = zIOverR;\n\tdReal zIOverR12 = zIOverR;\n\tdReal zIOverR13 = zIOverR;\n\tdReal zIOverR14 = zIOverR;\n\tdReal zIOverR15 = zIOverR;\n\tdReal zIOverR16 = zIOverR;\n\tdReal zIOverR17 = zIOverR;\n\tdReal zIOverR18 = zIOverR;\n\tdReal zIOverR19 = zIOverR;\n\tdReal zIOverR20 = zIOverR;\n\tdReal zIOverR21 = zIOverR;\n\tdReal zIOverR22 = zIOverR;\n\tdReal zIOverR23 = zIOverR;\n\tdReal zIOverR24 = zIOverR;\n\tdReal zIOverR25 = zIOverR;\n\tdReal zIOverR26 = zIOverR;\n\tdReal zIOverR27 = zIOverR;\n\tdReal zIOverR28 = zIOverR;\n\tdReal zIOverR29 = zIOverR;\n\tdReal zIOverR30 = zIOverR;\n\tdReal zIOverR31 = zIOverR;\n\tdReal zIOverR32 =", "CodeBleu_score": 10.326740259790302}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\t//Calculate the hemisphere's surface area\n\tdReal area = M_PI * pow(m_radius, 2) * (1 - zIOverR);\n\n\t//Calculate the hemisphere's surface area in the first quadrant\n\tdReal area1 = M_PI * pow(m_radius, 2) * (1 - zIOverR) * (1 - tanTheta0);\n\n\t//Calculate the hemisphere's surface area in the second quadrant\n\tdReal area2 = M_PI * pow(m_radius, 2) * (1 - zIOverR) * (1 - sinTheta1);\n\n\t//Calculate the hemisphere's surface area in the third quadrant\n\tdReal area3 = M_PI * pow(m_radius, 2) * (1 - zIOverR) * (1 - tanTheta0) * (1 - sinTheta1);\n\n\t//Calculate the hemisphere's surface area in the fourth quadrant\n\tdReal area4 = M_PI * pow(m_radius, 2) * (1 - zIOverR) * (1 - tanTheta0) * (1 - sinTheta1);\n\n\t//Calculate the hemisphere's surface area in the first octant\n\tdReal area5 = M_PI * pow(m_radius, 2) * (1 - zIOverR) * (1 - tanTheta0) * (1 - sinTheta1);\n\n\t//Calculate the hemisphere's surface area in the second octant\n\tdReal area6 = M_PI * pow(m_radius, 2) * (1 - zIOverR) * (1 - tanTheta0) * (1 - sinTheta1);\n\n\t//Calculate the hemisphere's surface area in the third octant\n\tdReal area7 = M_PI * pow(m_radius, 2) * (1 - zIOverR) * (1 - tanTheta0) * (1 - sinTheta1);\n\n\t//Calculate the hemisphere's surface area in the fourth octant\n\tdReal area8 = M_PI * pow(m_radius, 2) *", "CodeBleu_score": 33.089009040499484}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal xBuoyancyCenter = 0;\n\tdReal x0 = 0;\n\tdReal x1 = 0;\n\tdReal x2 = 0;\n\tdReal x3 = 0;\n\tdReal x4 = 0;\n\tdReal x5 = 0;\n\tdReal x6 = 0;\n\tdReal x7 = 0;\n\tdReal x8 = 0;\n\tdReal x9 = 0;\n\tdReal x10 = 0;\n\tdReal x11 = 0;\n\tdReal x12 = 0;\n\tdReal x13 = 0;\n\tdReal x14 = 0;\n\tdReal x15 = 0;\n\tdReal x16 = 0;\n\tdReal x17 = 0;\n\tdReal x18 = 0;\n\tdReal x19 = 0;\n\tdReal x20 = 0;\n\tdReal x21 = 0;\n\tdReal x22 = 0;\n\tdReal x23 = 0;\n\tdReal x24 = 0;\n\tdReal x25 = 0;\n\tdReal x26 = 0;\n\tdReal x27 = 0;\n\tdReal x28 = 0;\n\tdReal x29 = 0;\n\tdReal x30 = 0;\n\tdReal x31 = 0;\n\tdReal x32 = 0;\n\tdReal x33 = 0;\n\tdReal x34 = 0;\n\tdReal x35 = 0;\n\tdReal x36 = 0;\n\tdReal x37 = 0;\n\tdReal x38 = 0;\n\tdReal x39 = 0;\n\tdReal x40 = 0;\n\tdReal x41 = 0;\n\tdReal x42 = 0;\n\tdReal x43 = 0;\n\tdReal x44 = 0;\n\tdReal x45 = 0;\n\tdReal", "CodeBleu_score": 9.951900974647712}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const{\n\tdReal volume2 = volume * volume;\n\tdReal zIOverR2 = zIOverR * zIOverR;\n\tdReal zIOverR4 = zIOverR2 * zIOverR2;\n\tdReal zIOverR6 = zIOverR4 * zIOverR2;\n\tdReal zIOverR8 = zIOverR6 * zIOverR2;\n\tdReal zIOverR10 = zIOverR8 * zIOverR2;\n\tdReal zIOverR12 = zIOverR10 * zIOverR2;\n\tdReal zIOverR14 = zIOverR12 * zIOverR2;\n\tdReal zIOverR16 = zIOverR14 * zIOverR2;\n\tdReal zIOverR18 = zIOverR16 * zIOverR2;\n\tdReal zIOverR20 = zIOverR18 * zIOverR2;\n\tdReal zIOverR22 = zIOverR20 * zIOverR2;\n\tdReal zIOverR24 = zIOverR22 * zIOverR2;\n\tdReal zIOverR26 = zIOverR24 * zIOverR2;\n\tdReal zIOverR28 = zIOverR26 * zIOverR2;\n\tdReal zIOverR30 = zIOverR28 * zIOverR2;\n\tdReal zIOverR32 = zIOverR30 * zIOverR2;\n\tdReal zIOverR34 = zIOverR32 * zIOverR2;\n\tdReal zIOverR36 = zIOverR34 * zIOverR2;\n\tdReal zIOverR38 = zIOverR36 * zIOverR2;\n\tdReal zIOverR40 = zIOverR38 * zIOverR2;\n\tdReal zIOverR42 = zIOverR40 * zIOverR2;\n\tdReal zIOverR4", "CodeBleu_score": 34.495252352089956}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.3603136746945}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n  dUASSERT(o2->type == dTriMeshClass, \"This geom is not a trimesh and hence cannot be used for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 33.802972378890445}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion){\n\tdIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(o1->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(o1, o2, flags, immersion);\n  return data.performImmersionChecking();\n}", "CodeBleu_score": 25.19228016192519}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart(){\n\tROS_DEBUG_STREAM_NAMED(\"SleepNode\", \"Starting SleepNode\");\n  if (!getInput<double>(\"duration\", duration_)) {\n    ROS_WARN_STREAM_NAMED(\"SleepNode\", \"No duration given, aborting\");\n    return NodeStatus::FAILURE;\n  }\n  if (duration_ <= 0.0) {\n    ROS_WARN_STREAM_NAMED(\"SleepNode\", \"Duration is non-positive, aborting\");\n    return NodeStatus::FAILURE;\n  }\n  timer_waiting_ = false;\n  timer_ = nh_.createTimer(ros::Duration(duration_), &SleepNode::timerCallback, this);\n  timer_.start();\n  return NodeStatus::RUNNING;\n}", "CodeBleu_score": 41.12807704110706}, {"code": "NodeStatus SleepNode::onStart(){\n\tif (input_.isEmpty()) {\n        return NodeStatus::SUCCESS;\n    }\n\n    auto duration = input_.getDuration();\n    if (duration <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n\n    timer_waiting_ = true;\n    timer_.start(duration, [this]() {\n        if (timer_waiting_) {\n            timer_waiting_ = false;\n            emitSignal(output_, \"wake_up\");\n        }\n    });\n\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 45.07681857092075}, {"code": "NodeStatus SleepNode::onStart(){\n\t// TODO: Implement\n    return NodeStatus::SUCCESS;\n}", "CodeBleu_score": 5.133797453058873}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick(){\n\t// Get entry\n    std::string entryName = getEntryName();\n    Entry* entry = getEntry(entryName);\n    if (entry == nullptr) {\n        ROS_ERROR(\"Entry %s not found\", entryName.c_str());\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock entry\n    entry->lock();\n\n    // Get entry sequence ID\n    uint32_t sequenceID = entry->getSequenceID();\n\n    // Check if sequence ID has changed\n    if (sequenceID != sequenceID_) {\n        sequenceID_ = sequenceID;\n        entry->unlock();\n        return NodeStatus::SUCCESS;\n    }\n\n    // Unlock entry\n    entry->unlock();\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 47.766368683936676}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tEntry *entry = getEntry();\n\n\tif (entry != nullptr) {\n\t\tstd::lock_guard<std::mutex> lock(entry->mutex);\n\n\t\tif (entry->sequenceID != sequenceID) {\n\t\t\tsequenceID = entry->sequenceID;\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 30.809492033624892}, {"code": "NodeStatus EntryUpdatedAction::tick(){\n\tif (blackboard->getEntry<std::string>(key).getSequenceId() != sequenceId) {\n        sequenceId = blackboard->getEntry<std::string>(key).getSequenceId();\n        return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 28.03699496900469}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n\t\treturn (size_t) (abs(successThreshold_) * children.size());\n\t}\n\telse {\n\t\treturn (size_t) successThreshold_;\n\t}\n}", "CodeBleu_score": 54.685287351922426}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n\t\treturn static_cast<size_t>(successThreshold_ * children.size());\n\t} else {\n\t\treturn successThreshold_;\n\t}\n}", "CodeBleu_score": 53.36346799240847}, {"code": "size_t ParallelNode::successThreshold() const{\n\tif (successThreshold_ < 0) {\n\t\treturn -successThreshold_ / children.size();\n\t}\n\treturn successThreshold_;\n}", "CodeBleu_score": 46.700113554236005}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop(){\n\t// Sleep for 10 milliseconds between iterations\n  std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  // Check the status of the heartbeat\n  if (_p->heartbeat.status == Heartbeat::Status::ACTIVE) {\n    // If the heartbeat is active, check the time since the last heartbeat\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(\n            std::chrono::steady_clock::now() - _p->heartbeat.last_heartbeat)\n            .count() > 1000) {\n      // If the heartbeat has been inactive for more than 1 second, disable all breakpoints\n      _p->heartbeat.status = Heartbeat::Status::INACTIVE;\n      _p->heartbeat.last_heartbeat = std::chrono::steady_clock::now();\n      enableAllHooks(false);\n    }\n  } else {\n    // If the heartbeat is inactive, check the time since the last heartbeat\n    if (std::chrono::duration_cast<std::chrono::milliseconds>(\n            std::chrono::steady_clock::now() - _p->heartbeat.last_heartbeat)\n            .count() > 1000) {\n      // If the heartbeat has been inactive for more than 1 second, enable all breakpoints\n      _p->heartbeat.status = Heartbeat::Status::ACTIVE;\n      _p->heartbeat.last_heartbeat = std::chrono::steady_clock::now();\n      enableAllHooks(true);\n    }\n  }\n  // If the heartbeat status has changed, call the callback function\n  if (_p->heartbeat.status_changed) {\n    _p->heartbeat.status_changed = false;\n    if (_p->heartbeat.status == Heartbeat::Status::ACTIVE) {\n      _p->heartbeat.callback();\n    }\n  }\n  // Call this function again\n  heartbeatLoop();", "CodeBleu_score": 38.10901036053333}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\t// TODO: this should be a while loop, and we should be able to break out of it\n  // by setting a flag in the class.\n  // TODO: this should be a separate thread, not a loop in the main thread.\n  // TODO: this should be a loop that can be stopped.\n  // TODO: this should be a loop that can be paused.\n  // TODO: this should be a loop that can be resumed.\n  // TODO: this should be a loop that can be restarted.\n  // TODO: this should be a loop that can be started.\n  // TODO: this should be a loop that can be reset.\n  // TODO: this should be a loop that can be reinitialized.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that can be reconfigured.\n  // TODO: this should be a loop that", "CodeBleu_score": 3.386686330332041}, {"code": "void Groot2Publisher::heartbeatLoop(){\n\twhile (true) {\n    if (_p->heartbeat_status == HeartbeatStatus::ACTIVE) {\n      if (_p->last_heartbeat_time + _p->heartbeat_interval < std::chrono::steady_clock::now()) {\n        _p->heartbeat_status = HeartbeatStatus::INACTIVE;\n        _p->logger->log(spdlog::level::warn, \"Heartbeat lost\");\n        _p->logger->log(spdlog::level::warn, \"Disabling all breakpoints\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a local server, make sure it is running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a remote server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a local server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a remote server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a local server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a remote server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a local server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a remote server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a local server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a remote server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"If you are running a local server, make sure it is still running\");\n        _p->logger->log(spdlog::level::warn, \"", "CodeBleu_score": 26.903090734377987}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> result;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    std::string bb_name_tmp;\n    std::string bb_name_tmp2;\n    std::string bb_name_tmp3;\n    std::string bb_name_tmp4;\n    std::string bb_name_tmp5;\n    std::string bb_name_tmp6;\n    std::string bb_name_tmp7;\n    std::string bb_name_tmp8;\n    std::string bb_name_tmp9;\n    std::string bb_name_tmp10;\n    std::string bb_name_tmp11;\n    std::string bb_name_tmp12;\n    std::string bb_name_tmp13;\n    std::string bb_name_tmp14;\n    std::string bb_name_tmp15;\n    std::string bb_name_tmp16;\n    std::string bb_name_tmp17;\n    std::string bb_name_tmp18;\n    std::string bb_name_tmp19;\n    std::string bb_name_tmp20;\n    std::string bb_name_tmp21;\n    std::string bb_name_tmp22;\n    std::string bb_name_tmp23;\n    std::string bb_name_tmp24;\n    std::string bb_name_tmp25;\n    std::string bb_name_tmp26;\n    std::string bb_name_tmp27;\n    std::string bb_name_tmp28;\n    std::string bb_name_tmp29;\n    std::string bb_name_tmp30;\n    std::string bb_name_tmp31;\n    std::string bb_name_tmp32;\n    std::string bb_name_tmp33;\n    std::string bb_name_tmp34;\n    std::string bb_name_tmp3", "CodeBleu_score": 12.523730610631864}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\tstd::vector<uint8_t> output_msgpack;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    std::vector<std::string> bb_names;\n    while (std::getline(ss, bb_name, ',')) {\n        bb_names.push_back(bb_name);\n    }\n    for (auto it = bb_names.begin(); it != bb_names.end(); it++) {\n        std::string bb_name = *it;\n        std::stringstream ss(bb_name);\n        std::string bb_name_part;\n        std::vector<std::string> bb_name_parts;\n        while (std::getline(ss, bb_name_part, '/')) {\n            bb_name_parts.push_back(bb_name_part);\n        }\n        if (bb_name_parts.size() < 2) {\n            ROS_WARN(\"[Groot2Publisher::generateBlackboardsDump] Blackboard name %s is invalid.\", bb_name.c_str());\n            continue;\n        }\n        std::string bb_name_root = bb_name_parts[0];\n        std::string bb_name_subtree = bb_name_parts[1];\n        std::string bb_name_leaf = bb_name_parts[bb_name_parts.size() - 1];\n        std::string bb_name_full = bb_name_root + \"/\" + bb_name_subtree;\n        std::string bb_name_full_leaf = bb_name_full + \"/\" + bb_name_leaf;\n        if (!blackboards_->hasBlackboard(bb_name_full_leaf)) {\n            ROS_WARN(\"[Groot2Publisher::generateBlackboardsDump] Blackboard name %s does not exist.\", bb_name_full_leaf.c_str());\n            continue;\n        }\n        Blackboard* bb = blackboards_->getBlackboard(bb_name_full_leaf);\n        if (bb", "CodeBleu_score": 40.592405469347945}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list){\n\t// Create a JSON object to store the blackboards\n    json bb_json = json::object();\n\n    // Split the input string into a vector of strings\n    std::vector<std::string> bb_names;\n    boost::split(bb_names, bb_list, boost::is_any_of(\",\"));\n\n    // Iterate through the vector of strings and find the corresponding subtrees\n    for (const std::string& bb_name : bb_names) {\n        // Find the subtree\n        std::shared_ptr<Blackboard> bb = this->blackboard_tree->findSubtree(bb_name);\n\n        // If the subtree is valid, export the blackboard to JSON and add it to the JSON object\n        if (bb != nullptr) {\n            bb_json[bb_name] = bb->toJSON();\n        }\n    }\n\n    // Convert the JSON object to MessagePack format and return it\n    return json::to_msgpack(bb_json);\n}", "CodeBleu_score": 43.234771562494764}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status != Monitor::Hook::Status::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = Monitor::Hook::Status::READY;\n  hook->remove = remove;\n  hook->result = result;\n  hook->ready = true;\n  hook->cv.notify_all();\n  return true;\n}", "CodeBleu_score": 50.4351099186511}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status != Monitor::Hook::Status::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->status = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cond.notify_all();\n  return true;\n}", "CodeBleu_score": 49.05069283888703}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove){\n\tauto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n  std::unique_lock<std::mutex> lk(hook->mutex);\n  if(hook->status != Monitor::Hook::BREAKPOINT)\n  {\n    return false;\n  }\n  hook->result = result;\n  hook->remove = remove;\n  hook->ready = true;\n  hook->cv.notify_all();\n  return true;\n}", "CodeBleu_score": 47.73417149070229}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  NodeStatus status = tick_functor_(*this);\n  if(status != prev_status)\n  {\n    setStatus(status);\n  }\n  return status;\n}", "CodeBleu_score": 25.409985304426037}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  if(halt_requested_.load())\n  {\n    setStatus(NodeStatus::IDLE);\n    halt_requested_.store(false);\n    return NodeStatus::IDLE;\n  }\n\n  try\n  {\n    NodeStatus status = tick_functor_(*this);\n    if(status != prev_status)\n    {\n      setStatus(status);\n    }\n  }\n  catch(std::exception& ex)\n  {\n    setStatus(NodeStatus::IDLE);\n    halt_requested_.store(false);\n    throw ex;\n  }\n  catch(...)\n  {\n    setStatus(NodeStatus::IDLE);\n    halt_requested_.store(false);\n    throw;\n  }\n\n  if(exception_ptr_ != nullptr)\n  {\n    std::rethrow_exception(exception_ptr_);\n  }\n  return status();\n}", "CodeBleu_score": 50.74289575282347}, {"code": "NodeStatus BT::ThreadedAction::executeTick(){\n\tNodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n    halt_requested_.store(false);\n    std::thread thread(&BT::ThreadedAction::threaded_executeTick, this);\n    thread.detach();\n  }\n\n  NodeStatus status = tick_functor_(*this);\n  if(status != prev_status)\n  {\n    setStatus(status);\n  }\n  return status;\n}", "CodeBleu_score": 31.581960381380846}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tstd::function<void(const TreeNode*, int)> print_recursive = [&print_recursive, &stream](const TreeNode* node, int depth) {\n        stream << std::string(depth, '\\t') << node->getName() << std::endl;\n        for (auto child : node->getChildren()) {\n            print_recursive(child, depth + 1);\n        }\n        if (node->getChild()) {\n            print_recursive(node->getChild(), depth + 1);\n        }\n    };\n    stream << \"--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", "CodeBleu_score": 21.15368054769088}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif (root_node == nullptr) {\n        return;\n    }\n\n    // Define a lambda function to print the tree recursively\n    auto printTree = [&](const TreeNode* node, int depth) {\n        // Print the node's name\n        stream << std::string(depth, ' ') << node->name << std::endl;\n\n        // Print the children of the node\n        if (node->type == TreeNodeType::ControlNode) {\n            // Print the children of the node\n            for (auto child : node->children) {\n                printTree(child, depth + 1);\n            }\n        }\n        else if (node->type == TreeNodeType::DecoratorNode) {\n            // Print the child of the node\n            printTree(node->child, depth + 1);\n        }\n    };\n\n    // Print the tree\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    printTree(root_node, 0);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 39.12820764703984}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream){\n\tif (root_node == nullptr) {\n        return;\n    }\n    auto print_node = [&](const TreeNode* node) {\n        if (node == nullptr) {\n            return;\n        }\n        if (node->isControlNode()) {\n            stream << std::string(node->getDepth() * 2, ' ') << node->getName() << std::endl;\n            for (auto child : node->getChildren()) {\n                print_node(child);\n            }\n        } else if (node->isDecoratorNode()) {\n            stream << std::string(node->getDepth() * 2, ' ') << node->getName() << std::endl;\n            print_node(node->getChild());\n        }\n    };\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    print_node(root_node);\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 40.61877069951259}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto & child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 92.34187483461082}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif (!node) {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if (auto control = dynamic_cast<const BT::ControlNode*>(node)) {\n    for (const auto& child : control->children()) {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  } else if (auto decorator = dynamic_cast<const BT::DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 92.96577020547093}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor){\n\tif(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}", "CodeBleu_score": 99.65854358087711}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.getRegistrationID()) != builders.end()) {\n        throw BehaviorTreeException(\"Node builder with ID '\" +\n                                    manifest.getRegistrationID() +\n                                    \"' already exists.\");\n    }\n\n    builders.insert(std::make_pair(manifest.getRegistrationID(), builder));\n    manifests.insert(std::make_pair(manifest.getRegistrationID(), manifest));\n}", "CodeBleu_score": 45.52444257475119}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (this->builders.count(manifest.id) > 0) {\n        throw BehaviorTreeException(\"Attempted to register a builder with the same ID as an existing builder.\");\n    }\n    this->builders[manifest.id] = builder;\n    this->manifests[manifest.id] = manifest;\n}", "CodeBleu_score": 34.95220827565523}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder){\n\tif (builders.find(manifest.id) != builders.end()) {\n    throw BehaviorTreeException(\"Node with ID \" + manifest.id +\n                                \" already registered.\");\n  }\n  builders[manifest.id] = builder;\n  manifests[manifest.id] = manifest;\n}", "CodeBleu_score": 42.143130989678625}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [tick_functor, ports](const NodeConfiguration& config) {\n    return SimpleActionNode::make(tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest{\n      ID, NodeType::ACTION, ports,\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},\n      std::vector<std::string>{},", "CodeBleu_score": 32.27070442490055}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tauto builder = [tick_functor, ports] (const TreeNodeManifest& manifest,\n                                        const Blackboard::Ptr& blackboard) {\n    return std::make_shared<SimpleActionNode>(manifest.name, blackboard, tick_functor, ports);\n  };\n\n  auto manifest = TreeNodeManifest(ID, \"SimpleActionNode\", ports);\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 54.32898855984574}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports){\n\tNodeBuilder builder = [tick_functor](const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(config, tick_functor);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.registration_ID = ID;\n  manifest.type = NodeType::ACTION;\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}", "CodeBleu_score": 56.30122553555622}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.size());\n\n    for (const auto& subtree : tree) {\n        Blackboard::Ptr blackboard_backup = std::make_shared<Blackboard>();\n        blackboard_backup->Clone(subtree->GetBlackboard());\n        blackboard_backups.push_back(blackboard_backup);\n    }\n\n    return blackboard_backups;\n}", "CodeBleu_score": 49.41602174342006}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.GetSubtrees().size());\n    for (const auto& subtree : tree.GetSubtrees()) {\n        Blackboard::Ptr blackboard = std::make_shared<Blackboard>();\n        blackboard->Clone(subtree->GetBlackboard());\n        blackboard_backups.push_back(blackboard);\n    }\n    return blackboard_backups;\n}", "CodeBleu_score": 49.52155321405527}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree){\n\tstd::vector<Blackboard::Ptr> blackboard_backups;\n\tblackboard_backups.reserve(tree.GetSubtrees().size());\n\tfor (const auto& subtree : tree.GetSubtrees()) {\n\t\tBlackboard::Ptr blackboard = std::make_shared<Blackboard>();\n\t\tblackboard->Clone(subtree.GetBlackboard());\n\t\tblackboard_backups.push_back(blackboard);\n\t}\n\treturn blackboard_backups;\n}", "CodeBleu_score": 48.91341191515098}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto result = ParseScript(script);\n  if(result)\n  {\n    return (*result)(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(result.error());\n  }\n}", "CodeBleu_score": 67.51038515741222}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor)\n  {\n    return executor(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 85.81878852551466}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script){\n\tauto executor = ParseScript(script);\n  if(executor)\n  {\n    return executor(env);\n  }\n  else\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}", "CodeBleu_score": 85.81878852551466}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tlib = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (lib == nullptr) {\n\t\tthrow RuntimeError(std::string(\"Failed to load library: \") + dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}", "CodeBleu_score": 52.45853515493493}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n    if (handle != nullptr) {\n        throw RuntimeError(\"A shared library has already been loaded.\");\n    }\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle == nullptr) {\n        throw RuntimeError(std::string(\"Failed to load shared library: \") + dlerror());\n    }\n    this->path = path;\n}", "CodeBleu_score": 51.705122918963255}, {"code": "void SharedLibrary::load(const std::string& path, int){\n\tstd::lock_guard<std::mutex> lock(mutex);\n    if (library != nullptr) {\n        throw RuntimeError(\"Shared library already loaded\");\n    }\n    library = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (library == nullptr) {\n        throw RuntimeError(std::string(\"Could not load shared library: \") + dlerror());\n    }\n    this->path = path;\n}", "CodeBleu_score": 52.22587784225119}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped.front() != '{' || stripped.back() != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substr(1, stripped.size() - 2);\n\t}\n\treturn true;\n}", "CodeBleu_score": 24.808996144045654}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.size() < 3) {\n        return false;\n    }\n    StringView stripped = str.substr(1, str.size() - 2);\n    if (stripped_pointer != nullptr) {\n        *stripped_pointer = stripped;\n    }\n    return stripped.starts_with('{') && stripped.ends_with('}');\n}", "CodeBleu_score": 23.313701064767898}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer){\n\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.substr(1, str.length() - 2);\n\tstripped.strip();\n\tif (stripped.length() < 1) {\n\t\treturn false;\n\t}\n\tif (stripped.front() != '{') {\n\t\treturn false;\n\t}\n\tif (stripped.back() != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped;\n\t}\n\treturn true;\n}", "CodeBleu_score": 25.175835543748292}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble line_cost = 0;\n    double point_cost;\n    int dx = x1 - x0;\n    int dy = y1 - y0;\n    double sx = (dx >= 0) ? 1 : -1;\n    double sy = (dy >= 0) ? 1 : -1;\n    double err = dx - dy;\n    double e2;\n    double x = x0;\n    double y = y0;\n\n    //if the cell is in an obstacle the path is invalid\n    if(pointCost(x0, y0) == -2)\n      return -2;\n    if(pointCost(x1, y1) == -2)\n      return -2;\n\n    //if the cell is in an obstacle the path is invalid\n    if(pointCost(x0, y0) == -1)\n      return -1;\n    if(pointCost(x1, y1) == -1)\n      return -1;\n\n    while(true) {\n      point_cost = pointCost(x, y);\n      if(point_cost < 0)\n        return point_cost;\n      line_cost += point_cost;\n      e2 = 2 * err;\n      if(e2 > -dy) {\n        err -= dy;\n        x += sx;\n      }\n      if(e2 < dx) {\n        err += dx;\n        y += sy;\n      }\n      if(x == x1 && y == y1)\n        break;\n    }\n    return line_cost;\n  }", "CodeBleu_score": 48.02361857480204}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n    double pointCost;\n    int x, y;\n    LineIterator it(x0, y0, x1, y1);\n    while(!it.isPastEnd()) {\n      it.increment();\n      x = it.getX();\n      y = it.getY();\n      pointCost = pointCost(x, y);\n      if(pointCost < 0)\n        return pointCost;\n      lineCost += pointCost;\n    }\n    return lineCost;\n  }", "CodeBleu_score": 57.72059202678492}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const{\n\tdouble lineCost = 0;\n    LineIterator line(costmap_, x0, y0, x1, y1);\n    double dx = x1 - x0;\n    double dy = y1 - y0;\n    double distance = sqrt(dx * dx + dy * dy);\n    double stepX = dx / distance;\n    double stepY = dy / distance;\n    double x = x0;\n    double y = y0;\n    double step = 0;\n    double pointCost = 0;\n    while(line.isValid()) {\n      pointCost = pointCost(line.getX(), line.getY());\n      if(pointCost < 0)\n        return pointCost;\n      else if(pointCost > 0) {\n        step += sqrt(stepX * stepX + stepY * stepY);\n        if(step > distance)\n          step = distance;\n        lineCost += step * pointCost;\n      }\n      line.increment();\n      x += stepX;\n      y += stepY;\n      stepX = (x1 - x) / distance;\n      stepY = (y1 - y) / distance;\n      step = 0;\n    }\n    return lineCost;\n  }", "CodeBleu_score": 47.033600160675626}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path msg;\n  msg.header = path.front().header;\n  for (const auto& pose : path) {\n    msg.poses.push_back(pose);\n  }\n  pub.publish(msg);\n}", "CodeBleu_score": 37.102317494196804}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n        return;\n    }\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = path.front().header.frame_id;\n    path_msg.header.stamp = path.front().header.stamp;\n    for (const auto& pose : path) {\n        path_msg.poses.push_back(pose);\n    }\n    pub.publish(path_msg);\n}", "CodeBleu_score": 46.54859924989104}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n\tif (path.empty()) {\n\t\treturn;\n\t}\n\n\tnav_msgs::Path plan;\n\tplan.header = path.front().header;\n\tplan.poses = path;\n\tpub.publish(plan);\n}", "CodeBleu_score": 29.54788297412088}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tif (base_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n      base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n    return true;\n  }\n  return false;\n}", "CodeBleu_score": 47.43658205869694}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\t// Check if the robot has stopped rotating\n  if (base_odom.twist.twist.angular.z <= rot_stopped_velocity) {\n    // Check if the robot has stopped translating\n    if (base_odom.twist.twist.linear.x <= trans_stopped_velocity) {\n      // If both conditions are met, the robot has stopped\n      return true;\n    }\n  }\n  // If the robot has not stopped, return false\n  return false;\n}", "CodeBleu_score": 45.80872187341928}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n\tdouble linear_velocity = base_odom.twist.twist.linear.x;\n    double angular_velocity = base_odom.twist.twist.angular.z;\n    if (abs(linear_velocity) <= trans_stopped_velocity && abs(angular_velocity) <= rot_stopped_velocity) {\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 50.565874054577634}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tif (setup) {\n    if (restore_defaults) {\n      config = default_limits;\n      setup = false;\n    }\n  } else {\n    default_limits = config;\n    setup = true;\n  }\n\n  if (config.max_vel_x > 0) {\n    max_vel_x = config.max_vel_x;\n  }\n  if (config.max_vel_y > 0) {\n    max_vel_y = config.max_vel_y;\n  }\n  if (config.max_vel_theta > 0) {\n    max_vel_theta = config.max_vel_theta;\n  }\n  if (config.max_vel_z > 0) {\n    max_vel_z = config.max_vel_z;\n  }\n  if (config.max_vel_xy > 0) {\n    max_vel_xy = config.max_vel_xy;\n  }\n  if (config.max_vel_z_up > 0) {\n    max_vel_z_up = config.max_vel_z_up;\n  }\n  if (config.max_vel_z_down > 0) {\n    max_vel_z_down = config.max_vel_z_down;\n  }\n  if (config.max_vel_turn > 0) {\n    max_vel_turn = config.max_vel_turn;\n  }\n  if (config.max_accel_x > 0) {\n    max_accel_x = config.max_accel_x;\n  }\n  if (config.max_accel_y > 0) {\n    max_accel_y = config.max_accel_y;\n  }\n  if (config.max_accel_theta > 0) {\n    max_accel_theta = config.max_accel_theta;\n  }\n  if (config.max_accel_z > 0) {\n    max_accel_z = config.max_accel_z;\n  }\n  if (config.max_accel_", "CodeBleu_score": 40.394898746063184}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tboost::mutex::scoped_lock lock(configuration_mutex);\n  if (!setup) {\n    setup = true;\n    if (restore_defaults) {\n      limits.max_trans_vel = 0.3;\n      limits.max_rot_vel = 1.0;\n      limits.max_trans_acc = 0.2;\n      limits.max_rot_acc = 1.0;\n      limits.max_trans_vel_fine = 0.1;\n      limits.max_rot_vel_fine = 0.5;\n      limits.max_trans_acc_fine = 0.1;\n      limits.max_rot_acc_fine = 0.5;\n      limits.max_trans_vel_coarse = 0.1;\n      limits.max_rot_vel_coarse = 0.5;\n      limits.max_trans_acc_coarse = 0.1;\n      limits.max_rot_acc_coarse = 0.5;\n      limits.max_yaw_rate = 1.0;\n      limits.min_yaw_rate = -1.0;\n      limits.max_yaw_change = 1.0;\n      limits.min_yaw_change = -1.0;\n      limits.max_yaw_rate_fine = 0.5;\n      limits.max_yaw_rate_coarse = 0.5;\n      limits.max_yaw_change_fine = 0.5;\n      limits.max_yaw_change_coarse = 0.5;\n      limits.max_trans_vel_x = 0.5;\n      limits.max_trans_vel_y = 0.5;\n      limits.max_trans_vel_z = 0.5;\n      limits.max_trans_acc_x = 0.1;\n      limits.max_trans_acc_y = 0.1;\n      limits.max_trans_acc_z = 0.1;\n      limits.max_trans_vel_yaw = 0.5;\n      limits.max_trans", "CodeBleu_score": 32.037678185236174}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults){\n\tboost::mutex::scoped_lock l(configuration_mutex_);\n  if (setup_ == false) {\n    setup_ = true;\n    default_limits_ = config;\n  }\n  if (restore_defaults) {\n    config = default_limits_;\n  }\n  current_limits_ = config;\n  configuration_mutex_.unlock();\n}", "CodeBleu_score": 63.35685488755427}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// If the cell is an obstacle or has no information, set its target distance to the maximum obstacle cost and return false.\n  if (check_cell->isObstacle() || check_cell->getTargetDistance() == -1) {\n    check_cell->setTargetDistance(costmap.getMaxObstacleDistance());\n    return false;\n  }\n\n  // Calculate the new target distance.\n  double new_target_distance = current_cell->getTargetDistance() +\n    (check_cell->getCost() - current_cell->getCost());\n\n  // If the new target distance is shorter, update the cell's target distance and return true.\n  if (new_target_distance < check_cell->getTargetDistance()) {\n    check_cell->setTargetDistance(new_target_distance);\n    return true;\n  }\n\n  // If the new target distance is longer, return false.\n  return false;\n}", "CodeBleu_score": 45.37312886867855}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\tif (check_cell->getObstacle()) {\n        check_cell->setTargetDistance(MAX_OBSTACLE_COST);\n        return false;\n    }\n\n    if (check_cell->getTargetDistance() == -1) {\n        check_cell->setTargetDistance(\n            calculateTargetDistance(current_cell, check_cell, costmap));\n    }\n\n    return true;\n}", "CodeBleu_score": 34.677314999894634}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap){\n\t// Check if the cell is an obstacle\n    if (check_cell->isObstacle()) {\n      // If the cell is an obstacle, set the target distance to the maximum obstacle cost\n      current_cell->setTargetDistance(costmap.getMaxObstacleCost());\n      return false;\n    }\n    // Check if the cell has information\n    if (check_cell->hasInformation()) {\n      // If the cell has information, return false\n      return false;\n    }\n    // Calculate the cost of the cell\n    double cost = current_cell->getCost() + costmap.getCost(check_cell->getX(), check_cell->getY());\n    // Check if the cost is less than the current target distance\n    if (cost < current_cell->getTargetDistance()) {\n      // If the cost is less than the current target distance, set the target distance to the cost and return true\n      current_cell->setTargetDistance(cost);\n      return true;\n    }\n    // Return false\n    return false;\n  }", "CodeBleu_score": 41.7477661175173}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\tif (footprint_spec_.empty()) {\n    ROS_ERROR(\"No footprint specified\");\n    return -9.0;\n  }\n\n  double cost = 0.0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n\n  for (unsigned int i = 0; i < traj.x_.size(); ++i) {\n    double x_cost = footprintCost(traj.x_[i], traj.y_[i], traj.th_[i], scale, footprint_spec_, costmap_, world_model_);\n    if (x_cost < 0) {\n      return x_cost;\n    }\n    cost += x_cost;\n  }\n\n  if (sum_scores_) {\n    cost /= traj.x_.size();\n  }\n\n  return cost;\n}", "CodeBleu_score": 52.72142432833489}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (!footprint_spec_.empty()) {\n    scaling_factor = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n    cost = footprintCost(traj.x_, traj.y_, traj.th_, scaling_factor, footprint_spec_, costmap_, world_model_);\n    if (cost < 0) {\n      return cost;\n    }\n  } else {\n    ROS_ERROR(\"Obstacle cost function: No footprint specification.\");\n    return -9.0;\n  }\n\n  //for each point in the trajectory, calculate the footprint cost\n  for (unsigned int i = 0; i < traj.traj_points_.size(); ++i) {\n    cost += footprintCost(traj.traj_points_[i].x, traj.traj_points_[i].y, traj.traj_points_[i].th, scaling_factor, footprint_spec_, costmap_, world_model_);\n    if (cost < 0) {\n      return cost;\n    }\n  }\n\n  //either sum the scores or take the maximum score based on the sum_scores_ flag\n  if (sum_scores_) {\n    return cost;\n  } else {\n    return std::max(cost, 0.0);\n  }\n}", "CodeBleu_score": 55.74080878967571}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj){\n\t//initialize the cost and scaling factor based on the trajectory and speed parameters\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (!footprint_spec_.empty()) {\n    scaling_factor = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  }\n  else {\n    ROS_ERROR(\"ObstacleCostFunction: No footprint specification given!\");\n    return -9.0;\n  }\n\n  //calculate the footprint cost\n  for (unsigned int i = 0; i < traj.x_.size(); ++i) {\n    double footprint_cost = footprintCost(traj.x_[i], traj.y_[i], traj.th_[i], scaling_factor, footprint_spec_, costmap_, world_model_);\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    }\n    else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  return cost;\n}", "CodeBleu_score": 57.443090516422444}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\tdouble footprint_cost = 0.0;\n    double cell_cost = 0.0;\n    double max_cost = 0.0;\n\n    if (world_model == NULL) {\n        ROS_WARN(\"ObstacleCostFunction::footprintCost: world_model is NULL\");\n        return -7.0;\n    }\n\n    if (costmap == NULL) {\n        ROS_WARN(\"ObstacleCostFunction::footprintCost: costmap is NULL\");\n        return -7.0;\n    }\n\n    // Check if the position is off the map\n    if (!costmap->worldToMap(x, y, i, j)) {\n        ROS_WARN(\"ObstacleCostFunction::footprintCost: position is off the map\");\n        return -7.0;\n    }\n\n    // Scale the footprint points\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        footprint_spec[i].x *= scale;\n        footprint_spec[i].y *= scale;\n    }\n\n    // Compute the footprint cost\n    for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n        footprint_cost += world_model->footprintCost(x + footprint_spec[i].x, y + footprint_spec[i].y, th);\n    }\n\n    // Compute the cell cost\n    cell_cost = costmap->getCost(this->i, this->j);\n\n    // Return the maximum cost between the footprint cost and the cell cost\n    if (footprint_cost > cell_cost) {\n        max_cost = footprint_cost;\n    } else {\n        max_cost = cell_cost;\n    }\n\n    if (max_cost < 0.0) {\n        return -6.0;\n    } else {\n        return max_cost;\n    }\n}", "CodeBleu_score": 55.28696580311745}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// If the position is off the map, return -7.0\n    if (!world_model->isWithinMapBounds(x, y)) {\n        return -7.0;\n    }\n\n    // If the costmap is empty, return -7.0\n    if (costmap->getSizeInCellsX() == 0 || costmap->getSizeInCellsY() == 0) {\n        return -7.0;\n    }\n\n    // Scale the footprint\n    std::vector<geometry_msgs::Point> scaled_footprint_spec = scaleFootprint(footprint_spec, scale);\n\n    // Get the footprint cost\n    double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint_spec, costmap);\n\n    // Get the cell cost\n    double cell_cost = costmap->getCost(costmap->worldToMap(x, y));\n\n    // Return the maximum cost\n    if (footprint_cost < 0) {\n        return -6.0;\n    }\n    if (cell_cost < 0) {\n        return -6.0;\n    }\n    return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 50.000986368500065}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model){\n\t// TODO: Implement this function\n  double footprint_cost = 0.0;\n  double cell_cost = 0.0;\n  double max_cost = 0.0;\n  double x_temp = 0.0;\n  double y_temp = 0.0;\n\n  for (int i = 0; i < footprint_spec.size(); i++) {\n    x_temp = x + scale * footprint_spec[i].x * cos(th) - scale * footprint_spec[i].y * sin(th);\n    y_temp = y + scale * footprint_spec[i].x * sin(th) + scale * footprint_spec[i].y * cos(th);\n\n    cell_cost = world_model->footprintCost(x_temp, y_temp, costmap);\n\n    if (cell_cost < 0) {\n      return -7.0;\n    }\n\n    if (cell_cost > footprint_cost) {\n      footprint_cost = cell_cost;\n    }\n  }\n\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  return footprint_cost;\n}", "CodeBleu_score": 60.09555356920775}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic.compare(odom_topic_) != 0) {\n    ROS_INFO_NAMED(\"dwa_local_planner\", \"Changing odometry topic from %s to %s\", odom_topic_.c_str(), odom_topic.c_str());\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      if (odom_subscriber_ != NULL) {\n        ROS_WARN_NAMED(\"dwa_local_planner\", \"OdometryHelperRos::setOdomTopic: Unsubscribing from old topic %s\", odom_topic_.c_str());\n        odom_subscriber_.shutdown();\n      }\n      odom_subscriber_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      ROS_WARN_NAMED(\"dwa_local_planner\", \"OdometryHelperRos::setOdomTopic: Unsubscribing from topic %s\", odom_topic_.c_str());\n      odom_subscriber_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 37.7023607444105}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tboost::mutex::scoped_lock lock(odom_mutex_);\n  if (odom_topic != odom_topic_) {\n    ROS_INFO_NAMED(\"dwa_local_planner\", \"OdometryHelperRos::setOdomTopic: changing odometry topic from %s to %s\",\n        odom_topic_.c_str(), odom_topic.c_str());\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}", "CodeBleu_score": 46.726128779686405}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic){\n\tif (odom_topic != odom_topic_) {\n    if (odom_topic_ != \"\") {\n      odom_sub_.shutdown();\n    }\n    if (odom_topic != \"\") {\n      odom_sub_ = nh_.subscribe<nav_msgs::Odometry>(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    odom_topic_ = odom_topic;\n  }\n}", "CodeBleu_score": 46.93422682287348}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist_sq = (pos - prev).squaredNorm();\n  float ang_diff = (pos - prev).norm();\n\n  if (dist_sq > 0.001f) {\n    if (dist_sq > 0.005f) {\n      resetOscillationFlags();\n    }\n  }\n\n  if (ang_diff > 0.001f) {\n    if (ang_diff > 0.005f) {\n      resetOscillationFlags();\n    }\n  }\n}", "CodeBleu_score": 37.91558094448192}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist = (pos - prev).squaredNorm();\n  float angle = getAngleBetweenVectors(pos, prev);\n\n  if (dist > 0.0001f) {\n    if (dist > 0.00001f) {\n      if (dist > 0.000001f) {\n        if (dist > 0.0000001f) {\n          if (dist > 0.00000001f) {\n            if (dist > 0.000000001f) {\n              if (dist > 0.0000000001f) {\n                if (dist > 0.00000000001f) {\n                  if (dist > 0.000000000001f) {\n                    if (dist > 0.0000000000001f) {\n                      if (dist > 0.00000000000001f) {\n                        if (dist > 0.000000000000001f) {\n                          if (dist > 0.0000000000000001f) {\n                            if (dist > 0.00000000000000001f) {\n                              if (dist > 0.000000000000000001f) {\n                                if (dist > 0.0000000000000000001f) {\n                                  if (dist > 0.00000000000000000001f) {\n                                    if (dist > 0.000000000000000000001f) {\n                                      if (dist > 0.0000000000000000", "CodeBleu_score": 20.687196778589655}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev){\n\tfloat dist_sq = (pos - prev).squaredNorm();\n  float ang_diff = std::abs(std::acos(pos.dot(prev) / (pos.norm() * prev.norm())));\n\n  if (dist_sq > dist_thresh_sq_) {\n    resetOscillationFlags();\n  }\n\n  if (ang_diff > ang_thresh_) {\n    resetOscillationFlags();\n  }\n}", "CodeBleu_score": 38.168328649669}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\tunsigned int gx, gy;\n    gridCoords(pt, gx, gy);\n\n    //check that the point is within the grid\n    if(gx >= width_ || gy >= height_ || gx < 0 || gy < 0)\n      return;\n\n    //check that the point is not too close to its nearest neighbor\n    double sq_dist = nearestNeighborDistance(pt);\n    if(sq_dist < sq_min_separation_)\n      return;\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //insert the point into the grid\n    unsigned int cell_index = cellIndex(gx, gy);\n    PointGridCell& cell = cells_[cell_index];\n    cell.points.push_back(pt);\n\n    //update the min and max values for the cell\n    cell.min_x = min(cell.min_x, pt.x);\n    cell.min_y = min(cell.min_y, pt.y);\n    cell.max_x = max(cell.max_x, pt.x);\n    cell.max_y = max(cell.max_y, pt.y);\n\n    //update the min and max values for the grid\n    min_x_ = min(min_x_, pt.x);\n    min_y_ = min(min_y_, pt.y);\n    max_x_ = max(max_x_, pt.x);\n    max_y_ = max(max_y_, pt.y);\n}", "CodeBleu_score": 55.13346802800972}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //check that the point is within the grid bounds\n    if(gx >= width_ || gx < 0 || gy >= height_ || gy < 0)\n      return;\n\n    //check that the point is not too close to its nearest neighbor\n    if(nearestNeighborDistance(pt) < sq_min_separation_)\n      return;\n\n    //calculate the grid index\n    unsigned int index = gridIndex(gx, gy);\n\n    //insert the point into the corresponding cell\n    grid_[index].push_back(pt);\n\n    //update the number of points in the grid\n    num_points_++;\n\n    //update the grid bounds\n    if(pt.x < min_x_)\n      min_x_ = pt.x;\n    if(pt.x > max_x_)\n      max_x_ = pt.x;\n    if(pt.y < min_y_)\n      min_y_ = pt.y;\n    if(pt.y > max_y_)\n      max_y_ = pt.y;\n}", "CodeBleu_score": 69.69773215700786}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n\t//get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //check that the point is within the grid bounds\n    if(gx >= width_ || gy >= height_)\n      return;\n\n    //check that the point is not too close to its nearest neighbor\n    double sq_dist = nearestNeighborDistance(pt);\n    if(sq_dist < sq_min_separation_)\n      return;\n\n    //calculate the grid index\n    unsigned int index = gx + gy * width_;\n\n    //insert the point into the corresponding cell\n    if(cells_[index].size() >= max_cell_size_)\n      return;\n\n    cells_[index].push_back(pt);\n}", "CodeBleu_score": 64.10128967670836}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f newvel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      if (vel[i] + acclimits[i] * dt > sample_target_vel[i]) {\n        newvel[i] = vel[i] + acclimits[i] * dt;\n      } else {\n        newvel[i] = sample_target_vel[i];\n      }\n    } else if (sample_target_vel[i] < vel[i]) {\n      if (vel[i] - acclimits[i] * dt < sample_target_vel[i]) {\n        newvel[i] = vel[i] - acclimits[i] * dt;\n      } else {\n        newvel[i] = sample_target_vel[i];\n      }\n    } else {\n      newvel[i] = vel[i];\n    }\n  }\n  return newvel;\n}", "CodeBleu_score": 66.70564478245485}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel;\n    new_vel << 0.0, 0.0, 0.0;\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel[i] > vel[i]) {\n            if (vel[i] + acclimits[i] * dt <= sample_target_vel[i]) {\n                new_vel[i] = vel[i] + acclimits[i] * dt;\n            } else {\n                new_vel[i] = sample_target_vel[i];\n            }\n        } else if (sample_target_vel[i] < vel[i]) {\n            if (vel[i] - acclimits[i] * dt >= sample_target_vel[i]) {\n                new_vel[i] = vel[i] - acclimits[i] * dt;\n            } else {\n                new_vel[i] = sample_target_vel[i];\n            }\n        } else {\n            new_vel[i] = vel[i];\n        }\n    }\n    return new_vel;\n}", "CodeBleu_score": 64.45713499949565}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt){\n\tEigen::Vector3f new_vel;\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i] + acclimits[i] * dt) {\n      new_vel[i] = vel[i] + acclimits[i] * dt;\n    }\n    else if (sample_target_vel[i] < vel[i] - acclimits[i] * dt) {\n      new_vel[i] = vel[i] - acclimits[i] * dt;\n    }\n    else {\n      new_vel[i] = sample_target_vel[i];\n    }\n  }\n  return new_vel;\n}", "CodeBleu_score": 70.88681038389943}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\t//Convert the goal point to cell coordinates\n  double goal_x = x;\n  double goal_y = y;\n\n  //Convert the goal point to world coordinates\n  double goal_cell_x = goal_x / cell_size;\n  double goal_cell_y = goal_y / cell_size;\n\n  //Convert the robot's current position to cell coordinates\n  double current_cell_x = cell_x;\n  double current_cell_y = cell_y;\n\n  //Iterate through the global plan in reverse\n  for (int i = global_plan.size() - 1; i >= 0; i--) {\n    //If the current cell is valid and the goal point is not within the cell\n    if (isCellValid(current_cell_x, current_cell_y) &&\n        !isPointInCell(goal_x, goal_y, current_cell_x, current_cell_y)) {\n      //Calculate the line cost from the robot's current position to the goal point\n      double line_cost = lineCost(current_cell_x, goal_cell_x, current_cell_y, goal_cell_y);\n\n      //If the line cost is less than zero, return DBL_MAX\n      if (line_cost < 0) {\n        return DBL_MAX;\n      }\n\n      //Calculate the direction to the goal point\n      double dir_x = goal_x - current_cell_x;\n      double dir_y = goal_y - current_cell_y;\n\n      //Calculate the angle between the direction to the goal point and the direction to the current cell\n      double angle = atan2(dir_y, dir_x) - atan2(current_cell_y, current_cell_x);\n\n      //If the angle is greater than pi, convert it to a negative value\n      if (angle > M_PI) {\n        angle -= 2 * M_PI;\n      } else if (angle < -M_PI) {\n        angle += 2 * M_PI;\n      }\n\n      //Return the absolute value of the angle\n      return fabs(angle);\n    }\n\n    //Move the current cell", "CodeBleu_score": 42.59328778743705}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble heading_diff = DBL_MAX;\n  double goal_x, goal_y;\n\n  //Convert the goal cell coordinates to world coordinates\n  goal_x = x + cell_x * resolution;\n  goal_y = y + cell_y * resolution;\n\n  //Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = global_plan.size() - 1; i >= 0; i--) {\n    if (lineCost(cell_x, global_plan[i].cell_x, cell_y, global_plan[i].cell_y) >= 0) {\n      double dx = goal_x - global_plan[i].x;\n      double dy = goal_y - global_plan[i].y;\n      double angle = atan2(dy, dx);\n      double diff = fabs(angle - heading);\n      if (diff < heading_diff) {\n        heading_diff = diff;\n      }\n    }\n  }\n\n  return heading_diff;\n}", "CodeBleu_score": 52.66636927337155}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n\tdouble heading_diff = DBL_MAX;\n  double goal_x, goal_y;\n  double dist;\n\n  //Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n  for (int i = global_plan.size() - 1; i >= 0; i--) {\n    goal_x = global_plan[i].x;\n    goal_y = global_plan[i].y;\n    dist = sqrt(pow(goal_x - x, 2) + pow(goal_y - y, 2));\n\n    //Check if the point is within the robot's FOV\n    if (dist < ROBOT_RADIUS + FOV_RADIUS) {\n      //Convert the goal cell coordinates to world coordinates\n      goal_x = goal_x * CELL_WIDTH + (CELL_WIDTH / 2);\n      goal_y = goal_y * CELL_HEIGHT + (CELL_HEIGHT / 2);\n\n      //Calculate the shortest angular distance between the current heading and the direction to the goal point\n      heading_diff = fabs(angleWrap(heading - atan2(goal_y - y, goal_x - x)));\n\n      //Check if the heading difference is less than the previous heading difference\n      if (heading_diff < DBL_MAX) {\n        break;\n      }\n    }\n  }\n\n  return heading_diff;\n}", "CodeBleu_score": 50.28726263433878}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t// Compute the cost of the trajectory.\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    // If the cost is non-negative, the trajectory is considered valid.\n    if ( cost >= 0.0 ) {\n      return true;\n    }\n\n    // Otherwise, log a warning with the sample velocities and cost.\n    ROS_WARN_STREAM(\"Invalid trajectory: cost = \" << cost << \" with vx = \" << vx_samp << \", vy = \" << vy_samp << \", vtheta = \" << vtheta_samp );\n    return false;\n}", "CodeBleu_score": 72.11685733176098}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\t// generate a trajectory\n    Trajectory t;\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost_, t);\n\n    // check the trajectory\n    if (t.cost_ < 0) {\n      // log the velocity and cost\n      ROS_WARN_STREAM(\"Trajectory invalid: \" << vx_samp << \" \" << vy_samp << \" \" << vtheta_samp << \" \" << t.cost_);\n      return false;\n    }\n    return true;\n  }", "CodeBleu_score": 56.42920807887704}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n\tTrajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    if (t.cost_ >= 0) {\n      return true;\n    } else {\n      std::cout << \"Trajectory invalid: vx: \" << vx_samp << \" vy: \" << vy_samp << \" vtheta: \" << vtheta_samp << \" cost: \" << t.cost_ << std::endl;\n      return false;\n    }\n  }", "CodeBleu_score": 58.57918932452662}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior(){\n\tif (!initialized_) {\n    ROS_ERROR(\"ClearCostmapRecovery has not been initialized, please call initialize() before using this plugin.\");\n    return;\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"Global costmap is NULL, please set the global_costmap_ parameter in the ClearCostmapRecovery plugin\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"Local costmap is NULL, please set the local_costmap_ parameter in the ClearCostmapRecovery plugin\");\n    return;\n  }\n\n  if (clear_global_costmap_) {\n    clear(global_costmap_);\n  }\n\n  if (clear_local_costmap_) {\n    clear(local_costmap_);\n  }\n\n  ros::WallTime end = ros::WallTime::now();\n  ROS_INFO_STREAM(\"ClearCostmapRecovery took \" << (end - start).toSec() << \" seconds to clear the costmaps.\");\n}", "CodeBleu_score": 34.384531976622355}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tROS_INFO(\"Clearing costmaps\");\n\n  if(!initialized_){\n    ROS_ERROR(\"ClearCostmapRecovery is not initialized\");\n    return;\n  }\n\n  if(!costmap_ros_){\n    ROS_ERROR(\"ClearCostmapRecovery does not have a costmap_ros\");\n    return;\n  }\n\n  if(!costmap_ros_->getGlobalCostmap()){\n    ROS_ERROR(\"ClearCostmapRecovery does not have a global costmap\");\n    return;\n  }\n\n  if(!costmap_ros_->getLocalCostmap()){\n    ROS_ERROR(\"ClearCostmapRecovery does not have a local costmap\");\n    return;\n  }\n\n  if(clear_global_){\n    ROS_INFO(\"Clearing global costmap\");\n    clear(costmap_ros_->getGlobalCostmap());\n  }\n\n  if(clear_local_){\n    ROS_INFO(\"Clearing local costmap\");\n    clear(costmap_ros_->getLocalCostmap());\n  }\n\n  ROS_INFO(\"Costmaps cleared\");\n}", "CodeBleu_score": 25.955951389153697}, {"code": "void ClearCostmapRecovery::runBehavior(){\n\tif(!initialized_){\n    ROS_ERROR(\"ClearCostmapRecovery: not initialized\");\n    return;\n  }\n\n  if(costmap_ros_ == NULL || costmap_ros_local_ == NULL){\n    ROS_ERROR(\"ClearCostmapRecovery: costmap_ros or costmap_ros_local is NULL\");\n    return;\n  }\n\n  if(clearable_layers_.empty()){\n    ROS_ERROR(\"ClearCostmapRecovery: no clearable layers specified\");\n    return;\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n\n  // clear the global costmap\n  if(affected_maps_ & GLOBAL){\n    ROS_DEBUG(\"Clearing global costmap\");\n    clear(costmap_ros_.get());\n  }\n\n  // clear the local costmap\n  if(affected_maps_ & LOCAL){\n    ROS_DEBUG(\"Clearing local costmap\");\n    clear(costmap_ros_local_.get());\n  }\n\n  ros::WallTime end = ros::WallTime::now();\n  ros::WallDuration elapsed = end - start;\n\n  if(affected_maps_ & GLOBAL){\n    ROS_DEBUG_STREAM(\"Cleared global costmap in \" << elapsed.toSec() << \" seconds\");\n  }\n\n  if(affected_maps_ & LOCAL){\n    ROS_DEBUG_STREAM(\"Cleared local costmap in \" << elapsed.toSec() << \" seconds\");\n  }\n}", "CodeBleu_score": 42.68889144494966}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tif (polygon.empty())\n\t\treturn;\n\tPolygonOutlineCells polygon_outline_cells;\n\tfor (unsigned int i = 0; i < polygon.size(); ++i) {\n\t\tif (i == polygon.size() - 1)\n\t\t\tpolygon_outline_cells.raytraceLine(polygon[i], polygon[0]);\n\t\telse\n\t\t\tpolygon_outline_cells.raytraceLine(polygon[i], polygon[i + 1]);\n\t}\n\tpolygon_outline_cells.closePolygon();\n\tpolygon_cells = polygon_outline_cells.getPolygon();\n}", "CodeBleu_score": 52.12151061934181}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\t// Initialize the PolygonOutlineCells object\n  PolygonOutlineCells polygon_cells_object;\n\n  // If the polygon is not empty, connect the last point to the first\n  if (!polygon.empty()) {\n    polygon_cells_object.addVertex(polygon.back());\n  }\n\n  // Iterate through the polygon vertices\n  for (unsigned int i = 0; i < polygon.size(); i++) {\n    // Get the current vertex\n    MapLocation vertex = polygon[i];\n\n    // Get the next vertex\n    MapLocation next_vertex;\n    if (i < polygon.size() - 1) {\n      next_vertex = polygon[i + 1];\n    } else {\n      next_vertex = polygon[0];\n    }\n\n    // Use raytraceLine to gather cells between the current vertex and the next vertex\n    raytraceLine(vertex, next_vertex, polygon_cells_object);\n  }\n\n  // Get the cells from the PolygonOutlineCells object\n  polygon_cells = polygon_cells_object.getCells();\n}", "CodeBleu_score": 56.98898561272595}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells){\n\tif (polygon.empty()) {\n    return;\n  }\n  PolygonOutlineCells polygon_outline_cells(polygon, this);\n  polygon_outline_cells.gatherCells();\n  polygon_outline_cells.closePolygon();\n  polygon_cells = polygon_outline_cells.getCells();\n}", "CodeBleu_score": 20.780759698501505}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  pub.publish(grid_);\n}", "CodeBleu_score": 96.07644084284831}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub){\n\tprepareGrid();\n  grid_pub_.publish(grid_);\n}", "CodeBleu_score": 48.1326047314528}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the mutex\n  costmap_->lockCostmap();\n  // Get the resolution\n  double resolution = costmap_->getResolution();\n  // Set the header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  // Set the resolution\n  grid_.info.resolution = resolution;\n  // Set the width and height\n  grid_.info.width = (int) (costmap_->getSizeInMetersX() / resolution);\n  grid_.info.height = (int) (costmap_->getSizeInMetersY() / resolution);\n  // Convert the map coordinates to world coordinates for the origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  // Set the origin's position and orientation\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  // Save the origin coordinates\n  origin_x_ = grid_.info.origin.position.x;\n  origin_y_ = grid_.info.origin.position.y;\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // Populate the grid data from the costmap's character map\n  for (int i = 0; i < grid_.info.width; i++) {\n    for (int j = 0; j < grid_.info.height; j++) {\n      // Get the index of the current cell\n      int index = i + j * grid_.info.width;\n      // Get the current cell\n      char c = costmap_->getCharMap()[index];\n      // Set the current cell\n      grid_.data[index] = translation_table_[c];\n    }\n  }\n  // Unlock the mutex\n  costmap_->unlockCostmap();\n}", "CodeBleu_score": 64.30994142272614}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\tstd::lock_guard<std::mutex> lock(*costmap_mutex_);\n  // Set the header\n  grid_.header.frame_id = map_frame_;\n  grid_.header.stamp = ros::Time::now();\n  // Set the resolution\n  grid_.info.resolution = costmap_->getResolution();\n  // Set the width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  // Set the origin\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  // Save the origin coordinates\n  origin_x_ = costmap_->getOriginX();\n  origin_y_ = costmap_->getOriginY();\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // Populate the grid data from the costmap's character map\n  for (int x = 0; x < grid_.info.width; x++) {\n    for (int y = 0; y < grid_.info.height; y++) {\n      grid_.data[x + y * grid_.info.width] =\n          costmap_->getCost(x, y) * 100;\n    }\n  }\n}", "CodeBleu_score": 54.01058216714061}, {"code": "void Costmap2DPublisher::prepareGrid(){\n\t// Lock the mutex\n  boost::mutex::scoped_lock lock(costmap_mutex_);\n  // Get the resolution\n  double resolution = costmap_->getResolution();\n  // Set the grid's header\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.header.stamp = ros::Time::now();\n  // Set the resolution, width, and height\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInMetersX() / resolution;\n  grid_.info.height = costmap_->getSizeInMetersY() / resolution;\n  // Set the origin position and orientation\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  // Save the origin coordinates\n  origin_x_ = costmap_->getOriginX();\n  origin_y_ = costmap_->getOriginY();\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // Populate the grid data from the costmap's character map using a translation table\n  unsigned int index = 0;\n  for (int y = 0; y < costmap_->getSizeInCellsY(); ++y) {\n    for (int x = 0; x < costmap_->getSizeInCellsX(); ++x) {\n      grid_.data[index] = translation_table_[costmap_->getCharMap()[index]];\n      ++index;\n    }\n  }\n}", "CodeBleu_score": 63.39834040910976}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// If the footprint is the same, don't bother.\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the footprint is valid, set it.\n  if (new_config.footprint.size() > 0) {\n    std::vector<geometry_msgs::Point> points;\n    for (const auto& point_string : new_config.footprint) {\n      geometry_msgs::Point point;\n      if (tf::pointMsgFromYAML(point_string, point)) {\n        points.push_back(point);\n      } else {\n        ROS_ERROR_NAMED(\"costmap_2d\", \"Invalid footprint string '%s'\", point_string.c_str());\n      }\n    }\n    if (points.size() > 0) {\n      setUnpaddedRobotFootprint(points);\n      return;\n    }\n  }\n\n  // If no valid footprint string is provided, use the robot radius.\n  if (new_config.robot_radius > 0) {\n    double radius = new_config.robot_radius;\n    double length = 2 * radius;\n    double width = 2 * radius;\n    double x = radius;\n    double y = radius;\n    double theta = 0;\n    double delta_x = length / 2.0;\n    double delta_y = width / 2.0;\n    geometry_msgs::Point point;\n    point.x = x;\n    point.y = y;\n    points.push_back(point);\n    for (int i = 0; i < 3; ++i) {\n      point.x = x + delta_x * cos(theta);\n      point.y = y + delta_y * sin(theta);\n      points.push_back(point);\n      theta += M_PI / 2.0;\n    }\n    setUnpaddedRobotFootprint(points);\n    return;\n  }\n\n  // If no footprint is provided, log", "CodeBleu_score": 57.97135880096814}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// Check if the footprint is the same\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // Check if the footprint string is valid\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    if (tf::shapeMsgToVector(new_config.footprint, points)) {\n      setUnpaddedRobotFootprint(points);\n      return;\n    }\n  }\n\n  // If the footprint string is invalid, log an error\n  ROS_ERROR(\"Invalid footprint string provided. Using default footprint.\");\n\n  // If no valid footprint string is provided, set the footprint based on the robot radius\n  double radius = new_config.robot_radius;\n  std::vector<geometry_msgs::Point> points;\n  points.push_back(geometry_msgs::Point(radius, radius, 0));\n  points.push_back(geometry_msgs::Point(radius, -radius, 0));\n  points.push_back(geometry_msgs::Point(-radius, -radius, 0));\n  points.push_back(geometry_msgs::Point(-radius, radius, 0));\n  setUnpaddedRobotFootprint(points);\n}", "CodeBleu_score": 61.32505116896638}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config){\n\t// If the footprint and robot radius in the new and old configurations are the same, we don't need to do anything.\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // If the new configuration contains a valid footprint string, we convert the string to a footprint and set it.\n  if (new_config.footprint.size() > 0) {\n    std::vector<geometry_msgs::Point> points;\n    if (parseFootprintFromString(new_config.footprint, points)) {\n      setUnpaddedRobotFootprint(points);\n      return;\n    }\n  }\n\n  // If the footprint string is invalid, we log an error.\n  ROS_ERROR(\"The footprint string '%s' is invalid. Using default footprint.\", new_config.footprint.c_str());\n\n  // If no valid footprint string is provided, we set the footprint based on the robot radius.\n  setUnpaddedRobotFootprint(createDefaultFootprint(new_config.robot_radius));\n}", "CodeBleu_score": 69.27442972406274}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// Get the robot's pose\n  geometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose))\n  {\n    ROS_WARN(\"Could not retrieve robot pose.\");\n    return;\n  }\n\n  // Get the robot's current pose\n  geometry_msgs::PoseStamped current_pose;\n  if (!getRobotPose(current_pose))\n  {\n    ROS_WARN(\"Could not retrieve robot pose.\");\n    return;\n  }\n\n  // Check if the robot moved\n  if (global_pose.pose.position.x != current_pose.pose.position.x ||\n      global_pose.pose.position.y != current_pose.pose.position.y)\n  {\n    ROS_INFO(\"The robot moved, reconfiguring.\");\n    reconfigure();\n  }\n}", "CodeBleu_score": 48.39295739727436}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\t// Get the robot's current pose\n  geometry_msgs::PoseStamped global_pose;\n  if (!getRobotPose(global_pose))\n  {\n    ROS_WARN(\"Costmap2DROS: Could not get robot pose.\");\n    return;\n  }\n  // Store the pose\n  new_pose = global_pose;\n}", "CodeBleu_score": 59.765912302102066}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event){\n\tgeometry_msgs::PoseStamped global_pose;\n  if (getRobotPose(global_pose))\n  {\n    new_pose = global_pose.pose;\n  }\n  else\n  {\n    ROS_WARN(\"Costmap2DROS: Failed to get robot pose. Cancelling reconfiguration.\");\n    reconfigure_timer_.stop();\n  }\n}", "CodeBleu_score": 52.87667709719061}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start(){\n\t// get the list of plugins\n  std::vector<costmap_2d::Layer*> layers = costmap_->getLayers();\n\n  // check if the costmap was stopped\n  if (stopped_) {\n    // reactivate each plugin\n    for (unsigned int i = 0; i < layers.size(); ++i) {\n      layers[i]->activate();\n    }\n\n    // set the stopped flag to false\n    stopped_ = false;\n  }\n\n  // set the stop_updates_ flag to false\n  stop_updates_ = false;\n\n  // wait until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !costmap_->isInitialized() || !costmap_->isActive()) {\n    ros::spinOnce();\n    ros::Duration(0.01).sleep();\n  }\n}", "CodeBleu_score": 51.196365508888}, {"code": "void Costmap2DROS::start(){\n\tROS_INFO(\"Starting costmap2d\");\n\n  // Retrieve the list of plugins\n  std::vector<Costmap2DPlugin*> plugins = getPlugins();\n\n  // Check if the costmap is stopped\n  if (stopped_) {\n    // If stopped, reactivate the plugins and set the stopped flag to false\n    for (std::vector<Costmap2DPlugin*>::iterator it = plugins.begin(); it != plugins.end(); ++it) {\n      (*it)->activate();\n    }\n    stopped_ = false;\n  }\n\n  // Set the stop_updates_ flag to false\n  stop_updates_ = false;\n\n  // Wait until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!isInitialized() || !isActive()) {\n    ros::Duration(0.1).sleep();\n  }\n}", "CodeBleu_score": 54.07777123267292}, {"code": "void Costmap2DROS::start(){\n\t// Get the list of plugins\n  std::vector<std::string> plugin_names = getPlugins();\n\n  // Check if the costmap is stopped\n  if (stopped_) {\n    // Resubscribe to topics\n    for (unsigned int i = 0; i < plugin_names.size(); i++) {\n      if (plugin_names[i] == \"costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"layered_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"obstacle_layer\") {\n        continue;\n      }\n      if (plugin_names[i] == \"static_layer\") {\n        continue;\n      }\n      if (plugin_names[i] == \"inflation_layer\") {\n        continue;\n      }\n      if (plugin_names[i] == \"unknown_space_layer\") {\n        continue;\n      }\n      if (plugin_names[i] == \"dynamic_layer\") {\n        continue;\n      }\n      if (plugin_names[i] == \"static_layer\") {\n        continue;\n      }\n      if (plugin_names[i] == \"traversability_layer\") {\n        continue;\n      }\n      if (plugin_names[i] == \"footprint_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"global_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"layered_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"global_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"footprint_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"footprint_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names[i] == \"footprint_costmap_2d\") {\n        continue;\n      }\n      if (plugin_names", "CodeBleu_score": 24.963738476175035}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observations_.empty()) {\n\t\treturn;\n\t}\n\n\tif (observation_keep_time_ == 0) {\n\t\tobservations_.clear();\n\t\treturn;\n\t}\n\n\t// remove observations that are older than the specified keep time\n\tauto it = observations_.begin();\n\twhile (it != observations_.end()) {\n\t\tif (it->second.observation_time + observation_keep_time_ < ros::Time::now()) {\n\t\t\tit = observations_.erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}", "CodeBleu_score": 31.69909300040593}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0) {\n        observations_.clear();\n    } else {\n        while (!observations_.empty()) {\n            if (observations_.front().time_stamp_ + observation_keep_time_ > ros::Time::now()) {\n                break;\n            }\n            observations_.pop_front();\n        }\n    }\n}", "CodeBleu_score": 26.63892875999214}, {"code": "void ObservationBuffer::purgeStaleObservations(){\n\tif (observation_keep_time_ == 0) {\n    // No need to purge observations if we're not keeping any\n    return;\n  }\n\n  // Iterate through the list and remove observations that are older than the specified keep time\n  for (ObservationList::iterator it = observations_.begin(); it != observations_.end();) {\n    if (it->second.getTime() + observation_keep_time_ < ros::Time::now()) {\n      it = observations_.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}", "CodeBleu_score": 33.602829826406285}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\tif (start_index < 0 || end_index >= path.size()) {\n    ROS_ERROR(\"Invalid indices for orientation interpolation!\");\n    return;\n  }\n\n  if (start_index == end_index) {\n    ROS_WARN(\"Start and end indices are the same. No interpolation necessary.\");\n    return;\n  }\n\n  // Get yaw angles at start and end indices\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine shortest angular distance between yaw angles\n  double diff_angle = start_angle - end_angle;\n  if (std::abs(diff_angle) > M_PI) {\n    diff_angle = diff_angle - std::copysign(2*M_PI, diff_angle);\n  }\n\n  // Calculate change in angle for each pose in range\n  double angle_increment = diff_angle / (end_index - start_index);\n\n  // Update orientation of each pose in range\n  for (int i = start_index; i < end_index; i++) {\n    set_angle(&path[i], path[i].pose.orientation.z + angle_increment);\n  }\n}", "CodeBleu_score": 50.945076756824335}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// Check if start and end indices are within bounds of the path\n  if (start_index < 0 || start_index >= path.size()) {\n    ROS_WARN_STREAM(\"Start index is out of bounds of path.\");\n    return;\n  }\n  if (end_index < 0 || end_index >= path.size()) {\n    ROS_WARN_STREAM(\"End index is out of bounds of path.\");\n    return;\n  }\n\n  // Get the start and end yaw angles\n  double start_yaw = tf2::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Calculate the shortest angular distance between the yaw angles\n  double shortest_angular_distance = atan2(sin(end_yaw - start_yaw),\n                                           cos(end_yaw - start_yaw));\n\n  // Calculate the incremental change in angle for each pose\n  double incremental_angle = shortest_angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    double yaw = tf2::getYaw(path[i].pose.orientation);\n    set_angle(&path[i], yaw + incremental_angle);\n  }\n}", "CodeBleu_score": 52.720881361039964}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index){\n\t// Calculate the yaw angle at the start and end indices.\n  double start_angle = tf2::getYaw(path[start_index].pose.orientation);\n  double end_angle = tf2::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the two angles.\n  double delta_angle = end_angle - start_angle;\n  if (delta_angle > M_PI) {\n    delta_angle -= 2 * M_PI;\n  } else if (delta_angle < -M_PI) {\n    delta_angle += 2 * M_PI;\n  }\n\n  // Calculate the incremental change in angle for each pose.\n  double incremental_angle = delta_angle / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range.\n  for (int i = start_index; i < end_index; i++) {\n    set_angle(&path[i], start_angle + (i - start_index) * incremental_angle);\n  }\n}", "CodeBleu_score": 55.77169715906746}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // call makePlan to generate a path\n  nav_msgs::Path path;\n  bool success = makePlan(req.start, req.goal, path);\n\n  // update the response with the success status and the generated path\n  resp.plan_found = success;\n  resp.plan.poses = path.poses;\n\n  // return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 72.35824577242813}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\tROS_INFO(\"Received makePlan request\");\n  // Set the frame id to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n  // Call makePlan to generate a path\n  nav_msgs::Path path = makePlan(req.start, req.goal);\n  // Update the response with the success status and the generated path\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.poses = path.poses;\n  resp.plan.header.stamp = ros::Time::now();\n  resp.plan_found = true;\n  ROS_INFO(\"Sending makePlan response\");\n  return true;\n}", "CodeBleu_score": 53.865603286623006}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp){\n\t// Set the start and goal frame_ids to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  nav_msgs::Path path = makePlan(req.start, req.goal);\n\n  // Update the response with the success status and the generated path\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.poses = path.poses;\n  resp.plan.header.stamp = ros::Time::now();\n\n  // Return true to indicate that the service was processed\n  return true;\n}", "CodeBleu_score": 53.78470073777646}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~\" + name);\n    private_nh.param(\"global_frame\", global_frame, std::string(\"map\"));\n    private_nh.param(\"global_planner_frequency\", global_planner_frequency, 1.0);\n    private_nh.param(\"global_planner_lookahead_distance\", global_planner_lookahead_distance, 10.0);\n    private_nh.param(\"global_planner_lookahead_k\", global_planner_lookahead_k, 1.0);\n    private_nh.param(\"global_planner_lookahead_threshold\", global_planner_lookahead_threshold, 0.0);\n    private_nh.param(\"global_planner_lookahead_step\", global_planner_lookahead_step, 0.5);\n    private_nh.param(\"global_planner_lookahead_step_k\", global_planner_lookahead_step_k, 1.0);\n    private_nh.param(\"global_planner_lookahead_step_threshold\", global_planner_lookahead_step_threshold, 0.0);\n    private_nh.param(\"global_planner_lookahead_step_step\", global_planner_lookahead_step_step, 0.5);\n    private_nh.param(\"global_planner_lookahead_step_step_k\", global_planner_lookahead_step_step_k, 1.0);\n    private_nh.param(\"global_planner_lookahead_step_step_threshold\", global_planner_lookahead_step_step_threshold, 0.0);\n    private_nh.param(\"global_planner_lookahead_step_step_step\", global_planner_lookahead_step_step_step, 0.5);\n    private_nh.param(\"global_planner_lookahead_step_step_step_k\", global_planner_lookahead_step_step_step_", "CodeBleu_score": 34.988924109433995}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tros::NodeHandle private_nh(\"~/\" + name);\n    private_nh.param(\"global_planner_frequency\", global_planner_frequency_, 1.0);\n    private_nh.param(\"global_planner_patience\", global_planner_patience_, 0.0);\n    private_nh.param(\"global_planner_range\", global_planner_range_, 10000.0);\n    private_nh.param(\"global_planner_goal_tolerance\", global_planner_goal_tolerance_, 0.1);\n    private_nh.param(\"global_planner_max_retries\", global_planner_max_retries_, 5);\n    private_nh.param(\"global_planner_min_delay\", global_planner_min_delay_, 0.0);\n    private_nh.param(\"global_planner_max_delay\", global_planner_max_delay_, 0.0);\n    private_nh.param(\"global_planner_delay_growth\", global_planner_delay_growth_, 0.2);\n    private_nh.param(\"global_planner_delay_shrink\", global_planner_delay_shrink_, 0.9);\n    private_nh.param(\"global_planner_delay_min\", global_planner_delay_min_, 0.0);\n    private_nh.param(\"global_planner_delay_max\", global_planner_delay_max_, 0.0);\n    private_nh.param(\"global_planner_delay_threshold\", global_planner_delay_threshold_, 0.0);\n    private_nh.param(\"global_planner_delay_threshold_factor\", global_planner_delay_threshold_factor_, 0.0);\n    private_nh.param(\"global_planner_delay_threshold_min\", global_planner_delay_threshold_min_, 0.0);\n    private_nh.param(\"global_planner_delay_threshold_max\", global_planner_delay", "CodeBleu_score": 34.35621643072299}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()){\n\tROS_INFO(\"Initializing PlannerWithCostmap\");\n    ros::NodeHandle nh(\"~\");\n    // Read in parameters\n    double cost_scaling_factor;\n    nh.param(\"cost_scaling_factor\", cost_scaling_factor, 1.0);\n    nh.param(\"goal_pos_tolerance\", goal_pos_tolerance_, 0.1);\n    nh.param(\"goal_yaw_tolerance\", goal_yaw_tolerance_, 0.1);\n    nh.param(\"planning_window\", planning_window_, 200);\n    nh.param(\"planning_rate\", planning_rate_, 10.0);\n    nh.param(\"max_vel_x\", max_vel_x_, 0.5);\n    nh.param(\"max_vel_y\", max_vel_y_, 0.5);\n    nh.param(\"max_vel_theta\", max_vel_theta_, 0.5);\n    nh.param(\"min_vel_x\", min_vel_x_, -0.5);\n    nh.param(\"min_vel_y\", min_vel_y_, -0.5);\n    nh.param(\"min_vel_theta\", min_vel_theta_, -0.5);\n    nh.param(\"max_vel_x_backwards\", max_vel_x_backwards_, -0.5);\n    nh.param(\"max_vel_y_backwards\", max_vel_y_backwards_, -0.5);\n    nh.param(\"max_vel_theta_backwards\", max_vel_theta_backwards_, -0.5);\n    nh.param(\"min_vel_x_backwards\", min_vel_x_backwards_, -0.5);\n    nh.param(\"min_vel_y_backwards\", min_vel_y_backwards_, -0.5);\n    nh.param(\"min_vel_theta_backwards\", min_vel_theta_backwards_, -0.5);\n    nh.param(\"translation_scaling_factor\", translation_scaling_", "CodeBleu_score": 40.216253662167034}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (wx < min_x || wx > max_x || wy < min_y || wy > max_y) {\n\t\treturn false;\n\t}\n\tmx = (wx - origin_x) / resolution;\n\tmy = (wy - origin_y) / resolution;\n\treturn true;\n}", "CodeBleu_score": 29.91594328022293}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (wx < 0.0 || wx >= world_size_x_ || wy < 0.0 || wy >= world_size_y_) {\n\t\treturn false;\n\t}\n\tmx = wx / resolution_ + origin_x_;\n\tmy = wy / resolution_ + origin_y_;\n\treturn true;\n}", "CodeBleu_score": 22.645774423413055}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my){\n\tif (wx < 0 || wx > world_x_size_ || wy < 0 || wy > world_y_size_) {\n    return false;\n  }\n\n  mx = (wx - origin_x_) / resolution_;\n  my = (wy - origin_y_) / resolution_;\n\n  return true;\n}", "CodeBleu_score": 28.16027288003967}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n        ROS_ERROR(\"Planner not initialized\");\n        return;\n    }\n\n    nav_msgs::Path path_msg;\n    path_msg.header.stamp = ros::Time::now();\n    path_msg.header.frame_id = global_frame_;\n    path_msg.poses.resize(path.size());\n    for (unsigned int i = 0; i < path.size(); i++) {\n        path_msg.poses[i] = path[i];\n    }\n    plan_pub_.publish(path_msg);\n}", "CodeBleu_score": 73.92485014434244}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\tif (!initialized_) {\n    ROS_ERROR(\"Global planner not initialized, please call initialize() before using this function\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = global_frame_;\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses.resize(path.size());\n  std::copy(path.begin(), path.end(), gui_path.poses.begin());\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 56.67879830483089}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n\t//Check if the planner is initialized\n    if(!initialized_) {\n        ROS_ERROR(\"GlobalPlanner::publishPlan: Planner not initialized.\");\n        return;\n    }\n\n    //Create a Path message\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = global_frame_;\n    path_msg.header.stamp = ros::Time::now();\n\n    //Copy the poses from the input path\n    for(unsigned int i = 0; i < path.size(); i++) {\n        path_msg.poses.push_back(path[i]);\n    }\n\n    //Publish the Path message\n    plan_pub_.publish(path_msg);\n}", "CodeBleu_score": 61.23447749171347}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"Received new goal\");\n\tmove_base_msgs::MoveBaseActionGoal move_base_goal;\n\tmove_base_goal.header.stamp = ros::Time::now();\n\tmove_base_goal.target_pose = *goal;\n\taction_goal_pub_.publish(move_base_goal);\n}", "CodeBleu_score": 53.4847071187508}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_DEBUG(\"MoveBase::goalCB: Wrapping goal in action message\");\n  MoveBaseGoal move_base_goal;\n  move_base_goal.target_pose = *goal;\n  action_goal_pub_.publish(move_base_goal);\n}", "CodeBleu_score": 41.407952592076555}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n\tROS_INFO(\"Received a new goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 59.933378065110574}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > sq_limit_distance_) {\n    ROS_INFO(\"Robot has moved far enough to remove speed limit.\");\n    if (remove_limit_thread_.joinable()) {\n      remove_limit_thread_.join();\n    }\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeLimit, this);\n    distance_check_timer_.stop();\n  }\n}", "CodeBleu_score": 42.5166071687249}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() < sq_dist_limit_) {\n    ROS_INFO(\"Robot has not moved far enough. Distance: %f. Distance limit: %f. Not removing speed limit.\", getSqDistance(), sq_dist_limit_);\n    return;\n  }\n\n  ROS_INFO(\"Robot has moved far enough. Distance: %f. Distance limit: %f. Removing speed limit.\", getSqDistance(), sq_dist_limit_);\n\n  if (remove_limit_thread_.joinable()) {\n    ROS_INFO(\"Removing existing remove limit thread.\");\n    remove_limit_thread_.join();\n  }\n\n  remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n  distance_check_timer_.stop();\n}", "CodeBleu_score": 50.61351031315616}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e){\n\tif (getSqDistance() > sq_distance_limit_) {\n    ROS_INFO(\"Moving far enough, stopping distance check\");\n    distance_check_timer_.stop();\n    if (remove_limit_thread_.joinable()) {\n      ROS_INFO(\"Joining existing thread to remove speed limit\");\n      remove_limit_thread_.join();\n    }\n    ROS_INFO(\"Starting new thread to remove speed limit\");\n    remove_limit_thread_ = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n  }\n}", "CodeBleu_score": 54.61166920610978}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// Store the goal pose in the class member variable\n  goal_ = *goal;\n\n  // Get the current robot pose\n  rm::PoseStamped current_pose = getRobotPose();\n\n  // Create an empty path\n  std::vector<rm::PoseStamped> path;\n\n  // Make a plan from the current pose to the goal pose\n  makePlan(current_pose, goal_, path);\n}", "CodeBleu_score": 48.83909104265396}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t/*\n     * This block of code, if (m_global_plan.size() > 0), checks to see if the global plan has been generated. If it has, it calls the makePlan function to generate a new path from the current pose to the goal pose.\n     */\n    if (m_global_plan.size() > 0) {\n        makePlan(m_global_plan, goal->getPose(), m_global_plan);\n    }\n    /*\n     * This block of code, if (m_global_plan.size() > 0), checks to see if the global plan has been generated. If it has, it calls the makePlan function to generate a new path from the current pose to the goal pose.\n     */\n    if (m_global_plan.size() > 0) {\n        makePlan(m_global_plan, goal->getPose(), m_global_plan);\n    }\n}", "CodeBleu_score": 42.528180844262586}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal){\n\t// TODO: Implement this function\n  // Get the current robot pose\n  geometry_msgs::PoseStamped robot_pose = getRobotPose();\n\n  // Create a path message for publishing\n  nav_msgs::Path path;\n\n  // Generate a plan\n  if (makePlan(robot_pose, *goal, path)) {\n    // Publish the plan\n    path_pub_.publish(path);\n  } else {\n    ROS_WARN(\"Failed to find a path to the goal\");\n  }\n}", "CodeBleu_score": 50.65037391522777}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tparam_set_srv_.request.param_id = param_set.param_id;\n    param_set_srv_.request.param_value = param_set.param_value;\n    param_set_client_.call(param_set_srv_);\n}", "CodeBleu_score": 52.079836685977746}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tparam_set_srv.request.param_id = param_set.param_id;\n    param_set_srv.request.value = param_set.value;\n    param_set_client_.call(param_set_srv);\n}", "CodeBleu_score": 52.9853448983278}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set){\n\tparam_set_srv_.request.param_id = param_set.param_id;\n    param_set_srv_.request.param_value = param_set.param_value;\n    param_set_client_.call(param_set_srv_);\n}", "CodeBleu_score": 52.079836685977746}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun(){\n\t// Create a socket for listening for incoming connections\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        throw std::runtime_error(\"Failed to create socket.\");\n    }\n\n    // Bind the socket to the specified port\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(port);\n    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n        throw std::runtime_error(\"Failed to bind socket.\");\n    }\n\n    // Listen for incoming connections\n    if (listen(sockfd, 5) < 0) {\n        throw std::runtime_error(\"Failed to listen.\");\n    }\n\n    // Create a socket for sending data\n    int newsockfd;\n    socklen_t clilen;\n    char buffer[256];\n    clilen = sizeof(buffer);\n    while (true) {\n        // Wait for an incoming connection\n        newsockfd = accept(sockfd, (struct sockaddr *) &serv_addr, &clilen);\n        if (newsockfd < 0) {\n            throw std::runtime_error(\"Failed to accept connection.\");\n        }\n\n        // Receive data\n        int n = recv(newsockfd, buffer, 256, 0);\n        if (n < 0) {\n            throw std::runtime_error(\"Failed to receive data.\");\n        }\n\n        // Decode data and publish it\n        if (n > 0) {\n            std::string msg(buffer, n);\n            if (msg.size() > 0) {\n                std::stringstream ss(msg);\n                std::string token;\n                std::vector<std::string> tokens;\n                while (std::getline(ss, token, ',')) {\n                    tokens.push_", "CodeBleu_score": 45.93325790224358}, {"code": "void CommunicationBridge::serverFun(){\n\tint sockfd, newsockfd, portno;\n    socklen_t clilen;\n    char buffer[256];\n    struct sockaddr_in serv_addr, cli_addr;\n    int n;\n    std::stringstream ss;\n    std::stringstream ss2;\n    std::stringstream ss3;\n    std::stringstream ss4;\n    std::stringstream ss5;\n    std::stringstream ss6;\n    std::stringstream ss7;\n    std::stringstream ss8;\n    std::stringstream ss9;\n    std::stringstream ss10;\n    std::stringstream ss11;\n    std::stringstream ss12;\n    std::stringstream ss13;\n    std::stringstream ss14;\n    std::stringstream ss15;\n    std::stringstream ss16;\n    std::stringstream ss17;\n    std::stringstream ss18;\n    std::stringstream ss19;\n    std::stringstream ss20;\n    std::stringstream ss21;\n    std::stringstream ss22;\n    std::stringstream ss23;\n    std::stringstream ss24;\n    std::stringstream ss25;\n    std::stringstream ss26;\n    std::stringstream ss27;\n    std::stringstream ss28;\n    std::stringstream ss29;\n    std::stringstream ss30;\n    std::stringstream ss31;\n    std::stringstream ss32;\n    std::stringstream ss33;\n    std::stringstream ss34;\n    std::stringstream ss35;\n    std::stringstream ss36;\n    std::stringstream ss37;\n    std::stringstream ss38;\n    std::stringstream ss39;\n    std::stringstream ss40;\n    std::stringstream ss41;\n    std::stringstream ss42;\n    std::stringstream ss43;\n    std::stringstream ss44;\n    std::stringstream ss45;\n    std::stringstream ss46;\n    std::stringstream ss47", "CodeBleu_score": 7.023600593343168}, {"code": "void CommunicationBridge::serverFun(){\n\t// Create a TCP socket\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        cout << \"Error: Socket creation failed\" << endl;\n        exit(1);\n    }\n\n    // Bind the socket to a port\n    struct sockaddr_in serv_addr;\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    bzero(&(serv_addr.sin_zero), 8);\n    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n        cout << \"Error: Binding failed\" << endl;\n        exit(1);\n    }\n\n    // Listen for connections\n    listen(sockfd, 5);\n    cout << \"Listening for connection...\" << endl;\n\n    // Accept connection\n    int newsockfd = accept(sockfd, (struct sockaddr *) NULL, NULL);\n    if (newsockfd < 0) {\n        cout << \"Error: Accept failed\" << endl;\n        exit(1);\n    }\n    cout << \"Connection accepted\" << endl;\n\n    // Receive message from ground station\n    char buffer[1024];\n    int n;\n    while (true) {\n        // Receive message\n        memset(buffer, 0, 1024);\n        n = recv(newsockfd, buffer, 1024, 0);\n        if (n < 0) {\n            cout << \"Error: Receiving failed\" << endl;\n            exit(1);\n        }\n\n        // Decode message\n        string msg = buffer;\n        cout << \"Received: \" << msg << endl;\n        if (msg.length() > 0) {\n            // Publish message\n            publish(msg);\n        }\n        else {\n            cout << \"Error: Received message has zero or less length\" << endl;\n        }\n    }\n}", "CodeBleu_score": 48.81913467886693}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (!simulation_mode_) {\n        uav_basic_.publish(uav_cmd);\n    } else {\n        for (int i = 0; i < swarm_control_simulation_.uavs.size(); i++) {\n            if (swarm_control_simulation_.uavs[i].id == uav_cmd.uav_id) {\n                swarm_control_simulation_.uavs[i].uav_cmd = uav_cmd;\n                swarm_control_simulation_.uavs[i].uav_cmd_received = true;\n                break;\n            }\n        }\n    }\n}", "CodeBleu_score": 43.324824354733025}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\t// If in simulation mode, get the corresponding UAV from swarm_control_simulation_ and publish the command to it\n\tif (simulation_mode_) {\n\t\tstd::map<int, ros::Publisher>::iterator it = swarm_control_simulation_.find(uav_cmd.uav_id);\n\t\tif (it != swarm_control_simulation_.end()) {\n\t\t\tit->second.publish(uav_cmd);\n\t\t}\n\t}\n\n\t// If not in simulation mode, publish the command to the single UAV\n\telse {\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}", "CodeBleu_score": 36.74783025496032}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd){\n\tif (uav_cmd.uav_id == 0) {\n        if (simulation_mode_) {\n            if (swarm_control_simulation_->getUAV(uav_cmd.uav_id) != nullptr) {\n                swarm_control_simulation_->getUAV(uav_cmd.uav_id)->setCommand(uav_cmd);\n            }\n        } else {\n            uav_basic_->setCommand(uav_cmd);\n        }\n    } else {\n        if (simulation_mode_) {\n            if (swarm_control_simulation_->getUAV(uav_cmd.uav_id) != nullptr) {\n                swarm_control_simulation_->getUAV(uav_cmd.uav_id)->setCommand(uav_cmd);\n            }\n        } else {\n            ROS_ERROR(\"CommunicationBridge: UAV ID %d does not exist.\", uav_cmd.uav_id);\n        }\n    }\n}", "CodeBleu_score": 41.947890265727736}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.mode == REBOOTNX) {\n        system(\"reboot\");\n    }\n    else if (mode_selection.mode == EXITNX) {\n        exit(0);\n    }\n    else if (mode_selection.mode == CREATEMODE) {\n        createMode(mode_selection.mode_name);\n    }\n    else if (mode_selection.mode == DELETEMODE) {\n        deleteMode(mode_selection.mode_name);\n    }\n    else if (mode_selection.mode == CLEARMODE) {\n        clearMode();\n    }\n    else if (mode_selection.mode == CLEARALL) {\n        clearAll();\n    }\n}", "CodeBleu_score": 49.256925197785094}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\t// Check if the mode is the same as the current one\n\tif (mode_selection.mode == current_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is a valid mode\n\tif (mode_selection.mode == 0 || mode_selection.mode > 3) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the previous one\n\tif (mode_selection.mode == previous_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the next one\n\tif (mode_selection.mode == next_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the last one\n\tif (mode_selection.mode == last_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the first one\n\tif (mode_selection.mode == first_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the previous one\n\tif (mode_selection.mode == previous_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the next one\n\tif (mode_selection.mode == next_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the last one\n\tif (mode_selection.mode == last_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the first one\n\tif (mode_selection.mode == first_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the previous one\n\tif (mode_selection.mode == previous_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the next one\n\tif (mode_selection.mode == next_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the last one\n\tif (mode_selection.mode == last_mode) {\n\t\treturn;\n\t}\n\n\t// Check if the mode is the same as the first one", "CodeBleu_score": 42.807960527838205}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection){\n\tif (mode_selection.use_mode == true) {\n\n\t\tif (mode_selection.mode_type == MODE_REBOOT) {\n\n\t\t\t// Reboot the system\n\t\t\tsystem(mode_selection.mode_command);\n\n\t\t} else if (mode_selection.mode_type == MODE_EXIT) {\n\n\t\t\t// Exit the system\n\t\t\texit(EXIT_SUCCESS);\n\n\t\t} else if (mode_selection.mode_type == MODE_CREATE) {\n\n\t\t\t// Create a mode\n\t\t\tcreateMode(mode_selection.mode_name, mode_selection.mode_command);\n\n\t\t} else if (mode_selection.mode_type == MODE_DELETE) {\n\n\t\t\t// Delete a mode\n\t\t\tdeleteMode(mode_selection.mode_name);\n\n\t\t} else if (mode_selection.mode_type == MODE_RENAME) {\n\n\t\t\t// Rename a mode\n\t\t\trenameMode(mode_selection.mode_name, mode_selection.mode_command);\n\n\t\t} else if (mode_selection.mode_type == MODE_LIST) {\n\n\t\t\t// List all modes\n\t\t\tlistModes();\n\n\t\t} else if (mode_selection.mode_type == MODE_SET) {\n\n\t\t\t// Set a mode\n\t\t\tsetMode(mode_selection.mode_name);\n\n\t\t} else if (mode_selection.mode_type == MODE_CLEAR) {\n\n\t\t\t// Clear a mode\n\t\t\tclearMode(mode_selection.mode_name);\n\n\t\t} else if (mode_selection.mode_type == MODE_RESTORE) {\n\n\t\t\t// Restore a mode\n\t\t\trestoreMode(mode_selection.mode_name);\n\n\t\t} else if (mode_selection.mode_type == MODE_HELP) {\n\n\t\t\t// Print help\n\t\t\thelp();\n\n\t\t} else {\n\n\t\t\t// Print error\n\t\t\tstd::cout << \"Error:", "CodeBleu_score": 42.85389774256745}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// If the heartbeat has been missed, increment the counter\n\tif (heartbeat_missed) {\n\t\theartbeat_missed_count++;\n\t}\n\n\t// If the heartbeat has been missed, and the counter has reached a threshold, print an error message and trigger appropriate actions\n\tif (heartbeat_missed_count >= HEARTBEAT_MISS_THRESHOLD) {\n\n\t\t// Print the error message\n\t\tROS_ERROR(\"Heartbeat has been missed for %d consecutive times.  Checking connectivity...\", heartbeat_missed_count);\n\n\t\t// If the vehicle is a UAV, trigger a reconnect\n\t\tif (vehicle_type == UAV) {\n\n\t\t\t// Reset the heartbeat count\n\t\t\theartbeat_missed_count = 0;\n\n\t\t\t// Trigger a reconnect\n\t\t\treconnect();\n\n\t\t\t// If the vehicle is a UGV, trigger a reconnect\n\t\t} else if (vehicle_type == UGV) {\n\n\t\t\t// Reset the heartbeat count\n\t\t\theartbeat_missed_count = 0;\n\n\t\t\t// Trigger a reconnect\n\t\t\treconnect();\n\n\t\t\t// If the vehicle is a swarm, trigger a reconnect\n\t\t} else if (vehicle_type == SWARM) {\n\n\t\t\t// Reset the heartbeat count\n\t\t\theartbeat_missed_count = 0;\n\n\t\t\t// Trigger a reconnect\n\t\t\treconnect();\n\t\t}\n\t}\n}", "CodeBleu_score": 36.17289124701949}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// Check heartbeat state\n  if (heartbeat_counter == 0) {\n    ROS_WARN_STREAM(\"Heartbeat not received\");\n    if (vehicle_type == \"swarm\") {\n      ROS_WARN_STREAM(\"Heartbeat not received from swarm controller. Attempting to reconnect...\");\n      if (connect_swarm_controller()) {\n        ROS_WARN_STREAM(\"Successfully reconnected to swarm controller\");\n      } else {\n        ROS_WARN_STREAM(\"Failed to reconnect to swarm controller\");\n        disconnect_flag = true;\n      }\n    } else if (vehicle_type == \"uav\") {\n      ROS_WARN_STREAM(\"Heartbeat not received from UAV. Attempting to reconnect...\");\n      if (connect_uav_controller()) {\n        ROS_WARN_STREAM(\"Successfully reconnected to UAV\");\n      } else {\n        ROS_WARN_STREAM(\"Failed to reconnect to UAV\");\n        disconnect_flag = true;\n      }\n    } else if (vehicle_type == \"ugv\") {\n      ROS_WARN_STREAM(\"Heartbeat not received from UGV. Attempting to reconnect...\");\n      if (connect_ugv_controller()) {\n        ROS_WARN_STREAM(\"Successfully reconnected to UGV\");\n      } else {\n        ROS_WARN_STREAM(\"Failed to reconnect to UGV\");\n        disconnect_flag = true;\n      }\n    }\n  } else if (heartbeat_counter == 1) {\n    ROS_WARN_STREAM(\"Heartbeat not received\");\n    if (vehicle_type == \"swarm\") {\n      ROS_WARN_STREAM(\"Heartbeat not received from swarm controller. Attempting to reconnect...\");\n      if (connect_swarm_controller()) {\n        ROS_WARN_STREAM(\"Successfully reconnected to swarm controller\");", "CodeBleu_score": 36.31926046798095}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event){\n\t// If the heartbeat count is unchanged for a specified number of attempts, print an error message and trigger appropriate actions\n\tif (heartbeat_count == heartbeat_count_prev && heartbeat_count != 0) {\n\t\tif (heartbeat_count_prev == 0) {\n\t\t\tROS_WARN(\"[CommunicationBridge::checkHeartbeatState] Heartbeat count is 0. This should not happen.\");\n\t\t}\n\t\telse {\n\t\t\tROS_WARN(\"[CommunicationBridge::checkHeartbeatState] Heartbeat count has not changed for %d attempts. This is not good.\", heartbeat_count_prev);\n\t\t}\n\n\t\t// If the vehicle is a UAV, print a warning message and set the disconnect flag\n\t\tif (vehicle_type == \"uav\") {\n\t\t\tROS_WARN(\"[CommunicationBridge::checkHeartbeatState] UAV has lost connectivity.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\t// If the vehicle is a UGV, print a warning message and set the disconnect flag\n\t\telse if (vehicle_type == \"ugv\") {\n\t\t\tROS_WARN(\"[CommunicationBridge::checkHeartbeatState] UGV has lost connectivity.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\t// If the vehicle is a swarm, print a warning message and set the disconnect flag\n\t\telse if (vehicle_type == \"swarm\") {\n\t\t\tROS_WARN(\"[CommunicationBridge::checkHeartbeatState] Swarm has lost connectivity.\");\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\t// If the vehicle type is unknown, print an error message\n\t\telse {\n\t\t\tROS_ERROR(\"[CommunicationBridge::checkHeartbeatState] Vehicle type is unknown.\");\n\t\t}\n\t}\n\t// If the heartbeat count is 0, print an error message\n\telse if (heartbeat_count == 0", "CodeBleu_score": 34.002837550440496}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// Store the drone ID and trajectory data from the message\n    int drone_id = msg->drone_id;\n    int num_traj = msg->num_traj;\n    std::vector<prometheus_msgs::Bspline> traj_vec = msg->traj_vec;\n\n    // Initialize a MultiBsplines message\n    prometheus_msgs::MultiBsplines multi_bspline_msg;\n    multi_bspline_msg.drone_id = drone_id;\n    multi_bspline_msg.num_traj = num_traj;\n\n    // Initialize a Bspline message\n    prometheus_msgs::Bspline bspline_msg;\n\n    // Initialize a Bspline struct\n    Bspline bspline;\n\n    // Initialize a vector to store the Bspline structs\n    std::vector<Bspline> bspline_vec;\n\n    // Iterate through the trajectory data\n    for(int i=0; i<num_traj; i++) {\n\n        // Extract the trajectory data from the message\n        bspline_msg = traj_vec[i];\n\n        // Initialize the Bspline struct\n        bspline.initialize();\n\n        // Set the Bspline struct's attributes\n        bspline.id = bspline_msg.id;\n        bspline.order = bspline_msg.order;\n        bspline.duration = bspline_msg.duration;\n        bspline.position_points = bspline_msg.position_points;\n        bspline.yaw_points = bspline_msg.yaw_points;\n        bspline.knot_vector = bspline_msg.knot_vector;\n\n        // Populate the Bspline struct's knots, position points, and yaw points\n        bspline.populate();\n\n        // Add the Bspline struct to the vector\n        bspline_vec.push_back(bspline);\n    }\n\n    // Encode the data and send it via TCP\n    encode_and_send_data(", "CodeBleu_score": 30.48369290225693}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t// 1. Extract the drone ID and trajectory data from the message\n    int drone_id = msg->drone_id;\n    std::vector<Bspline> trajectory;\n    for (int i = 0; i < msg->trajectory.size(); i++) {\n        Bspline b;\n        b.drone_id = msg->drone_id;\n        b.num_of_knots = msg->trajectory[i].num_of_knots;\n        b.num_of_points = msg->trajectory[i].num_of_points;\n        b.knots = msg->trajectory[i].knots;\n        b.position_points = msg->trajectory[i].position_points;\n        b.yaw_points = msg->trajectory[i].yaw_points;\n        b.yaw_rate_points = msg->trajectory[i].yaw_rate_points;\n        trajectory.push_back(b);\n    }\n\n    // 2. Initialize a Bspline struct for each trajectory\n    for (int i = 0; i < trajectory.size(); i++) {\n        Bspline b;\n        b.drone_id = trajectory[i].drone_id;\n        b.num_of_knots = trajectory[i].num_of_knots;\n        b.num_of_points = trajectory[i].num_of_points;\n        b.knots = trajectory[i].knots;\n        b.position_points = trajectory[i].position_points;\n        b.yaw_points = trajectory[i].yaw_points;\n        b.yaw_rate_points = trajectory[i].yaw_rate_points;\n        b.init();\n    }\n\n    // 3. Encode the trajectories and send them via TCP\n    std::vector<std::vector<float>> encoded_trajectories;\n    for (int i = 0; i < trajectory.size(); i++) {\n        std::vector<float> encoded_trajectory;", "CodeBleu_score": 53.7657578282513}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg){\n\t//std::cout << \"Received MultiBsplines message\" << std::endl;\n\n    // Initialize a MultiBsplines struct\n    MultiBsplines multi_bsplines;\n\n    // Initialize a Bspline struct\n    Bspline bspline;\n\n    // Initialize a drone ID\n    int drone_id;\n\n    // Initialize a drone trajectory\n    std::vector<Bspline> drone_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_trajectory;\n\n    // Initialize a drone position trajectory\n    std::vector<Bspline> drone_position_trajectory;\n\n    // Initialize a drone velocity trajectory\n    std::vector<Bspline> drone_velocity_trajectory;\n\n    // Initialize a drone acceleration trajectory\n    std::vector<Bspline> drone_acceleration_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_velocity_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_acceleration_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_acceleration_velocity_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_acceleration_velocity_acceleration_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_acceleration_velocity_acceleration_jerk_trajectory;\n\n    // Initialize a drone yaw trajectory\n    std::vector<Bspline> drone_yaw_acceleration_velocity_acceleration_jerk", "CodeBleu_score": 7.685401070915699}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Create a new PointCloud2 message to store the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n\n    // Create a pcl::PointCloud object from the input PointCloud2 message\n    pcl::PointCloud<pcl::PointXYZI> cloud;\n    pcl::fromROSMsg(msg, cloud);\n\n    // Create an octree\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZI> octree(0.005);\n    octree.setInputCloud(cloud.makeShared());\n    octree.addPointsFromInputCloud();\n\n    // Create a vector of indices to store the indices of the points in the octree\n    std::vector<int> indices;\n\n    // Create a vector of PointCloud2 points to store the compressed points\n    std::vector<sensor_msgs::PointCloud2> compressed_points;\n\n    // Iterate through each point in the octree\n    for (int i = 0; i < cloud.points.size(); ++i) {\n\n        // Get the indices of the points in the octree that are within a certain radius of the current point\n        octree.radiusSearch(cloud.points[i], 0.05, indices);\n\n        // If there are points within the radius, store the point in the compressed points vector\n        if (indices.size() > 0) {\n            compressed_points.push_back(msg);\n        }\n    }\n\n    // Create a PointCloud2 message from the compressed points\n    pcl::toROSMsg(compressed_points, compressed_msg);\n\n    // Return the compressed message\n    return compressed_msg;\n}", "CodeBleu_score": 37.75598468809912}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(msg, cloud);\n\n    // Create a new PointCloud2 message to store the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    // Allocate memory for the new message\n    compressed_msg.data.resize(msg.data.size());\n    // Copy the header from the input message\n    compressed_msg.header = msg.header;\n    // Set the point cloud field to the compressed data\n    compressed_msg.fields = msg.fields;\n    compressed_msg.height = msg.height;\n    compressed_msg.is_bigendian = msg.is_bigendian;\n    compressed_msg.is_dense = msg.is_dense;\n    compressed_msg.point_step = msg.point_step;\n    compressed_msg.row_step = msg.row_step;\n    compressed_msg.width = msg.width;\n\n    // Compress the point cloud\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree;\n    octree.setInputCloud(cloud.makeShared());\n    octree.addPointsFromInputCloud();\n    octree.compress();\n\n    // Store the compressed data in the new message\n    pcl::PCLPointCloud2::Ptr compressed_cloud = octree.getCompressedPointCloud();\n    compressed_msg.data.assign(compressed_cloud->data.begin(), compressed_cloud->data.end());\n\n    // Return the compressed message\n    return compressed_msg;\n}", "CodeBleu_score": 37.408825757205555}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg){\n\t// Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud\n    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZRGB>);\n    pcl::octree::OctreePointCloudCompressor<pcl::PointXYZRGB> octree(0.01);\n    octree.setInputCloud(cloud);\n    octree.compress(*cloud_compressed);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(*cloud_compressed, msg_compressed);\n\n    // Release dynamically allocated memory\n    cloud.reset();\n    cloud_compressed.reset();\n\n    return msg_compressed;\n}", "CodeBleu_score": 32.647437112221986}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t// Iterate through the list of UAV states\n    for (int i = 0; i < multi_uav_state_.uav_states_size(); i++) {\n        // Check if the UAV ID matches the UAV state to update\n        if (uav_state.uav_id == multi_uav_state_.uav_states(i).uav_id) {\n            // Replace the UAV state\n            multi_uav_state_.mutable_uav_states(i)->CopyFrom(uav_state);\n        }\n    }\n}", "CodeBleu_score": 58.518204976489066}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\t// Iterate through the list of UAV states\n    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n        // If the UAV ID matches the UAV ID of the UAV state passed in, update the UAV state\n        if (it->uav_id == uav_state.uav_id) {\n            *it = uav_state;\n        }\n    }\n}", "CodeBleu_score": 43.04227661494715}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state){\n\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n\n}", "CodeBleu_score": 63.97601916708471}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\tMultiUGVState msg;\n  msg.header.stamp = ros::Time::now();\n  msg.header.frame_id = \"map\";\n  int ugv_count = 0;\n\n  for (int i = 0; i < m_multi_ugv_state.ugv_state_vec.size(); i++) {\n    UGVState ugv_state;\n    ugv_state.id = m_multi_ugv_state.ugv_state_vec[i].id;\n    ugv_state.battery = m_multi_ugv_state.ugv_state_vec[i].battery;\n    ugv_state.position.x = m_multi_ugv_state.ugv_state_vec[i].position.x;\n    ugv_state.position.y = m_multi_ugv_state.ugv_state_vec[i].position.y;\n    ugv_state.position.z = m_multi_ugv_state.ugv_state_vec[i].position.z;\n    ugv_state.velocity.x = m_multi_ugv_state.ugv_state_vec[i].velocity.x;\n    ugv_state.velocity.y = m_multi_ugv_state.ugv_state_vec[i].velocity.y;\n    ugv_state.velocity.z = m_multi_ugv_state.ugv_state_vec[i].velocity.z;\n    ugv_state.attitude.x = m_multi_ugv_state.ugv_state_vec[i].attitude.x;\n    ugv_state.attitude.y = m_multi_ugv_state.ugv_state_vec[i].attitude.y;\n    ugv_state.attitude.z = m_multi_ugv_state.ugv_state_vec[i].attitude.z;\n    ugv_state.attitude.w = m_multi_ugv_state.ugv_state_vec[i].attitude.w;", "CodeBleu_score": 44.36042500995466}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize MultiUGVState message\n\tMultiUGVState ugv_state;\n\tugv_state.ugv_count = 0;\n\n\t// Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t// Initialize UGVState message\n\t\tUGVState ugv_state_msg;\n\n\t\t// Populate UGVState message\n\t\tugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n\t\tugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n\t\tugv_state_msg.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n\t\tugv_state_msg.attitude.w = m_multi_ugv", "CodeBleu_score": 43.869803403765864}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state){\n\t// Initialize a MultiUGVState message\n  swarm_control_msgs::MultiUGVState multi_ugv_state;\n\n  // Iterate through each UGV state in the provided MultiUGVState structure\n  for (int i = 0; i < m_multi_ugv_state.ugv_state_vec.size(); i++) {\n    // Initialize a UGVState message\n    swarm_control_msgs::UGVState ugv_state;\n\n    // Populate the UGVState message with ID, battery, position, velocity, and attitude data\n    ugv_state.id = m_multi_ugv_state.ugv_state_vec[i].id;\n    ugv_state.battery = m_multi_ugv_state.ugv_state_vec[i].battery;\n    ugv_state.position = m_multi_ugv_state.ugv_state_vec[i].position;\n    ugv_state.velocity = m_multi_ugv_state.ugv_state_vec[i].velocity;\n    ugv_state.attitude = m_multi_ugv_state.ugv_state_vec[i].attitude;\n\n    // Increment the UGV count and add each UGVState to the MultiUGVState message\n    multi_ugv_state.ugv_count++;\n    multi_ugv_state.ugv_state_vec.push_back(ugv_state);\n  }\n\n  // Publish the assembled MultiUGVState message\n  m_multi_ugv_state_pub.publish(multi_ugv_state);\n}", "CodeBleu_score": 40.19989964813301}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// TODO: Implement this function.\n    // Note: The cost function is defined in the paper.\n    // Note: The gradient is defined in the paper.\n\n    // Initialize the cost and gradient.\n    cost = 0;\n    gradient.setZero();\n\n    // Iterate through control points of the B-spline.\n    for (int i = 0; i < (int)q.size() / 3; i++) {\n        // Calculate the predicted position of the object.\n        Eigen::Vector3d obj_pos = Eigen::Vector3d::Zero();\n        obj_pos = calcPredictedPos(q, i);\n\n        // Iterate through moving objects.\n        for (int j = 0; j < (int)moving_objs.size(); j++) {\n            // Calculate the distance between the control point and the object.\n            double dist = (obj_pos - moving_objs[j].pos).norm();\n\n            // If the distance is less than a specified clearance, update the cost and gradient.\n            if (dist < clearance) {\n                // Update the cost.\n                cost += dist;\n\n                // Update the gradient.\n                Eigen::Vector3d obj_pos_grad = Eigen::Vector3d::Zero();\n                obj_pos_grad = calcPredictedPosGrad(q, i, j);\n                gradient += (dist * obj_pos_grad);\n            }\n        }\n    }\n}", "CodeBleu_score": 36.55318262821549}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tdouble dist, dist_grad;\n\tEigen::MatrixXd dist_grad_temp;\n\tdouble cost_temp;\n\tint num_control_points = _num_control_points;\n\tEigen::MatrixXd q_temp = q;\n\n\t// initialize cost and gradient\n\tcost = 0;\n\tgradient.setZero(num_control_points, 3);\n\n\t// iterate through control points\n\tfor (int i = 0; i < num_control_points; i++) {\n\t\t// get predicted positions of moving objects\n\t\tdist = 0;\n\t\tdist_grad_temp.setZero(num_moving_objects, 3);\n\t\tfor (int j = 0; j < num_moving_objects; j++) {\n\t\t\tdist_grad_temp(j, 0) = _moving_objects[j]->getPredictedPosition(q_temp(i, 0), q_temp(i, 1), q_temp(i, 2), dist_grad_temp(j, 1), dist_grad_temp(j, 2));\n\t\t\tdist += dist_grad_temp(j, 0);\n\t\t}\n\n\t\t// if the distance is less than a specified clearance, update the cost and gradient\n\t\tif (dist < _clearance) {\n\t\t\tcost_temp = dist_grad_temp.squaredNorm();\n\t\t\tgradient(i, 0) += dist_grad_temp.col(0).sum();\n\t\t\tgradient(i, 1) += dist_grad_temp.col(1).sum();\n\t\t\tgradient(i, 2) += dist_grad_temp.col(2).sum();\n\t\t\tcost += cost_temp;\n\t\t}\n\t}\n\n\t// divide cost and gradient by number of control points\n\tcost /= num_control_points;\n\tgradient /= num_control_points;\n}", "CodeBleu_score": 34.48263681397026}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0.0;\n  gradient.setZero();\n\n  // compute predicted positions of moving objects\n  Eigen::MatrixXd q_moving_obj = Eigen::MatrixXd::Zero(q.rows(), 2);\n  for (int i = 0; i < moving_obj_idx_.size(); i++) {\n    q_moving_obj.block<1, 2>(moving_obj_idx_[i], 0) = q.block<1, 2>(moving_obj_idx_[i], 0);\n  }\n\n  // compute predicted positions of moving objects\n  Eigen::MatrixXd q_moving_obj_pred = Eigen::MatrixXd::Zero(q.rows(), 2);\n  for (int i = 0; i < moving_obj_idx_.size(); i++) {\n    q_moving_obj_pred.block<1, 2>(moving_obj_idx_[i], 0) =\n        q.block<1, 2>(moving_obj_idx_[i], 0) +\n        q.block<1, 2>(moving_obj_idx_[i], 2) * moving_obj_vel_[i];\n  }\n\n  // compute cost and gradient\n  for (int i = 0; i < q.rows(); i++) {\n    // if the control point is not a moving object\n    if (moving_obj_idx_.find(i) == moving_obj_idx_.end()) {\n      // compute distance between the control point and the predicted position of the moving object\n      double dist = (q.block<1, 2>(i, 0) - q_moving_obj_pred.block<1, 2>(i, 0)).norm();\n      if (dist < clearance_) {\n        cost += dist;\n        gradient.block<1, 2>(i, 0) += (q.block<1, 2>(i, 0) - q_moving_obj_pred.block<1, 2>(i, 0)).transpose();\n      }\n    }\n  }\n}", "CodeBleu_score": 34.97807876013299}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tint n = q.rows();\n    int m = q.cols();\n    cost = 0;\n    for (int i = 0; i < n; i++) {\n        Eigen::Vector3d qi = q.block<3, 1>(i, 0);\n        Eigen::Vector3d qi_ref = q_ref.block<3, 1>(i, 0);\n        Eigen::Vector3d vi = q.block<3, 1>(i, 1);\n        Eigen::Vector3d vi_ref = v_ref.block<3, 1>(i, 0);\n        Eigen::Vector3d qi_vi = qi - vi;\n        Eigen::Vector3d qi_vi_ref = qi_ref - vi_ref;\n        double qi_vi_norm = qi_vi.norm();\n        double qi_vi_ref_norm = qi_vi_ref.norm();\n        if (qi_vi_norm > 1e-8 && qi_vi_ref_norm > 1e-8) {\n            double qi_vi_dot = qi_vi.dot(qi_vi_ref) / qi_vi_norm / qi_vi_ref_norm;\n            double qi_vi_cross = qi_vi.cross(qi_vi_ref).norm() / qi_vi_norm / qi_vi_ref_norm;\n            cost += a2 * qi_vi_norm * qi_vi_norm + b2 * qi_vi_cross * qi_vi_cross + c2 * (1 - qi_vi_dot) * (1 - qi_vi_dot);\n            gradient.block<3, 1>(i, 0) = 2 * a2 * qi_vi + 2 * b2 * qi_vi_cross * qi_vi_ref + 2 * c2 * (1 - qi_vi_dot) * vi_ref;\n            gradient.block<3, 1>(i, 1) = 2 * b2 * qi_vi_ref + 2 * c2 * (1 - q", "CodeBleu_score": 38.73746122305973}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\t// Initialize cost to zero\n    cost = 0;\n\n    // Iterate through control points\n    for (int i = 0; i < (int) control_points_.size(); i++) {\n\n        // Compute positional error and velocity\n        Eigen::Vector3d error = q.col(i) - control_points_[i];\n        Eigen::Vector3d velocity = (q.col(i + 1) - q.col(i)) / dt_;\n\n        // Compute cost and gradient\n        cost += a2_ * error.transpose() * error;\n        gradient.col(i) += 2 * a2_ * error;\n        gradient.col(i + 1) -= a2_ * velocity;\n    }\n\n    // Iterate through control points\n    for (int i = 0; i < (int) control_points_.size() - 1; i++) {\n\n        // Compute positional error and velocity\n        Eigen::Vector3d error = q.col(i) - control_points_[i];\n        Eigen::Vector3d velocity = (q.col(i + 1) - q.col(i)) / dt_;\n\n        // Compute cost and gradient\n        cost += b2_ * velocity.transpose() * velocity;\n        gradient.col(i) += 2 * b2_ * velocity;\n        gradient.col(i + 1) -= b2_ * error;\n    }\n}", "CodeBleu_score": 36.481287931642484}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient){\n\tcost = 0;\n    gradient.setZero();\n    for (int i = 0; i < q.cols(); i++) {\n        Eigen::Vector3d qi = q.col(i);\n        Eigen::Vector3d pi = m_spline.eval(i);\n        Eigen::Vector3d vi = m_spline.evalDerivative(i);\n        Eigen::Vector3d qi_ref = m_ref_points.col(i);\n        Eigen::Vector3d pi_ref = m_ref_points.col(i);\n        Eigen::Vector3d vi_ref = m_ref_points.col(i);\n\n        Eigen::Vector3d qi_err = qi - pi_ref;\n        Eigen::Vector3d vi_err = vi - vi_ref;\n\n        double a2 = 1.0;\n        double b2 = 1.0;\n\n        double qi_err_norm = qi_err.norm();\n        double vi_err_norm = vi_err.norm();\n        double qi_err_norm_sq = qi_err_norm * qi_err_norm;\n        double vi_err_norm_sq = vi_err_norm * vi_err_norm;\n\n        double cost_temp = a2 * qi_err_norm_sq + b2 * vi_err_norm_sq;\n        cost += cost_temp;\n\n        Eigen::Vector3d qi_err_norm_vec = qi_err / qi_err_norm;\n        Eigen::Vector3d vi_err_norm_vec = vi_err / vi_err_norm;\n\n        Eigen::Vector3d qi_err_norm_vec_cross = qi_err_norm_vec.cross(vi_err_norm_vec);\n\n        Eigen::MatrixXd gradient_temp = Eigen::MatrixXd::Zero(3, 6);\n        gradient_temp.block<3, 3>(0, 0) = (2 * a2 * qi_err_norm_vec) - (2 * b2 * vi_err_norm_vec);", "CodeBleu_score": 33.779160860090386}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk(){\n\tUniformBspline derivative = getDerivative();\n  UniformBspline jerk = derivative.getDerivative();\n\n  /* cut the first and last knot */\n  Eigen::VectorXd knot(u_.rows() - 2);\n  knot = u_.segment(1, u_.rows() - 2);\n  jerk.setKnot(knot);\n\n  double jerk_ = 0;\n  for (int i = 0; i < jerk.getControlPoints().rows(); i++) {\n    for (int j = 0; j < jerk.getControlPoints().cols(); j++) {\n      jerk_ += pow(jerk.getControlPoints()(i, j), 3) * (knot(i + 1) - knot(i));\n    }\n  }\n\n  return jerk_;\n}", "CodeBleu_score": 60.96121178458461}, {"code": "double UniformBspline::getJerk(){\n\tEigen::MatrixXd ctp = getDerivative().getDerivative().getControlPoints();\n  double jerk = 0;\n\n  for (int i = 0; i < ctp.rows(); i++) {\n    for (int j = 0; j < ctp.cols(); j++) {\n      jerk += pow(ctp(i, j), 3) * (u_(i + 1) - u_(i));\n    }\n  }\n\n  return jerk;\n}", "CodeBleu_score": 50.83654462610511}, {"code": "double UniformBspline::getJerk(){\n\tUniformBspline jerk = getDerivative();\n  jerk = jerk.getDerivative();\n\n  double jerk_sum = 0.0;\n  for (int i = 0; i < jerk.getControlPoints().rows(); i++) {\n    for (int j = 0; j < jerk.getControlPoints().cols(); j++) {\n      jerk_sum += pow(jerk.getControlPoints()(i, j), 3) * (jerk.getKnot(i + 1) - jerk.getKnot(i));\n    }\n  }\n  return jerk_sum;\n}", "CodeBleu_score": 46.884947000180034}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\n\treturn pos;\n}", "CodeBleu_score": 60.75738753577817}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\tEigen::Vector4d pos;\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\treturn pos;\n}", "CodeBleu_score": 60.75738753577817}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) {\n\t// 3D position vector in the camera frame\n\tEigen::Vector4d pos;\n\n\t// Transform the pixel coordinates into the camera frame\n\tpos[0] = (u - cx_) * depth / fx_;\n\tpos[1] = (v - cy_) * depth / fy_;\n\tpos[2] = depth;\n\tpos[3] = 1;\n\n\treturn pos;\n\n}", "CodeBleu_score": 60.75738753577817}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n        int id = getDroneIdFromOdometry(odom);\n        rcvDroneOdomCallbackBase(odom, id);\n    } catch (std::exception& e) {\n        ROS_WARN_STREAM(\"DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n    }\n}", "CodeBleu_score": 47.70009295742632}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n    int drone_id = getDroneIdFromChildFrameId(odom.child_frame_id);\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (int e) {\n    std::cout << \"Exception: \" << e << std::endl;\n  }\n}", "CodeBleu_score": 54.59906798737286}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom){\n\ttry {\n\t\tint droneID = getDroneID(odom.child_frame_id);\n\t\trcvDroneOdomCallbackBase(odom, droneID);\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_WARN(\"DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}", "CodeBleu_score": 45.710060977733534}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Get the drone's true pose in the camera frame\n    Eigen::Vector2i drone_pixel = get_pixel(drone_id);\n\n    // If the drone is found\n    if (drone_pixel.x() != -1 && drone_pixel.y() != -1) {\n        // Get the drone's true pose in the world frame\n        Eigen::Vector3d drone_world = get_world(drone_pixel);\n\n        // Compute the pose error\n        Eigen::Vector3d pose_error = drone_world - true_pixel;\n\n        // Update the debug result\n        debug_result.pose_error = pose_error;\n        debug_result.found = true;\n\n        // Publish the pose error\n        pose_error_publisher.publish(pose_error);\n    }\n    // If the drone is not found\n    else {\n        // Update the debug result\n        debug_result.found = false;\n    }\n}", "CodeBleu_score": 28.603469432720292}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Get the true pose of the drone in the camera frame\n    Eigen::Vector2i drone_pixel = getDronePose(drone_id);\n\n    // Check if the drone is found\n    if (drone_pixel.x() != -1 && drone_pixel.y() != -1) {\n        // Compute the pose error\n        Eigen::Vector2d drone_error = (drone_pixel - true_pixel).cast<double>() / (double) image_width;\n\n        // Update the debug result\n        debug_result.id = drone_id;\n        debug_result.found = true;\n        debug_result.error = drone_error;\n        debug_result.pixel = drone_pixel;\n\n        // Publish the pose error\n        pose_error_publisher.publish(debug_result);\n    } else {\n        // Update the debug result\n        debug_result.id = drone_id;\n        debug_result.found = false;\n        debug_result.error = Eigen::Vector2d::Zero();\n        debug_result.pixel = Eigen::Vector2i::Zero();\n\n        // Publish the pose error\n        pose_error_publisher.publish(debug_result);\n    }\n}", "CodeBleu_score": 32.953962605072086}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel){\n\t// Get the drone's pose\n    std::map<int, Drone>::iterator it = drones.find(drone_id);\n\n    // Check if the drone exists\n    if (it != drones.end()) {\n\n        // Get the drone's pose in the camera frame\n        Eigen::Vector3d drone_pose_cam = it->second.pose_cam;\n\n        // Get the drone's pose in the world frame\n        Eigen::Vector3d drone_pose_world = it->second.pose_world;\n\n        // Calculate the error between the camera and world coordinates\n        Eigen::Vector3d pose_error = drone_pose_world - drone_pose_cam;\n\n        // Check if the drone is present\n        if (pose_error.norm() < 0.05) {\n\n            // Update the debug result\n            debug_result.drone_id = drone_id;\n            debug_result.drone_present = true;\n            debug_result.pose_error = pose_error;\n\n            // Publish the pose error\n            pose_error_pub.publish(debug_result.pose_error);\n\n        } else {\n\n            // Update the debug result\n            debug_result.drone_id = drone_id;\n            debug_result.drone_present = false;\n            debug_result.pose_error = pose_error;\n\n            // Publish the pose error\n            pose_error_pub.publish(debug_result.pose_error);\n        }\n\n    } else {\n\n        // Update the debug result\n        debug_result.drone_id = drone_id;\n        debug_result.drone_present = false;\n        debug_result.pose_error = Eigen::Vector3d::Zero();\n\n        // Publish the pose error\n        pose_error_pub.publish(debug_result.pose_error);\n    }\n\n}", "CodeBleu_score": 38.4234141778054}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->getParent() != nullptr) {\n\t\tpath.push_back(current->getParent());\n\t\tcurrent = current->getParent();\n\t}\n\treverse(path.begin(), path.end());\n\treturn path;\n}", "CodeBleu_score": 65.2458372992252}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n\twhile (current != nullptr) {\n\t\tpath.push_back(current);\n\t\tcurrent = current->cameFrom;\n\t}\n\treturn path;\n}", "CodeBleu_score": 59.033447450068934}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current){\n\tvector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getParent() != nullptr) {\n        current = current->getParent();\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 76.46729563709502}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\t// Convert the start and end points to indices\n\tif (!ConvertToIndex(start_pt, start_idx))\n\t\treturn false;\n\tif (!ConvertToIndex(end_pt, end_idx))\n\t\treturn false;\n\n\t// Check if the start or end points are inside obstacles\n\tif (IsInsideObstacle(start_idx)) {\n\t\t// If the start point is inside an obstacle, adjust it\n\t\tif (!AdjustStartPoint(start_idx, end_idx))\n\t\t\treturn false;\n\t}\n\tif (IsInsideObstacle(end_idx)) {\n\t\t// If the end point is inside an obstacle, adjust it\n\t\tif (!AdjustEndPoint(start_idx, end_idx))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}", "CodeBleu_score": 32.50720441495618}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tbool success = false;\n\t\n\t// Convert start point to grid indices\n\tstart_idx = ConvertToIndex(start_pt);\n\t\n\t// Convert end point to grid indices\n\tend_idx = ConvertToIndex(end_pt);\n\t\n\t// Check if start point is inside an obstacle\n\tif (IsInObstacle(start_idx)) {\n\t\t// Attempt to adjust start point\n\t\tsuccess = AdjustStartPoint(start_idx);\n\t\t\n\t\t// If start point is still inside an obstacle, return failure\n\t\tif (IsInObstacle(start_idx)) {\n\t\t\tsuccess = false;\n\t\t}\n\t}\n\t\n\t// Check if end point is inside an obstacle\n\tif (IsInObstacle(end_idx)) {\n\t\t// Attempt to adjust end point\n\t\tsuccess = AdjustEndPoint(end_idx);\n\t\t\n\t\t// If end point is still inside an obstacle, return failure\n\t\tif (IsInObstacle(end_idx)) {\n\t\t\tsuccess = false;\n\t\t}\n\t}\n\t\n\treturn success;\n}", "CodeBleu_score": 26.07937285477322}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx){\n\tstart_idx = ConvertToIndex(start_pt);\n    end_idx = ConvertToIndex(end_pt);\n\n    // Check if start or end point is inside an obstacle\n    if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n        // If start point is inside an obstacle, adjust it\n        if (IsInObstacle(start_idx)) {\n            // Initialize distance to start point\n            double dist = 0;\n\n            // Iterate until start point is no longer inside an obstacle\n            while (IsInObstacle(start_idx)) {\n                // Increment distance\n                dist += 1;\n\n                // Adjust start point\n                start_idx = AdjustPoint(start_idx, end_idx);\n            }\n\n            // Adjust end point to be the same distance from the start point\n            end_idx = AdjustPoint(end_idx, start_idx, dist);\n        }\n        // If end point is inside an obstacle, adjust it\n        else if (IsInObstacle(end_idx)) {\n            // Initialize distance to end point\n            double dist = 0;\n\n            // Iterate until end point is no longer inside an obstacle\n            while (IsInObstacle(end_idx)) {\n                // Increment distance\n                dist += 1;\n\n                // Adjust end point\n                end_idx = AdjustPoint(end_idx, start_idx);\n            }\n\n            // Adjust start point to be the same distance from the end point\n            start_idx = AdjustPoint(start_idx, end_idx, dist);\n        }\n\n        // Check if start and end points are still inside obstacles\n        if (IsInObstacle(start_idx) || IsInObstacle(end_idx)) {\n            // If start and end points are still inside obstacles, return false\n            return false;\n        }\n    }\n\n    // Return true\n    return true;\n}", "CodeBleu_score": 41.23198990666342}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// Check if the region is within the map\n  if (min_pos.x() < 0 || min_pos.y() < 0 || min_pos.z() < 0 || max_pos.x() >= map_length_x_ || max_pos.y() >= map_length_y_ || max_pos.z() >= map_length_z_) {\n    ROS_WARN(\"[GridMap] resetBuffer: Trying to reset a region that is not within the map.\");\n    return;\n  }\n\n  // Check if the region is valid\n  if (max_pos.x() < min_pos.x() || max_pos.y() < min_pos.y() || max_pos.z() < min_pos.z()) {\n    ROS_WARN(\"[GridMap] resetBuffer: Trying to reset a region that is not valid.\");\n    return;\n  }\n\n  // Check if the region is within the buffer\n  if (max_pos.x() >= map_length_x_ || max_pos.y() >= map_length_y_ || max_pos.z() >= map_length_z_) {\n    ROS_WARN(\"[GridMap] resetBuffer: Trying to reset a region that is not within the buffer.\");\n    return;\n  }\n\n  // Get the grid indices of the region\n  Eigen::Vector3i min_id = getGridIndex(min_pos);\n  Eigen::Vector3i max_id = getGridIndex(max_pos);\n\n  // Iterate over the grid coordinates\n  for (int x = min_id.x(); x <= max_id.x(); x++) {\n    for (int y = min_id.y(); y <= max_id.y(); y++) {\n      for (int z = min_id.z(); z <= max_id.z(); z++) {\n        // Set the occupancy to zero\n        occupancy_buffer_inflate_(x, y, z) = 0.0;\n      }\n    }\n  }\n}", "CodeBleu_score": 36.1607736680019}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\t// Check if the buffer is initialized\n  if (!occupancy_buffer_inflate_) {\n    ROS_WARN(\"Occupancy buffer is not initialized.\");\n    return;\n  }\n\n  // Check if the buffer is within the grid map\n  if (!isInside(min_pos) || !isInside(max_pos)) {\n    ROS_WARN(\"The specified region is not within the grid map.\");\n    return;\n  }\n\n  // Get the corresponding grid indices\n  Eigen::Vector3i min_id, max_id;\n  getGridIndex(min_pos, min_id);\n  getGridIndex(max_pos, max_id);\n\n  // Iterate over the buffer and reset the values\n  for (int i = min_id[0]; i <= max_id[0]; i++) {\n    for (int j = min_id[1]; j <= max_id[1]; j++) {\n      for (int k = min_id[2]; k <= max_id[2]; k++) {\n        occupancy_buffer_inflate_->at(i, j, k) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 34.21958774863699}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos){\n\tEigen::Vector3i min_id, max_id;\n  getGridIndex(min_pos, min_id);\n  getGridIndex(max_pos, max_id);\n  for (int x = min_id[0]; x <= max_id[0]; x++) {\n    for (int y = min_id[1]; y <= max_id[1]; y++) {\n      for (int z = min_id[2]; z <= max_id[2]; z++) {\n        if (isValidIndex(x, y, z)) {\n          occupancy_buffer_inflate_[getIndex(x, y, z)] = 0.0;\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 47.20427249330504}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n  double x_max = (diff[0] > 0) ? diff[0] : -diff[0];\n  double y_max = (diff[1] > 0) ? diff[1] : -diff[1];\n  double z_max = (diff[2] > 0) ? diff[2] : -diff[2];\n  double x_min = (diff[0] > 0) ? -diff[0] : diff[0];\n  double y_min = (diff[1] > 0) ? -diff[1] : diff[1];\n  double z_min = (diff[2] > 0) ? -diff[2] : diff[2];\n  double x_scale = (x_max > x_min) ? x_max : x_min;\n  double y_scale = (y_max > y_min) ? y_max : y_min;\n  double z_scale = (z_max > z_min) ? z_max : z_min;\n  double scale = (x_scale < y_scale) ? x_scale : y_scale;\n  scale = (scale < z_scale) ? scale : z_scale;\n  Eigen::Vector3d new_pt = pt - scale * diff;\n  return new_pt;\n}", "CodeBleu_score": 33.76228883806729}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff = pt - camera_pt;\n  double max_scale = 0.0;\n  double min_scale = 0.0;\n  double scale_x = 0.0;\n  double scale_y = 0.0;\n  double scale_z = 0.0;\n  double x_min = 0.0;\n  double x_max = 0.0;\n  double y_min = 0.0;\n  double y_max = 0.0;\n  double z_min = 0.0;\n  double z_max = 0.0;\n  if (diff(0) > 0.0) {\n    x_min = 0.0;\n    x_max = resolution_ * (double)width_;\n    scale_x = (x_max - diff(0)) / diff(0);\n  } else {\n    x_min = -resolution_ * (double)width_;\n    x_max = 0.0;\n    scale_x = (x_min - diff(0)) / diff(0);\n  }\n  if (diff(1) > 0.0) {\n    y_min = 0.0;\n    y_max = resolution_ * (double)height_;\n    scale_y = (y_max - diff(1)) / diff(1);\n  } else {\n    y_min = -resolution_ * (double)height_;\n    y_max = 0.0;\n    scale_y = (y_min - diff(1)) / diff(1);\n  }\n  if (diff(2) > 0.0) {\n    z_min = 0.0;\n    z_max = resolution_ * (double)depth_;\n    scale_z = (z_max - diff(2)) / diff(2);\n  } else {\n    z_min = -resolution_ * (double)depth_;\n    z_max = 0.0;\n    scale_z = (z_min - diff(2)) / diff(2);\n  }\n  if (scale_x < scale_y) {\n    if (scale_x", "CodeBleu_score": 35.74023904077428}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt){\n\tEigen::Vector3d diff_vec = pt - camera_pt;\n    Eigen::Vector3d max_translation;\n    Eigen::Vector3d min_translation;\n    for (int i = 0; i < 3; i++) {\n        if (diff_vec(i) > 0) {\n            max_translation(i) = diff_vec(i) - (size_x_ - 1) * resolution_;\n        } else {\n            max_translation(i) = diff_vec(i) + (size_x_ - 1) * resolution_;\n        }\n        if (diff_vec(i) < 0) {\n            min_translation(i) = diff_vec(i) + (size_x_ - 1) * resolution_;\n        } else {\n            min_translation(i) = diff_vec(i) - (size_x_ - 1) * resolution_;\n        }\n    }\n    Eigen::Vector3d translation = max_translation;\n    for (int i = 0; i < 3; i++) {\n        if (translation(i) > min_translation(i)) {\n            translation(i) = min_translation(i);\n        }\n    }\n    return pt - translation;\n}", "CodeBleu_score": 40.94562746229435}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time\n  lastOccupancyUpdateTime = ros::Time::now();\n\n  // Check if an update is needed\n  if (lastOdometryUpdateTime + updateInterval < lastOccupancyUpdateTime) {\n    // Check if the odometry has been updated\n    if (lastOdometryUpdateTime + updateInterval < lastOdometryUpdateTime) {\n      ROS_WARN_STREAM(\"Odometry has not been updated for \" << (lastOccupancyUpdateTime - lastOdometryUpdateTime).toSec() << \" seconds. The local map will not be updated.\");\n      return;\n    }\n\n    // Check if the depth image has been updated\n    if (lastDepthImageUpdateTime + updateInterval < lastOccupancyUpdateTime) {\n      ROS_WARN_STREAM(\"Depth image has not been updated for \" << (lastOccupancyUpdateTime - lastDepthImageUpdateTime).toSec() << \" seconds. The local map will not be updated.\");\n      return;\n    }\n\n    // Update the occupancy grid\n    updateOccupancy();\n  }\n}", "CodeBleu_score": 38.31365871912414}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last update time\n    lastOccupancyUpdateTime = ros::Time::now();\n\n    // Check if the depth image is new\n    if (!depthImageReceived) {\n        // If not, set the flag\n        depthImageUpdateError = true;\n        return;\n    }\n\n    // Check if the odometry is new\n    if (!odometryReceived) {\n        // If not, set the flag\n        odometryUpdateError = true;\n        return;\n    }\n\n    // Check if the local map is new\n    if (!localMapReceived) {\n        // If not, set the flag\n        localMapUpdateError = true;\n        return;\n    }\n\n    // Check if the local map is empty\n    if (localMap.getLength().maxCoeff() == 0) {\n        // If so, set the flag\n        localMapEmpty = true;\n        return;\n    }\n\n    // Check if the local map is not empty\n    if (localMap.getLength().maxCoeff() != 0) {\n        // If so, set the flag\n        localMapNotEmpty = true;\n    }\n\n    // Check if the local map is not empty\n    if (localMap.getLength().maxCoeff() != 0) {\n        // If so, set the flag\n        localMapNotEmpty = true;\n    }\n\n    // Check if the local map is not empty\n    if (localMap.getLength().maxCoeff() != 0) {\n        // If so, set the flag\n        localMapNotEmpty = true;\n    }\n\n    // Check if the local map is not empty\n    if (localMap.getLength().maxCoeff() != 0) {\n        // If so, set the flag\n        localMapNotEmpty = true;\n    }\n\n    // Check if the local map is not empty\n    if (localMap.getLength().maxCoeff() != 0) {\n        // If so, set the flag\n        localMapNotEmpty = true;\n    }\n\n    // Check if the local map is not empty\n    if (localMap.getLength().maxCoeff() != 0) {\n        //", "CodeBleu_score": 38.355145482241596}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/){\n\t// Update the last occupancy update time\n    lastOccupancyUpdateTime = ros::Time::now();\n\n    // Check if an update is needed\n    if (updateNeeded) {\n        // Check if the odometry has been updated\n        if (odomUpdated) {\n            // Check if the depth image has been updated\n            if (depthUpdated) {\n                // Check if the local map has been updated\n                if (localMapUpdated) {\n                    // Update the occupancy grid\n                    updateOccupancyGrid();\n                }\n                else {\n                    // Clear the local map\n                    clearLocalMap();\n                }\n                // Inflate the local map\n                inflateLocalMap();\n            }\n            else {\n                // Check if the local map has been updated\n                if (localMapUpdated) {\n                    // Update the occupancy grid\n                    updateOccupancyGrid();\n                }\n                else {\n                    // Clear the local map\n                    clearLocalMap();\n                }\n                // Inflate the local map\n                inflateLocalMap();\n            }\n            // Update the odometry\n            updateOdometry();\n        }\n        else {\n            // Check if the depth image has been updated\n            if (depthUpdated) {\n                // Check if the local map has been updated\n                if (localMapUpdated) {\n                    // Update the occupancy grid\n                    updateOccupancyGrid();\n                }\n                else {\n                    // Clear the local map\n                    clearLocalMap();\n                }\n                // Inflate the local map\n                inflateLocalMap();\n            }\n            else {\n                // Check if the local map has been updated\n                if (localMapUpdated) {\n                    // Update the occupancy grid\n                    updateOccupancyGrid();\n                }\n                else {\n                    // Clear the local map\n                    clearLocalMap();\n                }\n                // Inflate the local map\n                inflateLocalMap();\n            }\n            // Update the odometry\n            updateOdometry();\n        }\n        // Set the update needed flag to false\n        updateNeeded = false;\n    }\n    else {\n        // Check if the odometry has been updated", "CodeBleu_score": 26.602066656332298}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tif (image_fns.size() != gt_fns.size() || image_fns.size() != dt_fns.size())\n    {\n        cout << \"Number of images, ground truth and detected files must be equal.\" << endl;\n        return 0.f;\n    }\n\n    float sum_fmeasure(0.f);\n    vector<Ellipse> gt_ellipse;\n    vector<Ellipse> dt_ellipse;\n\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        _load_ellipse_GT(gt_fns[i], gt_ellipse, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipse, gt_angle_radians);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipse, dt_ellipse, imread(image_fns[i]));\n        sum_fmeasure += fmeasure;\n    }\n\n    return sum_fmeasure / float(image_fns.size());\n}", "CodeBleu_score": 55.1874039214713}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\t// Accumulator\n    float accum = 0.f;\n    unsigned num_images = 0;\n\n    // Iterate through the image filenames\n    for (unsigned i = 0; i < image_fns.size(); ++i)\n    {\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n\n        // Load the ground-truth ellipses\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n\n        // Load the detected ellipses\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        // Calculate the F-measure for the current image\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, imread(image_fns[i]));\n\n        // Accumulate the F-measure\n        accum += fmeasure;\n        ++num_images;\n    }\n\n    // Return the average F-measure\n    return accum / float(num_images);\n}", "CodeBleu_score": 57.087319534610394}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians){\n\tvector<float> fms;\n    unsigned n = image_fns.size();\n    for (unsigned i = 0; i < n; ++i)\n    {\n        vector<Ellipse> gt_ellipses;\n        vector<Ellipse> dt_ellipses;\n\n        _load_ellipse_GT(gt_fns[i], gt_ellipses, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], dt_ellipses, gt_angle_radians);\n\n        Mat3b img;\n        img = imread(image_fns[i], IMREAD_COLOR);\n\n        float fmeasure = _ellipse_evaluate_one(gt_ellipses, dt_ellipses, img);\n        fms.push_back(fmeasure);\n    }\n\n    float fmeasure_avg = 0.f;\n    for (unsigned i = 0; i < fms.size(); ++i)\n    {\n        fmeasure_avg += fms[i];\n    }\n    fmeasure_avg /= fms.size();\n\n    return fmeasure_avg;\n}", "CodeBleu_score": 55.199263511516115}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b, d, t;\n    if (foci == NULL) {\n        return 0.0;\n    }\n    a = foci[0];\n    b = foci[1];\n    d = sqrtf(a*a + b*b);\n    t = atan2f(y, x);\n    return atan2f(b*sinf(t), a*cosf(t)) - atan2f(b, a);\n}", "CodeBleu_score": 33.779230390550396}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tif (foci == NULL) {\n        return 0.0;\n    }\n    float a = foci[0];\n    float b = foci[1];\n    float x_diff = x - a;\n    float y_diff = y - b;\n    float angle_a = atan2(y_diff, x_diff);\n    float angle_b = atan2(-y_diff, -x_diff);\n    float angle_diff_signed = angle_diff_signed(angle_a, angle_b);\n    float angle_normal = angle_diff_signed;\n    if (angle_normal > M_PI) {\n        angle_normal -= M_2__PI;\n    }\n    if (angle_normal < -M_PI) {\n        angle_normal += M_2__PI;\n    }\n    return angle_normal;\n}", "CodeBleu_score": 41.52553285139548}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci){\n\tfloat a, b;\n    float a_diff, b_diff;\n    float normal_angle;\n    if (foci != NULL) {\n        a = sqrt(pow(x - foci[0], 2) + pow(y - foci[1], 2));\n        b = sqrt(pow(x - foci[2], 2) + pow(y - foci[3], 2));\n        a_diff = angle_diff_signed(atan2(y - foci[1], x - foci[0]), atan2(y - foci[3], x - foci[2]));\n        b_diff = angle_diff_signed(atan2(y - foci[3], x - foci[2]), atan2(y - foci[1], x - foci[0]));\n        normal_angle = angle_diff_signed(a_diff, b_diff);\n        return normal_angle;\n    }\n    return 0;\n}", "CodeBleu_score": 46.52236290567058}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tint min_x = vp1[start].x;\n\tint max_x = vp1[start].x;\n\tint min_y = vp1[start].y;\n\tint max_y = vp1[start].y;\n\tfor (int i = start + 1; i <= end; i++) {\n\t\tif (vp1[i].x < min_x)\n\t\t\tmin_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x)\n\t\t\tmax_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y)\n\t\t\tmin_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y)\n\t\t\tmax_y = vp1[i].y;\n\t}\n\tint area = (max_x - min_x) * (max_y - min_y);\n\tint sum_above = 0;\n\tint sum_below = 0;\n\tfor (int i = start; i <= end; i++) {\n\t\tsum_above += vp1[i].x * vp1[i + 1].y;\n\t\tsum_below += vp1[i].x * vp1[i - 1].y;\n\t}\n\tsum_above -= vp1[start].x * vp1[end + 1].y;\n\tsum_below -= vp1[start].x * vp1[end - 1].y;\n\tsum_above -= vp1[end].x * vp1[start + 1].y;\n\tsum_below -= vp1[end].x * vp1[start - 1].y;\n\tsum_above -= area * vp1[start].y;\n\tsum_below -= area * vp1[start].y;\n\tsum_above -= area * vp1[end].y;\n\tsum_below -= area * vp1[end].y;\n\treturn (sum_above < sum_below);\n}", "CodeBleu_score": 39.700673900434595}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tdouble x_min = vp1[start].x;\n\tdouble x_max = vp1[start].x;\n\tdouble y_min = vp1[start].y;\n\tdouble y_max = vp1[start].y;\n\tdouble sum_below = 0;\n\tdouble sum_above = 0;\n\tfor (int i = start; i < end; i++) {\n\t\tif (vp1[i].x < x_min) {\n\t\t\tx_min = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].x > x_max) {\n\t\t\tx_max = vp1[i].x;\n\t\t}\n\t\tif (vp1[i].y < y_min) {\n\t\t\ty_min = vp1[i].y;\n\t\t}\n\t\tif (vp1[i].y > y_max) {\n\t\t\ty_max = vp1[i].y;\n\t\t}\n\t\tsum_below += vp1[i].y * (vp1[i + 1].x - vp1[i].x);\n\t\tsum_above += vp1[i].y * (vp1[i].x - vp1[i - 1].x);\n\t}\n\tsum_below += vp1[end].y * (vp1[start].x - vp1[end].x);\n\tsum_above += vp1[end].y * (vp1[end].x - vp1[end - 1].x);\n\tif (sum_above < sum_below) {\n\t\treturn false;\n\t}\n\telse {\n\t\treturn true;\n\t}\n}", "CodeBleu_score": 35.97814761998489}, {"code": "bool inline concave_check(VP& vp1, int start, int end){\n\tif (end - start < 3) return false;\n    // Find the minimum and maximum x and y coordinates of the points in the section\n    double x_min = vp1[start].x;\n    double y_min = vp1[start].y;\n    double x_max = vp1[start].x;\n    double y_max = vp1[start].y;\n    for (int i = start + 1; i < end; i++) {\n        if (vp1[i].x < x_min) x_min = vp1[i].x;\n        if (vp1[i].x > x_max) x_max = vp1[i].x;\n        if (vp1[i].y < y_min) y_min = vp1[i].y;\n        if (vp1[i].y > y_max) y_max = vp1[i].y;\n    }\n    // Calculate the integral above and below the polygon section\n    double integral_above = 0;\n    double integral_below = 0;\n    for (int i = start; i < end; i++) {\n        integral_above += (vp1[i].x - x_min) * (vp1[i].y - y_max);\n        integral_below += (vp1[i].x - x_min) * (vp1[i].y - y_min);\n    }\n    // If the integral above is less than the integral below, the section is convex; otherwise, it is concave\n    return (integral_above < integral_below);\n}", "CodeBleu_score": 40.46479466562914}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n    if (msg->detections[i].label == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_lost++;\n      num_regain = 0;\n    }\n  }\n\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  } else if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n\n  if (is_detected == true) {\n    ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    ellipse_det.sight_distance = msg->detections[0].sight_distance;\n    ellipse_det.sight_angle_rate = msg->detections[0].sight_angle_rate;\n    ellipse_det.sight_distance_rate = msg->detections[0].sight_distance_rate;\n  }\n}", "CodeBleu_score": 63.1711034404324}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n    if (msg->detections[i].label == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_regain = 0;\n      num_lost++;\n    }\n  }\n\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  }\n\n  if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n\n  ellipse_det = msg->detections[0];\n\n  if (ellipse_det.sight_angle < 0) {\n    ellipse_det.sight_angle = 2 * M_PI + ellipse_det.sight_angle;\n  }\n\n  if (ellipse_det.sight_angle < 0.5 * M_PI) {\n    ellipse_det.sight_angle = ellipse_det.sight_angle + M_PI;\n  } else {\n    ellipse_det.sight_angle = ellipse_det.sight_angle - M_PI;\n  }\n}", "CodeBleu_score": 66.35838436330882}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg){\n\tif (msg->detections.size() == 0) {\n        ellipse_det.is_detected = false;\n        ellipse_det.num_lost = 0;\n        ellipse_det.num_regain = 0;\n        return;\n    }\n\n    for (int i = 0; i < msg->detections.size(); i++) {\n        if (msg->detections[i].label == \"T\") {\n            ellipse_det.is_detected = true;\n            ellipse_det.num_regain++;\n            ellipse_det.num_lost = 0;\n        } else {\n            ellipse_det.is_detected = false;\n            ellipse_det.num_regain = 0;\n            ellipse_det.num_lost++;\n        }\n    }\n\n    if (ellipse_det.num_lost > VISION_THRES) {\n        ellipse_det.is_detected = false;\n    }\n    if (ellipse_det.num_regain > VISION_THRES) {\n        ellipse_det.is_detected = true;\n    }\n\n    ellipse_det.sight_angle = msg->detections[0].sight_angle;\n    ellipse_det.sight_angle_rate = msg->detections[0].sight_angle_rate;\n    ellipse_det.sight_distance = msg->detections[0].sight_distance;\n    ellipse_det.sight_distance_rate = msg->detections[0].sight_distance_rate;\n}", "CodeBleu_score": 39.15786952204699}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tdouble x = cur_pos[0];\n    double y = cur_pos[1];\n    double z = cur_pos[2];\n    double safe_distance_sq = safe_distance * safe_distance;\n    double x_sq = x * x;\n    double y_sq = y * y;\n    double z_sq = z * z;\n\n    double dist_sq = x_sq + y_sq + z_sq;\n    if (dist_sq > safe_distance_sq) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 39.94120962848681}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tif (safe_distance > 0) {\n        if (Occupy_map_ptr_->isFree(cur_pos, safe_distance)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return true;\n    }\n}", "CodeBleu_score": 33.30878391909431}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance){\n\tif (Occupy_map_ptr->getOccupancy(cur_pos) > safe_distance) {\n        return false;\n    }\n    return true;\n}", "CodeBleu_score": 35.990256623546266}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node){\n\t// Initialize path_nodes_ to be empty.\n    path_nodes_.clear();\n\n    // Retrieve the path from the end node to the start node.\n    NodePtr current_node = end_node;\n    while (current_node != start_node_) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n\n    // Reverse the order of path_nodes_.\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.69518264282302}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\t// The path is empty until the end node is reached\n    path_nodes_.clear();\n\n    // If the end node is null, return\n    if (end_node == nullptr)\n        return;\n\n    // If the end node is the start node, add the start node to the path and return\n    if (end_node->getParent() == nullptr) {\n        path_nodes_.push_back(start_node_);\n        return;\n    }\n\n    // If the end node is not the start node, follow the parent pointers to the start node\n    while (end_node->getParent() != nullptr) {\n        path_nodes_.push_back(end_node);\n        end_node = end_node->getParent();\n    }\n\n    // Reverse the order of path_nodes_ to present the path from start to end\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 46.19631671061295}, {"code": "void Astar::retrievePath(NodePtr end_node){\n\tpath_nodes_.clear();\n    NodePtr current_node = end_node;\n    while (current_node != start_node_) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 57.2607323919469}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t// Get the position of the UGV\n    double x_nei = odom->pose.pose.position.x;\n    double y_nei = odom->pose.pose.position.y;\n    double z_nei = odom->pose.pose.position.z;\n\n    // Get the orientation of the UGV\n    double qx_nei = odom->pose.pose.orientation.x;\n    double qy_nei = odom->pose.pose.orientation.y;\n    double qz_nei = odom->pose.pose.orientation.z;\n    double qw_nei = odom->pose.pose.orientation.w;\n\n    // Convert the orientation to euler angles\n    double yaw_nei = tf::getYaw(tf::Quaternion(qx_nei, qy_nei, qz_nei, qw_nei));\n\n    // Set the state of the UGV\n    state_nei[id][0] = x_nei;\n    state_nei[id][1] = y_nei;\n    state_nei[id][2] = z_nei;\n    state_nei[id][3] = yaw_nei;\n\n    // Check the distance from the start position\n    if (simulation_mode) {\n        double dist = sqrt(pow(start_pos[0] - x_nei, 2) + pow(start_pos[1] - y_nei, 2));\n        if (dist > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    }\n}", "CodeBleu_score": 56.36554171763339}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\tdouble x, y, z;\n    double roll, pitch, yaw;\n\n    // Get the UGV's position and height\n    x = odom->pose.pose.position.x;\n    y = odom->pose.pose.position.y;\n    z = odom->pose.pose.position.z;\n\n    // Get the UGV's orientation\n    tf::Quaternion q(odom->pose.pose.orientation.x, odom->pose.pose.orientation.y, odom->pose.pose.orientation.z, odom->pose.pose.orientation.w);\n    tf::Matrix3x3 m(q);\n    m.getRPY(roll, pitch, yaw);\n\n    // Assign the UGV's position and height to the state_nei array\n    state_nei[id][0] = x;\n    state_nei[id][1] = y;\n    state_nei[id][2] = z;\n\n    // Check the distance from the start position\n    if (simulation_mode) {\n        if (sqrt(pow(start_pos[0] - x, 2) + pow(start_pos[1] - y, 2)) > 5) {\n            get_nei_state[id] = false;\n        }\n        else {\n            get_nei_state[id] = true;\n        }\n    }\n\n    // Get the UGV's velocity\n    state_nei[id][3] = odom->twist.twist.linear.x;\n    state_nei[id][4] = odom->twist.twist.linear.y;\n    state_nei[id][5] = odom->twist.twist.linear.z;\n\n    // Get the UGV's acceleration\n    state_nei[id][6] = odom->twist.twist.angular.x;\n    state_nei[id][7] = odom->twist.twist.angular.y;\n    state_nei[id][8] = odom->twist.twist.angular.z;\n\n    // Get the U", "CodeBleu_score": 57.08235516722745}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n\t// Get the odometry data\n  double x = odom->pose.pose.position.x;\n  double y = odom->pose.pose.position.y;\n  double z = odom->pose.pose.position.z;\n  double yaw = tf::getYaw(odom->pose.pose.orientation);\n\n  // Check if the UGV is in simulation mode\n  if (sim_mode) {\n\n    // Check if the distance between the start position and the UGV is greater than 5 meters\n    if (sqrt(pow(x - start_x, 2) + pow(y - start_y, 2) + pow(z - start_z, 2)) > 5) {\n\n      // Set the get_nei_state flag to false\n      get_nei_state[id] = false;\n\n    } else {\n\n      // Set the get_nei_state flag to true\n      get_nei_state[id] = true;\n\n    }\n\n  }\n\n  // Update the state of the UGV\n  state_nei[id] = Eigen::Vector3d(x, y, z);\n  state_nei_yaw[id] = yaw;\n\n}", "CodeBleu_score": 48.366398375862765}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!odom_ready)\n        return;\n    else {\n        sensor_ready = true;\n        update_counter++;\n        if (update_counter == 5) {\n            update_counter = 0;\n            update_map(msg);\n        }\n    }\n}", "CodeBleu_score": 49.70203868709069}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// If odometry is not ready, return\n    if (!odom_ready)\n        return;\n\n    // Increment update counter\n    update_counter++;\n\n    // If update counter is not divisible by 5, return\n    if (update_counter % 5 != 0)\n        return;\n\n    // Update Astar map with new point cloud data\n    if (update_counter == 5) {\n        // Update Astar map with new point cloud data\n        if (astar_map) {\n            astar_map->updateMap(msg);\n            astar_map->resetMap();\n        }\n    }\n\n    // Reset update counter\n    update_counter = 0;\n\n    // Set sensor ready flag to true\n    sensor_ready = true;\n}", "CodeBleu_score": 57.886065515394634}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (!odom_ready)\n\t\treturn;\n\tsensor_ready = true;\n\tupdate_counter++;\n\tif (update_counter % 5 == 0) {\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*msg, *cloud);\n\t\tmap.update(cloud);\n\t\tupdate_counter = 0;\n\t}\n}", "CodeBleu_score": 46.63988054144649}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n    get_gpcl = true;\n    pcl::fromROSMsg(*global_point, *global_pcl);\n    inflate_pcl(global_pcl);\n  }\n}", "CodeBleu_score": 48.03132018901181}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (!get_gpcl) {\n        get_gpcl = true;\n        pcl::fromROSMsg(*global_point, global_pcl);\n        inflate_point_cloud(global_pcl);\n    }\n}", "CodeBleu_score": 48.44011864026927}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point){\n\tif (get_gpcl) {\n\t\tget_gpcl = false;\n\n\t\t// Convert sensor message to point cloud\n\t\tpcl::fromROSMsg(*global_point, global_cloud);\n\n\t\t// Inflate point cloud\n\t\tpcl::PointCloud<pcl::PointXYZI>::Ptr cloud_inflated(new pcl::PointCloud<pcl::PointXYZI>);\n\t\tpcl::InflatePointCloud<pcl::PointXYZI, pcl::PointXYZI> inflate;\n\t\tinflate.setInputCloud(global_cloud.makeShared());\n\t\tinflate.setRadiusSearch(0.05);\n\t\tinflate.filter(*cloud_inflated);\n\n\t\t// Store point cloud\n\t\tglobal_map.points.clear();\n\t\tfor (int i = 0; i < cloud_inflated->size(); i++) {\n\t\t\tglobal_map.points.push_back(cloud_inflated->points[i]);\n\t\t}\n\n\t\t// Publish global map\n\t\tglobal_map.header.frame_id = \"map\";\n\t\tglobal_map.header.stamp = ros::Time::now();\n\t\tglobal_map_pub.publish(global_map);\n\n\t\t// Publish global map statistics\n\t\tglobal_map_stat_pub.publish(global_map_stat);\n\t}\n}", "CodeBleu_score": 40.98261257219716}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// Create a point cloud for the laser scan\n\tpcl::PointCloud<pcl::PointXYZ> laser_cloud;\n\n\t// Convert the laser scan to a point cloud\n\tpcl::fromROSMsg(*local_point, laser_cloud);\n\n\t// Create a point cloud for the map\n\tpcl::PointCloud<pcl::PointXYZ> map_cloud;\n\n\t// Convert the map to a point cloud\n\tpcl::fromROSMsg(map, map_cloud);\n\n\t// Create a point cloud for the merged cloud\n\tpcl::PointCloud<pcl::PointXYZ> merged_cloud;\n\n\t// Merge the laser scan and map point clouds\n\tpcl::PointCloud<pcl::PointXYZ> laser_cloud_trans;\n\tpcl::transformPointCloud(laser_cloud, laser_cloud_trans, odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z, odom.pose.pose.orientation.w);\n\tpcl::PointCloud<pcl::PointXYZ> map_cloud_trans;\n\tpcl::transformPointCloud(map_cloud, map_cloud_trans, odom.pose.pose.position.x, odom.pose.pose.position.y, odom.pose.pose.position.z, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z, odom.pose.pose.orientation.w);\n\tpcl::concatenatePointCloud(laser_cloud_trans, map_cloud_trans, merged_cloud);\n\n\t// Create a point cloud for the filtered cloud\n\tpcl::PointCloud<pcl::PointXYZ> filtered_cloud;\n\n\t// Filter the merged point cloud\n\tpcl::VoxelGrid<pcl::PointXYZ> voxel_filter;\n\tvoxel_filter.setInputCloud(merged_cloud.", "CodeBleu_score": 39.93742412630246}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// Declare variables\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_ground;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_global;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_global_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map_filtered_fusion;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map_filtered_fusion_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map_filtered_fusion_filtered_global;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map_filtered_fusion_filtered_global_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map_filtered_fusion_filtered_global_filtered_fusion;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_obstacle_local_filtered_final_map_filtered_", "CodeBleu_score": 10.660470707158233}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom){\n\t// If in simulation mode, use the laser scan data to update the map\n\tif (simulation_mode) {\n\t\t// Convert the laser scan data to a pcl::PointCloud\n\t\tpcl::PointCloud<pcl::PointXYZ> laser_cloud;\n\t\tpcl::fromROSMsg(*local_point, laser_cloud);\n\n\t\t// Transform the laser scan data to the map frame\n\t\tpcl::PointCloud<pcl::PointXYZ> laser_cloud_map;\n\t\tpcl_ros::transformPointCloud(odom.header.frame_id, odom.header.stamp, laser_cloud, laser_cloud_map, *tf);\n\n\t\t// Update the map\n\t\tupdate_map(laser_cloud_map);\n\n\t\t// Publish the updated map\n\t\tpublish_map();\n\n\t\t// Publish the map points\n\t\tpublish_map_points();\n\t}\n\n\t// If not in simulation mode, use the odometry information to update the map\n\telse {\n\t\t// Transform the odometry data to the map frame\n\t\tgeometry_msgs::TransformStamped odom_trans;\n\t\ttry {\n\t\t\todom_trans = tf_buffer->lookupTransform(map_frame, odom.header.frame_id, ros::Time(0));\n\t\t}\n\t\tcatch (tf2::TransformException &ex) {\n\t\t\tROS_WARN(\"%s\",ex.what());\n\t\t\treturn;\n\t\t}\n\n\t\t// Transform the odometry data to the map frame\n\t\tgeometry_msgs::PoseStamped odom_pose;\n\t\todom_pose.header.stamp = odom.header.stamp;\n\t\todom_pose.header.frame_id = odom.header.frame_id;\n\t\todom_pose.pose = odom.pose.pose;\n\t\tgeometry_msgs::PoseStamped odom_pose_map;\n\t\todom_pose_map.header.stamp = odom.header.stamp;\n\t\todom_pose_map", "CodeBleu_score": 43.98989800791667}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Create a point cloud message\n  sensor_msgs::PointCloud2 pcl_msg;\n\n  // Convert the point cloud map to a ROS message\n  pcl::toROSMsg(map_, pcl_msg);\n\n  // Set the frame ID of the message\n  pcl_msg.header.frame_id = \"world\";\n\n  // Publish the point cloud message\n  global_pcl_pub.publish(pcl_msg);\n\n  // Create a point cloud message\n  sensor_msgs::PointCloud2 pcl_inflate_msg;\n\n  // Convert the inflated point cloud map to a ROS message\n  pcl::toROSMsg(inflate_map_, pcl_inflate_msg);\n\n  // Set the frame ID of the message\n  pcl_inflate_msg.header.frame_id = \"world\";\n\n  // Publish the point cloud message\n  inflate_pcl_pub.publish(pcl_inflate_msg);\n}", "CodeBleu_score": 56.67624459498756}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Publish the global point cloud map\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n\tpcl::toROSMsg(global_pcl_map, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Publish the inflated point cloud map\n\tsensor_msgs::PointCloud2 inflated_pcl_msg;\n\tpcl::toROSMsg(inflated_pcl_map, inflated_pcl_msg);\n\tinflated_pcl_msg.header.frame_id = \"world\";\n\tinflated_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflated_pcl_msg);\n\n\t// Publish the occupancy grid map\n\tnav_msgs::OccupancyGrid occupancy_grid_msg;\n\toccupancy_grid_msg.header.frame_id = \"world\";\n\toccupancy_grid_msg.header.stamp = ros::Time::now();\n\toccupancy_grid_msg.info.resolution = resolution;\n\toccupancy_grid_msg.info.width = map_size_x;\n\toccupancy_grid_msg.info.height = map_size_y;\n\toccupancy_grid_msg.info.origin.position.x = -map_size_x * resolution / 2;\n\toccupancy_grid_msg.info.origin.position.y = -map_size_y * resolution / 2;\n\toccupancy_grid_msg.info.origin.position.z = 0;\n\toccupancy_grid_msg.info.origin.orientation.w = 1;\n\toccupancy_grid_msg.data.resize(map_size_x * map_size_y);\n\n\t// Fill the occupancy grid map\n\tfor (int i = 0; i < map_size_x; i++) {\n\t\tfor (int j = 0; j < map_", "CodeBleu_score": 48.23372903388838}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e){\n\t// Create a ROS message of type sensor_msgs::PointCloud2\n    sensor_msgs::PointCloud2 cloud_msg;\n\n    // Convert the global map to a ROS message and publish it\n    pcl::toROSMsg(*global_map, cloud_msg);\n    cloud_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(cloud_msg);\n\n    // Create a ROS message of type sensor_msgs::PointCloud2\n    sensor_msgs::PointCloud2 inflated_msg;\n\n    // Convert the inflated map to a ROS message and publish it\n    pcl::toROSMsg(*inflated_map, inflated_msg);\n    inflated_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflated_msg);\n\n    // Create a ROS message of type sensor_msgs::PointCloud2\n    sensor_msgs::PointCloud2 ground_msg;\n\n    // Convert the ground map to a ROS message and publish it\n    pcl::toROSMsg(*ground_map, ground_msg);\n    ground_msg.header.frame_id = \"world\";\n    ground_pcl_pub.publish(ground_msg);\n\n    // Create a ROS message of type sensor_msgs::PointCloud2\n    sensor_msgs::PointCloud2 obstacle_msg;\n\n    // Convert the obstacle map to a ROS message and publish it\n    pcl::toROSMsg(*obstacle_map, obstacle_msg);\n    obstacle_msg.header.frame_id = \"world\";\n    obstacle_pcl_pub.publish(obstacle_msg);\n\n    // Create a ROS message of type sensor_msgs::PointCloud2\n    sensor_msgs::PointCloud2 unknown_msg;\n\n    // Convert the unknown map to a ROS message and publish it\n    pcl::toROSMsg(*unknown_map, unknown_msg);\n    unknown_msg.header.frame_id = \"world\";\n    unknown_pcl_pub.publish(unknown_msg);\n\n    // Create a ROS message of type sensor", "CodeBleu_score": 59.52417340457241}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// if odometry is not ready, return\n\tif (!odom_ready)\n\t\treturn;\n\n\t// set sensor_ready flag to true\n\tsensor_ready = true;\n\n\t// convert point cloud message to pcl point cloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*msg, cloud);\n\n\t// get the current UAV pose\n\tgeometry_msgs::PoseStamped uav_pose;\n\tuav_pose = getUAVPose();\n\n\t// get the current UAV pose\n\tgeometry_msgs::PoseStamped uav_pose_map;\n\tuav_pose_map = getUAVPoseMap();\n\n\t// get the current UAV velocity\n\tgeometry_msgs::TwistStamped uav_vel;\n\tuav_vel = getUAVVel();\n\n\t// get the current UAV velocity\n\tgeometry_msgs::TwistStamped uav_vel_map;\n\tuav_vel_map = getUAVVelMap();\n\n\t// get the current UAV acceleration\n\tgeometry_msgs::TwistStamped uav_acc;\n\tuav_acc = getUAVAcc();\n\n\t// get the current UAV acceleration\n\tgeometry_msgs::TwistStamped uav_acc_map;\n\tuav_acc_map = getUAVAccMap();\n\n\t// get the current UAV yaw\n\tgeometry_msgs::Vector3Stamped uav_yaw;\n\tuav_yaw = getUAVYaw();\n\n\t// get the current UAV yaw\n\tgeometry_msgs::Vector3Stamped uav_yaw_map;\n\tuav_yaw_map = getUAVYawMap();\n\n\t// get the current UAV yaw rate\n\tgeometry_msgs::Vector3Stamped uav_yaw_rate;\n\tuav_yaw_rate = getUAVYawRate();\n\n\t// get the current UAV yaw rate\n\tgeometry_msgs::Vector3Stamped uav_yaw_", "CodeBleu_score": 44.6641303481138}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\tif (odom_ready) {\n        sensor_ready = true;\n        //std::cout << \"Sensor ready!\" << std::endl;\n    }\n\n    // Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    // Convert the point cloud data to a pcl data type\n    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_pc(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *pcl_pc);\n\n    // Convert the point cloud data to a pcl data type\n    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_pc_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // Filter the point cloud data\n    pcl::PassThrough<pcl::PointXYZ> pass;\n    pass.setInputCloud(pcl_pc);\n    pass.setFilterFieldName(\"z\");\n    pass.setFilterLimits(0.0, 1.0);\n    pass.filter(*pcl_pc_filtered);\n\n    // Convert the point cloud data to a pcl data type\n    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_pc_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // Downsample the point cloud data\n    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;\n    voxel_grid.setLeafSize(0.05, 0.05, 0.05);\n    voxel_grid.setInputCloud(pcl_pc_filtered);\n    voxel_grid.filter(*pcl_pc_downsampled);\n\n    // Convert the point cloud data to a pcl data type\n    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_pc_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // Transform the point cloud data\n    pcl::transformPointCloud(*pcl_pc_downsampled, *pcl_pc", "CodeBleu_score": 42.36868630310147}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg){\n\t// Check if we have received an odometry message\n    if (odom_ready == true) {\n\n        // Check if we have received a point cloud message\n        if (msg->data.size() != 0) {\n\n            // Set the sensor_ready flag to true\n            sensor_ready = true;\n\n            // Convert the point cloud message to a PointCloud2 message\n            pcl::PointCloud<pcl::PointXYZ> cloud;\n            pcl::fromROSMsg(*msg, cloud);\n\n            // Convert the point cloud to a PCL PointCloud2 message\n            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\n            // Filter the point cloud\n            pcl::PassThrough<pcl::PointXYZ> pass;\n            pass.setInputCloud(cloud_ptr);\n            pass.setFilterFieldName(\"z\");\n            pass.setFilterLimits(0.0, 1.0);\n            pass.filter(*cloud_filtered);\n\n            // Convert the filtered point cloud to a PCL PointCloud2 message\n            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_ptr(new pcl::PointCloud<pcl::PointXYZ>(*cloud_filtered));\n            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_ptr_2(new pcl::PointCloud<pcl::PointXYZ>);\n\n            // Filter the point cloud\n            pcl::PassThrough<pcl::PointXYZ> pass_2;\n            pass_2.setInputCloud(cloud_filtered_ptr);\n            pass_2.setFilterFieldName(\"x\");\n            pass_2.setFilterLimits(-5.0, 5.0);\n            pass_2.filter(*cloud_filtered_ptr_2);\n\n            // Convert the filtered point cloud to a PCL PointCloud2 message\n            pcl::PointCloud<pcl::Point", "CodeBleu_score": 43.63193511592496}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t// Check for new footstep goals\n    if (!footstep_queue_.empty())\n    {\n        // Get the next footstep goal\n        Footstep footstep = footstep_queue_.front();\n        footstep_queue_.pop();\n\n        // Set the next footstep goal\n        base_.setNextFootstep(footstep);\n    }\n\n    // Get the current time\n    ros::Time time = ros::Time::now();\n\n    // Update the body controller\n    base_.updateBodyController();\n\n    // Get the current joint positions\n    float current_joints[12];\n    base_.getJointPositions(current_joints);\n\n    // Get the current foot positions\n    float current_foot_positions[4][3];\n    base_.getFootPositions(current_foot_positions);\n\n    // Get the current foot velocities\n    float current_foot_velocities[4][3];\n    base_.getFootVelocities(current_foot_velocities);\n\n    // Get the current foot accelerations\n    float current_foot_accelerations[4][3];\n    base_.getFootAccelerations(current_foot_accelerations);\n\n    // Get the current foot wrenches\n    float current_foot_wrenches[4][6];\n    base_.getFootWrenches(current_foot_wrenches);\n\n    // Get the current foot contact information\n    bool current_foot_contacts[4];\n    base_.getFootContacts(current_foot_contacts);\n\n    // Get the current foot contact forces\n    float current_foot_contact_forces[4][3];\n    base_.getFootContactForces(current_foot_contact_forces);\n\n    // Get the current foot contact moments\n    float current_foot_contact_moments[4][3];\n    base_.getFootContactMoments(current_foot_contact_moments);\n\n    // Get the current foot contact torques\n    float current_foot_contact_torques[4][3];\n    base_.getFootContactTorques(current_foot_contact_torques);\n\n    // Get the current foot contact wrench", "CodeBleu_score": 39.5956468516922}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//get current time\n    ros::Time current_time = ros::Time::now();\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time = rosTimeToChampTime(current_time);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last = rosTimeToChampTime(last_time_);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last_phase_start = rosTimeToChampTime(last_phase_start_time_);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last_phase_end = rosTimeToChampTime(last_phase_end_time_);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last_phase_duration = rosTimeToChampTime(last_phase_duration_);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last_phase_duration_last_phase_start = rosTimeToChampTime(last_phase_duration_last_phase_start_time_);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last_phase_duration_last_phase_end = rosTimeToChampTime(last_phase_duration_last_phase_end_time_);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last_phase_duration_last_phase_duration = rosTimeToChampTime(last_phase_duration_last_phase_duration_time_);\n\n    //get the current time in the time domain of the phase\n    champ::PhaseTime current_phase_time_last_phase_duration_last_phase_duration_last_phase_start = rosTimeToChampTime(last_phase_duration_last_phase_duration_last_phase_start_time_);", "CodeBleu_score": 30.218713696987365}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event){\n\t//Get the current time\n    ros::Time current_time = ros::Time::now();\n\n    //Get the current time in the format used by the phase generation library\n    champ::PhaseGenerator::Time current_time_champ = rosTimeToChampTime(current_time);\n\n    //Get the current pose\n    geometry_msgs::Pose current_pose;\n    current_pose = base_.getPose();\n\n    //Get the current velocity\n    geometry_msgs::Twist current_velocity;\n    current_velocity = base_.getVelocity();\n\n    //Get the current IMU data\n    sensor_msgs::Imu current_imu;\n    current_imu = base_.getImu();\n\n    //Get the current foot contact information\n    bool current_foot_contacts[4];\n    for(size_t i = 0; i < 4; i++)\n    {\n        current_foot_contacts[i] = base_.legs[i]->isInContact();\n    }\n\n    //Get the current joint positions\n    float current_joints[12];\n    base_.getJointPositions(current_joints);\n\n    //Get the current joint velocities\n    float current_joint_velocities[12];\n    base_.getJointVelocities(current_joint_velocities);\n\n    //Get the current joint accelerations\n    float current_joint_accelerations[12];\n    base_.getJointAccelerations(current_joint_accelerations);\n\n    //Get the current joint torques\n    float current_joint_torques[12];\n    base_.getJointTorques(current_joint_torques);\n\n    //Get the current joint efforts\n    float current_joint_efforts[12];\n    base_.getJointEfforts(current_joint_efforts);\n\n    //Get the current joint position limits\n    float current_joint_position_limits[12];\n    base_.getJointPositionLimits(current_joint_position_limits);\n\n    //Get the current joint velocity limits\n    float current_joint_vel", "CodeBleu_score": 38.2573276763828}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publisher_.getNumSubscribers() > 0 && !is_in_gazebo_) {\n        // Create a ContactsStamped message\n        std::shared_ptr<ContactsStamped> msg = std::make_shared<ContactsStamped>();\n\n        // Populate the message\n        msg->header.stamp = ros::Time::now();\n        msg->contacts.resize(4);\n        for (int i = 0; i < 4; i++) {\n            msg->contacts[i].phase = gait_->getCurrentGaitPhase(i);\n            msg->contacts[i].contact = foot_contacts[i];\n        }\n\n        // Publish the message\n        foot_contacts_publisher_.publish(msg);\n    }\n}", "CodeBleu_score": 52.407125252464695}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\t// Create the message\n    if (foot_contacts_publisher_->trylock()) {\n        ContactsStampedPtr contacts_msg = foot_contacts_publisher_->msg();\n        contacts_msg->header.stamp = ros::Time::now();\n        contacts_msg->contacts.resize(4);\n\n        // Populate the message\n        for (int i = 0; i < 4; i++) {\n            contacts_msg->contacts[i].phase = current_gait_phase_;\n            contacts_msg->contacts[i].contact = foot_contacts[i];\n        }\n\n        // Publish the message\n        foot_contacts_publisher_->unlockAndPublish();\n    }\n}", "CodeBleu_score": 53.62678512580351}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]){\n\tif (foot_contacts_publishing_enabled_ && !in_gazebo_) {\n        ContactsStamped contacts_stamped;\n        contacts_stamped.header.stamp = ros::Time::now();\n        contacts_stamped.contacts.resize(4);\n        for (int i = 0; i < 4; i++) {\n            contacts_stamped.contacts[i].phase = leg_controller_->getGaitPhase(i);\n            contacts_stamped.contacts[i].contact = foot_contacts[i];\n        }\n        foot_contacts_publisher_.publish(contacts_stamped);\n    }\n}", "CodeBleu_score": 62.44781462468259}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints){\n\tjoints_msg = Joints()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_msg.position = [joints.position.joint_1, joints.position.joint_2, joints.position.joint_3, joints.position.joint_4, joints.position.joint_5, joints.position.joint_6, joints.position.joint_7, joints.position.joint_8, joints.position.joint_9, joints.position.joint_10, joints.position.joint_11, joints.position.joint_12]\n    self.joints_pub.publish(joints_msg)\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.header.stamp = rospy.Time.now()\n    trajectory_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    trajectory_msg.points.append(JointTrajectoryPoint(positions=[joints.position.joint_1, joints.position.joint_2, joints.position.joint_3, joints.position.joint_4, joints.position.joint_5, joints.position.joint_6, joints.position.joint_7, joints.position.joint_8, joints.position.joint_9, joints.position.joint_10, joints.position.joint_11, joints.position.joint_12], velocities=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0", "CodeBleu_score": 32.214342959425565}, {"code": "def joints_cmd_callback(self, joints){\n\t# Create a minimal joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.position = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n    self.joint_state_pub.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    joint_traj_msg = JointTrajectory()\n    joint_traj_msg.header.stamp = rospy.Time.now()\n    joint_traj_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joint_traj_msg.points = [JointTrajectoryPoint()]\n    joint_traj_msg.points[0].positions = [joints.position[0], joints.position[1], joints.position[2], joints.position[3], joints.position[4], joints.position[5], joints.position[6], joints.position[7], joints.position[8], joints.position[9], joints.position[10], joints.position[11]]\n    joint_traj_msg.points[0].time_from_start = rospy.Duration(1.0)\n    self.joint_traj_pub.publish(joint_traj_msg)\n}", "CodeBleu_score": 32.54571257743361}, {"code": "def joints_cmd_callback(self, joints){\n\t# TODO: Implement this function\n    # Create a joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6', 'joint7', 'joint8', 'joint9', 'joint10', 'joint11', 'joint12']\n    joints_msg.position = joints.position[0:12]\n    # Publish the joints message\n    self.pub_joints.publish(joints_msg)\n    # Create a joint trajectory message with the same positions and a specified duration\n    traj_msg = JointTrajectory()\n    traj_msg.header.stamp = rospy.Time.now()\n    traj_msg.joint_names = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6', 'joint7', 'joint8', 'joint9', 'joint10', 'joint11', 'joint12']\n    traj_msg.points.append(JointTrajectoryPoint(positions=joints_msg.position, time_from_start=rospy.Duration(0.5)))\n    # Publish the joint trajectory message\n    self.pub_traj.publish(traj_msg)", "CodeBleu_score": 35.86723883509197}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\tfor (int i = 0; i < _msg->contacts.size(); i++) {\n    std::string collision = _msg->contacts[i].collision1_name;\n    std::string robot_name = collision.substr(0, collision.find_first_of(\"_\"));\n    std::string link_name = collision.substr(collision.find_last_of(\"_\") + 1);\n    if (robot_name == \"foot_left\") {\n      if (link_name == \"foot_left_collision\") {\n        foot_contact_states[0] = true;\n      }\n    } else if (robot_name == \"foot_right\") {\n      if (link_name == \"foot_right_collision\") {\n        foot_contact_states[1] = true;\n      }\n    } else if (robot_name == \"foot_middle\") {\n      if (link_name == \"foot_middle_collision\") {\n        foot_contact_states[2] = true;\n      }\n    }\n  }\n}", "CodeBleu_score": 38.17955933880249}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contacts[i] = false;\n  }\n\n  // For each contact in the message, split the collision string to identify the contact link\n  for (int i = 0; i < _msg->contacts.size(); i++) {\n    std::string collision = _msg->contacts[i].collision1_name;\n    std::string link;\n    if (collision.find(\"_l_\") != std::string::npos) {\n      link = collision.substr(collision.find(\"_l_\") + 3);\n    } else if (collision.find(\"_r_\") != std::string::npos) {\n      link = collision.substr(collision.find(\"_r_\") + 3);\n    } else {\n      continue;\n    }\n\n    // If the contact link matches one of the foot links, set the corresponding foot contact state to true\n    if (link == \"foot_l\") {\n      foot_contacts[0] = true;\n    } else if (link == \"foot_r\") {\n      foot_contacts[1] = true;\n    } else if (link == \"foot_ll\") {\n      foot_contacts[2] = true;\n    } else if (link == \"foot_rl\") {\n      foot_contacts[3] = true;\n    }\n  }\n}", "CodeBleu_score": 49.529451404692}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg){\n\t// Get the list of contact links\n\tstd::vector<std::string> contact_links = getContactLinks();\n\n\t// Get the list of foot links\n\tstd::vector<std::string> foot_links = getFootLinks();\n\n\t// Iterate through the list of contacts\n\tfor (int i = 0; i < _msg->contacts.size(); i++) {\n\n\t\t// Get the name of the collision\n\t\tstd::string collision_name = _msg->contacts[i].collision2_name;\n\n\t\t// Check if the collision name is in the list of foot links\n\t\tfor (int j = 0; j < foot_links.size(); j++) {\n\n\t\t\t// If the collision name is in the list of foot links\n\t\t\tif (collision_name.find(foot_links[j]) != std::string::npos) {\n\n\t\t\t\t// Set the foot contact state to true\n\t\t\t\tfoot_contact_states[j] = true;\n\t\t\t}\n\t\t}\n\n\t\t// Check if the collision name is in the list of contact links\n\t\tfor (int j = 0; j < contact_links.size(); j++) {\n\n\t\t\t// If the collision name is in the list of contact links\n\t\t\tif (collision_name.find(contact_links[j]) != std::string::npos) {\n\n\t\t\t\t// Set the foot contact state to false\n\t\t\t\tfoot_contact_states[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 47.496995340066675}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (!is_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kNumRotors);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  Eigen::Vector3d thrust = (acceleration + angular_acceleration.cross(odometry_.position - command_trajectory_.position_W))\n      * vehicle_parameters_.mass_;\n\n  // Project thrust onto body z-axis.\n  Eigen::Vector3d thrust_body_z = R_WB_.transpose() * thrust;\n\n  Eigen::Vector3d rotor_velocities_body;\n  rotor_velocities_body = thrust_body_z.cwiseProduct(kRotorVelocityMatrix);\n\n  // Ensure non-negative values.\n  for (int i = 0; i < kNumRotors; ++i) {\n    rotor_velocities_body[i] = std::max(rotor_velocities_body[i], 0.0);\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities_body.cwiseSqrt();\n}", "CodeBleu_score": 52.71906488585674}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  // Check if the controller is active.\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute desired acceleration and angular acceleration.\n  Eigen::Vector3d acceleration;\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust = -acceleration;\n  thrust = thrust.cwiseProduct(body_z_);\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d combined_acceleration = thrust + angular_acceleration;\n\n  // Rotor velocities are computed by multiplying with a predefined matrix, ensuring non-negative values, and taking the square root of each component.\n  *rotor_velocities = combined_acceleration.cwiseProduct(rotor_velocities_matrix_);\n\n  // Ensure non-negative values.\n  rotor_velocities->array() = rotor_velocities->array().max(0.0);\n\n  // Take the square root of each component.\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 42.370054661221424}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n  assert(command_trajectory_.isValid());\n\n  if (!is_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kNumMotors);\n    return;\n  }\n\n  // Compute desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(odometry_.acceleration, &angular_acceleration);\n\n  // Compute desired acceleration.\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  // Project acceleration onto body z-axis.\n  Eigen::Vector3d acceleration_body;\n  acceleration_body = odometry_.orientation.toRotationMatrix().transpose() * acceleration;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d desired_acceleration_body;\n  desired_acceleration_body = angular_acceleration + acceleration_body;\n\n  // Compute rotor velocities.\n  *rotor_velocities = controller_parameters_.rotor_velocities_gain_ * desired_acceleration_body;\n\n  // Ensure non-negative values.\n  for (int i = 0; i < kNumMotors; i++) {\n    rotor_velocities->coeffRef(i) = std::max(0.0, rotor_velocities->coeff(i));\n  }\n\n  // Take the square root of each component.\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 55.04226234168061}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\tEigen::Vector3d position_error = position_command_ - position_;\n    Eigen::Vector3d velocity_error = velocity_command_ - velocity_;\n\n    // Transform velocity error from vehicle frame to world frame\n    Eigen::Vector3d velocity_error_world =\n        vehicle_to_world_frame_transform_.rotation() * velocity_error;\n\n    // Compute desired acceleration\n    *acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_world +\n                    Eigen::Vector3d(0.0, 0.0, -9.81);\n\n    // Adjust for mass and gravity\n    *acceleration = (*acceleration) / mass_;\n\n    // Adjust for commanded acceleration\n    *acceleration += acceleration_command_;\n}", "CodeBleu_score": 31.644418074708764}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t// Transform the velocity to the world frame\n  Eigen::Vector3d velocity_world = transform_to_world_frame_ * vehicle_->GetVelocity();\n\n  // Compute the position error\n  Eigen::Vector3d position_error = command_trajectory_->GetPosition() - vehicle_->GetPosition();\n\n  // Compute the velocity error\n  Eigen::Vector3d velocity_error = command_trajectory_->GetVelocity() - velocity_world;\n\n  // Compute the acceleration error\n  Eigen::Vector3d acceleration_error = command_trajectory_->GetAcceleration() - vehicle_->GetAcceleration();\n\n  // Compute the desired acceleration\n  *acceleration = (position_gain_ * position_error + velocity_gain_ * velocity_error + acceleration_gain_ * acceleration_error) / vehicle_mass_;\n\n  // Adjust for gravity\n  *acceleration -= gravity_ * vehicle_->GetMass();\n}", "CodeBleu_score": 40.677080445766585}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const{\n\t//Transform the commanded velocity to the world frame\n    Eigen::Vector3d commandedVelocity = transform_to_world_frame(commanded_velocity_);\n\n    //Compute the position error\n    Eigen::Vector3d positionError = commanded_position_ - current_position_;\n\n    //Compute the velocity error\n    Eigen::Vector3d velocityError = commandedVelocity - current_velocity_;\n\n    //Compute the desired acceleration\n    *acceleration = position_gain_ * positionError + velocity_gain_ * velocityError;\n\n    //Incorporate the vehicle mass and gravity\n    *acceleration += mass_ * gravity_;\n\n    //Limit the maximum acceleration\n    for (int i = 0; i < 3; i++) {\n        if (acceleration->data()[i] > max_acceleration_) {\n            acceleration->data()[i] = max_acceleration_;\n        }\n        else if (acceleration->data()[i] < -max_acceleration_) {\n            acceleration->data()[i] = -max_acceleration_;\n        }\n    }\n}", "CodeBleu_score": 37.28738528748901}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (rotor_velocities->size() != rotor_configuration_.rotors_number_) {\n    rotor_velocities->resize(rotor_configuration_.rotors_number_);\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::Vector3d thrust_reference = angular_acceleration.cwiseProduct(control_attitude_thrust_reference_);\n\n  Eigen::VectorXd rotor_velocities_tmp = thrust_reference.cwiseProduct(rotor_velocities_matrix_);\n  rotor_velocities_tmp = rotor_velocities_tmp.array().max(Eigen::Vector3d::Constant(1.0)).matrix();\n  *rotor_velocities = rotor_velocities_tmp.cwiseSqrt();\n}", "CodeBleu_score": 51.15256250952992}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (rotor_velocities->size() != 4) {\n    rotor_velocities->resize(4);\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::Vector3d angular_acceleration_thrust_reference = angular_acceleration + control_attitude_thrust_reference_.head<3>();\n\n  rotor_velocities->head<3>() = rotor_velocity_matrix_ * angular_acceleration_thrust_reference;\n  rotor_velocities->tail<1>() = control_attitude_thrust_reference_.tail<1>();\n\n  rotor_velocities->array() = rotor_velocities->array().max(Eigen::VectorXd::Constant(rotor_velocities->size(), 1.0));\n  rotor_velocities->array() = rotor_velocities->array().min(Eigen::VectorXd::Constant(rotor_velocities->size(), 10.0));\n\n  rotor_velocities->array() = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 52.1959512404275}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const{\n\tassert(rotor_velocities);\n\n  if (control_attitude_thrust_reference_.size() != 3) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: control_attitude_thrust_reference_ has an invalid size: \" << control_attitude_thrust_reference_.size() << \" != 3\" << std::endl;\n    return;\n  }\n\n  if (gain_attitude_.size() != 3) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: gain_attitude_ has an invalid size: \" << gain_attitude_.size() << \" != 3\" << std::endl;\n    return;\n  }\n\n  if (gain_angular_rate_.size() != 3) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: gain_angular_rate_ has an invalid size: \" << gain_angular_rate_.size() << \" != 3\" << std::endl;\n    return;\n  }\n\n  if (rotor_velocities->size() != 4) {\n    std::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities has an invalid size: \" << rotor_velocities->size() << \" != 4\" << std::endl;\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n\n  Eigen::VectorXd desired_angular_acceleration(3);\n  desired_angular_acceleration << angular_acceleration, control_attitude_thrust_reference_(2);\n\n  // calculate rotor velocities\n  *rotor_velocities = rotor_velocities_matrix_ * desired_angular_acceleration;\n\n  // ensure all rotor velocities are at least one\n  for (int i = 0; i < rotor_velocities->size(); ++i) {\n    if ((*rotor_vel", "CodeBleu_score": 47.34810055878569}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    if start_index > end_index:\n        raise ValueError('start_time must be less than end_time')\n    copy = copy.deepcopy(self)\n    copy.time = copy.time[start_index:end_index]\n    copy.data = copy.data[start_index:end_index]\n    copy.data_unit = copy.data_unit[start_index:end_index]\n    copy.data_unit_symbol = copy.data_unit_symbol[start_index:end_index]\n    copy.data_unit_latex = copy.data_unit_latex[start_index:end_index]\n    copy.data_unit_offset = copy.data_unit_offset[start_index:end_index]\n    copy.data_unit_multiplier = copy.data_unit_multiplier[start_index:end_index]\n    copy.data_unit_prefix = copy.data_unit_prefix[start_index:end_index]\n    copy.data_unit_prefix_power = copy.data_unit_prefix_power[start_index:end_index]\n    copy.data_unit_offset = copy.data_unit_offset[start_index:end_index]\n    copy.data_unit_multiplier = copy.data_unit_multiplier[start_index:end_index]\n    copy.data_unit_prefix = copy.data_unit_prefix[start_index:end_index]\n    copy.data_unit_prefix_power = copy.data_unit_prefix_power[start_index:end_index]\n    copy.data_unit_offset = copy.data_unit_offset[start_index:end_index]\n    copy.data_unit_multiplier = copy.data_unit_multiplier[start_index:end_index]\n    copy.data_unit_prefix = copy.data_unit_prefix[start_index:end_index]\n    copy.data_unit_prefix_power = copy.data_unit_prefix_power[start_index:end_index]", "CodeBleu_score": 35.26587877996121}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    if start_index == end_index:\n        raise ValueError('Start and end times are the same')\n    if start_index > end_index:\n        raise ValueError('Start time is after end time')\n    if start_index == 0:\n        raise ValueError('Start time is before the first time')\n    if end_index == len(self.time):\n        raise ValueError('End time is after the last time')\n    if end_index > len(self.time):\n        raise ValueError('End time is after the last time')\n    if start_index < 0:\n        raise ValueError('Start time is before the first time')\n    if end_index < 0:\n        raise ValueError('End time is before the first time')\n    new_object = copy.deepcopy(self)\n    new_object.time = self.time[start_index:end_index]\n    new_object.data = self.data[start_index:end_index]\n    return new_object\n\n", "CodeBleu_score": 45.34074533254044}, {"code": "def slice(self, start_time, end_time)\n\tstart_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    if start_index == end_index:\n        return self\n    else:\n        sliced_data = deepcopy(self)\n        sliced_data.time = self.time[start_index:end_index]\n        sliced_data.data = self.data[start_index:end_index]\n        return sliced_data\n\n", "CodeBleu_score": 24.3355585601129}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\twaypoint_position = waypoint_msg.pose.position\n    waypoint_rotation = waypoint_msg.pose.orientation\n    waypoint_point = Point(waypoint_position.x, waypoint_position.y, waypoint_position.z)\n    waypoint_yaw = tf.transformations.euler_from_quaternion([waypoint_rotation.x, waypoint_rotation.y, waypoint_rotation.z, waypoint_rotation.w])[2]\n    if self.waypoint_point.x != waypoint_point.x or self.waypoint_point.y != waypoint_point.y or self.waypoint_point.z != waypoint_point.z or self.waypoint_yaw != waypoint_yaw:\n        self.waypoint_point = waypoint_point\n        self.waypoint_yaw = waypoint_yaw\n        self.append_point(waypoint_point)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 24.348185142618217}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tposition = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    euler_angles = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    point = Point(position.x, position.y, position.z)\n    if point.x != self.last_point.x or point.y != self.last_point.y or point.z != self.last_point.z or euler_angles[2] != self.last_yaw:\n        self.append_point(point)\n        self.append_yaw(euler_angles[2])\n        self.append_times(msg_time, bag_time)\n        self.last_point = point\n        self.last_yaw = euler_angles[2]\n\n", "CodeBleu_score": 26.13905677196354}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\tif self.last_waypoint is None:\n        self.last_waypoint = waypoint_msg\n        self.append_point(waypoint_msg.pose.position)\n        self.append_times(msg_time, bag_time)\n    elif self.last_waypoint.pose.position.x != waypoint_msg.pose.position.x or self.last_waypoint.pose.position.y != waypoint_msg.pose.position.y or self.last_waypoint.pose.position.z != waypoint_msg.pose.position.z or self.last_waypoint.pose.orientation.y != waypoint_msg.pose.orientation.y:\n        self.last_waypoint = waypoint_msg\n        self.append_point(waypoint_msg.pose.position)\n        self.append_times(msg_time, bag_time)\n\n", "CodeBleu_score": 22.96841749960592}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == '/imu/data':\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.to_sec(), bag_time)\n\n", "CodeBleu_score": 34.027205540846595}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == \"/imu/data\":\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.secs, bag_time)\n\n", "CodeBleu_score": 32.69854621747892}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\tif topic == \"/imu/data\":\n        self.acceleration_x = numpy.append(self.acceleration_x, msg.linear_acceleration.x)\n        self.acceleration_y = numpy.append(self.acceleration_y, msg.linear_acceleration.y)\n        self.acceleration_z = numpy.append(self.acceleration_z, msg.linear_acceleration.z)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n    elif topic == \"/imu/mag\":\n        self.magnetic_field_x = numpy.append(self.magnetic_field_x, msg.magnetic_field.x)\n        self.magnetic_field_y = numpy.append(self.magnetic_field_y, msg.magnetic_field.y)\n        self.magnetic_field_z = numpy.append(self.magnetic_field_z, msg.magnetic_field.z)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n    elif topic == \"/imu/temp\":\n        self.temperature = numpy.append(self.temperature, msg.temperature)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n    elif topic == \"/imu/pressure\":\n        self.pressure = numpy.append(self.pressure, msg.pressure)\n        self.append_times(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9, bag_time)\n\n", "CodeBleu_score": 26.07729427689313}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Plot accelerations\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_title(\"Acceleration Data\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.legend(loc=\"upper left\")\n\n    # Plot x, y, and z components of accelerations\n    for i in range(len(self.acceleration_data)):\n        ax.plot(self.acceleration_data[i].time, self.acceleration_data[i].x, label=\"x\")\n        ax.plot(self.acceleration_data[i].time, self.acceleration_data[i].y, label=\"y\")\n        ax.plot(self.acceleration_data[i].time, self.acceleration_data[i].z, label=\"z\")\n\n    # Save plot if saving plots is enabled\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        plot_filename = self.plot_prefix + \"_accelerations\" + plot_suffix + \".png\"\n        plt.savefig(plot_filename)\n\n    # Show plot if showing plots is enabled\n    if self.show_plots:\n        plt.show()\n\n    # Close plot\n    plt.close()\n\n", "CodeBleu_score": 34.98441470329194}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\tif self.acceleration_data is None:\n        raise ValueError(\"No acceleration data found.\")\n\n    if plot_suffix is None:\n        plot_suffix = \"\"\n\n    fig = plt.figure(figsize=(10, 10))\n    fig.suptitle(\"Acceleration Data\")\n\n    ax = fig.add_subplot(311)\n    ax.set_title(\"Acceleration\")\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    colors = [\"red\", \"green\", \"blue\"]\n    labels = [\"x\", \"y\", \"z\"]\n\n    for i in range(3):\n        ax.plot(self.time_data, self.acceleration_data[:, i], label=labels[i], color=colors[i])\n\n    ax.legend()\n\n    fig.savefig(\"acceleration_data\" + plot_suffix + \".png\")\n\n", "CodeBleu_score": 32.91055686785228}, {"code": "def plot_accelerations(self, plot_suffix=None)\n\t# Check if plotting is enabled\n    if not self.plotting_enabled:\n        return\n\n    # Set plot title\n    plot_title = \"Acceleration\"\n    if plot_suffix is not None:\n        plot_title += \" - \" + plot_suffix\n\n    # Create figure\n    fig = plt.figure()\n    fig.suptitle(plot_title)\n\n    # Create subplot\n    ax = fig.add_subplot(111)\n\n    # Plot accelerations\n    for i, acceleration in enumerate(self.accelerations):\n        ax.plot(acceleration.timestamps, acceleration.x, label=\"x\", color=self.colors[i], linestyle=self.linestyles[i])\n        ax.plot(acceleration.timestamps, acceleration.y, label=\"y\", color=self.colors[i], linestyle=self.linestyles[i])\n        ax.plot(acceleration.timestamps, acceleration.z, label=\"z\", color=self.colors[i], linestyle=self.linestyles[i])\n\n    # Set labels\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Add legend\n    ax.legend(loc=0)\n\n    # Save plot\n    if self.saving_enabled:\n        filename = self.plot_prefix + \"_accelerations\"\n        if plot_suffix is not None:\n            filename += \"_\" + plot_suffix\n        filename += \".png\"\n        fig.savefig(filename, dpi=self.dpi)\n        plt.close(fig)\n\n", "CodeBleu_score": 42.693968416631265}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n\tif len(pose_indeces) < 2:\n        raise ValueError(\"You need at least two pose indeces to compare positions\")\n    for pose_index in pose_indeces:\n        if pose_index > len(self.poses) - 1:\n            raise ValueError(\"Pose index out of range\")\n    for pose_index_one, pose_index_two in zip(pose_indeces, pose_indeces[1:]):\n        compare_two_xyz(self.poses[pose_index_one].position, self.poses[pose_index_two].position)\n\n", "CodeBleu_score": 35.669835356387495}, {"code": "def compare_positions(self, pose_indeces)\n\tif len(pose_indeces) > 1:\n        for i in range(len(pose_indeces)):\n            for j in range(i + 1, len(pose_indeces)):\n                compare_two_xyz(self.get_pose_xyz(pose_indeces[i]), self.get_pose_xyz(pose_indeces[j]))\n    else:\n        print(\"You need to provide at least two pose indices to compare positions.\")\n\n", "CodeBleu_score": 42.385530122863265}, {"code": "def compare_positions(self, pose_indeces)\n\t# TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Implement the compare_two_xyz function\n\n    # TODO(ff): Add a check that the number of pose indeces is greater than 1\n\n    # TODO(ff): Im", "CodeBleu_score": 2.864583333333333}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision_time in self.wrench:\n        if start_time <= collision_time <= end_time:\n            collision_times.append(collision_time)\n    return collision_times\n\n", "CodeBleu_score": 34.692306927427914}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 38.34182643493508}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\tcollision_times = []\n    for i in range(len(self.wrench)):\n        if start_time <= self.wrench[i][0] <= end_time:\n            collision_times.append(self.wrench[i][0])\n    return collision_times\n\n", "CodeBleu_score": 36.351892076246614}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\ttry:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 87.43368823459195}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n\n  const float multiplier = this->CalculateMultiplier();\n\n  Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n  Eigen::VectorXf noise = depth_data.unaryExpr(\n      [&](const float depth) { return this->CalculateNoise(depth); });\n\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (this->InRange(depth_data(i))) {\n      depth_data(i) += noise(i) * multiplier;\n    } else {\n      depth_data(i) = this->bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 47.479269659101995}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (!data) {\n    return;\n  }\n  const int num_pixels = width * height;\n  Eigen::Map<Eigen::VectorXf> depths(data, num_pixels);\n  const float multiplier =\n      this->max_depth / (this->max_depth - this->min_depth);\n  const float rms_noise =\n      this->rms_noise_ *\n      (this->max_depth - this->min_depth) / this->max_depth;\n  const float bad_point_value = this->bad_point_value_;\n  for (int i = 0; i < num_pixels; i++) {\n    if (this->InRange(depths(i))) {\n      depths(i) +=\n          (rms_noise * (2 * (rand() / (float)RAND_MAX - 0.5) - 1) *\n           multiplier);\n    } else {\n      depths(i) = bad_point_value;\n    }\n  }\n}", "CodeBleu_score": 46.06902787622046}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data){\n\tif (data == nullptr) {\n    return;\n  }\n  float multiplier = this->depth_multiplier_;\n  Eigen::MatrixXf data_matrix(height, width);\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      data_matrix(i, j) = data[i * width + j];\n    }\n  }\n  float rms_noise = this->rms_noise_;\n  Eigen::VectorXf noise_vector = this->noise_vector_;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (this->InRange(data_matrix(i, j))) {\n        data_matrix(i, j) +=\n            multiplier * noise_vector(i * width + j) * rms_noise;\n      } else {\n        data_matrix(i, j) = this->bad_point_value_;\n      }\n    }\n  }\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      data[i * width + j] = data_matrix(i, j);\n    }\n  }\n}", "CodeBleu_score": 46.92386709517644}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get the current simulation time\n  double sim_time = world->GetSimTime().Double();\n  // Convert it to ROS time\n  ros::Time ros_time(sim_time);\n  // Write the message to the bag file\n  trajectory_bag.write(waypoint_topic, ros_time, trajectory_msg);\n}", "CodeBleu_score": 40.49416333773184}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Get current simulation time and convert to ROS time\n  ros::Time current_time = ros::Time::now();\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n  // Write the trajectory message to the bag file\n  if (bag.isOpen()) {\n    trajectory_msgs::MultiDOFJointTrajectory trajectory_msg_copy;\n    trajectory_msg_copy.header.stamp = ros_time;\n    trajectory_msg_copy.header.frame_id = \"world\";\n    trajectory_msg_copy.joint_names = trajectory_msg->joint_names;\n    for (size_t i = 0; i < trajectory_msg->points.size(); i++) {\n      trajectory_msgs::MultiDOFJointTrajectoryPoint point;\n      point.time_from_start = trajectory_msg->points[i].time_from_start;\n      point.transforms = trajectory_msg->points[i].transforms;\n      trajectory_msg_copy.points.push_back(point);\n    }\n    bag.write(waypoint_topic_, ros_time, trajectory_msg_copy);\n  }\n}", "CodeBleu_score": 42.173944422989706}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg){\n\t// Convert Gazebo time to ROS time\n  ros::Time ros_time = ros::Time::now();\n  ros_time.sec = ros_time.sec + (gazebo::common::Time::GetWallTime() -\n                                  gazebo_start_time).Double();\n\n  // Write the trajectory message to a bag file\n  bag.write(waypoint_topic_name, ros_time, trajectory_msg);\n}", "CodeBleu_score": 41.4642678362555}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Converts the simulation time to ROS time\n  ros::Time ros_time = ros::Time::now() + ros::Duration(now.Double());\n\n  // Prepares a message for the motor velocities\n  gazebo_msgs::Actuators msg;\n  msg.header.stamp = ros_time;\n  msg.header.frame_id = \"base_link\";\n\n  // Iterates through the motor joints\n  for (int i = 0; i < num_motors; i++) {\n    // Calculates the slowed-down rotational velocities\n    double motor_velocity = motor_joints[i]->GetVelocity(0) * motor_slowdown;\n\n    // Assigns the slowed-down rotational velocities to the message\n    msg.motor_speed.push_back(motor_velocity);\n  }\n\n  // Writes the message to the bag file\n  motor_velocities_publisher.publish(msg);\n}", "CodeBleu_score": 39.0062037495428}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\t// Get the time in ROS time\n    ros::Time ros_now = ros::Time::now();\n\n    // Get the simulation time\n    double sim_now = now.Double();\n\n    // Get the time difference between the simulation time and ROS time\n    double dt = sim_now - ros_now.toSec();\n\n    // Initialize the message\n    gazebo_msgs::Actuators msg;\n\n    // Iterate through the motor joints\n    for (int i = 0; i < num_motors; i++) {\n\n        // Get the joint\n        physics::JointPtr motor_joint = model->GetJoint(motor_names[i]);\n\n        // Get the joint angle\n        double joint_angle = motor_joint->GetAngle(0).Radian();\n\n        // Get the joint velocity\n        double joint_velocity = motor_joint->GetVelocity(0);\n\n        // Get the joint torque\n        double joint_torque = motor_joint->GetForce(0);\n\n        // Calculate the slowed-down rotational velocity\n        double slowed_velocity = joint_velocity * slowdown_factor;\n\n        // Assign the data to the message\n        msg.header.stamp = ros_now;\n        msg.header.frame_id = frame_id;\n        msg.motor_name[i] = motor_names[i];\n        msg.motor_position[i] = joint_angle;\n        msg.motor_velocity[i] = slowed_velocity;\n        msg.motor_torque[i] = joint_torque;\n\n    }\n\n    // Write the data to the bag file\n    actuators_pub.publish(msg);\n\n}", "CodeBleu_score": 44.61845168357407}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now){\n\tros::Time ros_time = ros::Time::now();\n    ros::Duration duration = ros_time - start_time;\n    ros::Duration ros_now = ros::Duration(now.Double());\n    ros::Duration ros_diff = ros_now - duration;\n    ros::Duration ros_diff_sec = ros_diff.sec + ros_diff.nsec * 1e-9;\n    // ROS_INFO(\"ros_now: %f, duration: %f, ros_diff: %f\", ros_now.toSec(), duration.toSec(), ros_diff.toSec());\n\n    // Create a message to store the motor velocities\n    sensor_msgs::JointState msg;\n    msg.header.stamp = ros_diff_sec;\n    msg.name.resize(num_motors);\n    msg.velocity.resize(num_motors);\n\n    // Iterate through the motor joints\n    for (int i = 0; i < num_motors; i++) {\n        // Get the motor joint\n        physics::JointPtr motor = model->GetJoint(motor_names[i]);\n\n        // Get the motor joint velocity\n        double motor_velocity = motor->GetVelocity(0);\n\n        // Slow down the motor joint velocity\n        double slow_velocity = motor_velocity * slow_down_factor;\n\n        // Assign the slowed-down motor joint velocity to the message\n        msg.velocity[i] = slow_velocity;\n    }\n\n    // Publish the message\n    motor_velocity_publisher->publish(msg);\n}", "CodeBleu_score": 40.33677518285521}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\t// Log that the callback was called\n  if (debug_print_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert the normalized input values to control surface angles\n  roll_surface_.angle = NormalizedInputToAngle(roll_surface_,\n      roll_pitch_yawrate_thrust_msg->roll);\n  pitch_surface_.angle = NormalizedInputToAngle(pitch_surface_,\n      roll_pitch_yawrate_thrust_msg->pitch);\n  yaw_surface_.angle = NormalizedInputToAngle(yaw_surface_,\n      roll_pitch_yawrate_thrust_msg->yaw_rate);\n\n  // Set the throttle value\n  throttle_surface_.angle = NormalizedInputToAngle(throttle_surface_,\n      roll_pitch_yawrate_thrust_msg->thrust);\n}", "CodeBleu_score": 43.33134772314907}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_print_) {\n    gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback called\"\n        << std::endl;\n  }\n  double roll = NormalizedInputToAngle(\n      control_surfaces_.roll, roll_pitch_yawrate_thrust_msg->roll);\n  double pitch = NormalizedInputToAngle(\n      control_surfaces_.pitch, roll_pitch_yawrate_thrust_msg->pitch);\n  double yaw_rate = NormalizedInputToAngle(\n      control_surfaces_.yaw_rate, roll_pitch_yawrate_thrust_msg->yaw_rate);\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust;\n  // Set the control surface angles.\n  control_surfaces_.ailerons.angle = roll;\n  control_surfaces_.elevator.angle = pitch;\n  control_surfaces_.rudder.angle = yaw_rate;\n  // Set the throttle value.\n  control_surfaces_.throttle.angle = thrust;\n}", "CodeBleu_score": 44.899780423157374}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg){\n\tif (debug_print_) {\n    gzmsg << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n  }\n\n  double roll_input = roll_pitch_yawrate_thrust_msg->roll;\n  double pitch_input = roll_pitch_yawrate_thrust_msg->pitch;\n  double yawrate_input = roll_pitch_yawrate_thrust_msg->yawrate;\n  double thrust_input = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Convert normalized inputs to angles\n  double roll_angle = NormalizedInputToAngle(roll_surface_, roll_input);\n  double pitch_angle = NormalizedInputToAngle(pitch_surface_, pitch_input);\n  double yawrate_angle = NormalizedInputToAngle(yawrate_surface_, yawrate_input);\n\n  // Set the throttle\n  throttle_ = thrust_input;\n\n  // Set the control surfaces\n  ailerons_->SetPosition(0, roll_angle);\n  elevator_->SetPosition(0, pitch_angle);\n  rudder_->SetPosition(0, yawrate_angle);\n}", "CodeBleu_score": 39.9968385223204}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\tif (_dt <= 0.0) {\n    gzerr << \"Invalid time delta [\" << _dt << \"]", "CodeBleu_score": 5.580800456477341}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// Convert timeout to timeval struct.\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for data on file descriptors.\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(_fd, &readfds);\n  int ret = select(_fd + 1, &readfds, NULL, NULL, &timeout);\n\n  // If data is available, receive it.\n  if (ret > 0) {\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n    if (len <= 0) {\n      printf(\"Failed receiving mavlink message\n\");\n    } else {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      // Parse buffer for MAVLink messages.\n      for (int i = 0; i < len; ++i) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}", "CodeBleu_score": 60.8399841222083}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs){\n\t// Convert timeout to timeval structure.\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll file descriptors.\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(_fd, &fds);\n\n  int ret = select(_fd + 1, &fds, NULL, NULL, &tv);\n\n  // Check if data is available.\n  if (ret > 0) {\n    // Data is available, receive it.\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    ssize_t len = recv(_fd, buffer, MAVLINK_MAX_PACKET_LEN, 0);\n\n    if (len <= 0) {\n      printf(\"Failed receiving mavlink message\n\");\n    }\n\n    // Parse messages.\n    mavlink_message_t msg;\n    mavlink_status_t status;\n\n    for (unsigned i = 0; i < len; ++i) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n        handle_message(&msg);\n      }\n    }\n  }\n}", "CodeBleu_score": 65.135024514915}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n\tstd::lock_guard<std::mutex> guard(mutex);\n    if (open) {\n        io_service.stop();\n        if (io_thread.joinable()) {\n            io_thread.join();\n        }\n        serial_port.close();\n        open = false;\n        std::cout << \"GazeboMavlinkInterface::close: closed.\" << std::endl;\n    }\n}", "CodeBleu_score": 52.965724886246676}, {"code": "void GazeboMavlinkInterface::close() {\n\t// Lock mutex to ensure thread safety\n    boost::mutex::scoped_lock lock(mutex);\n\n    // Check if interface is open\n    if (!is_open) {\n        // Interface is not open\n        return;\n    }\n\n    // Set interface to closed\n    is_open = false;\n\n    // Stop I/O service\n    io_service.stop();\n\n    // Join I/O thread if joinable\n    if (io_thread.joinable()) {\n        // Join thread\n        io_thread.join();\n    }\n\n    // Close serial device\n    serial_dev.close();\n}", "CodeBleu_score": 58.825537655247814}, {"code": "void GazeboMavlinkInterface::close() {\n\tboost::mutex::scoped_lock lock(mutex);\n  if (open) {\n    io_service.stop();\n    if (io_thread.joinable()) {\n      io_thread.join();\n    }\n    serial_port.close();\n    open = false;\n  }\n}", "CodeBleu_score": 58.436349103427844}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x = 0.0;\n  double y = 0.0;\n  double z = 0.0;\n  double x1 = 0.0;\n  double y1 = 0.0;\n  double z1 = 0.0;\n  double x2 = 0.0;\n  double y2 = 0.0;\n  double z2 = 0.0;\n  double x3 = 0.0;\n  double y3 = 0.0;\n  double z3 = 0.0;\n  double x4 = 0.0;\n  double y4 = 0.0;\n  double z4 = 0.0;\n  double x5 = 0.0;\n  double y5 = 0.0;\n  double z5 = 0.0;\n  double x6 = 0.0;\n  double y6 = 0.0;\n  double z6 = 0.0;\n  double x7 = 0.0;\n  double y7 = 0.0;\n  double z7 = 0.0;\n  double x8 = 0.0;\n  double y8 = 0.0;\n  double z8 = 0.0;\n  double x9 = 0.0;\n  double y9 = 0.0;\n  double z9 = 0.0;\n  double x10 = 0.0;\n  double y10 = 0.0;\n  double z10 = 0.0;\n  double x11 = 0.0;\n  double y11 = 0.0;\n  double z11 = 0.0;\n  double x12 = 0.0;\n  double y12 = 0.0;\n  double z12 = 0.0;\n  double x13 = 0.0;\n  double y13 = 0.0;\n  double z13 = 0.0;\n  double x14 = 0.0;\n  double y14 = 0.0;\n  double z14 = 0.0;\n  double x15", "CodeBleu_score": 5.3613552082605285}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x1, x2, y1, y2, z1, z2;\n    x1 = x2 = y1 = y2 = z1 = z2 = 0;\n\n    if (x1 == x2) {\n        return ignition::math::Vector3d(x1, y1, z1);\n    }\n\n    if (x1 > x2) {\n        x1 = x2;\n        x2 = x1;\n        y1 = y2;\n        y2 = y1;\n        z1 = z2;\n        z2 = z1;\n    }\n\n    if (x > x1 && x < x2) {\n        double x_interp = (x - x1) / (x2 - x1);\n        double y_interp = (y1 + x_interp * (y2 - y1));\n        double z_interp = (z1 + x_interp * (z2 - z1));\n        return ignition::math::Vector3d(x_interp, y_interp, z_interp);\n    }\n\n    return ignition::math::Vector3d(x1, y1, z1);\n}", "CodeBleu_score": 34.9584843055014}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation{\n\tdouble x1, y1, z1, x2, y2, z2, x3, y3, z3;\n  double x4, y4, z4;\n  double x5, y5, z5;\n  double x6, y6, z6;\n  double x7, y7, z7;\n  double x8, y8, z8;\n  double x9, y9, z9;\n  double x10, y10, z10;\n  double x11, y11, z11;\n  double x12, y12, z12;\n  double x13, y13, z13;\n  double x14, y14, z14;\n  double x15, y15, z15;\n  double x16, y16, z16;\n  double x17, y17, z17;\n  double x18, y18, z18;\n  double x19, y19, z19;\n  double x20, y20, z20;\n  double x21, y21, z21;\n  double x22, y22, z22;\n  double x23, y23, z23;\n  double x24, y24, z24;\n  double x25, y25, z25;\n  double x26, y26, z26;\n  double x27, y27, z27;\n  double x28, y28, z28;\n  double x29, y29, z29;\n  double x30, y30, z30;\n  double x31, y31, z31;\n  double x32, y32, z32;\n  double x33, y33, z33;\n  double x34, y34, z34;\n  double x35, y35, z35;\n  double x36, y36, z36;\n  double x37", "CodeBleu_score": 5.395105180951143}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time){\n\tif (looping) {\n\t\ttime = fmod(_time, length);\n\t}\n\telse {\n\t\ttime = std::clamp(_time, 0.0, length);\n\t}\n\tUpdate();\n}", "CodeBleu_score": 28.899736895267903}, {"code": "void Animation::SetTime(double _time){\n\tif (looping) {\n\t\tif (_time >= time) {\n\t\t\twhile (_time >= time + length)\n\t\t\t\ttime += length;\n\t\t}\n\t\telse {\n\t\t\twhile (_time < time)\n\t\t\t\ttime -= length;\n\t\t}\n\t}\n\telse {\n\t\tif (_time >= time + length)\n\t\t\ttime = length;\n\t\telse if (_time < 0)\n\t\t\ttime = 0;\n\t\telse\n\t\t\ttime = _time;\n\t}\n}", "CodeBleu_score": 36.80971880715688}, {"code": "void Animation::SetTime(double _time){\n\tif (loop) {\n\t\ttime = fmod(_time, length);\n\t}\n\telse {\n\t\ttime = std::clamp(time, 0.0, length);\n\t}\n}", "CodeBleu_score": 20.318271998556675}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    self.construct_target()\n    print(\"Vehicle type: \" + self.vehicle_type)\n    print(\"Vehicle ID: \" + self.vehicle_id)\n    print(\"Flight mode: \" + self.flight_mode)\n    print(\"Coordinate frame: \" + str(self.coordinate_frame))\n    print(\"Motion type: \" + str(self.motion_type))\n\n", "CodeBleu_score": 38.99518252770595}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target()\n\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", self.flight_mode)\n    print(\"Coordinate frame: \", self.coordinate_frame)\n    print(\"Motion type: \", self.motion_type)\n    print(\"Target: \", target_raw_pose)\n\n    self.vehicle.send_mavlink(self.construct_target())\n\n", "CodeBleu_score": 41.22447183124868}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n\n    print(\"Vehicle Type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight Mode: \", self.flight_mode)\n\n    target_raw_pose = self.construct_target()\n    self.send_target_pose(target_raw_pose)\n\n", "CodeBleu_score": 43.032403062490324}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.set_flight_mode(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except Exception as e:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": \"+str(e))\n            return False\n\n", "CodeBleu_score": 56.571408002212344}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        self.flight_mode = self.flight_mode.upper()\n        print(\"Switching to \" + self.flight_mode + \" mode.\")\n        try:\n            self.vehicle.mode = VehicleMode(self.flight_mode)\n            self.vehicle.flush()\n            if self.vehicle.mode != VehicleMode(self.flight_mode):\n                print(\"Failed to switch to \" + self.flight_mode + \" mode.\")\n                return False\n            else:\n                print(\"Successfully switched to \" + self.flight_mode + \" mode.\")\n                return True\n        except:\n            print(\"Failed to switch to \" + self.flight_mode + \" mode.\")\n            return False\n\n", "CodeBleu_score": 35.230303199636246}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.switch_to_flight_mode(self.flight_mode)\n            print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type+'_'+self.vehicle_id+\": FAILURE TO SWITCH TO FLIGHT MODE: \"+self.flight_mode)\n            return False\n\n", "CodeBleu_score": 55.93310567403942}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}, {"code": "def cmd_vel_enu_callback(self, msg)\n\t=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0", "CodeBleu_score": 39.287204166066914}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.flight_mode == 'HOVER':\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02) or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        else:\n            self.hover_flag = 1\n    elif self.flight_mode == 'OFFBOARD':\n        if self.hover_flag == 1:\n            self.flight_mode = 'HOVER'\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            self.hover()\n\n", "CodeBleu_score": 58.5242852386959}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.flight_mode == 'HOVER' and self.hover_flag == 1:\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n        elif abs(x) <= 0.02 and abs(y) <= 0.02 and abs(z) <= 0.02 and abs(w) <= 0.005:\n            self.hover_flag = 1\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    elif self.flight_mode == 'HOVER' and self.hover_flag == 0:\n        self.flight_mode = 'OFFBOARD'\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n    elif self.flight_mode == 'OFFBOARD' and self.hover_flag == 0:\n        self.flight_mode = 'HOVER'\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n\n", "CodeBleu_score": 60.077066550143044}, {"code": "def hover_state_transition(self, x, y, z, w)\n\tif self.flight_mode != \"HOVER\":\n        if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n    else:\n        if (abs(x) < 0.02 and abs(y) < 0.02 and abs(z) < 0.02 and abs(w) < 0.005):\n            self.hover_flag = 1\n\n", "CodeBleu_score": 64.54487288769317}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 16.806809161752323}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q[0], q[1], q[2], q[3]).yaw\n", "CodeBleu_score": 18.843449014415253}, {"code": "def q2yaw(self, q)\n\tif isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 16.806809161752323}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n    target_raw_pose = self.construct_target()\n    self.vehicle.send_mavlink(target_raw_pose)\n    print(\"Vehicle type: \", self.vehicle_type, \"", "CodeBleu_score": 32.89432238953742}, {"code": "def hover(self)\n\tself.coordinate_frame = 1\n    self.motion_type = 0\n\n    target_raw_pose = self.construct_target()\n\n    self.send_target_pose(target_raw_pose)\n\n    print(\"Vehicle type: \", self.vehicle_type)\n    print(\"Vehicle ID: \", self.vehicle_id)\n    print(\"Flight mode: \", \"Hover\")\n\n", "CodeBleu_score": 34.76524374763731}, {"code": "def hover(self)\n\tself.coordinate_frame = CoordinateFrame.GLOBAL_FRAME\n    self.motion_type = 3\n\n    target_raw_pose = self.construct_target()\n\n    self.vehicle.send_mavlink(target_raw_pose)\n\n    print(\"Vehicle type: \" + self.vehicle_type + \"", "CodeBleu_score": 22.74943288733617}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = self.vehicle.mode.name\n            self.vehicle.mode = VehicleMode(self.flight_mode)\n            self.flight_mode = self.vehicle.mode.name\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except Exception as e:\n            print(e)\n            return False\n\n", "CodeBleu_score": 50.625365895026086}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode = self.client.call(self.service_name, flightMode=self.flight_mode).flightMode\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except rospy.ServiceException as e:\n            print(\"Flight mode switch failed: \" + str(e))\n            return False\n\n", "CodeBleu_score": 47.56036621293692}, {"code": "def flight_mode_switch(self)\n\tif self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    else:\n        try:\n            self.set_flight_mode(self.flight_mode)\n            self.flight_mode = self.get_flight_mode()\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)\n            return True\n        except:\n            print(self.vehicle_type + '_' + self.vehicle_id + \":\" + \"Flight mode switch failed\")\n            return False\n\n", "CodeBleu_score": 55.25681463101769}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 55.40188162220928}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 55.40188162220928}, {"code": "def run(self, assignment, algorithm, play, rond)\n\tself.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()", "CodeBleu_score": 55.40188162220928}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\tif msg.id == i:\n        self.local_pose[i] = msg\n        if msg.id == self.id:\n            self.takeoff_target_pose[i] = msg\n            self.hover_target_pose[i] = msg\n        if msg.id == 1:\n            self.global_pose[i] = msg\n        else:\n            self.global_pose[i] = self.global_pose[1]\n\n", "CodeBleu_score": 19.856734991503856}, {"code": "def local_pose_callback(self, msg, i)\n\tif msg.id == i:\n        self.local_pose[i] = msg\n        if self.local_pose[i].id == self.id:\n            self.takeoff_target_pose[i] = self.local_pose[i]\n            self.hover_target_pose[i] = self.local_pose[i]\n        if self.local_pose[i].id == 0:\n            self.global_pose[i] = self.local_pose[i]\n        else:\n            self.global_pose[i] = self.global_pose[i - 1]\n            self.global_pose[i].x = self.global_pose[i - 1].x + self.local_pose[i].x\n            self.global_pose[i].y = self.global_pose[i - 1].y + self.local_pose[i].y\n            self.global_pose[i].z = self.global_pose[i - 1].z + self.local_pose[i].z\n            self.global_pose[i].yaw = self.global_pose[i - 1].yaw + self.local_pose[i].yaw\n            self.global_pose[i].vx = self.global_pose[i - 1].vx + self.local_pose[i].vx\n            self.global_pose[i].vy = self.global_pose[i - 1].vy + self.local_pose[i].vy\n            self.global_pose[i].vz = self.global_pose[i - 1].vz + self.local_pose[i].vz\n            self.global_pose[i].w = self.global_pose[i - 1].w + self.local_pose[i].w\n\n", "CodeBleu_score": 20.92282882615037}, {"code": "def local_pose_callback(self, msg, i)\n\t# If the message index matches the UAV ID, set the local pose to the message\n    if msg.id == self.uav_id:\n        self.local_pose = msg\n\n    # Update the takeoff target pose\n    if msg.id == self.uav_id and self.takeoff_target_pose is None:\n        self.takeoff_target_pose = msg\n\n    # Update the hover target pose\n    if msg.id == self.uav_id and self.hover_target_pose is None:\n        self.hover_target_pose = msg\n\n    # Update the global pose\n    if msg.id == self.uav_id:\n        self.global_pose.position.x = msg.position.x + self.global_pose_bias.position.x\n        self.global_pose.position.y = msg.position.y + self.global_pose_bias.position.y\n        self.global_pose.position.z = msg.position.z + self.global_pose_bias.position.z\n        self.global_pose.orientation.x = msg.orientation.x + self.global_pose_bias.orientation.x\n        self.global_pose.orientation.y = msg.orientation.y + self.global_pose_bias.orientation.y\n        self.global_pose.orientation.z = msg.orientation.z + self.global_pose_bias.orientation.z\n        self.global_pose.orientation.w = msg.orientation.w + self.global_pose_bias.orientation.w\n\n", "CodeBleu_score": 20.692738091332235}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == 1:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.60577377925034}, {"code": "def takeoff_detection(self)\n\tif self.uav.altitude > 0.2 and self.uav.arm_state == 1:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 63.14825113394774}, {"code": "def takeoff_detection(self)\n\tif self.altitude > 0.2 and self.arm_state == 1:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 61.60577377925034}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n\t# Initialize the distance matrix\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n\n    # Loop through each UAV in the original formation\n    for i in range(len(orig_formation)):\n\n        # Loop through each UAV in the changed formation\n        for j in range(len(change_formation)):\n\n            # Calculate the distance between the two UAVs\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j]) - 50\n\n    return dist_matrix\n\n", "CodeBleu_score": 24.557883913784085}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# Define the number of UAVs in the original and changed formations\n    num_orig_uavs = len(orig_formation)\n    num_change_uavs = len(change_formation)\n\n    # Create a distance matrix of the same size as the original formation\n    distance_matrix = np.zeros((num_orig_uavs, num_change_uavs))\n\n    # For each UAV in the original formation\n    for i in range(num_orig_uavs):\n\n        # For each UAV in the changed formation\n        for j in range(num_change_uavs):\n\n            # Calculate the distance between the UAVs using the Euclidean norm\n            distance = np.linalg.norm(orig_formation[i] - change_formation[j])\n\n            # Subtract 50 from the distance\n            distance = distance - 50\n\n            # Convert the distance to an integer\n            distance = int(distance)\n\n            # Store the distance in the distance matrix\n            distance_matrix[i, j] = distance\n\n    # Return the distance matrix\n    return distance_matrix\n\n", "CodeBleu_score": 23.468594210523857}, {"code": "def build_graph(self, orig_formation, change_formation)\n\t# Calculate the distance between the UAVs in the original formation and the changed formation\n    dist_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j]) - 50\n    return dist_matrix\n\n", "CodeBleu_score": 24.557883913784085}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}, {"code": "def find_path(self, i)\n\tself.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False\n\n", "CodeBleu_score": 53.10314008215627}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\twhile not all(self.visit_left):\n        for i, _ in enumerate(self.visit_left, start=0):\n            if not self.visit_left[i]:\n                self.find_path(i)\n                self.adjust_labels()\n    return self.match_right\n\n", "CodeBleu_score": 11.924942613410233}, {"code": "def KM(self)\n\tfor i in range(self.num_uavs):\n        self.slack_right = [1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 7.556344779058344}, {"code": "def KM(self)\n\tfor i, _ in enumerate(self.adj_matrix, start=0):\n        self.visit_left[i] = False\n        self.visit_right[i] = False\n        self.slack_right[i] = 1000000\n    while True:\n        for i, _ in enumerate(self.adj_matrix, start=0):\n            if self.visit_left[i]:\n                continue\n            if self.find_path(i):\n                break\n        else:\n            for i, _ in enumerate(self.adj_matrix, start=0):\n                if self.slack_right[i] == 1000000:\n                    self.label_left[i] -= 1\n                    self.label_right[i] += 1\n            break\n    return self.match_right\n\n", "CodeBleu_score": 25.145948999772212}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\thsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.14795030481221}, {"code": "def yellow_dectection(image)\n\t# Converting the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Defining the lower and upper bounds of the yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Creating a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Applying the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n\t# Converting image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Creating a mask for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Applying mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::string descriptionContainer;\n    return findStandaloneTagDescription(descriptionContainer, id, printWarning);\n}", "CodeBleu_score": 9.706259578338951}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tstd::string descriptionContainer;\n    return findStandaloneTagDescription(id, descriptionContainer);\n}", "CodeBleu_score": 9.393826652297358}, {"code": "bool TagDetector::findStandaloneTagDescription{\n\tif (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n        descriptionContainer = standalone_tag_descriptions_[id];\n        return true;\n    } else if (printWarning) {\n        logWarning(\"No standalone tag description found for ID \" + std::to_string(id) + \".\");\n        return false;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 31.316062012595342}]}
